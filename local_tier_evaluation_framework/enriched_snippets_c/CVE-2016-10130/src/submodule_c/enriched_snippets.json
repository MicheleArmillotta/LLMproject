[
  {
    "function_name": "submodule_get_wd_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "2001-2078",
    "snippet": "static void submodule_get_wd_status(\n\tunsigned int *status,\n\tgit_submodule *sm,\n\tgit_repository *sm_repo,\n\tgit_submodule_ignore_t ign)\n{\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\tconst git_oid *wd_oid =\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) ? &sm->wd_oid : NULL;\n\tgit_tree *sm_head = NULL;\n\tgit_index *index = NULL;\n\tgit_diff_options opt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff;\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__WD_FLAGS;\n\n\tif (!index_oid) {\n\t\tif (wd_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_ADDED;\n\t}\n\telse if (!wd_oid) {\n\t\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_SCANNED) != 0 &&\n\t\t\t(sm->flags & GIT_SUBMODULE_STATUS_IN_WD) == 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNINITIALIZED;\n\t\telse\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_DELETED;\n\t}\n\telse if (!git_oid_equal(index_oid, wd_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_WD_MODIFIED;\n\n\t/* if we have no repo, then we're done */\n\tif (!sm_repo)\n\t\treturn;\n\n\t/* the diffs below could be optimized with an early termination\n\t * option to the git_diff functions, but for now this is sufficient\n\t * (and certainly no worse that what core git does).\n\t */\n\n\tif (ign == GIT_SUBMODULE_IGNORE_NONE)\n\t\topt.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t(void)git_repository_index__weakptr(&index, sm_repo);\n\n\t/* if we don't have an unborn head, check diff with index */\n\tif (git_repository_head_tree(&sm_head, sm_repo) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\t/* perform head to index diff on submodule */\n\t\tif (git_diff_tree_to_index(&diff, sm_repo, sm_head, index, &opt) < 0)\n\t\t\tgiterr_clear();\n\t\telse {\n\t\t\tif (git_diff_num_deltas(diff) > 0)\n\t\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED;\n\t\t\tgit_diff_free(diff);\n\t\t\tdiff = NULL;\n\t\t}\n\n\t\tgit_tree_free(sm_head);\n\t}\n\n\t/* perform index-to-workdir diff on submodule */\n\tif (git_diff_index_to_workdir(&diff, sm_repo, index, &opt) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\tsize_t untracked =\n\t\t\tgit_diff_num_deltas_of_type(diff, GIT_DELTA_UNTRACKED);\n\n\t\tif (untracked > 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNTRACKED;\n\n\t\tif (git_diff_num_deltas(diff) != untracked)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_WD_MODIFIED;\n\n\t\tgit_diff_free(diff);\n\t\tdiff = NULL;\n\t}\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas",
          "args": [
            "diff"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1486-1490",
          "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas_of_type",
          "args": [
            "diff",
            "GIT_DELTA_UNTRACKED"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas_of_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1492-1504",
          "snippet": "size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)\n{\n\tsize_t i, count = 0;\n\tconst git_diff_delta *delta;\n\n\tassert(diff);\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tcount += (delta->status == type);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)\n{\n\tsize_t i, count = 0;\n\tconst git_diff_delta *delta;\n\n\tassert(diff);\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tcount += (delta->status == type);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&diff",
            "sm_repo",
            "index",
            "&opt"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "sm_head"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&diff",
            "sm_repo",
            "sm_head",
            "index",
            "&opt"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&sm_head",
            "sm_repo"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "sm_repo"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "index_oid",
            "wd_oid"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_index_id",
          "args": [
            "sm"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_index_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "933-941",
          "snippet": "const git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nstatic void submodule_get_wd_status(\n\tunsigned int *status,\n\tgit_submodule *sm,\n\tgit_repository *sm_repo,\n\tgit_submodule_ignore_t ign)\n{\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\tconst git_oid *wd_oid =\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) ? &sm->wd_oid : NULL;\n\tgit_tree *sm_head = NULL;\n\tgit_index *index = NULL;\n\tgit_diff_options opt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff;\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__WD_FLAGS;\n\n\tif (!index_oid) {\n\t\tif (wd_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_ADDED;\n\t}\n\telse if (!wd_oid) {\n\t\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_SCANNED) != 0 &&\n\t\t\t(sm->flags & GIT_SUBMODULE_STATUS_IN_WD) == 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNINITIALIZED;\n\t\telse\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_DELETED;\n\t}\n\telse if (!git_oid_equal(index_oid, wd_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_WD_MODIFIED;\n\n\t/* if we have no repo, then we're done */\n\tif (!sm_repo)\n\t\treturn;\n\n\t/* the diffs below could be optimized with an early termination\n\t * option to the git_diff functions, but for now this is sufficient\n\t * (and certainly no worse that what core git does).\n\t */\n\n\tif (ign == GIT_SUBMODULE_IGNORE_NONE)\n\t\topt.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t(void)git_repository_index__weakptr(&index, sm_repo);\n\n\t/* if we don't have an unborn head, check diff with index */\n\tif (git_repository_head_tree(&sm_head, sm_repo) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\t/* perform head to index diff on submodule */\n\t\tif (git_diff_tree_to_index(&diff, sm_repo, sm_head, index, &opt) < 0)\n\t\t\tgiterr_clear();\n\t\telse {\n\t\t\tif (git_diff_num_deltas(diff) > 0)\n\t\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED;\n\t\t\tgit_diff_free(diff);\n\t\t\tdiff = NULL;\n\t\t}\n\n\t\tgit_tree_free(sm_head);\n\t}\n\n\t/* perform index-to-workdir diff on submodule */\n\tif (git_diff_index_to_workdir(&diff, sm_repo, index, &opt) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\tsize_t untracked =\n\t\t\tgit_diff_num_deltas_of_type(diff, GIT_DELTA_UNTRACKED);\n\n\t\tif (untracked > 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNTRACKED;\n\n\t\tif (git_diff_num_deltas(diff) != untracked)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_WD_MODIFIED;\n\n\t\tgit_diff_free(diff);\n\t\tdiff = NULL;\n\t}\n}"
  },
  {
    "function_name": "submodule_get_index_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1983-1998",
    "snippet": "static void submodule_get_index_status(unsigned int *status, git_submodule *sm)\n{\n\tconst git_oid *head_oid  = git_submodule_head_id(sm);\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__INDEX_FLAGS;\n\n\tif (!head_oid) {\n\t\tif (index_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_ADDED;\n\t}\n\telse if (!index_oid)\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_DELETED;\n\telse if (!git_oid_equal(head_oid, index_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_MODIFIED;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "head_oid",
            "index_oid"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_index_id",
          "args": [
            "sm"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_index_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "933-941",
          "snippet": "const git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_head_id",
          "args": [
            "sm"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_head_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "943-951",
          "snippet": "const git_oid *git_submodule_head_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID)\n\t\treturn &submodule->head_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_head_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID)\n\t\treturn &submodule->head_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic void submodule_get_index_status(unsigned int *status, git_submodule *sm)\n{\n\tconst git_oid *head_oid  = git_submodule_head_id(sm);\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__INDEX_FLAGS;\n\n\tif (!head_oid) {\n\t\tif (index_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_ADDED;\n\t}\n\telse if (!index_oid)\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_DELETED;\n\telse if (!git_oid_equal(head_oid, index_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_MODIFIED;\n}"
  },
  {
    "function_name": "get_url_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1965-1981",
    "snippet": "static int get_url_base(git_buf *url, git_repository *repo)\n{\n\tint error;\n\tgit_remote *remote = NULL;\n\n\tif (!(error = lookup_default_remote(&remote, repo))) {\n\t\terror = git_buf_sets(url, git_remote_url(remote));\n\t\tgit_remote_free(remote);\n\t}\n\telse if (error == GIT_ENOTFOUND) {\n\t\t/* if repository does not have a default remote, use workdir instead */\n\t\tgiterr_clear();\n\t\terror = git_buf_sets(url, git_repository_workdir(repo));\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "url",
            "git_repository_workdir(repo)"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_url",
          "args": [
            "remote"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "609-613",
          "snippet": "const char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nconst char *git_remote_url(const git_remote *remote)\n{\n\tassert(remote);\n\treturn remote->url;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_default_remote",
          "args": [
            "&remote",
            "repo"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_default_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1948-1963",
          "snippet": "static int lookup_default_remote(git_remote **remote, git_repository *repo)\n{\n\tint error = lookup_head_remote(remote, repo);\n\n\t/* if that failed, use 'origin' instead */\n\tif (error == GIT_ENOTFOUND)\n\t\terror = git_remote_lookup(remote, repo, \"origin\");\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(\n\t\t\tGITERR_SUBMODULE,\n\t\t\t\"Cannot get default remote for submodule - no local tracking \"\n\t\t\t\"branch for HEAD and origin does not exist\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_default_remote(git_remote **remote, git_repository *repo)\n{\n\tint error = lookup_head_remote(remote, repo);\n\n\t/* if that failed, use 'origin' instead */\n\tif (error == GIT_ENOTFOUND)\n\t\terror = git_remote_lookup(remote, repo, \"origin\");\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(\n\t\t\tGITERR_SUBMODULE,\n\t\t\t\"Cannot get default remote for submodule - no local tracking \"\n\t\t\t\"branch for HEAD and origin does not exist\");\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int get_url_base(git_buf *url, git_repository *repo)\n{\n\tint error;\n\tgit_remote *remote = NULL;\n\n\tif (!(error = lookup_default_remote(&remote, repo))) {\n\t\terror = git_buf_sets(url, git_remote_url(remote));\n\t\tgit_remote_free(remote);\n\t}\n\telse if (error == GIT_ENOTFOUND) {\n\t\t/* if repository does not have a default remote, use workdir instead */\n\t\tgiterr_clear();\n\t\terror = git_buf_sets(url, git_repository_workdir(repo));\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "lookup_default_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1948-1963",
    "snippet": "static int lookup_default_remote(git_remote **remote, git_repository *repo)\n{\n\tint error = lookup_head_remote(remote, repo);\n\n\t/* if that failed, use 'origin' instead */\n\tif (error == GIT_ENOTFOUND)\n\t\terror = git_remote_lookup(remote, repo, \"origin\");\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(\n\t\t\tGITERR_SUBMODULE,\n\t\t\t\"Cannot get default remote for submodule - no local tracking \"\n\t\t\t\"branch for HEAD and origin does not exist\");\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Cannot get default remote for submodule - no local tracking \"\n\t\t\t\"branch for HEAD and origin does not exist\""
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "remote",
            "repo",
            "\"origin\""
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_head_remote",
          "args": [
            "remote",
            "repo"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_head_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1933-1945",
          "snippet": "static int lookup_head_remote(git_remote **remote, git_repository *repo)\n{\n\tint error;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\n\t/* lookup remote of remote tracking branch name */\n\tif (!(error = lookup_head_remote_key(&remote_name, repo)))\n\t\terror = git_remote_lookup(remote, repo, remote_name.ptr);\n\n\tgit_buf_free(&remote_name);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_head_remote(git_remote **remote, git_repository *repo)\n{\n\tint error;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\n\t/* lookup remote of remote tracking branch name */\n\tif (!(error = lookup_head_remote_key(&remote_name, repo)))\n\t\terror = git_remote_lookup(remote, repo, remote_name.ptr);\n\n\tgit_buf_free(&remote_name);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_default_remote(git_remote **remote, git_repository *repo)\n{\n\tint error = lookup_head_remote(remote, repo);\n\n\t/* if that failed, use 'origin' instead */\n\tif (error == GIT_ENOTFOUND)\n\t\terror = git_remote_lookup(remote, repo, \"origin\");\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(\n\t\t\tGITERR_SUBMODULE,\n\t\t\t\"Cannot get default remote for submodule - no local tracking \"\n\t\t\t\"branch for HEAD and origin does not exist\");\n\n\treturn error;\n}"
  },
  {
    "function_name": "lookup_head_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1933-1945",
    "snippet": "static int lookup_head_remote(git_remote **remote, git_repository *repo)\n{\n\tint error;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\n\t/* lookup remote of remote tracking branch name */\n\tif (!(error = lookup_head_remote_key(&remote_name, repo)))\n\t\terror = git_remote_lookup(remote, repo, remote_name.ptr);\n\n\tgit_buf_free(&remote_name);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&remote_name"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_lookup",
          "args": [
            "remote",
            "repo",
            "remote_name.ptr"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "420-524",
          "snippet": "int git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nint git_remote_lookup(git_remote **out, git_repository *repo, const char *name)\n{\n\tgit_remote *remote;\n\tgit_buf buf = GIT_BUF_INIT;\n\tconst char *val;\n\tint error = 0;\n\tgit_config *config;\n\tstruct refspec_cb_data data = { NULL };\n\tbool optional_setting_found = false, found;\n\n\tassert(out && repo && name);\n\n\tif ((error = ensure_remote_name_is_valid(name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tremote = git__calloc(1, sizeof(git_remote));\n\tGITERR_CHECK_ALLOC(remote);\n\n\tremote->name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(remote->name);\n\n\tif (git_vector_init(&remote->refs, 32, NULL) < 0 ||\n\t    git_vector_init(&remote->refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->passive_refspecs, 2, NULL) < 0 ||\n\t    git_vector_init(&remote->active_refspecs, 2, NULL) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_buf_printf(&buf, \"remote.%s.url\", name)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tremote->repo = repo;\n\tremote->download_tags = GIT_REMOTE_DOWNLOAD_TAGS_AUTO;\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->url = apply_insteadof(config, val, GIT_DIRECTION_FETCH);\n\t\tGITERR_CHECK_ALLOC(remote->url);\n\t}\n\n\tval = NULL;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.pushurl\", name);\n\n\tif ((error = get_optional_config(&found, config, &buf, NULL, (void *)&val)) < 0)\n\t\tgoto cleanup;\n\n\toptional_setting_found |= found;\n\n\tif (!optional_setting_found) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgiterr_set(GITERR_CONFIG, \"Remote '%s' does not exist.\", name);\n\t\tgoto cleanup;\n\t}\n\n\tif (found && strlen(val) > 0) {\n\t\tremote->pushurl = apply_insteadof(config, val, GIT_DIRECTION_PUSH);\n\t\tGITERR_CHECK_ALLOC(remote->pushurl);\n\t}\n\n\tdata.remote = remote;\n\tdata.fetch = true;\n\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.fetch\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tdata.fetch = false;\n\tgit_buf_clear(&buf);\n\tgit_buf_printf(&buf, \"remote.%s.push\", name);\n\n\tif ((error = get_optional_config(NULL, config, &buf, refspec_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (download_tags_value(remote, config) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = lookup_remote_prune_config(remote, config, name)) < 0)\n\t\tgoto cleanup;\n\n\t/* Move the data over to where the matching functions can find them */\n\tif ((error = dwim_refspecs(&remote->active_refspecs, &remote->refspecs, &remote->refs)) < 0)\n\t\tgoto cleanup;\n\n\t*out = remote;\n\ncleanup:\n\tgit_config_free(config);\n\tgit_buf_free(&buf);\n\n\tif (error < 0)\n\t\tgit_remote_free(remote);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_head_remote_key",
          "args": [
            "&remote_name",
            "repo"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_head_remote_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1892-1930",
          "snippet": "static int lookup_head_remote_key(git_buf *remote_name, git_repository *repo)\n{\n\tint error;\n\tgit_reference *head = NULL;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\t/* lookup and dereference HEAD */\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\t/**\n\t * If head does not refer to a branch, then return\n\t * GIT_ENOTFOUND to indicate that we could not find\n\t * a remote key for the local tracking branch HEAD points to.\n\t **/\n\tif (!git_reference_is_branch(head)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"HEAD does not refer to a branch.\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\t/* lookup remote tracking branch of HEAD */\n\tif ((error = git_branch_upstream_name(\n\t\t&upstream_name,\n\t\trepo,\n\t\tgit_reference_name(head))) < 0)\n\t\tgoto done;\n\n\t/* lookup remote of remote tracking branch */\n\tif ((error = git_branch_remote_name(remote_name, repo, upstream_name.ptr)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_buf_free(&upstream_name);\n\tgit_reference_free(head);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_head_remote_key(git_buf *remote_name, git_repository *repo)\n{\n\tint error;\n\tgit_reference *head = NULL;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\t/* lookup and dereference HEAD */\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\t/**\n\t * If head does not refer to a branch, then return\n\t * GIT_ENOTFOUND to indicate that we could not find\n\t * a remote key for the local tracking branch HEAD points to.\n\t **/\n\tif (!git_reference_is_branch(head)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"HEAD does not refer to a branch.\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\t/* lookup remote tracking branch of HEAD */\n\tif ((error = git_branch_upstream_name(\n\t\t&upstream_name,\n\t\trepo,\n\t\tgit_reference_name(head))) < 0)\n\t\tgoto done;\n\n\t/* lookup remote of remote tracking branch */\n\tif ((error = git_branch_remote_name(remote_name, repo, upstream_name.ptr)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_buf_free(&upstream_name);\n\tgit_reference_free(head);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_head_remote(git_remote **remote, git_repository *repo)\n{\n\tint error;\n\tgit_buf remote_name = GIT_BUF_INIT;\n\n\t/* lookup remote of remote tracking branch name */\n\tif (!(error = lookup_head_remote_key(&remote_name, repo)))\n\t\terror = git_remote_lookup(remote, repo, remote_name.ptr);\n\n\tgit_buf_free(&remote_name);\n\n\treturn error;\n}"
  },
  {
    "function_name": "lookup_head_remote_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1892-1930",
    "snippet": "static int lookup_head_remote_key(git_buf *remote_name, git_repository *repo)\n{\n\tint error;\n\tgit_reference *head = NULL;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\t/* lookup and dereference HEAD */\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\t/**\n\t * If head does not refer to a branch, then return\n\t * GIT_ENOTFOUND to indicate that we could not find\n\t * a remote key for the local tracking branch HEAD points to.\n\t **/\n\tif (!git_reference_is_branch(head)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"HEAD does not refer to a branch.\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\t/* lookup remote tracking branch of HEAD */\n\tif ((error = git_branch_upstream_name(\n\t\t&upstream_name,\n\t\trepo,\n\t\tgit_reference_name(head))) < 0)\n\t\tgoto done;\n\n\t/* lookup remote of remote tracking branch */\n\tif ((error = git_branch_remote_name(remote_name, repo, upstream_name.ptr)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_buf_free(&upstream_name);\n\tgit_reference_free(head);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "head"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&upstream_name"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_remote_name",
          "args": [
            "remote_name",
            "repo",
            "upstream_name.ptr"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_remote_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "422-488",
          "snippet": "int git_branch_remote_name(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tgit_strarray remote_list = {0};\n\tsize_t i;\n\tgit_remote *remote;\n\tconst git_refspec *fetchspec;\n\tint error = 0;\n\tchar *remote_name = NULL;\n\n\tassert(buf && repo && refname);\n\n\tgit_buf_sanitize(buf);\n\n\t/* Verify that this is a remote branch */\n\tif (!git_reference__is_remote(refname)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a remote branch.\",\n\t\t\trefname);\n\t\terror = GIT_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the remotes */\n\tif ((error = git_remote_list(&remote_list, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* Find matching remotes */\n\tfor (i = 0; i < remote_list.count; i++) {\n\t\tif ((error = git_remote_lookup(&remote, repo, remote_list.strings[i])) < 0)\n\t\t\tcontinue;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, refname);\n\t\tif (fetchspec) {\n\t\t\t/* If we have not already set out yet, then set\n\t\t\t * it to the matching remote name. Otherwise\n\t\t\t * multiple remotes match this reference, and it\n\t\t\t * is ambiguous. */\n\t\t\tif (!remote_name) {\n\t\t\t\tremote_name = remote_list.strings[i];\n\t\t\t} else {\n\t\t\t\tgit_remote_free(remote);\n\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Reference '%s' is ambiguous\", refname);\n\t\t\t\terror = GIT_EAMBIGUOUS;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tgit_remote_free(remote);\n\t}\n\n\tif (remote_name) {\n\t\tgit_buf_clear(buf);\n\t\terror = git_buf_puts(buf, remote_name);\n\t} else {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not determine remote for '%s'\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit_buf_free(buf);\n\n\tgit_strarray_free(&remote_list);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_remote_name(git_buf *buf, git_repository *repo, const char *refname)\n{\n\tgit_strarray remote_list = {0};\n\tsize_t i;\n\tgit_remote *remote;\n\tconst git_refspec *fetchspec;\n\tint error = 0;\n\tchar *remote_name = NULL;\n\n\tassert(buf && repo && refname);\n\n\tgit_buf_sanitize(buf);\n\n\t/* Verify that this is a remote branch */\n\tif (!git_reference__is_remote(refname)) {\n\t\tgiterr_set(GITERR_INVALID, \"Reference '%s' is not a remote branch.\",\n\t\t\trefname);\n\t\terror = GIT_ERROR;\n\t\tgoto cleanup;\n\t}\n\n\t/* Get the remotes */\n\tif ((error = git_remote_list(&remote_list, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* Find matching remotes */\n\tfor (i = 0; i < remote_list.count; i++) {\n\t\tif ((error = git_remote_lookup(&remote, repo, remote_list.strings[i])) < 0)\n\t\t\tcontinue;\n\n\t\tfetchspec = git_remote__matching_dst_refspec(remote, refname);\n\t\tif (fetchspec) {\n\t\t\t/* If we have not already set out yet, then set\n\t\t\t * it to the matching remote name. Otherwise\n\t\t\t * multiple remotes match this reference, and it\n\t\t\t * is ambiguous. */\n\t\t\tif (!remote_name) {\n\t\t\t\tremote_name = remote_list.strings[i];\n\t\t\t} else {\n\t\t\t\tgit_remote_free(remote);\n\n\t\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\t\"Reference '%s' is ambiguous\", refname);\n\t\t\t\terror = GIT_EAMBIGUOUS;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tgit_remote_free(remote);\n\t}\n\n\tif (remote_name) {\n\t\tgit_buf_clear(buf);\n\t\terror = git_buf_puts(buf, remote_name);\n\t} else {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not determine remote for '%s'\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tif (error < 0)\n\t\tgit_buf_free(buf);\n\n\tgit_strarray_free(&remote_list);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_upstream_name",
          "args": [
            "&upstream_name",
            "repo",
            "git_reference_name(head)"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_upstream_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "332-395",
          "snippet": "int git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream_name(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tconst char *refname)\n{\n\tgit_buf remote_name = GIT_BUF_INIT;\n\tgit_buf merge_name = GIT_BUF_INIT;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error = -1;\n\tgit_remote *remote = NULL;\n\tconst git_refspec *refspec;\n\tgit_config *config;\n\n\tassert(out && refname);\n\n\tgit_buf_sanitize(out);\n\n\tif (!git_reference__is_branch(refname))\n\t\treturn not_a_local_branch(refname);\n\n\tif ((error = git_repository_config_snapshot(&config, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&remote_name, config, refname, \"branch.%s.remote\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif ((error = retrieve_upstream_configuration(\n\t\t&merge_name, config, refname, \"branch.%s.merge\")) < 0)\n\t\t\tgoto cleanup;\n\n\tif (git_buf_len(&remote_name) == 0 || git_buf_len(&merge_name) == 0) {\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"branch '%s' does not have an upstream\", refname);\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\tif (strcmp(\".\", git_buf_cstr(&remote_name)) != 0) {\n\t\tif ((error = git_remote_lookup(&remote, repo, git_buf_cstr(&remote_name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\trefspec = git_remote__matching_refspec(remote, git_buf_cstr(&merge_name));\n\t\tif (!refspec) {\n\t\t\terror = GIT_ENOTFOUND;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (git_refspec_transform(&buf, refspec, git_buf_cstr(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\t} else\n\t\tif (git_buf_set(&buf, git_buf_cstr(&merge_name), git_buf_len(&merge_name)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = git_buf_set(out, git_buf_cstr(&buf), git_buf_len(&buf));\n\ncleanup:\n\tgit_config_free(config);\n\tgit_remote_free(remote);\n\tgit_buf_free(&remote_name);\n\tgit_buf_free(&merge_name);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "head"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"HEAD does not refer to a branch.\""
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_branch",
          "args": [
            "head"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1177-1181",
          "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head",
          "args": [
            "&head",
            "repo"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_head_remote_key(git_buf *remote_name, git_repository *repo)\n{\n\tint error;\n\tgit_reference *head = NULL;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\t/* lookup and dereference HEAD */\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\t/**\n\t * If head does not refer to a branch, then return\n\t * GIT_ENOTFOUND to indicate that we could not find\n\t * a remote key for the local tracking branch HEAD points to.\n\t **/\n\tif (!git_reference_is_branch(head)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"HEAD does not refer to a branch.\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\t/* lookup remote tracking branch of HEAD */\n\tif ((error = git_branch_upstream_name(\n\t\t&upstream_name,\n\t\trepo,\n\t\tgit_reference_name(head))) < 0)\n\t\tgoto done;\n\n\t/* lookup remote of remote tracking branch */\n\tif ((error = git_branch_remote_name(remote_name, repo, upstream_name.ptr)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_buf_free(&upstream_name);\n\tgit_reference_free(head);\n\n\treturn error;\n}"
  },
  {
    "function_name": "open_gitmodules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1862-1889",
    "snippet": "static git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_MODULES_FILE \".gitmodules\""
    ],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_free",
          "args": [
            "mods"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "17-21",
          "snippet": "GIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_open",
          "args": [
            "mods",
            "GIT_CONFIG_LEVEL_LOCAL"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "12-15",
          "snippet": "GIT_INLINE(int) git_config_file_open(git_config_backend *cfg, unsigned int level)\n{\n\treturn cfg->open(cfg, level);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(int) git_config_file_open(git_config_backend *cfg, unsigned int level)\n{\n\treturn cfg->open(cfg, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file__ondisk",
          "args": [
            "&mods",
            "path.ptr"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file__ondisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.c",
          "lines": "711-739",
          "snippet": "int git_config_file__ondisk(git_config_backend **out, const char *path)\n{\n\tdiskfile_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->file_path = git__strdup(path);\n\tGITERR_CHECK_ALLOC(backend->file_path);\n\n\tbackend->header.parent.open = config_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set;\n\tbackend->header.parent.set_multivar = config_set_multivar;\n\tbackend->header.parent.del = config_delete;\n\tbackend->header.parent.del_multivar = config_delete_multivar;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.snapshot = config_snapshot;\n\tbackend->header.parent.lock = config_lock;\n\tbackend->header.parent.unlock = config_unlock;\n\tbackend->header.parent.free = backend_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}",
          "includes": [
            "#include <regex.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include \"array.h\"",
            "#include \"strmap.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"sysdir.h\"",
            "#include \"filebuf.h\"",
            "#include \"config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regex.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include \"array.h\"\n#include \"strmap.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"sysdir.h\"\n#include \"filebuf.h\"\n#include \"config.h\"\n#include \"common.h\"\n\nint git_config_file__ondisk(git_config_backend **out, const char *path)\n{\n\tdiskfile_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(diskfile_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->header.parent.version = GIT_CONFIG_BACKEND_VERSION;\n\tgit_mutex_init(&backend->header.values_mutex);\n\n\tbackend->file_path = git__strdup(path);\n\tGITERR_CHECK_ALLOC(backend->file_path);\n\n\tbackend->header.parent.open = config_open;\n\tbackend->header.parent.get = config_get;\n\tbackend->header.parent.set = config_set;\n\tbackend->header.parent.set_multivar = config_set_multivar;\n\tbackend->header.parent.del = config_delete;\n\tbackend->header.parent.del_multivar = config_delete_multivar;\n\tbackend->header.parent.iterator = config_iterator_new;\n\tbackend->header.parent.snapshot = config_snapshot;\n\tbackend->header.parent.lock = config_lock;\n\tbackend->header.parent.unlock = config_unlock;\n\tbackend->header.parent.free = backend_free;\n\n\t*out = (git_config_backend *)backend;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "path.ptr"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "workdir",
            "GIT_MODULES_FILE"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}"
  },
  {
    "function_name": "gitmodules_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1838-1860",
    "snippet": "static git_config *gitmodules_snapshot(git_repository *repo)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_config *mods = NULL, *snap = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (git_config_open_ondisk(&mods, path.ptr) < 0)\n\t\t\tmods = NULL;\n\t}\n\n\tgit_buf_free(&path);\n\n\tif (mods) {\n\t\tgit_config_snapshot(&snap, mods);\n\t\tgit_config_free(mods);\n\t}\n\n\treturn snap;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_MODULES_FILE \".gitmodules\""
    ],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "mods"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_snapshot",
          "args": [
            "&snap",
            "mods"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "149-179",
          "snippet": "int git_config_snapshot(git_config **out, git_config *in)\n{\n\tint error = 0;\n\tsize_t i;\n\tfile_internal *internal;\n\tgit_config *config;\n\n\t*out = NULL;\n\n\tif (git_config_new(&config) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&in->files, i, internal) {\n\t\tgit_config_backend *b;\n\n\t\tif ((error = internal->file->snapshot(&b, internal->file)) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_add_backend(config, b, internal->level, 0)) < 0) {\n\t\t\tb->free(b);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error < 0)\n\t\tgit_config_free(config);\n\telse\n\t\t*out = config;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_snapshot(git_config **out, git_config *in)\n{\n\tint error = 0;\n\tsize_t i;\n\tfile_internal *internal;\n\tgit_config *config;\n\n\t*out = NULL;\n\n\tif (git_config_new(&config) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&in->files, i, internal) {\n\t\tgit_config_backend *b;\n\n\t\tif ((error = internal->file->snapshot(&b, internal->file)) < 0)\n\t\t\tbreak;\n\n\t\tif ((error = git_config_add_backend(config, b, internal->level, 0)) < 0) {\n\t\t\tb->free(b);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (error < 0)\n\t\tgit_config_free(config);\n\telse\n\t\t*out = config;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_open_ondisk",
          "args": [
            "&mods",
            "path.ptr"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_open_ondisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "131-147",
          "snippet": "int git_config_open_ondisk(git_config **out, const char *path)\n{\n\tint error;\n\tgit_config *config;\n\n\t*out = NULL;\n\n\tif (git_config_new(&config) < 0)\n\t\treturn -1;\n\n\tif ((error = git_config_add_file_ondisk(config, path, GIT_CONFIG_LEVEL_LOCAL, 0)) < 0)\n\t\tgit_config_free(config);\n\telse\n\t\t*out = config;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_open_ondisk(git_config **out, const char *path)\n{\n\tint error;\n\tgit_config *config;\n\n\t*out = NULL;\n\n\tif (git_config_new(&config) < 0)\n\t\treturn -1;\n\n\tif ((error = git_config_add_file_ondisk(config, path, GIT_CONFIG_LEVEL_LOCAL, 0)) < 0)\n\t\tgit_config_free(config);\n\telse\n\t\t*out = config;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "workdir",
            "GIT_MODULES_FILE"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config *gitmodules_snapshot(git_repository *repo)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_config *mods = NULL, *snap = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (git_config_open_ondisk(&mods, path.ptr) < 0)\n\t\t\tmods = NULL;\n\t}\n\n\tgit_buf_free(&path);\n\n\tif (mods) {\n\t\tgit_config_snapshot(&snap, mods);\n\t\tgit_config_free(mods);\n\t}\n\n\treturn snap;\n}"
  },
  {
    "function_name": "submodule_load_from_wd_lite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1816-1831",
    "snippet": "static int submodule_load_from_wd_lite(git_submodule *sm)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&path, git_repository_workdir(sm->repo), sm->path) < 0)\n\t\treturn -1;\n\n\tif (git_path_isdir(path.ptr))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\tif (git_path_contains(&path, DOT_GIT))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD;\n\n\tgit_buf_free(&path);\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_contains",
          "args": [
            "&path",
            "DOT_GIT"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_contains_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "678-681",
          "snippet": "bool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "path.ptr"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "git_repository_workdir(sm->repo)",
            "sm->path"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "sm->repo"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_load_from_wd_lite(git_submodule *sm)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&path, git_repository_workdir(sm->repo), sm->path) < 0)\n\t\treturn -1;\n\n\tif (git_path_isdir(path.ptr))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\tif (git_path_contains(&path, DOT_GIT))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD;\n\n\tgit_buf_free(&path);\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_load_each",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1760-1814",
    "snippet": "static int submodule_load_each(const git_config_entry *entry, void *payload)\n{\n\tlfc_data *data = payload;\n\tconst char *namestart, *property;\n\tgit_strmap_iter pos;\n\tgit_strmap *map = data->map;\n\tgit_buf name = GIT_BUF_INIT;\n\tgit_submodule *sm;\n\tint error;\n\n\tif (git__prefixcmp(entry->name, \"submodule.\") != 0)\n\t\treturn 0;\n\n\tnamestart = entry->name + strlen(\"submodule.\");\n\tproperty  = strrchr(namestart, '.');\n\n\tif (!property || (property == namestart))\n\t\treturn 0;\n\n\tproperty++;\n\n\tif ((error = git_buf_set(&name, namestart, property - namestart -1)) < 0)\n\t\treturn error;\n\n\t/*\n\t * Now that we have the submodule's name, we can use that to\n\t * figure out whether it's in the map. If it's not, we create\n\t * a new submodule, load the config and insert it. If it's\n\t * already inserted, we've already loaded it, so we skip.\n\t */\n\tpos = git_strmap_lookup_index(map, name.ptr);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\terror = 0;\n\t\tgoto done;\n\t}\n\n\tif ((error = submodule_alloc(&sm, data->repo, name.ptr)) < 0)\n\t\tgoto done;\n\n\tif ((error = submodule_read_config(sm, data->mods)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\tgoto done;\n\t}\n\n\tgit_strmap_insert(map, sm->name, sm, error);\n\tassert(error != 0);\n\tif (error < 0)\n\t\tgoto done;\n\n\terror = 0;\n\ndone:\n\tgit_buf_free(&name);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_each(const git_config_entry *entry, void *payload);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error != 0"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_insert",
          "args": [
            "map",
            "sm->name",
            "sm",
            "error"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_read_config",
          "args": [
            "sm",
            "data->mods"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_read_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1680-1758",
          "snippet": "static int submodule_read_config(git_submodule *sm, git_config *cfg)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tconst char *value;\n\tint error, in_config = 0;\n\n\t/*\n\t * TODO: Look up path in index and if it is present but not a GITLINK\n\t * then this should be deleted (at least to match git's behavior)\n\t */\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"path\")) == 0) {\n\t\tin_config = 1;\n\t/*\n\t * TODO: if case insensitive filesystem, then the following strcmp\n\t * should be strcasecmp\n\t */\n\t\tif (strcmp(sm->name, value) != 0) {\n\t\t\tif (sm->path != sm->name)\n\t\t\t\tgit__free(sm->path);\n\t\t\tsm->path = git__strdup(value);\n\t\t\tGITERR_CHECK_ALLOC(sm->path);\n\t\t}\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"url\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->url = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->url);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"branch\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->branch = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->branch);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"update\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_update(&sm->update, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->update_default = sm->update;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"fetchRecurseSubmodules\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_recurse(&sm->fetch_recurse, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->fetch_recurse_default = sm->fetch_recurse;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"ignore\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_ignore(&sm->ignore, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->ignore_default = sm->ignore;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif (in_config)\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&key);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tconst char *value;\n\tint error, in_config = 0;\n\n\t/*\n\t * TODO: Look up path in index and if it is present but not a GITLINK\n\t * then this should be deleted (at least to match git's behavior)\n\t */\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"path\")) == 0) {\n\t\tin_config = 1;\n\t/*\n\t * TODO: if case insensitive filesystem, then the following strcmp\n\t * should be strcasecmp\n\t */\n\t\tif (strcmp(sm->name, value) != 0) {\n\t\t\tif (sm->path != sm->name)\n\t\t\t\tgit__free(sm->path);\n\t\t\tsm->path = git__strdup(value);\n\t\t\tGITERR_CHECK_ALLOC(sm->path);\n\t\t}\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"url\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->url = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->url);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"branch\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->branch = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->branch);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"update\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_update(&sm->update, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->update_default = sm->update;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"fetchRecurseSubmodules\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_recurse(&sm->fetch_recurse, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->fetch_recurse_default = sm->fetch_recurse;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"ignore\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_ignore(&sm->ignore, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->ignore_default = sm->ignore;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif (in_config)\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&key);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_alloc",
          "args": [
            "&sm",
            "data->repo",
            "name.ptr"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1562-1591",
          "snippet": "static int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "map",
            "pos"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "map",
            "name.ptr"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "&name",
            "namestart",
            "property - namestart -1"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "namestart",
            "'.'"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"submodule.\""
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "entry->name",
            "\"submodule.\""
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_each(const git_config_entry *entry, void *payload);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_load_each(const git_config_entry *entry, void *payload)\n{\n\tlfc_data *data = payload;\n\tconst char *namestart, *property;\n\tgit_strmap_iter pos;\n\tgit_strmap *map = data->map;\n\tgit_buf name = GIT_BUF_INIT;\n\tgit_submodule *sm;\n\tint error;\n\n\tif (git__prefixcmp(entry->name, \"submodule.\") != 0)\n\t\treturn 0;\n\n\tnamestart = entry->name + strlen(\"submodule.\");\n\tproperty  = strrchr(namestart, '.');\n\n\tif (!property || (property == namestart))\n\t\treturn 0;\n\n\tproperty++;\n\n\tif ((error = git_buf_set(&name, namestart, property - namestart -1)) < 0)\n\t\treturn error;\n\n\t/*\n\t * Now that we have the submodule's name, we can use that to\n\t * figure out whether it's in the map. If it's not, we create\n\t * a new submodule, load the config and insert it. If it's\n\t * already inserted, we've already loaded it, so we skip.\n\t */\n\tpos = git_strmap_lookup_index(map, name.ptr);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\terror = 0;\n\t\tgoto done;\n\t}\n\n\tif ((error = submodule_alloc(&sm, data->repo, name.ptr)) < 0)\n\t\tgoto done;\n\n\tif ((error = submodule_read_config(sm, data->mods)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\tgoto done;\n\t}\n\n\tgit_strmap_insert(map, sm->name, sm, error);\n\tassert(error != 0);\n\tif (error < 0)\n\t\tgoto done;\n\n\terror = 0;\n\ndone:\n\tgit_buf_free(&name);\n\treturn error;\n}"
  },
  {
    "function_name": "submodule_read_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1680-1758",
    "snippet": "static int submodule_read_config(git_submodule *sm, git_config *cfg)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tconst char *value;\n\tint error, in_config = 0;\n\n\t/*\n\t * TODO: Look up path in index and if it is present but not a GITLINK\n\t * then this should be deleted (at least to match git's behavior)\n\t */\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"path\")) == 0) {\n\t\tin_config = 1;\n\t/*\n\t * TODO: if case insensitive filesystem, then the following strcmp\n\t * should be strcasecmp\n\t */\n\t\tif (strcmp(sm->name, value) != 0) {\n\t\t\tif (sm->path != sm->name)\n\t\t\t\tgit__free(sm->path);\n\t\t\tsm->path = git__strdup(value);\n\t\t\tGITERR_CHECK_ALLOC(sm->path);\n\t\t}\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"url\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->url = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->url);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"branch\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->branch = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->branch);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"update\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_update(&sm->update, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->update_default = sm->update;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"fetchRecurseSubmodules\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_recurse(&sm->fetch_recurse, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->fetch_recurse_default = sm->fetch_recurse;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"ignore\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_ignore(&sm->ignore, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->ignore_default = sm->ignore;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif (in_config)\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&key);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&key"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_parse_ignore",
          "args": [
            "&sm->ignore",
            "value"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_parse_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1625-1637",
          "snippet": "int git_submodule_parse_ignore(git_submodule_ignore_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_IGNORE_NONE;\n\t\treturn submodule_config_error(\"ignore\", value);\n\t}\n\n\t*out = (git_submodule_ignore_t)val;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_parse_ignore(git_submodule_ignore_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_IGNORE_NONE;\n\t\treturn submodule_config_error(\"ignore\", value);\n\t}\n\n\t*out = (git_submodule_ignore_t)val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_value",
          "args": [
            "&value",
            "cfg",
            "&key",
            "sm->name",
            "\"ignore\""
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "get_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1667-1678",
          "snippet": "static int get_value(const char **out, git_config *cfg, git_buf *buf, const char *name, const char *field)\n{\n\tint error;\n\n\tgit_buf_clear(buf);\n\n\tif ((error = git_buf_printf(buf, \"submodule.%s.%s\", name, field)) < 0 ||\n\t    (error = git_config_get_string(out, cfg, buf->ptr)) < 0)\n\t\treturn error;\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\n\nstatic int get_value(const char **out, git_config *cfg, git_buf *buf, const char *name, const char *field)\n{\n\tint error;\n\n\tgit_buf_clear(buf);\n\n\tif ((error = git_buf_printf(buf, \"submodule.%s.%s\", name, field)) < 0 ||\n\t    (error = git_config_get_string(out, cfg, buf->ptr)) < 0)\n\t\treturn error;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_parse_recurse",
          "args": [
            "&sm->fetch_recurse",
            "value"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_parse_recurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1653-1665",
          "snippet": "int git_submodule_parse_recurse(git_submodule_recurse_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_recurse_map, ARRAY_SIZE(_sm_recurse_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_RECURSE_YES;\n\t\treturn submodule_config_error(\"recurse\", value);\n\t}\n\n\t*out = (git_submodule_recurse_t)val;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_cvar_map _sm_recurse_map[] = {\n\t{GIT_CVAR_STRING, \"on-demand\", GIT_SUBMODULE_RECURSE_ONDEMAND},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_RECURSE_NO},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_RECURSE_YES},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_recurse_map[] = {\n\t{GIT_CVAR_STRING, \"on-demand\", GIT_SUBMODULE_RECURSE_ONDEMAND},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_RECURSE_NO},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_RECURSE_YES},\n};\n\nint git_submodule_parse_recurse(git_submodule_recurse_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_recurse_map, ARRAY_SIZE(_sm_recurse_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_RECURSE_YES;\n\t\treturn submodule_config_error(\"recurse\", value);\n\t}\n\n\t*out = (git_submodule_recurse_t)val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_parse_update",
          "args": [
            "&sm->update",
            "value"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_parse_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1639-1651",
          "snippet": "int git_submodule_parse_update(git_submodule_update_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_update_map, ARRAY_SIZE(_sm_update_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\t\treturn submodule_config_error(\"update\", value);\n\t}\n\n\t*out = (git_submodule_update_t)val;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};\n\nint git_submodule_parse_update(git_submodule_update_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_update_map, ARRAY_SIZE(_sm_update_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\t\treturn submodule_config_error(\"update\", value);\n\t}\n\n\t*out = (git_submodule_update_t)val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sm->branch"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "value"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sm->url"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sm->path"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sm->path"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sm->name",
            "value"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tconst char *value;\n\tint error, in_config = 0;\n\n\t/*\n\t * TODO: Look up path in index and if it is present but not a GITLINK\n\t * then this should be deleted (at least to match git's behavior)\n\t */\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"path\")) == 0) {\n\t\tin_config = 1;\n\t/*\n\t * TODO: if case insensitive filesystem, then the following strcmp\n\t * should be strcasecmp\n\t */\n\t\tif (strcmp(sm->name, value) != 0) {\n\t\t\tif (sm->path != sm->name)\n\t\t\t\tgit__free(sm->path);\n\t\t\tsm->path = git__strdup(value);\n\t\t\tGITERR_CHECK_ALLOC(sm->path);\n\t\t}\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"url\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->url = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->url);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"branch\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->branch = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->branch);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"update\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_update(&sm->update, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->update_default = sm->update;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"fetchRecurseSubmodules\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_recurse(&sm->fetch_recurse, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->fetch_recurse_default = sm->fetch_recurse;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"ignore\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_ignore(&sm->ignore, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->ignore_default = sm->ignore;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif (in_config)\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&key);\n\treturn error;\n}"
  },
  {
    "function_name": "get_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1667-1678",
    "snippet": "static int get_value(const char **out, git_config *cfg, git_buf *buf, const char *name, const char *field)\n{\n\tint error;\n\n\tgit_buf_clear(buf);\n\n\tif ((error = git_buf_printf(buf, \"submodule.%s.%s\", name, field)) < 0 ||\n\t    (error = git_config_get_string(out, cfg, buf->ptr)) < 0)\n\t\treturn error;\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_get_string",
          "args": [
            "out",
            "cfg",
            "buf->ptr"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_string_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "857-875",
          "snippet": "int git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "buf",
            "\"submodule.%s.%s\"",
            "name",
            "field"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\n\nstatic int get_value(const char **out, git_config *cfg, git_buf *buf, const char *name, const char *field)\n{\n\tint error;\n\n\tgit_buf_clear(buf);\n\n\tif ((error = git_buf_printf(buf, \"submodule.%s.%s\", name, field)) < 0 ||\n\t    (error = git_config_get_string(out, cfg, buf->ptr)) < 0)\n\t\treturn error;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_parse_recurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1653-1665",
    "snippet": "int git_submodule_parse_recurse(git_submodule_recurse_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_recurse_map, ARRAY_SIZE(_sm_recurse_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_RECURSE_YES;\n\t\treturn submodule_config_error(\"recurse\", value);\n\t}\n\n\t*out = (git_submodule_recurse_t)val;\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_recurse_map[] = {\n\t{GIT_CVAR_STRING, \"on-demand\", GIT_SUBMODULE_RECURSE_ONDEMAND},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_RECURSE_NO},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_RECURSE_YES},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_config_error",
          "args": [
            "\"recurse\"",
            "value"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_config_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1618-1623",
          "snippet": "static int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_lookup_map_value",
          "args": [
            "&val",
            "_sm_recurse_map",
            "ARRAY_SIZE(_sm_recurse_map)",
            "value"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_lookup_map_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1197-1241",
          "snippet": "int git_config_lookup_map_value(\n\tint *out,\n\tconst git_cvar_map *maps,\n\tsize_t map_n,\n\tconst char *value)\n{\n\tsize_t i;\n\n\tif (!value)\n\t\tgoto fail_parse;\n\n\tfor (i = 0; i < map_n; ++i) {\n\t\tconst git_cvar_map *m = maps + i;\n\n\t\tswitch (m->cvar_type) {\n\t\tcase GIT_CVAR_FALSE:\n\t\tcase GIT_CVAR_TRUE: {\n\t\t\tint bool_val;\n\n\t\t\tif (git__parse_bool(&bool_val, value) == 0 &&\n\t\t\t\tbool_val == (int)m->cvar_type) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GIT_CVAR_INT32:\n\t\t\tif (git_config_parse_int32(out, value) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase GIT_CVAR_STRING:\n\t\t\tif (strcasecmp(value, m->str_match) == 0) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nfail_parse:\n\tgiterr_set(GITERR_CONFIG, \"Failed to map '%s'\", value);\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_lookup_map_value(\n\tint *out,\n\tconst git_cvar_map *maps,\n\tsize_t map_n,\n\tconst char *value)\n{\n\tsize_t i;\n\n\tif (!value)\n\t\tgoto fail_parse;\n\n\tfor (i = 0; i < map_n; ++i) {\n\t\tconst git_cvar_map *m = maps + i;\n\n\t\tswitch (m->cvar_type) {\n\t\tcase GIT_CVAR_FALSE:\n\t\tcase GIT_CVAR_TRUE: {\n\t\t\tint bool_val;\n\n\t\t\tif (git__parse_bool(&bool_val, value) == 0 &&\n\t\t\t\tbool_val == (int)m->cvar_type) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GIT_CVAR_INT32:\n\t\t\tif (git_config_parse_int32(out, value) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase GIT_CVAR_STRING:\n\t\t\tif (strcasecmp(value, m->str_match) == 0) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nfail_parse:\n\tgiterr_set(GITERR_CONFIG, \"Failed to map '%s'\", value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_recurse_map"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_recurse_map[] = {\n\t{GIT_CVAR_STRING, \"on-demand\", GIT_SUBMODULE_RECURSE_ONDEMAND},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_RECURSE_NO},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_RECURSE_YES},\n};\n\nint git_submodule_parse_recurse(git_submodule_recurse_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_recurse_map, ARRAY_SIZE(_sm_recurse_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_RECURSE_YES;\n\t\treturn submodule_config_error(\"recurse\", value);\n\t}\n\n\t*out = (git_submodule_recurse_t)val;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_submodule_parse_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1639-1651",
    "snippet": "int git_submodule_parse_update(git_submodule_update_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_update_map, ARRAY_SIZE(_sm_update_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\t\treturn submodule_config_error(\"update\", value);\n\t}\n\n\t*out = (git_submodule_update_t)val;\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_config_error",
          "args": [
            "\"update\"",
            "value"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_config_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1618-1623",
          "snippet": "static int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_lookup_map_value",
          "args": [
            "&val",
            "_sm_update_map",
            "ARRAY_SIZE(_sm_update_map)",
            "value"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_lookup_map_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1197-1241",
          "snippet": "int git_config_lookup_map_value(\n\tint *out,\n\tconst git_cvar_map *maps,\n\tsize_t map_n,\n\tconst char *value)\n{\n\tsize_t i;\n\n\tif (!value)\n\t\tgoto fail_parse;\n\n\tfor (i = 0; i < map_n; ++i) {\n\t\tconst git_cvar_map *m = maps + i;\n\n\t\tswitch (m->cvar_type) {\n\t\tcase GIT_CVAR_FALSE:\n\t\tcase GIT_CVAR_TRUE: {\n\t\t\tint bool_val;\n\n\t\t\tif (git__parse_bool(&bool_val, value) == 0 &&\n\t\t\t\tbool_val == (int)m->cvar_type) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GIT_CVAR_INT32:\n\t\t\tif (git_config_parse_int32(out, value) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase GIT_CVAR_STRING:\n\t\t\tif (strcasecmp(value, m->str_match) == 0) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nfail_parse:\n\tgiterr_set(GITERR_CONFIG, \"Failed to map '%s'\", value);\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_lookup_map_value(\n\tint *out,\n\tconst git_cvar_map *maps,\n\tsize_t map_n,\n\tconst char *value)\n{\n\tsize_t i;\n\n\tif (!value)\n\t\tgoto fail_parse;\n\n\tfor (i = 0; i < map_n; ++i) {\n\t\tconst git_cvar_map *m = maps + i;\n\n\t\tswitch (m->cvar_type) {\n\t\tcase GIT_CVAR_FALSE:\n\t\tcase GIT_CVAR_TRUE: {\n\t\t\tint bool_val;\n\n\t\t\tif (git__parse_bool(&bool_val, value) == 0 &&\n\t\t\t\tbool_val == (int)m->cvar_type) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GIT_CVAR_INT32:\n\t\t\tif (git_config_parse_int32(out, value) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase GIT_CVAR_STRING:\n\t\t\tif (strcasecmp(value, m->str_match) == 0) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nfail_parse:\n\tgiterr_set(GITERR_CONFIG, \"Failed to map '%s'\", value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_update_map"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};\n\nint git_submodule_parse_update(git_submodule_update_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_update_map, ARRAY_SIZE(_sm_update_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\t\treturn submodule_config_error(\"update\", value);\n\t}\n\n\t*out = (git_submodule_update_t)val;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_submodule_parse_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1625-1637",
    "snippet": "int git_submodule_parse_ignore(git_submodule_ignore_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_IGNORE_NONE;\n\t\treturn submodule_config_error(\"ignore\", value);\n\t}\n\n\t*out = (git_submodule_ignore_t)val;\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};",
      "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_config_error",
          "args": [
            "\"ignore\"",
            "value"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_config_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1618-1623",
          "snippet": "static int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_lookup_map_value",
          "args": [
            "&val",
            "_sm_ignore_map",
            "ARRAY_SIZE(_sm_ignore_map)",
            "value"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_lookup_map_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1197-1241",
          "snippet": "int git_config_lookup_map_value(\n\tint *out,\n\tconst git_cvar_map *maps,\n\tsize_t map_n,\n\tconst char *value)\n{\n\tsize_t i;\n\n\tif (!value)\n\t\tgoto fail_parse;\n\n\tfor (i = 0; i < map_n; ++i) {\n\t\tconst git_cvar_map *m = maps + i;\n\n\t\tswitch (m->cvar_type) {\n\t\tcase GIT_CVAR_FALSE:\n\t\tcase GIT_CVAR_TRUE: {\n\t\t\tint bool_val;\n\n\t\t\tif (git__parse_bool(&bool_val, value) == 0 &&\n\t\t\t\tbool_val == (int)m->cvar_type) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GIT_CVAR_INT32:\n\t\t\tif (git_config_parse_int32(out, value) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase GIT_CVAR_STRING:\n\t\t\tif (strcasecmp(value, m->str_match) == 0) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nfail_parse:\n\tgiterr_set(GITERR_CONFIG, \"Failed to map '%s'\", value);\n\treturn -1;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_lookup_map_value(\n\tint *out,\n\tconst git_cvar_map *maps,\n\tsize_t map_n,\n\tconst char *value)\n{\n\tsize_t i;\n\n\tif (!value)\n\t\tgoto fail_parse;\n\n\tfor (i = 0; i < map_n; ++i) {\n\t\tconst git_cvar_map *m = maps + i;\n\n\t\tswitch (m->cvar_type) {\n\t\tcase GIT_CVAR_FALSE:\n\t\tcase GIT_CVAR_TRUE: {\n\t\t\tint bool_val;\n\n\t\t\tif (git__parse_bool(&bool_val, value) == 0 &&\n\t\t\t\tbool_val == (int)m->cvar_type) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tcase GIT_CVAR_INT32:\n\t\t\tif (git_config_parse_int32(out, value) == 0)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\n\t\tcase GIT_CVAR_STRING:\n\t\t\tif (strcasecmp(value, m->str_match) == 0) {\n\t\t\t\t*out = m->map_value;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\nfail_parse:\n\tgiterr_set(GITERR_CONFIG, \"Failed to map '%s'\", value);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_ignore_map"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_parse_ignore(git_submodule_ignore_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_IGNORE_NONE;\n\t\treturn submodule_config_error(\"ignore\", value);\n\t}\n\n\t*out = (git_submodule_ignore_t)val;\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_config_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1618-1623",
    "snippet": "static int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Invalid value for submodule '%s' property: '%s'\"",
            "property",
            "value"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_config_error(const char *property, const char *value)\n{\n\tgiterr_set(GITERR_INVALID,\n\t\t\"Invalid value for submodule '%s' property: '%s'\", property, value);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_submodule_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1611-1616",
    "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "sm",
            "submodule_release"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
  },
  {
    "function_name": "submodule_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1593-1609",
    "snippet": "static void submodule_release(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\n\tif (sm->repo) {\n\t\tsm->repo = NULL;\n\t}\n\n\tif (sm->path != sm->name)\n\t\tgit__free(sm->path);\n\tgit__free(sm->name);\n\tgit__free(sm->url);\n\tgit__free(sm->branch);\n\tgit__memzero(sm, sizeof(*sm));\n\tgit__free(sm);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sm"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__memzero",
          "args": [
            "sm",
            "sizeof(*sm)"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "git__memzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "521-531",
          "snippet": "GIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic void submodule_release(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\n\tif (sm->repo) {\n\t\tsm->repo = NULL;\n\t}\n\n\tif (sm->path != sm->name)\n\t\tgit__free(sm->path);\n\tgit__free(sm->name);\n\tgit__free(sm->url);\n\tgit__free(sm->branch);\n\tgit__memzero(sm, sizeof(*sm));\n\tgit__free(sm);\n}"
  },
  {
    "function_name": "submodule_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1562-1591",
    "snippet": "static int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "sm"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sm"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "name"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "sm"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_submodule)"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Invalid submodule name\""
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_submodule_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1549-1555",
    "snippet": "int git_submodule_location(unsigned int *location, git_submodule *sm)\n{\n\tassert(location && sm);\n\n\treturn git_submodule__status(\n\t\tlocation, NULL, NULL, NULL, sm, GIT_SUBMODULE_IGNORE_ALL);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule__status",
          "args": [
            "location",
            "NULL",
            "NULL",
            "NULL",
            "sm",
            "GIT_SUBMODULE_IGNORE_ALL"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule__status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1473-1531",
          "snippet": "int git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "location && sm"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_location(unsigned int *location, git_submodule *sm)\n{\n\tassert(location && sm);\n\n\treturn git_submodule__status(\n\t\tlocation, NULL, NULL, NULL, sm, GIT_SUBMODULE_IGNORE_ALL);\n}"
  },
  {
    "function_name": "git_submodule_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1533-1547",
    "snippet": "int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tgit_submodule *sm;\n\tint error;\n\n\tassert(status && repo && name);\n\n\tif ((error = git_submodule_lookup(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\terror = git_submodule__status(status, NULL, NULL, NULL, sm, ignore);\n\tgit_submodule_free(sm);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule__status",
          "args": [
            "status",
            "NULL",
            "NULL",
            "NULL",
            "sm",
            "ignore"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule__status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1473-1531",
          "snippet": "int git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "&sm",
            "repo",
            "name"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "status && repo && name"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tgit_submodule *sm;\n\tint error;\n\n\tassert(status && repo && name);\n\n\tif ((error = git_submodule_lookup(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\terror = git_submodule__status(status, NULL, NULL, NULL, sm, ignore);\n\tgit_submodule_free(sm);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule__status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1473-1531",
    "snippet": "int git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_copy_oid_maybe",
          "args": [
            "out_wd_id",
            "&sm->wd_oid",
            "(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_copy_oid_maybe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1462-1471",
          "snippet": "static void submodule_copy_oid_maybe(\n\tgit_oid *tgt, const git_oid *src, bool valid)\n{\n\tif (tgt) {\n\t\tif (valid)\n\t\t\tmemcpy(tgt, src, sizeof(*tgt));\n\t\telse\n\t\t\tmemset(tgt, 0, sizeof(*tgt));\n\t}\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic void submodule_copy_oid_maybe(\n\tgit_oid *tgt, const git_oid *src, bool valid)\n{\n\tif (tgt) {\n\t\tif (valid)\n\t\t\tmemcpy(tgt, src, sizeof(*tgt));\n\t\telse\n\t\t\tmemset(tgt, 0, sizeof(*tgt));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "smrepo"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_get_wd_status",
          "args": [
            "&status",
            "sm",
            "smrepo",
            "ign"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_get_wd_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "2001-2078",
          "snippet": "static void submodule_get_wd_status(\n\tunsigned int *status,\n\tgit_submodule *sm,\n\tgit_repository *sm_repo,\n\tgit_submodule_ignore_t ign)\n{\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\tconst git_oid *wd_oid =\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) ? &sm->wd_oid : NULL;\n\tgit_tree *sm_head = NULL;\n\tgit_index *index = NULL;\n\tgit_diff_options opt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff;\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__WD_FLAGS;\n\n\tif (!index_oid) {\n\t\tif (wd_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_ADDED;\n\t}\n\telse if (!wd_oid) {\n\t\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_SCANNED) != 0 &&\n\t\t\t(sm->flags & GIT_SUBMODULE_STATUS_IN_WD) == 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNINITIALIZED;\n\t\telse\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_DELETED;\n\t}\n\telse if (!git_oid_equal(index_oid, wd_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_WD_MODIFIED;\n\n\t/* if we have no repo, then we're done */\n\tif (!sm_repo)\n\t\treturn;\n\n\t/* the diffs below could be optimized with an early termination\n\t * option to the git_diff functions, but for now this is sufficient\n\t * (and certainly no worse that what core git does).\n\t */\n\n\tif (ign == GIT_SUBMODULE_IGNORE_NONE)\n\t\topt.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t(void)git_repository_index__weakptr(&index, sm_repo);\n\n\t/* if we don't have an unborn head, check diff with index */\n\tif (git_repository_head_tree(&sm_head, sm_repo) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\t/* perform head to index diff on submodule */\n\t\tif (git_diff_tree_to_index(&diff, sm_repo, sm_head, index, &opt) < 0)\n\t\t\tgiterr_clear();\n\t\telse {\n\t\t\tif (git_diff_num_deltas(diff) > 0)\n\t\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED;\n\t\t\tgit_diff_free(diff);\n\t\t\tdiff = NULL;\n\t\t}\n\n\t\tgit_tree_free(sm_head);\n\t}\n\n\t/* perform index-to-workdir diff on submodule */\n\tif (git_diff_index_to_workdir(&diff, sm_repo, index, &opt) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\tsize_t untracked =\n\t\t\tgit_diff_num_deltas_of_type(diff, GIT_DELTA_UNTRACKED);\n\n\t\tif (untracked > 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNTRACKED;\n\n\t\tif (git_diff_num_deltas(diff) != untracked)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_WD_MODIFIED;\n\n\t\tgit_diff_free(diff);\n\t\tdiff = NULL;\n\t}\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nstatic void submodule_get_wd_status(\n\tunsigned int *status,\n\tgit_submodule *sm,\n\tgit_repository *sm_repo,\n\tgit_submodule_ignore_t ign)\n{\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\tconst git_oid *wd_oid =\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) ? &sm->wd_oid : NULL;\n\tgit_tree *sm_head = NULL;\n\tgit_index *index = NULL;\n\tgit_diff_options opt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff;\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__WD_FLAGS;\n\n\tif (!index_oid) {\n\t\tif (wd_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_ADDED;\n\t}\n\telse if (!wd_oid) {\n\t\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_SCANNED) != 0 &&\n\t\t\t(sm->flags & GIT_SUBMODULE_STATUS_IN_WD) == 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNINITIALIZED;\n\t\telse\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_DELETED;\n\t}\n\telse if (!git_oid_equal(index_oid, wd_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_WD_MODIFIED;\n\n\t/* if we have no repo, then we're done */\n\tif (!sm_repo)\n\t\treturn;\n\n\t/* the diffs below could be optimized with an early termination\n\t * option to the git_diff functions, but for now this is sufficient\n\t * (and certainly no worse that what core git does).\n\t */\n\n\tif (ign == GIT_SUBMODULE_IGNORE_NONE)\n\t\topt.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t(void)git_repository_index__weakptr(&index, sm_repo);\n\n\t/* if we don't have an unborn head, check diff with index */\n\tif (git_repository_head_tree(&sm_head, sm_repo) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\t/* perform head to index diff on submodule */\n\t\tif (git_diff_tree_to_index(&diff, sm_repo, sm_head, index, &opt) < 0)\n\t\t\tgiterr_clear();\n\t\telse {\n\t\t\tif (git_diff_num_deltas(diff) > 0)\n\t\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED;\n\t\t\tgit_diff_free(diff);\n\t\t\tdiff = NULL;\n\t\t}\n\n\t\tgit_tree_free(sm_head);\n\t}\n\n\t/* perform index-to-workdir diff on submodule */\n\tif (git_diff_index_to_workdir(&diff, sm_repo, index, &opt) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\tsize_t untracked =\n\t\t\tgit_diff_num_deltas_of_type(diff, GIT_DELTA_UNTRACKED);\n\n\t\tif (untracked > 0)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_UNTRACKED;\n\n\t\tif (git_diff_num_deltas(diff) != untracked)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_WD_WD_MODIFIED;\n\n\t\tgit_diff_free(diff);\n\t\tdiff = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_get_index_status",
          "args": [
            "&status",
            "sm"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_get_index_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1983-1998",
          "snippet": "static void submodule_get_index_status(unsigned int *status, git_submodule *sm)\n{\n\tconst git_oid *head_oid  = git_submodule_head_id(sm);\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__INDEX_FLAGS;\n\n\tif (!head_oid) {\n\t\tif (index_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_ADDED;\n\t}\n\telse if (!index_oid)\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_DELETED;\n\telse if (!git_oid_equal(head_oid, index_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_MODIFIED;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic void submodule_get_index_status(unsigned int *status, git_submodule *sm)\n{\n\tconst git_oid *head_oid  = git_submodule_head_id(sm);\n\tconst git_oid *index_oid = git_submodule_index_id(sm);\n\n\t*status = *status & ~GIT_SUBMODULE_STATUS__INDEX_FLAGS;\n\n\tif (!head_oid) {\n\t\tif (index_oid)\n\t\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_ADDED;\n\t}\n\telse if (!index_oid)\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_DELETED;\n\telse if (!git_oid_equal(head_oid, index_oid))\n\t\t*status |= GIT_SUBMODULE_STATUS_INDEX_MODIFIED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_SUBMODULE_STATUS__CLEAR_INTERNAL",
          "args": [
            "sm->flags"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_open",
          "args": [
            "&smrepo",
            "sm"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1349-1352",
          "snippet": "int git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_open_bare",
          "args": [
            "&smrepo",
            "sm"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_open_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1344-1347",
          "snippet": "int git_submodule_open_bare(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, true);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open_bare(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_update_head",
          "args": [
            "sm"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1406-1425",
          "snippet": "static int submodule_update_head(git_submodule *submodule)\n{\n\tgit_tree *head = NULL;\n\tgit_tree_entry *te = NULL;\n\n\tsubmodule->flags = submodule->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t  GIT_SUBMODULE_STATUS__HEAD_OID_VALID);\n\n\t/* if we can't look up file in current head, then done */\n\tif (git_repository_head_tree(&head, submodule->repo) < 0 ||\n\t\tgit_tree_entry_bypath(&te, head, submodule->path) < 0)\n\t\tgiterr_clear();\n\telse\n\t\tsubmodule_update_from_head_data(submodule, te->attr, git_tree_entry_id(te));\n\n\tgit_tree_entry_free(te);\n\tgit_tree_free(head);\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_update_head(git_submodule *submodule)\n{\n\tgit_tree *head = NULL;\n\tgit_tree_entry *te = NULL;\n\n\tsubmodule->flags = submodule->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t  GIT_SUBMODULE_STATUS__HEAD_OID_VALID);\n\n\t/* if we can't look up file in current head, then done */\n\tif (git_repository_head_tree(&head, submodule->repo) < 0 ||\n\t\tgit_tree_entry_bypath(&te, head, submodule->path) < 0)\n\t\tgiterr_clear();\n\telse\n\t\tsubmodule_update_from_head_data(submodule, te->attr, git_tree_entry_id(te));\n\n\tgit_tree_entry_free(te);\n\tgit_tree_free(head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_update_index",
          "args": [
            "sm"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1373-1391",
          "snippet": "static int submodule_update_index(git_submodule *sm)\n{\n\tgit_index *index;\n\tconst git_index_entry *ie;\n\n\tif (git_repository_index__weakptr(&index, sm->repo) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t  GIT_SUBMODULE_STATUS__INDEX_OID_VALID);\n\n\tif (!(ie = git_index_get_bypath(index, sm->path, 0)))\n\t\treturn 0;\n\n\tsubmodule_update_from_index_entry(sm, ie);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);\n\nstatic int submodule_update_index(git_submodule *sm)\n{\n\tgit_index *index;\n\tconst git_index_entry *ie;\n\n\tif (git_repository_index__weakptr(&index, sm->repo) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t  GIT_SUBMODULE_STATUS__INDEX_OID_VALID);\n\n\tif (!(ie = git_index_get_bypath(index, sm->path, 0)))\n\t\treturn 0;\n\n\tsubmodule_update_from_index_entry(sm, ie);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_copy_oid_maybe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1462-1471",
    "snippet": "static void submodule_copy_oid_maybe(\n\tgit_oid *tgt, const git_oid *src, bool valid)\n{\n\tif (tgt) {\n\t\tif (valid)\n\t\t\tmemcpy(tgt, src, sizeof(*tgt));\n\t\telse\n\t\t\tmemset(tgt, 0, sizeof(*tgt));\n\t}\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tgt",
            "0",
            "sizeof(*tgt)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt",
            "src",
            "sizeof(*tgt)"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic void submodule_copy_oid_maybe(\n\tgit_oid *tgt, const git_oid *src, bool valid)\n{\n\tif (tgt) {\n\t\tif (valid)\n\t\t\tmemcpy(tgt, src, sizeof(*tgt));\n\t\telse\n\t\t\tmemset(tgt, 0, sizeof(*tgt));\n\t}\n}"
  },
  {
    "function_name": "git_submodule_reload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1427-1460",
    "snippet": "int git_submodule_reload(git_submodule *sm, int force)\n{\n\tint error = 0;\n\tgit_config *mods;\n\n\tGIT_UNUSED(force);\n\n\tassert(sm);\n\n\tif (!git_repository_is_bare(sm->repo)) {\n\t\t/* refresh config data */\n\t\tmods = gitmodules_snapshot(sm->repo);\n\t\tif (mods != NULL) {\n\t\t\terror = submodule_read_config(sm, mods);\n\t\t\tgit_config_free(mods);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* refresh wd data */\n\t\tsm->flags &=\n\t\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_FLAGS);\n\n\t\terror = submodule_load_from_wd_lite(sm);\n\t}\n\n\tif (error == 0 && (error = submodule_update_index(sm)) == 0)\n\t\terror = submodule_update_head(sm);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_update_head",
          "args": [
            "sm"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1406-1425",
          "snippet": "static int submodule_update_head(git_submodule *submodule)\n{\n\tgit_tree *head = NULL;\n\tgit_tree_entry *te = NULL;\n\n\tsubmodule->flags = submodule->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t  GIT_SUBMODULE_STATUS__HEAD_OID_VALID);\n\n\t/* if we can't look up file in current head, then done */\n\tif (git_repository_head_tree(&head, submodule->repo) < 0 ||\n\t\tgit_tree_entry_bypath(&te, head, submodule->path) < 0)\n\t\tgiterr_clear();\n\telse\n\t\tsubmodule_update_from_head_data(submodule, te->attr, git_tree_entry_id(te));\n\n\tgit_tree_entry_free(te);\n\tgit_tree_free(head);\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_update_head(git_submodule *submodule)\n{\n\tgit_tree *head = NULL;\n\tgit_tree_entry *te = NULL;\n\n\tsubmodule->flags = submodule->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t  GIT_SUBMODULE_STATUS__HEAD_OID_VALID);\n\n\t/* if we can't look up file in current head, then done */\n\tif (git_repository_head_tree(&head, submodule->repo) < 0 ||\n\t\tgit_tree_entry_bypath(&te, head, submodule->path) < 0)\n\t\tgiterr_clear();\n\telse\n\t\tsubmodule_update_from_head_data(submodule, te->attr, git_tree_entry_id(te));\n\n\tgit_tree_entry_free(te);\n\tgit_tree_free(head);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_update_index",
          "args": [
            "sm"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1373-1391",
          "snippet": "static int submodule_update_index(git_submodule *sm)\n{\n\tgit_index *index;\n\tconst git_index_entry *ie;\n\n\tif (git_repository_index__weakptr(&index, sm->repo) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t  GIT_SUBMODULE_STATUS__INDEX_OID_VALID);\n\n\tif (!(ie = git_index_get_bypath(index, sm->path, 0)))\n\t\treturn 0;\n\n\tsubmodule_update_from_index_entry(sm, ie);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);\n\nstatic int submodule_update_index(git_submodule *sm)\n{\n\tgit_index *index;\n\tconst git_index_entry *ie;\n\n\tif (git_repository_index__weakptr(&index, sm->repo) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t  GIT_SUBMODULE_STATUS__INDEX_OID_VALID);\n\n\tif (!(ie = git_index_get_bypath(index, sm->path, 0)))\n\t\treturn 0;\n\n\tsubmodule_update_from_index_entry(sm, ie);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_load_from_wd_lite",
          "args": [
            "sm"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_load_from_wd_lite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1816-1831",
          "snippet": "static int submodule_load_from_wd_lite(git_submodule *sm)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&path, git_repository_workdir(sm->repo), sm->path) < 0)\n\t\treturn -1;\n\n\tif (git_path_isdir(path.ptr))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\tif (git_path_contains(&path, DOT_GIT))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD;\n\n\tgit_buf_free(&path);\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_load_from_wd_lite(git_submodule *sm)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&path, git_repository_workdir(sm->repo), sm->path) < 0)\n\t\treturn -1;\n\n\tif (git_path_isdir(path.ptr))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\tif (git_path_contains(&path, DOT_GIT))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD;\n\n\tgit_buf_free(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "mods"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_read_config",
          "args": [
            "sm",
            "mods"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_read_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1680-1758",
          "snippet": "static int submodule_read_config(git_submodule *sm, git_config *cfg)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tconst char *value;\n\tint error, in_config = 0;\n\n\t/*\n\t * TODO: Look up path in index and if it is present but not a GITLINK\n\t * then this should be deleted (at least to match git's behavior)\n\t */\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"path\")) == 0) {\n\t\tin_config = 1;\n\t/*\n\t * TODO: if case insensitive filesystem, then the following strcmp\n\t * should be strcasecmp\n\t */\n\t\tif (strcmp(sm->name, value) != 0) {\n\t\t\tif (sm->path != sm->name)\n\t\t\t\tgit__free(sm->path);\n\t\t\tsm->path = git__strdup(value);\n\t\t\tGITERR_CHECK_ALLOC(sm->path);\n\t\t}\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"url\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->url = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->url);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"branch\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->branch = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->branch);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"update\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_update(&sm->update, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->update_default = sm->update;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"fetchRecurseSubmodules\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_recurse(&sm->fetch_recurse, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->fetch_recurse_default = sm->fetch_recurse;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"ignore\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_ignore(&sm->ignore, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->ignore_default = sm->ignore;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif (in_config)\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&key);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tconst char *value;\n\tint error, in_config = 0;\n\n\t/*\n\t * TODO: Look up path in index and if it is present but not a GITLINK\n\t * then this should be deleted (at least to match git's behavior)\n\t */\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"path\")) == 0) {\n\t\tin_config = 1;\n\t/*\n\t * TODO: if case insensitive filesystem, then the following strcmp\n\t * should be strcasecmp\n\t */\n\t\tif (strcmp(sm->name, value) != 0) {\n\t\t\tif (sm->path != sm->name)\n\t\t\t\tgit__free(sm->path);\n\t\t\tsm->path = git__strdup(value);\n\t\t\tGITERR_CHECK_ALLOC(sm->path);\n\t\t}\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"url\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->url = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->url);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"branch\")) == 0) {\n\t\tin_config = 1;\n\t\tsm->branch = git__strdup(value);\n\t\tGITERR_CHECK_ALLOC(sm->branch);\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"update\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_update(&sm->update, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->update_default = sm->update;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"fetchRecurseSubmodules\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_recurse(&sm->fetch_recurse, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->fetch_recurse_default = sm->fetch_recurse;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = get_value(&value, cfg, &key, sm->name, \"ignore\")) == 0) {\n\t\tin_config = 1;\n\t\tif ((error = git_submodule_parse_ignore(&sm->ignore, value)) < 0)\n\t\t\tgoto cleanup;\n\t\tsm->ignore_default = sm->ignore;\n\t} else if (error != GIT_ENOTFOUND) {\n\t\tgoto cleanup;\n\t}\n\n\tif (in_config)\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\n\terror = 0;\n\ncleanup:\n\tgit_buf_free(&key);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitmodules_snapshot",
          "args": [
            "sm->repo"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "gitmodules_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1838-1860",
          "snippet": "static git_config *gitmodules_snapshot(git_repository *repo)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_config *mods = NULL, *snap = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (git_config_open_ondisk(&mods, path.ptr) < 0)\n\t\t\tmods = NULL;\n\t}\n\n\tgit_buf_free(&path);\n\n\tif (mods) {\n\t\tgit_config_snapshot(&snap, mods);\n\t\tgit_config_free(mods);\n\t}\n\n\treturn snap;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_MODULES_FILE \".gitmodules\""
          ],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config *gitmodules_snapshot(git_repository *repo)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_config *mods = NULL, *snap = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (git_config_open_ondisk(&mods, path.ptr) < 0)\n\t\t\tmods = NULL;\n\t}\n\n\tgit_buf_free(&path);\n\n\tif (mods) {\n\t\tgit_config_snapshot(&snap, mods);\n\t\tgit_config_free(mods);\n\t}\n\n\treturn snap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_is_bare",
          "args": [
            "sm->repo"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_is_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1882-1886",
          "snippet": "int git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sm"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "force"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_reload(git_submodule *sm, int force)\n{\n\tint error = 0;\n\tgit_config *mods;\n\n\tGIT_UNUSED(force);\n\n\tassert(sm);\n\n\tif (!git_repository_is_bare(sm->repo)) {\n\t\t/* refresh config data */\n\t\tmods = gitmodules_snapshot(sm->repo);\n\t\tif (mods != NULL) {\n\t\t\terror = submodule_read_config(sm, mods);\n\t\t\tgit_config_free(mods);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* refresh wd data */\n\t\tsm->flags &=\n\t\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_FLAGS);\n\n\t\terror = submodule_load_from_wd_lite(sm);\n\t}\n\n\tif (error == 0 && (error = submodule_update_index(sm)) == 0)\n\t\terror = submodule_update_head(sm);\n\n\treturn error;\n}"
  },
  {
    "function_name": "submodule_update_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1406-1425",
    "snippet": "static int submodule_update_head(git_submodule *submodule)\n{\n\tgit_tree *head = NULL;\n\tgit_tree_entry *te = NULL;\n\n\tsubmodule->flags = submodule->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t  GIT_SUBMODULE_STATUS__HEAD_OID_VALID);\n\n\t/* if we can't look up file in current head, then done */\n\tif (git_repository_head_tree(&head, submodule->repo) < 0 ||\n\t\tgit_tree_entry_bypath(&te, head, submodule->path) < 0)\n\t\tgiterr_clear();\n\telse\n\t\tsubmodule_update_from_head_data(submodule, te->attr, git_tree_entry_id(te));\n\n\tgit_tree_entry_free(te);\n\tgit_tree_free(head);\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "head"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_free",
          "args": [
            "te"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "229-235",
          "snippet": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_update_from_head_data",
          "args": [
            "submodule",
            "te->attr",
            "git_tree_entry_id(te)"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_from_head_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1393-1404",
          "snippet": "static void submodule_update_from_head_data(\n\tgit_submodule *sm, mode_t mode, const git_oid *id)\n{\n\tif (!S_ISGITLINK(mode))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n\telse {\n\t\tgit_oid_cpy(&sm->head_oid, id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\t}\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic void submodule_update_from_head_data(\n\tgit_submodule *sm, mode_t mode, const git_oid *id)\n{\n\tif (!S_ISGITLINK(mode))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n\telse {\n\t\tgit_oid_cpy(&sm->head_oid, id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_id",
          "args": [
            "te"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "278-282",
          "snippet": "const git_oid *git_tree_entry_id(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->oid;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_tree_entry_id(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_bypath",
          "args": [
            "&te",
            "head",
            "submodule->path"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "897-957",
          "snippet": "int git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&head",
            "submodule->repo"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_update_head(git_submodule *submodule)\n{\n\tgit_tree *head = NULL;\n\tgit_tree_entry *te = NULL;\n\n\tsubmodule->flags = submodule->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t  GIT_SUBMODULE_STATUS__HEAD_OID_VALID);\n\n\t/* if we can't look up file in current head, then done */\n\tif (git_repository_head_tree(&head, submodule->repo) < 0 ||\n\t\tgit_tree_entry_bypath(&te, head, submodule->path) < 0)\n\t\tgiterr_clear();\n\telse\n\t\tsubmodule_update_from_head_data(submodule, te->attr, git_tree_entry_id(te));\n\n\tgit_tree_entry_free(te);\n\tgit_tree_free(head);\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_update_from_head_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1393-1404",
    "snippet": "static void submodule_update_from_head_data(\n\tgit_submodule *sm, mode_t mode, const git_oid *id)\n{\n\tif (!S_ISGITLINK(mode))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n\telse {\n\t\tgit_oid_cpy(&sm->head_oid, id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\t}\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&sm->head_oid",
            "id"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "mode"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic void submodule_update_from_head_data(\n\tgit_submodule *sm, mode_t mode, const git_oid *id)\n{\n\tif (!S_ISGITLINK(mode))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n\telse {\n\t\tgit_oid_cpy(&sm->head_oid, id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\t}\n}"
  },
  {
    "function_name": "submodule_update_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1373-1391",
    "snippet": "static int submodule_update_index(git_submodule *sm)\n{\n\tgit_index *index;\n\tconst git_index_entry *ie;\n\n\tif (git_repository_index__weakptr(&index, sm->repo) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t  GIT_SUBMODULE_STATUS__INDEX_OID_VALID);\n\n\tif (!(ie = git_index_get_bypath(index, sm->path, 0)))\n\t\treturn 0;\n\n\tsubmodule_update_from_index_entry(sm, ie);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_update_from_index_entry",
          "args": [
            "sm",
            "ie"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_from_index_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1354-1371",
          "snippet": "static void submodule_update_from_index_entry(\n\tgit_submodule *sm, const git_index_entry *ie)\n{\n\tbool already_found = (sm->flags & GIT_SUBMODULE_STATUS_IN_INDEX) != 0;\n\n\tif (!S_ISGITLINK(ie->mode)) {\n\t\tif (!already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n\t} else {\n\t\tif (already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\t\telse\n\t\t\tgit_oid_cpy(&sm->index_oid, &ie->id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID;\n\t}\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic void submodule_update_from_index_entry(\n\tgit_submodule *sm, const git_index_entry *ie)\n{\n\tbool already_found = (sm->flags & GIT_SUBMODULE_STATUS_IN_INDEX) != 0;\n\n\tif (!S_ISGITLINK(ie->mode)) {\n\t\tif (!already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n\t} else {\n\t\tif (already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\t\telse\n\t\t\tgit_oid_cpy(&sm->index_oid, &ie->id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_get_bypath",
          "args": [
            "index",
            "sm->path",
            "0"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "807-825",
          "snippet": "const git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "sm->repo"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);\n\nstatic int submodule_update_index(git_submodule *sm)\n{\n\tgit_index *index;\n\tconst git_index_entry *ie;\n\n\tif (git_repository_index__weakptr(&index, sm->repo) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t  GIT_SUBMODULE_STATUS__INDEX_OID_VALID);\n\n\tif (!(ie = git_index_get_bypath(index, sm->path, 0)))\n\t\treturn 0;\n\n\tsubmodule_update_from_index_entry(sm, ie);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_update_from_index_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1354-1371",
    "snippet": "static void submodule_update_from_index_entry(\n\tgit_submodule *sm, const git_index_entry *ie)\n{\n\tbool already_found = (sm->flags & GIT_SUBMODULE_STATUS_IN_INDEX) != 0;\n\n\tif (!S_ISGITLINK(ie->mode)) {\n\t\tif (!already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n\t} else {\n\t\tif (already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\t\telse\n\t\t\tgit_oid_cpy(&sm->index_oid, &ie->id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID;\n\t}\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);",
      "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&sm->index_oid",
            "&ie->id"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "ie->mode"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic void submodule_update_from_index_entry(\n\tgit_submodule *sm, const git_index_entry *ie)\n{\n\tbool already_found = (sm->flags & GIT_SUBMODULE_STATUS_IN_INDEX) != 0;\n\n\tif (!S_ISGITLINK(ie->mode)) {\n\t\tif (!already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n\t} else {\n\t\tif (already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\t\telse\n\t\t\tgit_oid_cpy(&sm->index_oid, &ie->id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID;\n\t}\n}"
  },
  {
    "function_name": "git_submodule_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1349-1352",
    "snippet": "int git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule__open",
          "args": [
            "subrepo",
            "sm",
            "false"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule__open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1290-1342",
          "snippet": "static int git_submodule__open(\n\tgit_repository **subrepo, git_submodule *sm, bool bare)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int flags = GIT_REPOSITORY_OPEN_NO_SEARCH;\n\tconst char *wd;\n\n\tassert(sm && subrepo);\n\n\tif (git_repository__ensure_not_bare(\n\t\t\tsm->repo, \"open submodule repository\") < 0)\n\t\treturn GIT_EBAREREPO;\n\n\twd = git_repository_workdir(sm->repo);\n\n\tif (git_buf_joinpath(&path, wd, sm->path) < 0 ||\n\t\tgit_buf_joinpath(&path, path.ptr, DOT_GIT) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  GIT_SUBMODULE_STATUS__WD_SCANNED);\n\n\tif (bare)\n\t\tflags |= GIT_REPOSITORY_OPEN_BARE;\n\n\terror = git_repository_open_ext(subrepo, path.ptr, flags, wd);\n\n\t/* if we opened the submodule successfully, grab HEAD OID, etc. */\n\tif (!error) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\t\tif (!git_reference_name_to_id(&sm->wd_oid, *subrepo, GIT_HEAD_FILE))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\t\telse\n\t\t\tgiterr_clear();\n\t} else if (git_path_exists(path.ptr)) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS_IN_WD;\n\t} else {\n\t\tgit_buf_rtruncate_at_char(&path, '/'); /* remove \"/.git\" */\n\n\t\tif (git_path_isdir(path.ptr))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int git_submodule__open(\n\tgit_repository **subrepo, git_submodule *sm, bool bare)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int flags = GIT_REPOSITORY_OPEN_NO_SEARCH;\n\tconst char *wd;\n\n\tassert(sm && subrepo);\n\n\tif (git_repository__ensure_not_bare(\n\t\t\tsm->repo, \"open submodule repository\") < 0)\n\t\treturn GIT_EBAREREPO;\n\n\twd = git_repository_workdir(sm->repo);\n\n\tif (git_buf_joinpath(&path, wd, sm->path) < 0 ||\n\t\tgit_buf_joinpath(&path, path.ptr, DOT_GIT) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  GIT_SUBMODULE_STATUS__WD_SCANNED);\n\n\tif (bare)\n\t\tflags |= GIT_REPOSITORY_OPEN_BARE;\n\n\terror = git_repository_open_ext(subrepo, path.ptr, flags, wd);\n\n\t/* if we opened the submodule successfully, grab HEAD OID, etc. */\n\tif (!error) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\t\tif (!git_reference_name_to_id(&sm->wd_oid, *subrepo, GIT_HEAD_FILE))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\t\telse\n\t\t\tgiterr_clear();\n\t} else if (git_path_exists(path.ptr)) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS_IN_WD;\n\t} else {\n\t\tgit_buf_rtruncate_at_char(&path, '/'); /* remove \"/.git\" */\n\n\t\tif (git_path_isdir(path.ptr))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}"
  },
  {
    "function_name": "git_submodule_open_bare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1344-1347",
    "snippet": "int git_submodule_open_bare(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, true);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule__open",
          "args": [
            "subrepo",
            "sm",
            "true"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule__open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1290-1342",
          "snippet": "static int git_submodule__open(\n\tgit_repository **subrepo, git_submodule *sm, bool bare)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int flags = GIT_REPOSITORY_OPEN_NO_SEARCH;\n\tconst char *wd;\n\n\tassert(sm && subrepo);\n\n\tif (git_repository__ensure_not_bare(\n\t\t\tsm->repo, \"open submodule repository\") < 0)\n\t\treturn GIT_EBAREREPO;\n\n\twd = git_repository_workdir(sm->repo);\n\n\tif (git_buf_joinpath(&path, wd, sm->path) < 0 ||\n\t\tgit_buf_joinpath(&path, path.ptr, DOT_GIT) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  GIT_SUBMODULE_STATUS__WD_SCANNED);\n\n\tif (bare)\n\t\tflags |= GIT_REPOSITORY_OPEN_BARE;\n\n\terror = git_repository_open_ext(subrepo, path.ptr, flags, wd);\n\n\t/* if we opened the submodule successfully, grab HEAD OID, etc. */\n\tif (!error) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\t\tif (!git_reference_name_to_id(&sm->wd_oid, *subrepo, GIT_HEAD_FILE))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\t\telse\n\t\t\tgiterr_clear();\n\t} else if (git_path_exists(path.ptr)) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS_IN_WD;\n\t} else {\n\t\tgit_buf_rtruncate_at_char(&path, '/'); /* remove \"/.git\" */\n\n\t\tif (git_path_isdir(path.ptr))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int git_submodule__open(\n\tgit_repository **subrepo, git_submodule *sm, bool bare)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int flags = GIT_REPOSITORY_OPEN_NO_SEARCH;\n\tconst char *wd;\n\n\tassert(sm && subrepo);\n\n\tif (git_repository__ensure_not_bare(\n\t\t\tsm->repo, \"open submodule repository\") < 0)\n\t\treturn GIT_EBAREREPO;\n\n\twd = git_repository_workdir(sm->repo);\n\n\tif (git_buf_joinpath(&path, wd, sm->path) < 0 ||\n\t\tgit_buf_joinpath(&path, path.ptr, DOT_GIT) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  GIT_SUBMODULE_STATUS__WD_SCANNED);\n\n\tif (bare)\n\t\tflags |= GIT_REPOSITORY_OPEN_BARE;\n\n\terror = git_repository_open_ext(subrepo, path.ptr, flags, wd);\n\n\t/* if we opened the submodule successfully, grab HEAD OID, etc. */\n\tif (!error) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\t\tif (!git_reference_name_to_id(&sm->wd_oid, *subrepo, GIT_HEAD_FILE))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\t\telse\n\t\t\tgiterr_clear();\n\t} else if (git_path_exists(path.ptr)) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS_IN_WD;\n\t} else {\n\t\tgit_buf_rtruncate_at_char(&path, '/'); /* remove \"/.git\" */\n\n\t\tif (git_path_isdir(path.ptr))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open_bare(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, true);\n}"
  },
  {
    "function_name": "git_submodule__open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1290-1342",
    "snippet": "static int git_submodule__open(\n\tgit_repository **subrepo, git_submodule *sm, bool bare)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int flags = GIT_REPOSITORY_OPEN_NO_SEARCH;\n\tconst char *wd;\n\n\tassert(sm && subrepo);\n\n\tif (git_repository__ensure_not_bare(\n\t\t\tsm->repo, \"open submodule repository\") < 0)\n\t\treturn GIT_EBAREREPO;\n\n\twd = git_repository_workdir(sm->repo);\n\n\tif (git_buf_joinpath(&path, wd, sm->path) < 0 ||\n\t\tgit_buf_joinpath(&path, path.ptr, DOT_GIT) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  GIT_SUBMODULE_STATUS__WD_SCANNED);\n\n\tif (bare)\n\t\tflags |= GIT_REPOSITORY_OPEN_BARE;\n\n\terror = git_repository_open_ext(subrepo, path.ptr, flags, wd);\n\n\t/* if we opened the submodule successfully, grab HEAD OID, etc. */\n\tif (!error) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\t\tif (!git_reference_name_to_id(&sm->wd_oid, *subrepo, GIT_HEAD_FILE))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\t\telse\n\t\t\tgiterr_clear();\n\t} else if (git_path_exists(path.ptr)) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS_IN_WD;\n\t} else {\n\t\tgit_buf_rtruncate_at_char(&path, '/'); /* remove \"/.git\" */\n\n\t\tif (git_path_isdir(path.ptr))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "path.ptr"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtruncate_at_char",
          "args": [
            "&path",
            "'/'"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtruncate_at_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "464-468",
          "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "path.ptr"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&sm->wd_oid",
            "*subrepo",
            "GIT_HEAD_FILE"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_open_ext",
          "args": [
            "subrepo",
            "path.ptr",
            "flags",
            "wd"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_open_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "491-555",
          "snippet": "int git_repository_open_ext(\n\tgit_repository **repo_ptr,\n\tconst char *start_path,\n\tunsigned int flags,\n\tconst char *ceiling_dirs)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT, parent = GIT_BUF_INIT,\n\t\tlink_path = GIT_BUF_INIT;\n\tgit_repository *repo;\n\tgit_config *config = NULL;\n\n\tif (repo_ptr)\n\t\t*repo_ptr = NULL;\n\n\terror = find_repo(\n\t\t&path, &parent, &link_path, start_path, flags, ceiling_dirs);\n\n\tif (error < 0 || !repo_ptr)\n\t\treturn error;\n\n\trepo = repository_alloc();\n\tGITERR_CHECK_ALLOC(repo);\n\n\trepo->path_repository = git_buf_detach(&path);\n\tGITERR_CHECK_ALLOC(repo->path_repository);\n\n\tif (link_path.size) {\n\t\trepo->path_gitlink = git_buf_detach(&link_path);\n\t\tGITERR_CHECK_ALLOC(repo->path_gitlink);\n\t}\n\n\t/*\n\t * We'd like to have the config, but git doesn't particularly\n\t * care if it's not there, so we need to deal with that.\n\t */\n\n\terror = git_repository_config_snapshot(&config, repo);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\tif (config && (error = check_repositoryformatversion(config)) < 0)\n\t\tgoto cleanup;\n\n\tif ((flags & GIT_REPOSITORY_OPEN_BARE) != 0)\n\t\trepo->is_bare = 1;\n\telse {\n\n\t\tif (config &&\n\t\t    ((error = load_config_data(repo, config)) < 0 ||\n\t\t     (error = load_workdir(repo, config, &parent)) < 0))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&parent);\n\tgit_config_free(config);\n\n\tif (error < 0)\n\t\tgit_repository_free(repo);\n\telse\n\t\t*repo_ptr = repo;\n\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_open_ext(\n\tgit_repository **repo_ptr,\n\tconst char *start_path,\n\tunsigned int flags,\n\tconst char *ceiling_dirs)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT, parent = GIT_BUF_INIT,\n\t\tlink_path = GIT_BUF_INIT;\n\tgit_repository *repo;\n\tgit_config *config = NULL;\n\n\tif (repo_ptr)\n\t\t*repo_ptr = NULL;\n\n\terror = find_repo(\n\t\t&path, &parent, &link_path, start_path, flags, ceiling_dirs);\n\n\tif (error < 0 || !repo_ptr)\n\t\treturn error;\n\n\trepo = repository_alloc();\n\tGITERR_CHECK_ALLOC(repo);\n\n\trepo->path_repository = git_buf_detach(&path);\n\tGITERR_CHECK_ALLOC(repo->path_repository);\n\n\tif (link_path.size) {\n\t\trepo->path_gitlink = git_buf_detach(&link_path);\n\t\tGITERR_CHECK_ALLOC(repo->path_gitlink);\n\t}\n\n\t/*\n\t * We'd like to have the config, but git doesn't particularly\n\t * care if it's not there, so we need to deal with that.\n\t */\n\n\terror = git_repository_config_snapshot(&config, repo);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\tif (config && (error = check_repositoryformatversion(config)) < 0)\n\t\tgoto cleanup;\n\n\tif ((flags & GIT_REPOSITORY_OPEN_BARE) != 0)\n\t\trepo->is_bare = 1;\n\telse {\n\n\t\tif (config &&\n\t\t    ((error = load_config_data(repo, config)) < 0 ||\n\t\t     (error = load_workdir(repo, config, &parent)) < 0))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_buf_free(&parent);\n\tgit_config_free(config);\n\n\tif (error < 0)\n\t\tgit_repository_free(repo);\n\telse\n\t\t*repo_ptr = repo;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "path.ptr",
            "DOT_GIT"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "sm->repo"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "sm->repo",
            "\"open submodule repository\""
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sm && subrepo"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int git_submodule__open(\n\tgit_repository **subrepo, git_submodule *sm, bool bare)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int flags = GIT_REPOSITORY_OPEN_NO_SEARCH;\n\tconst char *wd;\n\n\tassert(sm && subrepo);\n\n\tif (git_repository__ensure_not_bare(\n\t\t\tsm->repo, \"open submodule repository\") < 0)\n\t\treturn GIT_EBAREREPO;\n\n\twd = git_repository_workdir(sm->repo);\n\n\tif (git_buf_joinpath(&path, wd, sm->path) < 0 ||\n\t\tgit_buf_joinpath(&path, path.ptr, DOT_GIT) < 0)\n\t\treturn -1;\n\n\tsm->flags = sm->flags &\n\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  GIT_SUBMODULE_STATUS__WD_SCANNED);\n\n\tif (bare)\n\t\tflags |= GIT_REPOSITORY_OPEN_BARE;\n\n\terror = git_repository_open_ext(subrepo, path.ptr, flags, wd);\n\n\t/* if we opened the submodule successfully, grab HEAD OID, etc. */\n\tif (!error) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\t\tif (!git_reference_name_to_id(&sm->wd_oid, *subrepo, GIT_HEAD_FILE))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\t\telse\n\t\t\tgiterr_clear();\n\t} else if (git_path_exists(path.ptr)) {\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS_IN_WD;\n\t} else {\n\t\tgit_buf_rtruncate_at_char(&path, '/'); /* remove \"/.git\" */\n\n\t\tif (git_path_isdir(path.ptr))\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1241-1288",
    "snippet": "int git_submodule_sync(git_submodule *sm)\n{\n\tint error = 0;\n\tgit_config *cfg = NULL;\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_repository *smrepo = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\t/* copy URL over to config only if it already exists */\n\n\tif (!(error = git_repository_config__weakptr(&cfg, sm->repo)) &&\n\t\t!(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)))\n\t\terror = git_config__update_entry(cfg, key.ptr, sm->url, true, true);\n\n\t/* if submodule exists in the working directory, update remote url */\n\n\tif (!error &&\n\t\t(sm->flags & GIT_SUBMODULE_STATUS_IN_WD) != 0 &&\n\t\t!(error = git_submodule_open(&smrepo, sm)))\n\t{\n\t\tgit_buf remote_name = GIT_BUF_INIT;\n\n\t\tif ((error = git_repository_config__weakptr(&cfg, smrepo)) < 0)\n\t\t\t/* return error from reading submodule config */;\n\t\telse if ((error = lookup_head_remote_key(&remote_name, smrepo)) < 0) {\n\t\t\tgiterr_clear();\n\t\t\terror = git_buf_sets(&key, \"remote.origin.url\");\n\t\t} else {\n\t\t\terror = git_buf_join3(\n\t\t\t\t&key, '.', \"remote\", remote_name.ptr, \"url\");\n\t\t\tgit_buf_free(&remote_name);\n\t\t}\n\n\t\tif (!error)\n\t\t\terror = git_config__update_entry(cfg, key.ptr, sm->url, true, false);\n\n\t\tgit_repository_free(smrepo);\n\t}\n\n\tgit_buf_free(&key);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&key"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "smrepo"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__update_entry",
          "args": [
            "cfg",
            "key.ptr",
            "sm->url",
            "true",
            "false"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "640-669",
          "snippet": "int git_config__update_entry(\n\tgit_config *config,\n\tconst char *key,\n\tconst char *value,\n\tbool overwrite_existing,\n\tbool only_if_existing)\n{\n\tint error = 0;\n\tgit_config_entry *ce = NULL;\n\n\tif ((error = git_config__lookup_entry(&ce, config, key, false)) < 0)\n\t\treturn error;\n\n\tif (!ce && only_if_existing) /* entry doesn't exist */\n\t\treturn 0;\n\tif (ce && !overwrite_existing) /* entry would be overwritten */\n\t\treturn 0;\n\tif (value && ce && ce->value && !strcmp(ce->value, value)) /* no change */\n\t\treturn 0;\n\tif (!value && (!ce || !ce->value)) /* asked to delete absent entry */\n\t\treturn 0;\n\n\tif (!value)\n\t\terror = git_config_delete_entry(config, key);\n\telse\n\t\terror = git_config_set_string(config, key, value);\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__update_entry(\n\tgit_config *config,\n\tconst char *key,\n\tconst char *value,\n\tbool overwrite_existing,\n\tbool only_if_existing)\n{\n\tint error = 0;\n\tgit_config_entry *ce = NULL;\n\n\tif ((error = git_config__lookup_entry(&ce, config, key, false)) < 0)\n\t\treturn error;\n\n\tif (!ce && only_if_existing) /* entry doesn't exist */\n\t\treturn 0;\n\tif (ce && !overwrite_existing) /* entry would be overwritten */\n\t\treturn 0;\n\tif (value && ce && ce->value && !strcmp(ce->value, value)) /* no change */\n\t\treturn 0;\n\tif (!value && (!ce || !ce->value)) /* asked to delete absent entry */\n\t\treturn 0;\n\n\tif (!value)\n\t\terror = git_config_delete_entry(config, key);\n\telse\n\t\terror = git_config_set_string(config, key, value);\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join3",
          "args": [
            "&key",
            "'.'",
            "\"remote\"",
            "remote_name.ptr",
            "\"url\""
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "657-716",
          "snippet": "int git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&key",
            "\"remote.origin.url\""
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_head_remote_key",
          "args": [
            "&remote_name",
            "smrepo"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_head_remote_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1892-1930",
          "snippet": "static int lookup_head_remote_key(git_buf *remote_name, git_repository *repo)\n{\n\tint error;\n\tgit_reference *head = NULL;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\t/* lookup and dereference HEAD */\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\t/**\n\t * If head does not refer to a branch, then return\n\t * GIT_ENOTFOUND to indicate that we could not find\n\t * a remote key for the local tracking branch HEAD points to.\n\t **/\n\tif (!git_reference_is_branch(head)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"HEAD does not refer to a branch.\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\t/* lookup remote tracking branch of HEAD */\n\tif ((error = git_branch_upstream_name(\n\t\t&upstream_name,\n\t\trepo,\n\t\tgit_reference_name(head))) < 0)\n\t\tgoto done;\n\n\t/* lookup remote of remote tracking branch */\n\tif ((error = git_branch_remote_name(remote_name, repo, upstream_name.ptr)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_buf_free(&upstream_name);\n\tgit_reference_free(head);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int lookup_head_remote_key(git_buf *remote_name, git_repository *repo)\n{\n\tint error;\n\tgit_reference *head = NULL;\n\tgit_buf upstream_name = GIT_BUF_INIT;\n\n\t/* lookup and dereference HEAD */\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\t/**\n\t * If head does not refer to a branch, then return\n\t * GIT_ENOTFOUND to indicate that we could not find\n\t * a remote key for the local tracking branch HEAD points to.\n\t **/\n\tif (!git_reference_is_branch(head)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"HEAD does not refer to a branch.\");\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\t/* lookup remote tracking branch of HEAD */\n\tif ((error = git_branch_upstream_name(\n\t\t&upstream_name,\n\t\trepo,\n\t\tgit_reference_name(head))) < 0)\n\t\tgoto done;\n\n\t/* lookup remote of remote tracking branch */\n\tif ((error = git_branch_remote_name(remote_name, repo, upstream_name.ptr)) < 0)\n\t\tgoto done;\n\ndone:\n\tgit_buf_free(&upstream_name);\n\tgit_reference_free(head);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config__weakptr",
          "args": [
            "&cfg",
            "smrepo"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "661-705",
          "snippet": "int git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_repositoryformatversion(git_config *config);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nstatic int check_repositoryformatversion(git_config *config);\n\nint git_repository_config__weakptr(git_config **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tif (repo->_config == NULL) {\n\t\tgit_buf global_buf = GIT_BUF_INIT;\n\t\tgit_buf xdg_buf = GIT_BUF_INIT;\n\t\tgit_buf system_buf = GIT_BUF_INIT;\n\t\tgit_buf programdata_buf = GIT_BUF_INIT;\n\t\tgit_config *config;\n\n\t\tgit_config_find_global(&global_buf);\n\t\tgit_config_find_xdg(&xdg_buf);\n\t\tgit_config_find_system(&system_buf);\n\t\tgit_config_find_programdata(&programdata_buf);\n\n\t\t/* If there is no global file, open a backend for it anyway */\n\t\tif (git_buf_len(&global_buf) == 0)\n\t\t\tgit_config__global_location(&global_buf);\n\n\t\terror = load_config(\n\t\t\t&config, repo,\n\t\t\tpath_unless_empty(&global_buf),\n\t\t\tpath_unless_empty(&xdg_buf),\n\t\t\tpath_unless_empty(&system_buf),\n\t\t\tpath_unless_empty(&programdata_buf));\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(config, repo);\n\n\t\t\tconfig = git__compare_and_swap(&repo->_config, NULL, config);\n\t\t\tif (config != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(config, NULL);\n\t\t\t\tgit_config_free(config);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&global_buf);\n\t\tgit_buf_free(&xdg_buf);\n\t\tgit_buf_free(&system_buf);\n\t\tgit_buf_free(&programdata_buf);\n\t}\n\n\t*out = repo->_config;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_open",
          "args": [
            "&smrepo",
            "sm"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1349-1352",
          "snippet": "int git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&key",
            "\"submodule.%s.url\"",
            "sm->name"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"No URL configured for submodule '%s'\"",
            "sm->name"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_sync(git_submodule *sm)\n{\n\tint error = 0;\n\tgit_config *cfg = NULL;\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_repository *smrepo = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\t/* copy URL over to config only if it already exists */\n\n\tif (!(error = git_repository_config__weakptr(&cfg, sm->repo)) &&\n\t\t!(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)))\n\t\terror = git_config__update_entry(cfg, key.ptr, sm->url, true, true);\n\n\t/* if submodule exists in the working directory, update remote url */\n\n\tif (!error &&\n\t\t(sm->flags & GIT_SUBMODULE_STATUS_IN_WD) != 0 &&\n\t\t!(error = git_submodule_open(&smrepo, sm)))\n\t{\n\t\tgit_buf remote_name = GIT_BUF_INIT;\n\n\t\tif ((error = git_repository_config__weakptr(&cfg, smrepo)) < 0)\n\t\t\t/* return error from reading submodule config */;\n\t\telse if ((error = lookup_head_remote_key(&remote_name, smrepo)) < 0) {\n\t\t\tgiterr_clear();\n\t\t\terror = git_buf_sets(&key, \"remote.origin.url\");\n\t\t} else {\n\t\t\terror = git_buf_join3(\n\t\t\t\t&key, '.', \"remote\", remote_name.ptr, \"url\");\n\t\t\tgit_buf_free(&remote_name);\n\t\t}\n\n\t\tif (!error)\n\t\t\terror = git_config__update_entry(cfg, key.ptr, sm->url, true, false);\n\n\t\tgit_repository_free(smrepo);\n\t}\n\n\tgit_buf_free(&key);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1197-1239",
    "snippet": "int git_submodule_init(git_submodule *sm, int overwrite)\n{\n\tint error;\n\tconst char *val;\n\tgit_buf key = GIT_BUF_INIT, effective_submodule_url = GIT_BUF_INIT;\n\tgit_config *cfg = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository_config(&cfg, sm->repo)) < 0)\n\t\treturn error;\n\n\t/* write \"submodule.NAME.url\" */\n\n\tif ((error = git_submodule_resolve_url(&effective_submodule_url, sm->repo, sm->url)) < 0 ||\n\t\t(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, effective_submodule_url.ptr, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* write \"submodule.NAME.update\" if not default */\n\n\tval = (sm->update == GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tNULL : git_submodule_update_to_str(sm->update);\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.update\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, val, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* success */\n\ncleanup:\n\tgit_config_free(cfg);\n\tgit_buf_free(&key);\n\tgit_buf_free(&effective_submodule_url);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&effective_submodule_url"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "cfg"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__update_entry",
          "args": [
            "cfg",
            "key.ptr",
            "val",
            "overwrite != 0",
            "false"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "640-669",
          "snippet": "int git_config__update_entry(\n\tgit_config *config,\n\tconst char *key,\n\tconst char *value,\n\tbool overwrite_existing,\n\tbool only_if_existing)\n{\n\tint error = 0;\n\tgit_config_entry *ce = NULL;\n\n\tif ((error = git_config__lookup_entry(&ce, config, key, false)) < 0)\n\t\treturn error;\n\n\tif (!ce && only_if_existing) /* entry doesn't exist */\n\t\treturn 0;\n\tif (ce && !overwrite_existing) /* entry would be overwritten */\n\t\treturn 0;\n\tif (value && ce && ce->value && !strcmp(ce->value, value)) /* no change */\n\t\treturn 0;\n\tif (!value && (!ce || !ce->value)) /* asked to delete absent entry */\n\t\treturn 0;\n\n\tif (!value)\n\t\terror = git_config_delete_entry(config, key);\n\telse\n\t\terror = git_config_set_string(config, key, value);\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__update_entry(\n\tgit_config *config,\n\tconst char *key,\n\tconst char *value,\n\tbool overwrite_existing,\n\tbool only_if_existing)\n{\n\tint error = 0;\n\tgit_config_entry *ce = NULL;\n\n\tif ((error = git_config__lookup_entry(&ce, config, key, false)) < 0)\n\t\treturn error;\n\n\tif (!ce && only_if_existing) /* entry doesn't exist */\n\t\treturn 0;\n\tif (ce && !overwrite_existing) /* entry would be overwritten */\n\t\treturn 0;\n\tif (value && ce && ce->value && !strcmp(ce->value, value)) /* no change */\n\t\treturn 0;\n\tif (!value && (!ce || !ce->value)) /* asked to delete absent entry */\n\t\treturn 0;\n\n\tif (!value)\n\t\terror = git_config_delete_entry(config, key);\n\telse\n\t\terror = git_config_set_string(config, key, value);\n\n\tgit_config_entry_free(ce);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&key",
            "\"submodule.%s.update\"",
            "sm->name"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_update_to_str",
          "args": [
            "sm->update"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_update_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "806-813",
          "snippet": "const char *git_submodule_update_to_str(git_submodule_update_t update)\n{\n\tint i;\n\tfor (i = 0; i < (int)ARRAY_SIZE(_sm_update_map); ++i)\n\t\tif (_sm_update_map[i].map_value == (int)update)\n\t\t\treturn _sm_update_map[i].str_match;\n\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};\n\nconst char *git_submodule_update_to_str(git_submodule_update_t update)\n{\n\tint i;\n\tfor (i = 0; i < (int)ARRAY_SIZE(_sm_update_map); ++i)\n\t\tif (_sm_update_map[i].map_value == (int)update)\n\t\t\treturn _sm_update_map[i].str_match;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_resolve_url",
          "args": [
            "&effective_submodule_url",
            "sm->repo",
            "sm->url"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_resolve_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "839-869",
          "snippet": "int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)\n{\n\tint error = 0;\n\tgit_buf normalized = GIT_BUF_INIT;\n\n\tassert(out && repo && url);\n\n\tgit_buf_sanitize(out);\n\n\t/* We do this in all platforms in case someone on Windows created the .gitmodules */\n\tif (strchr(url, '\\\\')) {\n\t\tif ((error = git_path_normalize_slashes(&normalized, url)) < 0)\n\t\t\treturn error;\n\n\t\turl = normalized.ptr;\n\t}\n\n\n\tif (git_path_is_relative(url)) {\n\t\tif (!(error = get_url_base(out, repo)))\n\t\t\terror = git_path_apply_relative(out, url);\n\t} else if (strchr(url, ':') != NULL || url[0] == '/') {\n\t\terror = git_buf_sets(out, url);\n\t} else {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid format for submodule URL\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&normalized);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)\n{\n\tint error = 0;\n\tgit_buf normalized = GIT_BUF_INIT;\n\n\tassert(out && repo && url);\n\n\tgit_buf_sanitize(out);\n\n\t/* We do this in all platforms in case someone on Windows created the .gitmodules */\n\tif (strchr(url, '\\\\')) {\n\t\tif ((error = git_path_normalize_slashes(&normalized, url)) < 0)\n\t\t\treturn error;\n\n\t\turl = normalized.ptr;\n\t}\n\n\n\tif (git_path_is_relative(url)) {\n\t\tif (!(error = get_url_base(out, repo)))\n\t\t\terror = git_path_apply_relative(out, url);\n\t} else if (strchr(url, ':') != NULL || url[0] == '/') {\n\t\terror = git_buf_sets(out, url);\n\t} else {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid format for submodule URL\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&normalized);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config",
          "args": [
            "&cfg",
            "sm->repo"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"No URL configured for submodule '%s'\"",
            "sm->name"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_init(git_submodule *sm, int overwrite)\n{\n\tint error;\n\tconst char *val;\n\tgit_buf key = GIT_BUF_INIT, effective_submodule_url = GIT_BUF_INIT;\n\tgit_config *cfg = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository_config(&cfg, sm->repo)) < 0)\n\t\treturn error;\n\n\t/* write \"submodule.NAME.url\" */\n\n\tif ((error = git_submodule_resolve_url(&effective_submodule_url, sm->repo, sm->url)) < 0 ||\n\t\t(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, effective_submodule_url.ptr, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* write \"submodule.NAME.update\" if not default */\n\n\tval = (sm->update == GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tNULL : git_submodule_update_to_str(sm->update);\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.update\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, val, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* success */\n\ncleanup:\n\tgit_config_free(cfg);\n\tgit_buf_free(&key);\n\tgit_buf_free(&effective_submodule_url);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1086-1195",
    "snippet": "int git_submodule_update(git_submodule *sm, int init, git_submodule_update_options *_update_options)\n{\n\tint error;\n\tunsigned int submodule_status;\n\tgit_config *config = NULL;\n\tconst char *submodule_url;\n\tgit_repository *sub_repo = NULL;\n\tgit_remote *remote = NULL;\n\tgit_object *target_commit = NULL;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_submodule_update_options update_options = GIT_SUBMODULE_UPDATE_OPTIONS_INIT;\n\tgit_clone_options clone_options = GIT_CLONE_OPTIONS_INIT;\n\n\tassert(sm);\n\n\tif (_update_options)\n\t\tmemcpy(&update_options, _update_options, sizeof(git_submodule_update_options));\n\n\tGITERR_CHECK_VERSION(&update_options, GIT_SUBMODULE_UPDATE_OPTIONS_VERSION, \"git_submodule_update_options\");\n\n\t/* Copy over the remote callbacks */\n\tmemcpy(&clone_options.fetch_opts, &update_options.fetch_opts, sizeof(git_fetch_options));\n\n\t/* Get the status of the submodule to determine if it is already initialized  */\n\tif ((error = git_submodule_status(&submodule_status, sm->repo, sm->name, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0)\n\t\tgoto done;\n\n\t/*\n\t * If submodule work dir is not already initialized, check to see\n\t * what we need to do (initialize, clone, return error...)\n\t */\n\tif (submodule_status & GIT_SUBMODULE_STATUS_WD_UNINITIALIZED) {\n\t\t/*\n\t\t * Work dir is not initialized, check to see if the submodule\n\t\t * info has been copied into .git/config\n\t\t */\n\t\tif ((error = git_repository_config_snapshot(&config, sm->repo)) < 0 ||\n\t\t\t(error = git_buf_printf(&buf, \"submodule.%s.url\", git_submodule_name(sm))) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_config_get_string(&submodule_url, config, git_buf_cstr(&buf))) < 0) {\n\t\t\t/*\n\t\t\t * If the error is not \"not found\" or if it is \"not found\" and we are not\n\t\t\t * initializing the submodule, then return error.\n\t\t\t */\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tgoto done;\n\n\t\t\tif (error == GIT_ENOTFOUND && !init) {\n\t\t\t\tgiterr_set(GITERR_SUBMODULE, \"Submodule is not initialized.\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* The submodule has not been initialized yet - initialize it now.*/\n\t\t\tif ((error = git_submodule_init(sm, 0)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgit_config_free(config);\n\t\t\tconfig = NULL;\n\n\t\t\tif ((error = git_repository_config_snapshot(&config, sm->repo)) < 0 ||\n\t\t\t\t(error = git_config_get_string(&submodule_url, config, git_buf_cstr(&buf))) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/** submodule is initialized - now clone it **/\n\t\t/* override repo creation */\n\t\tclone_options.repository_cb = git_submodule_update_repo_init_cb;\n\t\tclone_options.repository_cb_payload = sm;\n\n\t\t/*\n\t\t * Do not perform checkout as part of clone, instead we\n\t\t * will checkout the specific commit manually.\n\t\t */\n\t\tclone_options.checkout_opts.checkout_strategy = GIT_CHECKOUT_NONE;\n\t\tupdate_options.checkout_opts.checkout_strategy = update_options.clone_checkout_strategy;\n\n\t\tif ((error = git_clone(&sub_repo, submodule_url, sm->path, &clone_options)) < 0 ||\n\t\t\t(error = git_repository_set_head_detached(sub_repo, git_submodule_index_id(sm))) < 0 ||\n\t\t\t(error = git_checkout_head(sub_repo, &update_options.checkout_opts)) != 0)\n\t\t\tgoto done;\n\t} else {\n\t\t/**\n\t\t * Work dir is initialized - look up the commit in the parent repository's index,\n\t\t * update the workdir contents of the subrepository, and set the subrepository's\n\t\t * head to the new commit.\n\t\t */\n\t\tif ((error = git_submodule_open(&sub_repo, sm)) < 0 ||\n\t\t\t(error = git_object_lookup(&target_commit, sub_repo, git_submodule_index_id(sm), GIT_OBJ_COMMIT)) < 0 ||\n\t\t\t(error = git_checkout_tree(sub_repo, target_commit, &update_options.checkout_opts)) != 0 ||\n\t\t\t(error = git_repository_set_head_detached(sub_repo, git_submodule_index_id(sm))) < 0)\n\t\t\tgoto done;\n\n\t\t/* Invalidate the wd flags as the workdir has been updated. */\n\t\tsm->flags = sm->flags &\n\t\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  \tGIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  \tGIT_SUBMODULE_STATUS__WD_SCANNED);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_config_free(config);\n\tgit_object_free(target_commit);\n\tgit_remote_free(remote);\n\tgit_repository_free(sub_repo);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "sub_repo"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_remote_free",
          "args": [
            "remote"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "git_remote_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/remote.c",
          "lines": "1642-1670",
          "snippet": "void git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}",
          "includes": [
            "#include \"push.h\"",
            "#include \"fetchhead.h\"",
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"fetch.h\"",
            "#include \"remote.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"common.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);",
            "static int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"push.h\"\n#include \"fetchhead.h\"\n#include \"refspec.h\"\n#include \"refs.h\"\n#include \"fetch.h\"\n#include \"remote.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"common.h\"\n#include \"git2/net.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n#include \"git2/config.h\"\n\nstatic int dwim_refspecs(git_vector *out, git_vector *refspecs, git_vector *refs);\nstatic int lookup_remote_prune_config(git_remote *remote, git_config *config, const char *name);\n\nvoid git_remote_free(git_remote *remote)\n{\n\tif (remote == NULL)\n\t\treturn;\n\n\tif (remote->transport != NULL) {\n\t\tgit_remote_disconnect(remote);\n\n\t\tremote->transport->free(remote->transport);\n\t\tremote->transport = NULL;\n\t}\n\n\tgit_vector_free(&remote->refs);\n\n\tfree_refspecs(&remote->refspecs);\n\tgit_vector_free(&remote->refspecs);\n\n\tfree_refspecs(&remote->active_refspecs);\n\tgit_vector_free(&remote->active_refspecs);\n\n\tfree_refspecs(&remote->passive_refspecs);\n\tgit_vector_free(&remote->passive_refspecs);\n\n\tgit_push_free(remote->push);\n\tgit__free(remote->url);\n\tgit__free(remote->pushurl);\n\tgit__free(remote->name);\n\tgit__free(remote);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "target_commit"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "config"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_set_head_detached",
          "args": [
            "sub_repo",
            "git_submodule_index_id(sm)"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_set_head_detached_from_annotated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "2167-2174",
          "snippet": "int git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_set_head_detached_from_annotated(\n\tgit_repository *repo,\n\tconst git_annotated_commit *commitish)\n{\n\tassert(repo && commitish);\n\n\treturn detach(repo, git_annotated_commit_id(commitish), commitish->ref_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_index_id",
          "args": [
            "sm"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_index_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "933-941",
          "snippet": "const git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_checkout_tree",
          "args": [
            "sub_repo",
            "target_commit",
            "&update_options.checkout_opts"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "&target_commit",
            "sub_repo",
            "git_submodule_index_id(sm)",
            "GIT_OBJ_COMMIT"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_open",
          "args": [
            "&sub_repo",
            "sm"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1349-1352",
          "snippet": "int git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_checkout_head",
          "args": [
            "sub_repo",
            "&update_options.checkout_opts"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_clone",
          "args": [
            "&sub_repo",
            "submodule_url",
            "sm->path",
            "&clone_options"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "git_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/clone.c",
          "lines": "384-455",
          "snippet": "int git_clone(\n\tgit_repository **out,\n\tconst char *url,\n\tconst char *local_path,\n\tconst git_clone_options *_options)\n{\n\tint error = 0;\n\tgit_repository *repo = NULL;\n\tgit_remote *origin;\n\tgit_clone_options options = GIT_CLONE_OPTIONS_INIT;\n\tuint32_t rmdir_flags = GIT_RMDIR_REMOVE_FILES;\n\tgit_repository_create_cb repository_cb;\n\n\tassert(out && url && local_path);\n\n\tif (_options)\n\t\tmemcpy(&options, _options, sizeof(git_clone_options));\n\n\tGITERR_CHECK_VERSION(&options, GIT_CLONE_OPTIONS_VERSION, \"git_clone_options\");\n\n\t/* Only clone to a new directory or an empty directory */\n\tif (git_path_exists(local_path) && !git_path_is_empty_dir(local_path)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"'%s' exists and is not an empty directory\", local_path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* Only remove the root directory on failure if we create it */\n\tif (git_path_exists(local_path))\n\t\trmdir_flags |= GIT_RMDIR_SKIP_ROOT;\n\n\tif (options.repository_cb)\n\t\trepository_cb = options.repository_cb;\n\telse\n\t\trepository_cb = default_repository_create;\n\n\tif ((error = repository_cb(&repo, local_path, options.bare, options.repository_cb_payload)) < 0)\n\t\treturn error;\n\n\tif (!(error = create_and_configure_origin(&origin, repo, url, &options))) {\n\t\tint clone_local = git_clone__should_clone_local(url, options.local);\n\t\tint link = options.local != GIT_CLONE_LOCAL_NO_LINKS;\n\n\t\tif (clone_local == 1)\n\t\t\terror = clone_local_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch, link);\n\t\telse if (clone_local == 0)\n\t\t\terror = clone_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch);\n\t\telse\n\t\t\terror = -1;\n\n\t\tgit_remote_free(origin);\n\t}\n\n\tif (error != 0) {\n\t\tgit_error_state last_error = {0};\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\tgit_repository_free(repo);\n\t\trepo = NULL;\n\n\t\t(void)git_futils_rmdir_r(local_path, NULL, rmdir_flags);\n\n\t\tgiterr_state_restore(&last_error);\n\t}\n\n\t*out = repo;\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"path.h\"",
            "#include \"refs.h\"",
            "#include \"fileops.h\"",
            "#include \"remote.h\"",
            "#include \"common.h\"",
            "#include \"git2/tree.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/branch.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/clone.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"repository.h\"\n#include \"path.h\"\n#include \"refs.h\"\n#include \"fileops.h\"\n#include \"remote.h\"\n#include \"common.h\"\n#include \"git2/tree.h\"\n#include \"git2/commit.h\"\n#include \"git2/checkout.h\"\n#include \"git2/config.h\"\n#include \"git2/branch.h\"\n#include \"git2/revparse.h\"\n#include \"git2/remote.h\"\n#include \"git2/clone.h\"\n#include <assert.h>\n\nstatic int clone_local_into(git_repository *repo, git_remote *remote, const git_fetch_options *fetch_opts, const git_checkout_options *co_opts, const char *branch, int link);\n\nint git_clone(\n\tgit_repository **out,\n\tconst char *url,\n\tconst char *local_path,\n\tconst git_clone_options *_options)\n{\n\tint error = 0;\n\tgit_repository *repo = NULL;\n\tgit_remote *origin;\n\tgit_clone_options options = GIT_CLONE_OPTIONS_INIT;\n\tuint32_t rmdir_flags = GIT_RMDIR_REMOVE_FILES;\n\tgit_repository_create_cb repository_cb;\n\n\tassert(out && url && local_path);\n\n\tif (_options)\n\t\tmemcpy(&options, _options, sizeof(git_clone_options));\n\n\tGITERR_CHECK_VERSION(&options, GIT_CLONE_OPTIONS_VERSION, \"git_clone_options\");\n\n\t/* Only clone to a new directory or an empty directory */\n\tif (git_path_exists(local_path) && !git_path_is_empty_dir(local_path)) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"'%s' exists and is not an empty directory\", local_path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* Only remove the root directory on failure if we create it */\n\tif (git_path_exists(local_path))\n\t\trmdir_flags |= GIT_RMDIR_SKIP_ROOT;\n\n\tif (options.repository_cb)\n\t\trepository_cb = options.repository_cb;\n\telse\n\t\trepository_cb = default_repository_create;\n\n\tif ((error = repository_cb(&repo, local_path, options.bare, options.repository_cb_payload)) < 0)\n\t\treturn error;\n\n\tif (!(error = create_and_configure_origin(&origin, repo, url, &options))) {\n\t\tint clone_local = git_clone__should_clone_local(url, options.local);\n\t\tint link = options.local != GIT_CLONE_LOCAL_NO_LINKS;\n\n\t\tif (clone_local == 1)\n\t\t\terror = clone_local_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch, link);\n\t\telse if (clone_local == 0)\n\t\t\terror = clone_into(\n\t\t\t\trepo, origin, &options.fetch_opts, &options.checkout_opts,\n\t\t\t\toptions.checkout_branch);\n\t\telse\n\t\t\terror = -1;\n\n\t\tgit_remote_free(origin);\n\t}\n\n\tif (error != 0) {\n\t\tgit_error_state last_error = {0};\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\tgit_repository_free(repo);\n\t\trepo = NULL;\n\n\t\t(void)git_futils_rmdir_r(local_path, NULL, rmdir_flags);\n\n\t\tgiterr_state_restore(&last_error);\n\t}\n\n\t*out = repo;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_string",
          "args": [
            "&submodule_url",
            "config",
            "git_buf_cstr(&buf)"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_string_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "857-875",
          "snippet": "int git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&config",
            "sm->repo"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_init",
          "args": [
            "sm",
            "0"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1197-1239",
          "snippet": "int git_submodule_init(git_submodule *sm, int overwrite)\n{\n\tint error;\n\tconst char *val;\n\tgit_buf key = GIT_BUF_INIT, effective_submodule_url = GIT_BUF_INIT;\n\tgit_config *cfg = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository_config(&cfg, sm->repo)) < 0)\n\t\treturn error;\n\n\t/* write \"submodule.NAME.url\" */\n\n\tif ((error = git_submodule_resolve_url(&effective_submodule_url, sm->repo, sm->url)) < 0 ||\n\t\t(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, effective_submodule_url.ptr, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* write \"submodule.NAME.update\" if not default */\n\n\tval = (sm->update == GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tNULL : git_submodule_update_to_str(sm->update);\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.update\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, val, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* success */\n\ncleanup:\n\tgit_config_free(cfg);\n\tgit_buf_free(&key);\n\tgit_buf_free(&effective_submodule_url);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_init(git_submodule *sm, int overwrite)\n{\n\tint error;\n\tconst char *val;\n\tgit_buf key = GIT_BUF_INIT, effective_submodule_url = GIT_BUF_INIT;\n\tgit_config *cfg = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository_config(&cfg, sm->repo)) < 0)\n\t\treturn error;\n\n\t/* write \"submodule.NAME.url\" */\n\n\tif ((error = git_submodule_resolve_url(&effective_submodule_url, sm->repo, sm->url)) < 0 ||\n\t\t(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, effective_submodule_url.ptr, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* write \"submodule.NAME.update\" if not default */\n\n\tval = (sm->update == GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tNULL : git_submodule_update_to_str(sm->update);\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.update\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, val, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* success */\n\ncleanup:\n\tgit_config_free(cfg);\n\tgit_buf_free(&key);\n\tgit_buf_free(&effective_submodule_url);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Submodule is not initialized.\""
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"submodule.%s.url\"",
            "git_submodule_name(sm)"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_name",
          "args": [
            "sm"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "821-825",
          "snippet": "const char *git_submodule_name(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->name;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst char *git_submodule_name(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_status",
          "args": [
            "&submodule_status",
            "sm->repo",
            "sm->name",
            "GIT_SUBMODULE_IGNORE_UNSPECIFIED"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1533-1547",
          "snippet": "int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tgit_submodule *sm;\n\tint error;\n\n\tassert(status && repo && name);\n\n\tif ((error = git_submodule_lookup(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\terror = git_submodule__status(status, NULL, NULL, NULL, sm, ignore);\n\tgit_submodule_free(sm);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tgit_submodule *sm;\n\tint error;\n\n\tassert(status && repo && name);\n\n\tif ((error = git_submodule_lookup(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\terror = git_submodule__status(status, NULL, NULL, NULL, sm, ignore);\n\tgit_submodule_free(sm);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&clone_options.fetch_opts",
            "&update_options.fetch_opts",
            "sizeof(git_fetch_options)"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "&update_options",
            "GIT_SUBMODULE_UPDATE_OPTIONS_VERSION",
            "\"git_submodule_update_options\""
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&update_options",
            "_update_options",
            "sizeof(git_submodule_update_options)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sm"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_update(git_submodule *sm, int init, git_submodule_update_options *_update_options)\n{\n\tint error;\n\tunsigned int submodule_status;\n\tgit_config *config = NULL;\n\tconst char *submodule_url;\n\tgit_repository *sub_repo = NULL;\n\tgit_remote *remote = NULL;\n\tgit_object *target_commit = NULL;\n\tgit_buf buf = GIT_BUF_INIT;\n\tgit_submodule_update_options update_options = GIT_SUBMODULE_UPDATE_OPTIONS_INIT;\n\tgit_clone_options clone_options = GIT_CLONE_OPTIONS_INIT;\n\n\tassert(sm);\n\n\tif (_update_options)\n\t\tmemcpy(&update_options, _update_options, sizeof(git_submodule_update_options));\n\n\tGITERR_CHECK_VERSION(&update_options, GIT_SUBMODULE_UPDATE_OPTIONS_VERSION, \"git_submodule_update_options\");\n\n\t/* Copy over the remote callbacks */\n\tmemcpy(&clone_options.fetch_opts, &update_options.fetch_opts, sizeof(git_fetch_options));\n\n\t/* Get the status of the submodule to determine if it is already initialized  */\n\tif ((error = git_submodule_status(&submodule_status, sm->repo, sm->name, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0)\n\t\tgoto done;\n\n\t/*\n\t * If submodule work dir is not already initialized, check to see\n\t * what we need to do (initialize, clone, return error...)\n\t */\n\tif (submodule_status & GIT_SUBMODULE_STATUS_WD_UNINITIALIZED) {\n\t\t/*\n\t\t * Work dir is not initialized, check to see if the submodule\n\t\t * info has been copied into .git/config\n\t\t */\n\t\tif ((error = git_repository_config_snapshot(&config, sm->repo)) < 0 ||\n\t\t\t(error = git_buf_printf(&buf, \"submodule.%s.url\", git_submodule_name(sm))) < 0)\n\t\t\tgoto done;\n\n\t\tif ((error = git_config_get_string(&submodule_url, config, git_buf_cstr(&buf))) < 0) {\n\t\t\t/*\n\t\t\t * If the error is not \"not found\" or if it is \"not found\" and we are not\n\t\t\t * initializing the submodule, then return error.\n\t\t\t */\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\tgoto done;\n\n\t\t\tif (error == GIT_ENOTFOUND && !init) {\n\t\t\t\tgiterr_set(GITERR_SUBMODULE, \"Submodule is not initialized.\");\n\t\t\t\terror = GIT_ERROR;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* The submodule has not been initialized yet - initialize it now.*/\n\t\t\tif ((error = git_submodule_init(sm, 0)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgit_config_free(config);\n\t\t\tconfig = NULL;\n\n\t\t\tif ((error = git_repository_config_snapshot(&config, sm->repo)) < 0 ||\n\t\t\t\t(error = git_config_get_string(&submodule_url, config, git_buf_cstr(&buf))) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/** submodule is initialized - now clone it **/\n\t\t/* override repo creation */\n\t\tclone_options.repository_cb = git_submodule_update_repo_init_cb;\n\t\tclone_options.repository_cb_payload = sm;\n\n\t\t/*\n\t\t * Do not perform checkout as part of clone, instead we\n\t\t * will checkout the specific commit manually.\n\t\t */\n\t\tclone_options.checkout_opts.checkout_strategy = GIT_CHECKOUT_NONE;\n\t\tupdate_options.checkout_opts.checkout_strategy = update_options.clone_checkout_strategy;\n\n\t\tif ((error = git_clone(&sub_repo, submodule_url, sm->path, &clone_options)) < 0 ||\n\t\t\t(error = git_repository_set_head_detached(sub_repo, git_submodule_index_id(sm))) < 0 ||\n\t\t\t(error = git_checkout_head(sub_repo, &update_options.checkout_opts)) != 0)\n\t\t\tgoto done;\n\t} else {\n\t\t/**\n\t\t * Work dir is initialized - look up the commit in the parent repository's index,\n\t\t * update the workdir contents of the subrepository, and set the subrepository's\n\t\t * head to the new commit.\n\t\t */\n\t\tif ((error = git_submodule_open(&sub_repo, sm)) < 0 ||\n\t\t\t(error = git_object_lookup(&target_commit, sub_repo, git_submodule_index_id(sm), GIT_OBJ_COMMIT)) < 0 ||\n\t\t\t(error = git_checkout_tree(sub_repo, target_commit, &update_options.checkout_opts)) != 0 ||\n\t\t\t(error = git_repository_set_head_detached(sub_repo, git_submodule_index_id(sm))) < 0)\n\t\t\tgoto done;\n\n\t\t/* Invalidate the wd flags as the workdir has been updated. */\n\t\tsm->flags = sm->flags &\n\t\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t  \tGIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t  \tGIT_SUBMODULE_STATUS__WD_SCANNED);\n\t}\n\ndone:\n\tgit_buf_free(&buf);\n\tgit_config_free(config);\n\tgit_object_free(target_commit);\n\tgit_remote_free(remote);\n\tgit_repository_free(sub_repo);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_update_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1079-1084",
    "snippet": "int git_submodule_update_init_options(git_submodule_update_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_submodule_update_options, GIT_SUBMODULE_UPDATE_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_submodule_update_options",
            "GIT_SUBMODULE_UPDATE_OPTIONS_INIT"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_submodule_update_init_options(git_submodule_update_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_submodule_update_options, GIT_SUBMODULE_UPDATE_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_submodule_update_repo_init_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1064-1077",
    "snippet": "static int git_submodule_update_repo_init_cb(\n\tgit_repository **out,\n\tconst char *path,\n\tint bare,\n\tvoid *payload)\n{\n\tgit_submodule *sm;\n\n\tGIT_UNUSED(bare);\n\n\tsm = payload;\n\n\treturn submodule_repo_create(out, sm->repo, path);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_each(const git_config_entry *entry, void *payload);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "submodule_repo_create",
          "args": [
            "out",
            "sm->repo",
            "path"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_repo_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1016-1058",
          "snippet": "static int submodule_repo_create(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\tinitopt.flags =\n\t\tGIT_REPOSITORY_INIT_MKPATH |\n\t\tGIT_REPOSITORY_INIT_NO_REINIT |\n\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t/* Workdir: path to sub-repo working directory */\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.workdir_path = workdir.ptr;\n\n\t/**\n\t * Repodir: path to the sub-repo. sub-repo goes in:\n\t * <repo-dir>/modules/<name>/ with a gitlink in the\n\t * sub-repo workdir directory to that repository.\n\t */\n\terror = git_buf_join3(\n\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int submodule_repo_create(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\tinitopt.flags =\n\t\tGIT_REPOSITORY_INIT_MKPATH |\n\t\tGIT_REPOSITORY_INIT_NO_REINIT |\n\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t/* Workdir: path to sub-repo working directory */\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.workdir_path = workdir.ptr;\n\n\t/**\n\t * Repodir: path to the sub-repo. sub-repo goes in:\n\t * <repo-dir>/modules/<name>/ with a gitlink in the\n\t * sub-repo workdir directory to that repository.\n\t */\n\terror = git_buf_join3(\n\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "bare"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_each(const git_config_entry *entry, void *payload);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int git_submodule_update_repo_init_cb(\n\tgit_repository **out,\n\tconst char *path,\n\tint bare,\n\tvoid *payload)\n{\n\tgit_submodule *sm;\n\n\tGIT_UNUSED(bare);\n\n\tsm = payload;\n\n\treturn submodule_repo_create(out, sm->repo, path);\n}"
  },
  {
    "function_name": "submodule_repo_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1016-1058",
    "snippet": "static int submodule_repo_create(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\tinitopt.flags =\n\t\tGIT_REPOSITORY_INIT_MKPATH |\n\t\tGIT_REPOSITORY_INIT_NO_REINIT |\n\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t/* Workdir: path to sub-repo working directory */\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.workdir_path = workdir.ptr;\n\n\t/**\n\t * Repodir: path to the sub-repo. sub-repo goes in:\n\t * <repo-dir>/modules/<name>/ with a gitlink in the\n\t * sub-repo workdir directory to that repository.\n\t */\n\terror = git_buf_join3(\n\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&repodir"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_init_ext",
          "args": [
            "&subrepo",
            "repodir.ptr",
            "&initopt"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_init_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1665-1720",
          "snippet": "int git_repository_init_ext(\n\tgit_repository **out,\n\tconst char *given_repo,\n\tgit_repository_init_options *opts)\n{\n\tint error;\n\tgit_buf repo_path = GIT_BUF_INIT, wd_path = GIT_BUF_INIT;\n\tconst char *wd;\n\n\tassert(out && given_repo && opts);\n\n\tGITERR_CHECK_VERSION(opts, GIT_REPOSITORY_INIT_OPTIONS_VERSION, \"git_repository_init_options\");\n\n\terror = repo_init_directories(&repo_path, &wd_path, given_repo, opts);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\twd = (opts->flags & GIT_REPOSITORY_INIT_BARE) ? NULL : git_buf_cstr(&wd_path);\n\tif (valid_repository_path(&repo_path)) {\n\n\t\tif ((opts->flags & GIT_REPOSITORY_INIT_NO_REINIT) != 0) {\n\t\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\t\"Attempt to reinitialize '%s'\", given_repo);\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\topts->flags |= GIT_REPOSITORY_INIT__IS_REINIT;\n\n\t\terror = repo_init_config(\n\t\t\trepo_path.ptr, wd, opts->flags, opts->mode);\n\n\t\t/* TODO: reinitialize the templates */\n\t}\n\telse {\n\t\tif (!(error = repo_init_structure(\n\t\t\t\trepo_path.ptr, wd, opts)) &&\n\t\t\t!(error = repo_init_config(\n\t\t\t\trepo_path.ptr, wd, opts->flags, opts->mode)))\n\t\t\terror = repo_init_create_head(\n\t\t\t\trepo_path.ptr, opts->initial_head);\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_open(out, repo_path.ptr);\n\n\tif (!error && opts->origin_url)\n\t\terror = repo_init_create_origin(*out, opts->origin_url);\n\ncleanup:\n\tgit_buf_free(&repo_path);\n\tgit_buf_free(&wd_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_init_ext(\n\tgit_repository **out,\n\tconst char *given_repo,\n\tgit_repository_init_options *opts)\n{\n\tint error;\n\tgit_buf repo_path = GIT_BUF_INIT, wd_path = GIT_BUF_INIT;\n\tconst char *wd;\n\n\tassert(out && given_repo && opts);\n\n\tGITERR_CHECK_VERSION(opts, GIT_REPOSITORY_INIT_OPTIONS_VERSION, \"git_repository_init_options\");\n\n\terror = repo_init_directories(&repo_path, &wd_path, given_repo, opts);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\twd = (opts->flags & GIT_REPOSITORY_INIT_BARE) ? NULL : git_buf_cstr(&wd_path);\n\tif (valid_repository_path(&repo_path)) {\n\n\t\tif ((opts->flags & GIT_REPOSITORY_INIT_NO_REINIT) != 0) {\n\t\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\t\"Attempt to reinitialize '%s'\", given_repo);\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\topts->flags |= GIT_REPOSITORY_INIT__IS_REINIT;\n\n\t\terror = repo_init_config(\n\t\t\trepo_path.ptr, wd, opts->flags, opts->mode);\n\n\t\t/* TODO: reinitialize the templates */\n\t}\n\telse {\n\t\tif (!(error = repo_init_structure(\n\t\t\t\trepo_path.ptr, wd, opts)) &&\n\t\t\t!(error = repo_init_config(\n\t\t\t\trepo_path.ptr, wd, opts->flags, opts->mode)))\n\t\t\terror = repo_init_create_head(\n\t\t\t\trepo_path.ptr, opts->initial_head);\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_open(out, repo_path.ptr);\n\n\tif (!error && opts->origin_url)\n\t\terror = repo_init_create_origin(*out, opts->origin_url);\n\ncleanup:\n\tgit_buf_free(&repo_path);\n\tgit_buf_free(&wd_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join3",
          "args": [
            "&repodir",
            "'/'",
            "git_repository_path(parent_repo)",
            "\"modules\"",
            "path"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "657-716",
          "snippet": "int git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "parent_repo"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&workdir",
            "git_repository_workdir(parent_repo)",
            "path"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "parent_repo"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int submodule_repo_create(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\tinitopt.flags =\n\t\tGIT_REPOSITORY_INIT_MKPATH |\n\t\tGIT_REPOSITORY_INIT_NO_REINIT |\n\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t/* Workdir: path to sub-repo working directory */\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.workdir_path = workdir.ptr;\n\n\t/**\n\t * Repodir: path to the sub-repo. sub-repo goes in:\n\t * <repo-dir>/modules/<name>/ with a gitlink in the\n\t * sub-repo workdir directory to that repository.\n\t */\n\terror = git_buf_join3(\n\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_set_fetch_recurse_submodules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1009-1014",
    "snippet": "int git_submodule_set_fetch_recurse_submodules(git_repository *repo, const char *name, git_submodule_recurse_t recurse)\n{\n\tassert(repo && name);\n\n\treturn write_mapped_var(repo, name, _sm_recurse_map, ARRAY_SIZE(_sm_recurse_map), \"fetchRecurseSubmodules\", recurse);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_recurse_map[] = {\n\t{GIT_CVAR_STRING, \"on-demand\", GIT_SUBMODULE_RECURSE_ONDEMAND},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_RECURSE_NO},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_RECURSE_YES},\n};",
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_mapped_var",
          "args": [
            "repo",
            "name",
            "_sm_recurse_map",
            "ARRAY_SIZE(_sm_recurse_map)",
            "\"fetchRecurseSubmodules\"",
            "recurse"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "write_mapped_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "896-910",
          "snippet": "static int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_recurse_map"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_recurse_map[] = {\n\t{GIT_CVAR_STRING, \"on-demand\", GIT_SUBMODULE_RECURSE_ONDEMAND},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_RECURSE_NO},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_RECURSE_YES},\n};\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_set_fetch_recurse_submodules(git_repository *repo, const char *name, git_submodule_recurse_t recurse)\n{\n\tassert(repo && name);\n\n\treturn write_mapped_var(repo, name, _sm_recurse_map, ARRAY_SIZE(_sm_recurse_map), \"fetchRecurseSubmodules\", recurse);\n}"
  },
  {
    "function_name": "git_submodule_fetch_recurse_submodules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "1002-1007",
    "snippet": "git_submodule_recurse_t git_submodule_fetch_recurse_submodules(\n\tgit_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->fetch_recurse;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\ngit_submodule_recurse_t git_submodule_fetch_recurse_submodules(\n\tgit_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->fetch_recurse;\n}"
  },
  {
    "function_name": "git_submodule_set_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "995-1000",
    "snippet": "int git_submodule_set_update(git_repository *repo, const char *name, git_submodule_update_t update)\n{\n\tassert(repo && name);\n\n\treturn write_mapped_var(repo, name, _sm_update_map, ARRAY_SIZE(_sm_update_map), \"update\", update);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};",
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_mapped_var",
          "args": [
            "repo",
            "name",
            "_sm_update_map",
            "ARRAY_SIZE(_sm_update_map)",
            "\"update\"",
            "update"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "write_mapped_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "896-910",
          "snippet": "static int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_update_map"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_set_update(git_repository *repo, const char *name, git_submodule_update_t update)\n{\n\tassert(repo && name);\n\n\treturn write_mapped_var(repo, name, _sm_update_map, ARRAY_SIZE(_sm_update_map), \"update\", update);\n}"
  },
  {
    "function_name": "git_submodule_update_strategy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "988-993",
    "snippet": "git_submodule_update_t git_submodule_update_strategy(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn (submodule->update < GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tGIT_SUBMODULE_UPDATE_CHECKOUT : submodule->update;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\ngit_submodule_update_t git_submodule_update_strategy(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn (submodule->update < GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tGIT_SUBMODULE_UPDATE_CHECKOUT : submodule->update;\n}"
  },
  {
    "function_name": "git_submodule_set_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "981-986",
    "snippet": "int git_submodule_set_ignore(git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tassert(repo && name);\n\n\treturn write_mapped_var(repo, name, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), \"ignore\", ignore);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};",
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_mapped_var",
          "args": [
            "repo",
            "name",
            "_sm_ignore_map",
            "ARRAY_SIZE(_sm_ignore_map)",
            "\"ignore\"",
            "ignore"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "write_mapped_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "896-910",
          "snippet": "static int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_ignore_map"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_set_ignore(git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tassert(repo && name);\n\n\treturn write_mapped_var(repo, name, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), \"ignore\", ignore);\n}"
  },
  {
    "function_name": "git_submodule_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "974-979",
    "snippet": "git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn (submodule->ignore < GIT_SUBMODULE_IGNORE_NONE) ?\n\t\tGIT_SUBMODULE_IGNORE_NONE : submodule->ignore;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\ngit_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn (submodule->ignore < GIT_SUBMODULE_IGNORE_NONE) ?\n\t\tGIT_SUBMODULE_IGNORE_NONE : submodule->ignore;\n}"
  },
  {
    "function_name": "git_submodule_wd_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "953-972",
    "snippet": "const git_oid *git_submodule_wd_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\t/* load unless we think we have a valid oid */\n\tif (!(submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)) {\n\t\tgit_repository *subrepo;\n\n\t\t/* calling submodule open grabs the HEAD OID if possible */\n\t\tif (!git_submodule_open_bare(&subrepo, submodule))\n\t\t\tgit_repository_free(subrepo);\n\t\telse\n\t\t\tgiterr_clear();\n\t}\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)\n\t\treturn &submodule->wd_oid;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "subrepo"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_open_bare",
          "args": [
            "&subrepo",
            "submodule"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_open_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1344-1347",
          "snippet": "int git_submodule_open_bare(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, true);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open_bare(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_wd_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\t/* load unless we think we have a valid oid */\n\tif (!(submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)) {\n\t\tgit_repository *subrepo;\n\n\t\t/* calling submodule open grabs the HEAD OID if possible */\n\t\tif (!git_submodule_open_bare(&subrepo, submodule))\n\t\t\tgit_repository_free(subrepo);\n\t\telse\n\t\t\tgiterr_clear();\n\t}\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)\n\t\treturn &submodule->wd_oid;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "git_submodule_head_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "943-951",
    "snippet": "const git_oid *git_submodule_head_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID)\n\t\treturn &submodule->head_oid;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_head_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID)\n\t\treturn &submodule->head_oid;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "git_submodule_index_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "933-941",
    "snippet": "const git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_index_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID)\n\t\treturn &submodule->index_oid;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "git_submodule_set_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "926-931",
    "snippet": "int git_submodule_set_url(git_repository *repo, const char *name, const char *url)\n{\n\tassert(repo && name && url);\n\n\treturn write_var(repo, name, \"url\", url);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_var",
          "args": [
            "repo",
            "name",
            "\"url\"",
            "url"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "write_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "871-894",
          "snippet": "static int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name && url"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_set_url(git_repository *repo, const char *name, const char *url)\n{\n\tassert(repo && name && url);\n\n\treturn write_var(repo, name, \"url\", url);\n}"
  },
  {
    "function_name": "git_submodule_set_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "918-924",
    "snippet": "int git_submodule_set_branch(git_repository *repo, const char *name, const char *branch)\n{\n\n\tassert(repo && name);\n\n\treturn write_var(repo, name, \"branch\", branch);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_var",
          "args": [
            "repo",
            "name",
            "\"branch\"",
            "branch"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "write_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "871-894",
          "snippet": "static int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_set_branch(git_repository *repo, const char *name, const char *branch)\n{\n\n\tassert(repo && name);\n\n\treturn write_var(repo, name, \"branch\", branch);\n}"
  },
  {
    "function_name": "git_submodule_branch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "912-916",
    "snippet": "const char *git_submodule_branch(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->branch;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst char *git_submodule_branch(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->branch;\n}"
  },
  {
    "function_name": "write_mapped_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "896-910",
    "snippet": "static int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_var",
          "args": [
            "repo",
            "name",
            "var",
            "val"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "write_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "871-894",
          "snippet": "static int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"invalid value for %s\"",
            "var"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_lookup_map_enum",
          "args": [
            "&type",
            "&val",
            "maps",
            "nmaps",
            "ival"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_lookup_map_enum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1243-1261",
          "snippet": "int git_config_lookup_map_enum(git_cvar_t *type_out, const char **str_out,\n\t\t\t       const git_cvar_map *maps, size_t map_n, int enum_val)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < map_n; i++) {\n\t\tconst git_cvar_map *m = &maps[i];\n\n\t\tif (m->map_value != enum_val)\n\t\t\tcontinue;\n\n\t\t*type_out = m->cvar_type;\n\t\t*str_out = m->str_match;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_CONFIG, \"invalid enum value\");\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_lookup_map_enum(git_cvar_t *type_out, const char **str_out,\n\t\t\t       const git_cvar_map *maps, size_t map_n, int enum_val)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < map_n; i++) {\n\t\tconst git_cvar_map *m = &maps[i];\n\n\t\tif (m->map_value != enum_val)\n\t\t\tcontinue;\n\n\t\t*type_out = m->cvar_type;\n\t\t*str_out = m->str_match;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_CONFIG, \"invalid enum value\");\n\treturn GIT_ENOTFOUND;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_mapped_var(git_repository *repo, const char *name, git_cvar_map *maps, size_t nmaps, const char *var, int ival)\n{\n\tgit_cvar_t type;\n\tconst char *val;\n\n\tif (git_config_lookup_map_enum(&type, &val, maps, nmaps, ival) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"invalid value for %s\", var);\n\t\treturn -1;\n\t}\n\n\tif (type == GIT_CVAR_TRUE)\n\t\tval = \"true\";\n\n\treturn write_var(repo, name, var, val);\n}"
  },
  {
    "function_name": "write_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "871-894",
    "snippet": "static int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_file_free",
          "args": [
            "mods"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "17-21",
          "snippet": "GIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&key"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_delete",
          "args": [
            "mods",
            "key.ptr"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "35-39",
          "snippet": "GIT_INLINE(int) git_config_file_delete(\n\tgit_config_backend *cfg, const char *name)\n{\n\treturn cfg->del(cfg, name);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(int) git_config_file_delete(\n\tgit_config_backend *cfg, const char *name)\n{\n\treturn cfg->del(cfg, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_set_string",
          "args": [
            "mods",
            "key.ptr",
            "val"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "29-33",
          "snippet": "GIT_INLINE(int) git_config_file_set_string(\n\tgit_config_backend *cfg, const char *name, const char *value)\n{\n\treturn cfg->set(cfg, name, value);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(int) git_config_file_set_string(\n\tgit_config_backend *cfg, const char *name, const char *value)\n{\n\treturn cfg->set(cfg, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&key",
            "\"submodule.%s.%s\"",
            "name",
            "var"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_gitmodules",
          "args": [
            "repo",
            "GITMODULES_CREATE"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "open_gitmodules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1862-1889",
          "snippet": "static git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_MODULES_FILE \".gitmodules\""
          ],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int write_var(git_repository *repo, const char *name, const char *var, const char *val)\n{\n\tgit_buf key = GIT_BUF_INIT;\n\tgit_config_backend *mods;\n\tint error;\n\n\tmods = open_gitmodules(repo, GITMODULES_CREATE);\n\tif (!mods)\n\t\treturn -1;\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.%s\", name, var)) < 0)\n\t\tgoto cleanup;\n\n\tif (val)\n\t\terror = git_config_file_set_string(mods, key.ptr, val);\n\telse\n\t\terror = git_config_file_delete(mods, key.ptr);\n\n\tgit_buf_free(&key);\n\ncleanup:\n\tgit_config_file_free(mods);\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_resolve_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "839-869",
    "snippet": "int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)\n{\n\tint error = 0;\n\tgit_buf normalized = GIT_BUF_INIT;\n\n\tassert(out && repo && url);\n\n\tgit_buf_sanitize(out);\n\n\t/* We do this in all platforms in case someone on Windows created the .gitmodules */\n\tif (strchr(url, '\\\\')) {\n\t\tif ((error = git_path_normalize_slashes(&normalized, url)) < 0)\n\t\t\treturn error;\n\n\t\turl = normalized.ptr;\n\t}\n\n\n\tif (git_path_is_relative(url)) {\n\t\tif (!(error = get_url_base(out, repo)))\n\t\t\terror = git_path_apply_relative(out, url);\n\t} else if (strchr(url, ':') != NULL || url[0] == '/') {\n\t\terror = git_buf_sets(out, url);\n\t} else {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid format for submodule URL\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&normalized);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&normalized"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Invalid format for submodule URL\""
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "out",
            "url"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "url",
            "':'"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_apply_relative",
          "args": [
            "out",
            "url"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_apply_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "782-786",
          "snippet": "int git_path_apply_relative(git_buf *target, const char *relpath)\n{\n\tgit_buf_joinpath(target, git_buf_cstr(target), relpath);\n\treturn git_path_resolve_relative(target, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_apply_relative(git_buf *target, const char *relpath)\n{\n\tgit_buf_joinpath(target, git_buf_cstr(target), relpath);\n\treturn git_path_resolve_relative(target, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_url_base",
          "args": [
            "out",
            "repo"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "get_url_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1965-1981",
          "snippet": "static int get_url_base(git_buf *url, git_repository *repo)\n{\n\tint error;\n\tgit_remote *remote = NULL;\n\n\tif (!(error = lookup_default_remote(&remote, repo))) {\n\t\terror = git_buf_sets(url, git_remote_url(remote));\n\t\tgit_remote_free(remote);\n\t}\n\telse if (error == GIT_ENOTFOUND) {\n\t\t/* if repository does not have a default remote, use workdir instead */\n\t\tgiterr_clear();\n\t\terror = git_buf_sets(url, git_repository_workdir(repo));\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int get_url_base(git_buf *url, git_repository *repo)\n{\n\tint error;\n\tgit_remote *remote = NULL;\n\n\tif (!(error = lookup_default_remote(&remote, repo))) {\n\t\terror = git_buf_sets(url, git_remote_url(remote));\n\t\tgit_remote_free(remote);\n\t}\n\telse if (error == GIT_ENOTFOUND) {\n\t\t/* if repository does not have a default remote, use workdir instead */\n\t\tgiterr_clear();\n\t\terror = git_buf_sets(url, git_repository_workdir(repo));\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_is_relative",
          "args": [
            "url"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_is_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "126-129",
          "snippet": "GIT_INLINE(int) git_path_is_relative(const char *p)\n{\n\treturn (p[0] == '.' && (p[1] == '/' || (p[1] == '.' && p[2] == '/')));\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_path_is_relative(const char *p)\n{\n\treturn (p[0] == '.' && (p[1] == '/' || (p[1] == '.' && p[2] == '/')));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_normalize_slashes",
          "args": [
            "&normalized",
            "url"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_normalize_slashes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1703-1717",
          "snippet": "int git_path_normalize_slashes(git_buf *out, const char *path)\n{\n\tint error;\n\tchar *p;\n\n\tif ((error = git_buf_puts(out, path)) < 0)\n\t\treturn error;\n\n\tfor (p = out->ptr; *p; p++) {\n\t\tif (*p == '\\\\')\n\t\t\t*p = '/';\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_normalize_slashes(git_buf *out, const char *path)\n{\n\tint error;\n\tchar *p;\n\n\tif ((error = git_buf_puts(out, path)) < 0)\n\t\treturn error;\n\n\tfor (p = out->ptr; *p; p++) {\n\t\tif (*p == '\\\\')\n\t\t\t*p = '/';\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "url",
            "'\\\\'"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && url"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)\n{\n\tint error = 0;\n\tgit_buf normalized = GIT_BUF_INIT;\n\n\tassert(out && repo && url);\n\n\tgit_buf_sanitize(out);\n\n\t/* We do this in all platforms in case someone on Windows created the .gitmodules */\n\tif (strchr(url, '\\\\')) {\n\t\tif ((error = git_path_normalize_slashes(&normalized, url)) < 0)\n\t\t\treturn error;\n\n\t\turl = normalized.ptr;\n\t}\n\n\n\tif (git_path_is_relative(url)) {\n\t\tif (!(error = get_url_base(out, repo)))\n\t\t\terror = git_path_apply_relative(out, url);\n\t} else if (strchr(url, ':') != NULL || url[0] == '/') {\n\t\terror = git_buf_sets(out, url);\n\t} else {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid format for submodule URL\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&normalized);\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "833-837",
    "snippet": "const char *git_submodule_url(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->url;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst char *git_submodule_url(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->url;\n}"
  },
  {
    "function_name": "git_submodule_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "827-831",
    "snippet": "const char *git_submodule_path(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->path;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst char *git_submodule_path(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->path;\n}"
  },
  {
    "function_name": "git_submodule_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "821-825",
    "snippet": "const char *git_submodule_name(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->name;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst char *git_submodule_name(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->name;\n}"
  },
  {
    "function_name": "git_submodule_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "815-819",
    "snippet": "git_repository *git_submodule_owner(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->repo;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "submodule"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\ngit_repository *git_submodule_owner(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn submodule->repo;\n}"
  },
  {
    "function_name": "git_submodule_update_to_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "806-813",
    "snippet": "const char *git_submodule_update_to_str(git_submodule_update_t update)\n{\n\tint i;\n\tfor (i = 0; i < (int)ARRAY_SIZE(_sm_update_map); ++i)\n\t\tif (_sm_update_map[i].map_value == (int)update)\n\t\t\treturn _sm_update_map[i].str_match;\n\treturn NULL;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "_sm_update_map"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_update_map[] = {\n\t{GIT_CVAR_STRING, \"checkout\", GIT_SUBMODULE_UPDATE_CHECKOUT},\n\t{GIT_CVAR_STRING, \"rebase\", GIT_SUBMODULE_UPDATE_REBASE},\n\t{GIT_CVAR_STRING, \"merge\", GIT_SUBMODULE_UPDATE_MERGE},\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_UPDATE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_UPDATE_CHECKOUT},\n};\n\nconst char *git_submodule_update_to_str(git_submodule_update_t update)\n{\n\tint i;\n\tfor (i = 0; i < (int)ARRAY_SIZE(_sm_update_map); ++i)\n\t\tif (_sm_update_map[i].map_value == (int)update)\n\t\t\treturn _sm_update_map[i].str_match;\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_submodule_add_to_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "736-804",
    "snippet": "int git_submodule_add_to_index(git_submodule *sm, int write_index)\n{\n\tint error;\n\tgit_repository *sm_repo = NULL;\n\tgit_index *index;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_commit *head;\n\tgit_index_entry entry;\n\tstruct stat st;\n\n\tassert(sm);\n\n\t/* force reload of wd OID by git_submodule_open */\n\tsm->flags = sm->flags & ~GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(sm->repo), sm->path)) < 0 ||\n\t\t(error = git_submodule_open(&sm_repo, sm)) < 0)\n\t\tgoto cleanup;\n\n\t/* read stat information for submodule working directory */\n\tif (p_stat(path.ptr, &st) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without working directory\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = sm->path;\n\tgit_index_entry__init_from_stat(\n\t\t&entry, &st, !(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE));\n\n\t/* calling git_submodule_open will have set sm->wd_oid if possible */\n\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) == 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without HEAD to index\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\tgit_oid_cpy(&entry.id, &sm->wd_oid);\n\n\tif ((error = git_commit_lookup(&head, sm_repo, &sm->wd_oid)) < 0)\n\t\tgoto cleanup;\n\n\tentry.ctime.seconds = (int32_t)git_commit_time(head);\n\tentry.ctime.nanoseconds = 0;\n\tentry.mtime.seconds = (int32_t)git_commit_time(head);\n\tentry.mtime.nanoseconds = 0;\n\n\tgit_commit_free(head);\n\n\t/* add it */\n\terror = git_index_add(index, &entry);\n\n\t/* write it, if requested */\n\tif (!error && write_index) {\n\t\terror = git_index_write(index);\n\n\t\tif (!error)\n\t\t\tgit_oid_cpy(&sm->index_oid, &sm->wd_oid);\n\t}\n\ncleanup:\n\tgit_repository_free(sm_repo);\n\tgit_buf_free(&path);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "sm_repo"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&sm->index_oid",
            "&sm->wd_oid"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_write",
          "args": [
            "index"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "750-763",
          "snippet": "int git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_add",
          "args": [
            "index",
            "&entry"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1580-1598",
          "snippet": "int git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "head"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_time",
          "args": [
            "head"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_time",
          "args": [
            "head"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_lookup",
          "args": [
            "&head",
            "sm_repo",
            "&sm->wd_oid"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "20-23",
          "snippet": "int git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_commit_lookup(git_commit **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Cannot add submodule without HEAD to index\""
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry__init_from_stat",
          "args": [
            "&entry",
            "&st",
            "!(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry__init_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "827-843",
          "snippet": "void git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_caps",
          "args": [
            "index"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "590-595",
          "snippet": "int git_index_caps(const git_index *index)\n{\n\treturn ((index->ignore_case ? GIT_INDEXCAP_IGNORE_CASE : 0) |\n\t\t\t(index->distrust_filemode ? GIT_INDEXCAP_NO_FILEMODE : 0) |\n\t\t\t(index->no_symlinks ? GIT_INDEXCAP_NO_SYMLINKS : 0));\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_caps(const git_index *index)\n{\n\treturn ((index->ignore_case ? GIT_INDEXCAP_IGNORE_CASE : 0) |\n\t\t\t(index->distrust_filemode ? GIT_INDEXCAP_NO_FILEMODE : 0) |\n\t\t\t(index->no_symlinks ? GIT_INDEXCAP_NO_SYMLINKS : 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry",
            "0",
            "sizeof(entry)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "path.ptr",
            "&st"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_open",
          "args": [
            "&sm_repo",
            "sm"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1349-1352",
          "snippet": "int git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_open(git_repository **subrepo, git_submodule *sm)\n{\n\treturn git_submodule__open(subrepo, sm, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "git_repository_workdir(sm->repo)",
            "sm->path"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "sm->repo"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "sm->repo"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sm"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nint git_submodule_add_to_index(git_submodule *sm, int write_index)\n{\n\tint error;\n\tgit_repository *sm_repo = NULL;\n\tgit_index *index;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_commit *head;\n\tgit_index_entry entry;\n\tstruct stat st;\n\n\tassert(sm);\n\n\t/* force reload of wd OID by git_submodule_open */\n\tsm->flags = sm->flags & ~GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(sm->repo), sm->path)) < 0 ||\n\t\t(error = git_submodule_open(&sm_repo, sm)) < 0)\n\t\tgoto cleanup;\n\n\t/* read stat information for submodule working directory */\n\tif (p_stat(path.ptr, &st) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without working directory\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = sm->path;\n\tgit_index_entry__init_from_stat(\n\t\t&entry, &st, !(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE));\n\n\t/* calling git_submodule_open will have set sm->wd_oid if possible */\n\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) == 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without HEAD to index\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\tgit_oid_cpy(&entry.id, &sm->wd_oid);\n\n\tif ((error = git_commit_lookup(&head, sm_repo, &sm->wd_oid)) < 0)\n\t\tgoto cleanup;\n\n\tentry.ctime.seconds = (int32_t)git_commit_time(head);\n\tentry.ctime.nanoseconds = 0;\n\tentry.mtime.seconds = (int32_t)git_commit_time(head);\n\tentry.mtime.nanoseconds = 0;\n\n\tgit_commit_free(head);\n\n\t/* add it */\n\terror = git_index_add(index, &entry);\n\n\t/* write it, if requested */\n\tif (!error && write_index) {\n\t\terror = git_index_write(index);\n\n\t\tif (!error)\n\t\t\tgit_oid_cpy(&sm->index_oid, &sm->wd_oid);\n\t}\n\ncleanup:\n\tgit_repository_free(sm_repo);\n\tgit_buf_free(&path);\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_add_finalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "722-734",
    "snippet": "int git_submodule_add_finalize(git_submodule *sm)\n{\n\tint error;\n\tgit_index *index;\n\n\tassert(sm);\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_index_add_bypath(index, GIT_MODULES_FILE)) < 0)\n\t\treturn error;\n\n\treturn git_submodule_add_to_index(sm, true);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_MODULES_FILE \".gitmodules\""
    ],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule_add_to_index",
          "args": [
            "sm",
            "true"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_add_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "736-804",
          "snippet": "int git_submodule_add_to_index(git_submodule *sm, int write_index)\n{\n\tint error;\n\tgit_repository *sm_repo = NULL;\n\tgit_index *index;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_commit *head;\n\tgit_index_entry entry;\n\tstruct stat st;\n\n\tassert(sm);\n\n\t/* force reload of wd OID by git_submodule_open */\n\tsm->flags = sm->flags & ~GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(sm->repo), sm->path)) < 0 ||\n\t\t(error = git_submodule_open(&sm_repo, sm)) < 0)\n\t\tgoto cleanup;\n\n\t/* read stat information for submodule working directory */\n\tif (p_stat(path.ptr, &st) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without working directory\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = sm->path;\n\tgit_index_entry__init_from_stat(\n\t\t&entry, &st, !(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE));\n\n\t/* calling git_submodule_open will have set sm->wd_oid if possible */\n\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) == 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without HEAD to index\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\tgit_oid_cpy(&entry.id, &sm->wd_oid);\n\n\tif ((error = git_commit_lookup(&head, sm_repo, &sm->wd_oid)) < 0)\n\t\tgoto cleanup;\n\n\tentry.ctime.seconds = (int32_t)git_commit_time(head);\n\tentry.ctime.nanoseconds = 0;\n\tentry.mtime.seconds = (int32_t)git_commit_time(head);\n\tentry.mtime.nanoseconds = 0;\n\n\tgit_commit_free(head);\n\n\t/* add it */\n\terror = git_index_add(index, &entry);\n\n\t/* write it, if requested */\n\tif (!error && write_index) {\n\t\terror = git_index_write(index);\n\n\t\tif (!error)\n\t\t\tgit_oid_cpy(&sm->index_oid, &sm->wd_oid);\n\t}\n\ncleanup:\n\tgit_repository_free(sm_repo);\n\tgit_buf_free(&path);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nint git_submodule_add_to_index(git_submodule *sm, int write_index)\n{\n\tint error;\n\tgit_repository *sm_repo = NULL;\n\tgit_index *index;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_commit *head;\n\tgit_index_entry entry;\n\tstruct stat st;\n\n\tassert(sm);\n\n\t/* force reload of wd OID by git_submodule_open */\n\tsm->flags = sm->flags & ~GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(sm->repo), sm->path)) < 0 ||\n\t\t(error = git_submodule_open(&sm_repo, sm)) < 0)\n\t\tgoto cleanup;\n\n\t/* read stat information for submodule working directory */\n\tif (p_stat(path.ptr, &st) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without working directory\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = sm->path;\n\tgit_index_entry__init_from_stat(\n\t\t&entry, &st, !(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE));\n\n\t/* calling git_submodule_open will have set sm->wd_oid if possible */\n\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) == 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without HEAD to index\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\tgit_oid_cpy(&entry.id, &sm->wd_oid);\n\n\tif ((error = git_commit_lookup(&head, sm_repo, &sm->wd_oid)) < 0)\n\t\tgoto cleanup;\n\n\tentry.ctime.seconds = (int32_t)git_commit_time(head);\n\tentry.ctime.nanoseconds = 0;\n\tentry.mtime.seconds = (int32_t)git_commit_time(head);\n\tentry.mtime.nanoseconds = 0;\n\n\tgit_commit_free(head);\n\n\t/* add it */\n\terror = git_index_add(index, &entry);\n\n\t/* write it, if requested */\n\tif (!error && write_index) {\n\t\terror = git_index_write(index);\n\n\t\tif (!error)\n\t\t\tgit_oid_cpy(&sm->index_oid, &sm->wd_oid);\n\t}\n\ncleanup:\n\tgit_repository_free(sm_repo);\n\tgit_buf_free(&path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_add_bypath",
          "args": [
            "index",
            "GIT_MODULES_FILE"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1470-1521",
          "snippet": "int git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "sm->repo"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "sm"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_add_finalize(git_submodule *sm)\n{\n\tint error;\n\tgit_index *index;\n\n\tassert(sm);\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_index_add_bypath(index, GIT_MODULES_FILE)) < 0)\n\t\treturn error;\n\n\treturn git_submodule_add_to_index(sm, true);\n}"
  },
  {
    "function_name": "git_submodule_repo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "694-720",
    "snippet": "int git_submodule_repo_init(\n\tgit_repository **out,\n\tconst git_submodule *sm,\n\tint use_gitlink)\n{\n\tint error;\n\tgit_repository *sub_repo = NULL;\n\tconst char *configured_url;\n\tgit_config *cfg = NULL;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tassert(out && sm);\n\n\t/* get the configured remote url of the submodule */\n\tif ((error = git_buf_printf(&buf, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_repository_config_snapshot(&cfg, sm->repo)) < 0 ||\n\t\t(error = git_config_get_string(&configured_url, cfg, buf.ptr)) < 0 ||\n\t\t(error = submodule_repo_init(&sub_repo, sm->repo, sm->path, configured_url, use_gitlink)) < 0)\n\t\tgoto done;\n\n\t*out = sub_repo;\n\ndone:\n\tgit_config_free(cfg);\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "cfg"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_repo_init",
          "args": [
            "&sub_repo",
            "sm->repo",
            "sm->path",
            "configured_url",
            "use_gitlink"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_repo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "549-597",
          "snippet": "static int submodule_repo_init(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path,\n\tconst char *url,\n\tbool use_gitlink)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.flags = GIT_REPOSITORY_INIT_MKPATH | GIT_REPOSITORY_INIT_NO_REINIT;\n\tinitopt.origin_url = url;\n\n\t/* init submodule repository and add origin remote as needed */\n\n\t/* New style: sub-repo goes in <repo-dir>/modules/<name>/ with a\n\t * gitlink in the sub-repo workdir directory to that repository\n\t *\n\t * Old style: sub-repo goes directly into repo/<name>/.git/\n\t */\n\t if (use_gitlink) {\n\t\terror = git_buf_join3(\n\t\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitopt.workdir_path = workdir.ptr;\n\t\tinitopt.flags |=\n\t\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\t} else\n\t\terror = git_repository_init_ext(&subrepo, workdir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int submodule_repo_init(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path,\n\tconst char *url,\n\tbool use_gitlink)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.flags = GIT_REPOSITORY_INIT_MKPATH | GIT_REPOSITORY_INIT_NO_REINIT;\n\tinitopt.origin_url = url;\n\n\t/* init submodule repository and add origin remote as needed */\n\n\t/* New style: sub-repo goes in <repo-dir>/modules/<name>/ with a\n\t * gitlink in the sub-repo workdir directory to that repository\n\t *\n\t * Old style: sub-repo goes directly into repo/<name>/.git/\n\t */\n\t if (use_gitlink) {\n\t\terror = git_buf_join3(\n\t\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitopt.workdir_path = workdir.ptr;\n\t\tinitopt.flags |=\n\t\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\t} else\n\t\terror = git_repository_init_ext(&subrepo, workdir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_get_string",
          "args": [
            "&configured_url",
            "cfg",
            "buf.ptr"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_get_string_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "857-875",
          "snippet": "int git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_get_string_buf(\n\tgit_buf *out, const git_config *cfg, const char *name)\n{\n\tgit_config_entry *entry;\n\tint ret;\n\tconst char *str;\n\n\tgit_buf_sanitize(out);\n\n\tret  = get_entry(&entry, cfg, name, true, GET_ALL_ERRORS);\n\tstr = !ret ? (entry->value ? entry->value : \"\") : NULL;\n\n\tif (str)\n\t\tret = git_buf_puts(out, str);\n\n\tgit_config_entry_free(entry);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&cfg",
            "sm->repo"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&buf",
            "\"submodule.%s.url\"",
            "sm->name"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && sm"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_repo_init(\n\tgit_repository **out,\n\tconst git_submodule *sm,\n\tint use_gitlink)\n{\n\tint error;\n\tgit_repository *sub_repo = NULL;\n\tconst char *configured_url;\n\tgit_config *cfg = NULL;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tassert(out && sm);\n\n\t/* get the configured remote url of the submodule */\n\tif ((error = git_buf_printf(&buf, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_repository_config_snapshot(&cfg, sm->repo)) < 0 ||\n\t\t(error = git_config_get_string(&configured_url, cfg, buf.ptr)) < 0 ||\n\t\t(error = submodule_repo_init(&sub_repo, sm->repo, sm->path, configured_url, use_gitlink)) < 0)\n\t\tgoto done;\n\n\t*out = sub_repo;\n\ndone:\n\tgit_config_free(cfg);\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_add_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "599-692",
    "snippet": "int git_submodule_add_setup(\n\tgit_submodule **out,\n\tgit_repository *repo,\n\tconst char *url,\n\tconst char *path,\n\tint use_gitlink)\n{\n\tint error = 0;\n\tgit_config_backend *mods = NULL;\n\tgit_submodule *sm = NULL;\n\tgit_buf name = GIT_BUF_INIT, real_url = GIT_BUF_INIT;\n\tgit_repository *subrepo = NULL;\n\n\tassert(repo && url && path);\n\n\t/* see if there is already an entry for this submodule */\n\n\tif (git_submodule_lookup(NULL, repo, path) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Attempt to add submodule '%s' that already exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* validate and normalize path */\n\n\tif (git__prefixcmp(path, git_repository_workdir(repo)) == 0)\n\t\tpath += strlen(git_repository_workdir(repo));\n\n\tif (git_path_root(path) >= 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Submodule path must be a relative path\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/* update .gitmodules */\n\n\tif (!(mods = open_gitmodules(repo, GITMODULES_CREATE))) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Adding submodules to a bare repository is not supported\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_buf_printf(&name, \"submodule.%s.path\", path)) < 0 ||\n\t\t(error = git_config_file_set_string(mods, name.ptr, path)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = submodule_config_key_trunc_puts(&name, \"url\")) < 0 ||\n\t\t(error = git_config_file_set_string(mods, name.ptr, url)) < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_clear(&name);\n\n\t/* init submodule repository and add origin remote as needed */\n\n\terror = git_buf_joinpath(&name, git_repository_workdir(repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* if the repo does not already exist, then init a new repo and add it.\n\t * Otherwise, just add the existing repo.\n\t */\n\tif (!(git_path_exists(name.ptr) &&\n\t\tgit_path_contains(&name, DOT_GIT))) {\n\n\t\t/* resolve the actual URL to use */\n\t\tif ((error = git_submodule_resolve_url(&real_url, repo, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t if ((error = submodule_repo_init(&subrepo, repo, path, real_url.ptr, use_gitlink)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_submodule_lookup(&sm, repo, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_submodule_init(sm, false);\n\ncleanup:\n\tif (error && sm) {\n\t\tgit_submodule_free(sm);\n\t\tsm = NULL;\n\t}\n\tif (out != NULL)\n\t\t*out = sm;\n\n\tgit_config_file_free(mods);\n\tgit_repository_free(subrepo);\n\tgit_buf_free(&real_url);\n\tgit_buf_free(&name);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "subrepo"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_free",
          "args": [
            "mods"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "17-21",
          "snippet": "GIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_init",
          "args": [
            "sm",
            "false"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1197-1239",
          "snippet": "int git_submodule_init(git_submodule *sm, int overwrite)\n{\n\tint error;\n\tconst char *val;\n\tgit_buf key = GIT_BUF_INIT, effective_submodule_url = GIT_BUF_INIT;\n\tgit_config *cfg = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository_config(&cfg, sm->repo)) < 0)\n\t\treturn error;\n\n\t/* write \"submodule.NAME.url\" */\n\n\tif ((error = git_submodule_resolve_url(&effective_submodule_url, sm->repo, sm->url)) < 0 ||\n\t\t(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, effective_submodule_url.ptr, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* write \"submodule.NAME.update\" if not default */\n\n\tval = (sm->update == GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tNULL : git_submodule_update_to_str(sm->update);\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.update\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, val, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* success */\n\ncleanup:\n\tgit_config_free(cfg);\n\tgit_buf_free(&key);\n\tgit_buf_free(&effective_submodule_url);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_init(git_submodule *sm, int overwrite)\n{\n\tint error;\n\tconst char *val;\n\tgit_buf key = GIT_BUF_INIT, effective_submodule_url = GIT_BUF_INIT;\n\tgit_config *cfg = NULL;\n\n\tif (!sm->url) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"No URL configured for submodule '%s'\", sm->name);\n\t\treturn -1;\n\t}\n\n\tif ((error = git_repository_config(&cfg, sm->repo)) < 0)\n\t\treturn error;\n\n\t/* write \"submodule.NAME.url\" */\n\n\tif ((error = git_submodule_resolve_url(&effective_submodule_url, sm->repo, sm->url)) < 0 ||\n\t\t(error = git_buf_printf(&key, \"submodule.%s.url\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, effective_submodule_url.ptr, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* write \"submodule.NAME.update\" if not default */\n\n\tval = (sm->update == GIT_SUBMODULE_UPDATE_CHECKOUT) ?\n\t\tNULL : git_submodule_update_to_str(sm->update);\n\n\tif ((error = git_buf_printf(&key, \"submodule.%s.update\", sm->name)) < 0 ||\n\t\t(error = git_config__update_entry(\n\t\t\tcfg, key.ptr, val, overwrite != 0, false)) < 0)\n\t\tgoto cleanup;\n\n\t/* success */\n\ncleanup:\n\tgit_config_free(cfg);\n\tgit_buf_free(&key);\n\tgit_buf_free(&effective_submodule_url);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "&sm",
            "repo",
            "path"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_repo_init",
          "args": [
            "&subrepo",
            "repo",
            "path",
            "real_url.ptr",
            "use_gitlink"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_repo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "549-597",
          "snippet": "static int submodule_repo_init(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path,\n\tconst char *url,\n\tbool use_gitlink)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.flags = GIT_REPOSITORY_INIT_MKPATH | GIT_REPOSITORY_INIT_NO_REINIT;\n\tinitopt.origin_url = url;\n\n\t/* init submodule repository and add origin remote as needed */\n\n\t/* New style: sub-repo goes in <repo-dir>/modules/<name>/ with a\n\t * gitlink in the sub-repo workdir directory to that repository\n\t *\n\t * Old style: sub-repo goes directly into repo/<name>/.git/\n\t */\n\t if (use_gitlink) {\n\t\terror = git_buf_join3(\n\t\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitopt.workdir_path = workdir.ptr;\n\t\tinitopt.flags |=\n\t\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\t} else\n\t\terror = git_repository_init_ext(&subrepo, workdir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int submodule_repo_init(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path,\n\tconst char *url,\n\tbool use_gitlink)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.flags = GIT_REPOSITORY_INIT_MKPATH | GIT_REPOSITORY_INIT_NO_REINIT;\n\tinitopt.origin_url = url;\n\n\t/* init submodule repository and add origin remote as needed */\n\n\t/* New style: sub-repo goes in <repo-dir>/modules/<name>/ with a\n\t * gitlink in the sub-repo workdir directory to that repository\n\t *\n\t * Old style: sub-repo goes directly into repo/<name>/.git/\n\t */\n\t if (use_gitlink) {\n\t\terror = git_buf_join3(\n\t\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitopt.workdir_path = workdir.ptr;\n\t\tinitopt.flags |=\n\t\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\t} else\n\t\terror = git_repository_init_ext(&subrepo, workdir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_resolve_url",
          "args": [
            "&real_url",
            "repo",
            "url"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_resolve_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "839-869",
          "snippet": "int git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)\n{\n\tint error = 0;\n\tgit_buf normalized = GIT_BUF_INIT;\n\n\tassert(out && repo && url);\n\n\tgit_buf_sanitize(out);\n\n\t/* We do this in all platforms in case someone on Windows created the .gitmodules */\n\tif (strchr(url, '\\\\')) {\n\t\tif ((error = git_path_normalize_slashes(&normalized, url)) < 0)\n\t\t\treturn error;\n\n\t\turl = normalized.ptr;\n\t}\n\n\n\tif (git_path_is_relative(url)) {\n\t\tif (!(error = get_url_base(out, repo)))\n\t\t\terror = git_path_apply_relative(out, url);\n\t} else if (strchr(url, ':') != NULL || url[0] == '/') {\n\t\terror = git_buf_sets(out, url);\n\t} else {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid format for submodule URL\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&normalized);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nint git_submodule_resolve_url(git_buf *out, git_repository *repo, const char *url)\n{\n\tint error = 0;\n\tgit_buf normalized = GIT_BUF_INIT;\n\n\tassert(out && repo && url);\n\n\tgit_buf_sanitize(out);\n\n\t/* We do this in all platforms in case someone on Windows created the .gitmodules */\n\tif (strchr(url, '\\\\')) {\n\t\tif ((error = git_path_normalize_slashes(&normalized, url)) < 0)\n\t\t\treturn error;\n\n\t\turl = normalized.ptr;\n\t}\n\n\n\tif (git_path_is_relative(url)) {\n\t\tif (!(error = get_url_base(out, repo)))\n\t\t\terror = git_path_apply_relative(out, url);\n\t} else if (strchr(url, ':') != NULL || url[0] == '/') {\n\t\terror = git_buf_sets(out, url);\n\t} else {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid format for submodule URL\");\n\t\terror = -1;\n\t}\n\n\tgit_buf_free(&normalized);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_contains",
          "args": [
            "&name",
            "DOT_GIT"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_contains_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "678-681",
          "snippet": "bool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "name.ptr"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&name",
            "git_repository_workdir(repo)",
            "path"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&name"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_set_string",
          "args": [
            "mods",
            "name.ptr",
            "url"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_set_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "29-33",
          "snippet": "GIT_INLINE(int) git_config_file_set_string(\n\tgit_config_backend *cfg, const char *name, const char *value)\n{\n\treturn cfg->set(cfg, name, value);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(int) git_config_file_set_string(\n\tgit_config_backend *cfg, const char *name, const char *value)\n{\n\treturn cfg->set(cfg, name, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_config_key_trunc_puts",
          "args": [
            "&name",
            "\"url\""
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_config_key_trunc_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "109-114",
          "snippet": "static int submodule_config_key_trunc_puts(git_buf *key, const char *suffix)\n{\n\tssize_t idx = git_buf_rfind(key, '.');\n\tgit_buf_truncate(key, (size_t)(idx + 1));\n\treturn git_buf_puts(key, suffix);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_config_key_trunc_puts(git_buf *key, const char *suffix)\n{\n\tssize_t idx = git_buf_rfind(key, '.');\n\tgit_buf_truncate(key, (size_t)(idx + 1));\n\treturn git_buf_puts(key, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&name",
            "\"submodule.%s.path\"",
            "path"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Adding submodules to a bare repository is not supported\""
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_gitmodules",
          "args": [
            "repo",
            "GITMODULES_CREATE"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "open_gitmodules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1862-1889",
          "snippet": "static git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_MODULES_FILE \".gitmodules\""
          ],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_root",
          "args": [
            "path"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "238-263",
          "snippet": "int git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_root(const char *path)\n{\n\tint offset = 0;\n\n\t/* Does the root of the path look like a windows drive ? */\n\tif (LOOKS_LIKE_DRIVE_PREFIX(path))\n\t\toffset += 2;\n\n#ifdef GIT_WIN32\n\t/* Are we dealing with a windows network path? */\n\telse if ((path[0] == '/' && path[1] == '/' && path[2] != '/') ||\n\t\t(path[0] == '\\\\' && path[1] == '\\\\' && path[2] != '\\\\'))\n\t{\n\t\toffset += 2;\n\n\t\t/* Skip the computer name segment */\n\t\twhile (path[offset] && path[offset] != '/' && path[offset] != '\\\\')\n\t\t\toffset++;\n\t}\n#endif\n\n\tif (path[offset] == '/' || path[offset] == '\\\\')\n\t\treturn offset;\n\n\treturn -1;\t/* Not a real error - signals that path is not rooted */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "git_repository_workdir(repo)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "path",
            "git_repository_workdir(repo)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"Attempt to add submodule '%s' that already exists\"",
            "path"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && url && path"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_add_setup(\n\tgit_submodule **out,\n\tgit_repository *repo,\n\tconst char *url,\n\tconst char *path,\n\tint use_gitlink)\n{\n\tint error = 0;\n\tgit_config_backend *mods = NULL;\n\tgit_submodule *sm = NULL;\n\tgit_buf name = GIT_BUF_INIT, real_url = GIT_BUF_INIT;\n\tgit_repository *subrepo = NULL;\n\n\tassert(repo && url && path);\n\n\t/* see if there is already an entry for this submodule */\n\n\tif (git_submodule_lookup(NULL, repo, path) < 0)\n\t\tgiterr_clear();\n\telse {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Attempt to add submodule '%s' that already exists\", path);\n\t\treturn GIT_EEXISTS;\n\t}\n\n\t/* validate and normalize path */\n\n\tif (git__prefixcmp(path, git_repository_workdir(repo)) == 0)\n\t\tpath += strlen(git_repository_workdir(repo));\n\n\tif (git_path_root(path) >= 0) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Submodule path must be a relative path\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\t/* update .gitmodules */\n\n\tif (!(mods = open_gitmodules(repo, GITMODULES_CREATE))) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Adding submodules to a bare repository is not supported\");\n\t\treturn -1;\n\t}\n\n\tif ((error = git_buf_printf(&name, \"submodule.%s.path\", path)) < 0 ||\n\t\t(error = git_config_file_set_string(mods, name.ptr, path)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = submodule_config_key_trunc_puts(&name, \"url\")) < 0 ||\n\t\t(error = git_config_file_set_string(mods, name.ptr, url)) < 0)\n\t\tgoto cleanup;\n\n\tgit_buf_clear(&name);\n\n\t/* init submodule repository and add origin remote as needed */\n\n\terror = git_buf_joinpath(&name, git_repository_workdir(repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* if the repo does not already exist, then init a new repo and add it.\n\t * Otherwise, just add the existing repo.\n\t */\n\tif (!(git_path_exists(name.ptr) &&\n\t\tgit_path_contains(&name, DOT_GIT))) {\n\n\t\t/* resolve the actual URL to use */\n\t\tif ((error = git_submodule_resolve_url(&real_url, repo, url)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t if ((error = submodule_repo_init(&subrepo, repo, path, real_url.ptr, use_gitlink)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_submodule_lookup(&sm, repo, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_submodule_init(sm, false);\n\ncleanup:\n\tif (error && sm) {\n\t\tgit_submodule_free(sm);\n\t\tsm = NULL;\n\t}\n\tif (out != NULL)\n\t\t*out = sm;\n\n\tgit_config_file_free(mods);\n\tgit_repository_free(subrepo);\n\tgit_buf_free(&real_url);\n\tgit_buf_free(&name);\n\n\treturn error;\n}"
  },
  {
    "function_name": "submodule_repo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "549-597",
    "snippet": "static int submodule_repo_init(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path,\n\tconst char *url,\n\tbool use_gitlink)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.flags = GIT_REPOSITORY_INIT_MKPATH | GIT_REPOSITORY_INIT_NO_REINIT;\n\tinitopt.origin_url = url;\n\n\t/* init submodule repository and add origin remote as needed */\n\n\t/* New style: sub-repo goes in <repo-dir>/modules/<name>/ with a\n\t * gitlink in the sub-repo workdir directory to that repository\n\t *\n\t * Old style: sub-repo goes directly into repo/<name>/.git/\n\t */\n\t if (use_gitlink) {\n\t\terror = git_buf_join3(\n\t\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitopt.workdir_path = workdir.ptr;\n\t\tinitopt.flags |=\n\t\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\t} else\n\t\terror = git_repository_init_ext(&subrepo, workdir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&repodir"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_init_ext",
          "args": [
            "&subrepo",
            "workdir.ptr",
            "&initopt"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_init_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1665-1720",
          "snippet": "int git_repository_init_ext(\n\tgit_repository **out,\n\tconst char *given_repo,\n\tgit_repository_init_options *opts)\n{\n\tint error;\n\tgit_buf repo_path = GIT_BUF_INIT, wd_path = GIT_BUF_INIT;\n\tconst char *wd;\n\n\tassert(out && given_repo && opts);\n\n\tGITERR_CHECK_VERSION(opts, GIT_REPOSITORY_INIT_OPTIONS_VERSION, \"git_repository_init_options\");\n\n\terror = repo_init_directories(&repo_path, &wd_path, given_repo, opts);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\twd = (opts->flags & GIT_REPOSITORY_INIT_BARE) ? NULL : git_buf_cstr(&wd_path);\n\tif (valid_repository_path(&repo_path)) {\n\n\t\tif ((opts->flags & GIT_REPOSITORY_INIT_NO_REINIT) != 0) {\n\t\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\t\"Attempt to reinitialize '%s'\", given_repo);\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\topts->flags |= GIT_REPOSITORY_INIT__IS_REINIT;\n\n\t\terror = repo_init_config(\n\t\t\trepo_path.ptr, wd, opts->flags, opts->mode);\n\n\t\t/* TODO: reinitialize the templates */\n\t}\n\telse {\n\t\tif (!(error = repo_init_structure(\n\t\t\t\trepo_path.ptr, wd, opts)) &&\n\t\t\t!(error = repo_init_config(\n\t\t\t\trepo_path.ptr, wd, opts->flags, opts->mode)))\n\t\t\terror = repo_init_create_head(\n\t\t\t\trepo_path.ptr, opts->initial_head);\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_open(out, repo_path.ptr);\n\n\tif (!error && opts->origin_url)\n\t\terror = repo_init_create_origin(*out, opts->origin_url);\n\ncleanup:\n\tgit_buf_free(&repo_path);\n\tgit_buf_free(&wd_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_init_ext(\n\tgit_repository **out,\n\tconst char *given_repo,\n\tgit_repository_init_options *opts)\n{\n\tint error;\n\tgit_buf repo_path = GIT_BUF_INIT, wd_path = GIT_BUF_INIT;\n\tconst char *wd;\n\n\tassert(out && given_repo && opts);\n\n\tGITERR_CHECK_VERSION(opts, GIT_REPOSITORY_INIT_OPTIONS_VERSION, \"git_repository_init_options\");\n\n\terror = repo_init_directories(&repo_path, &wd_path, given_repo, opts);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\twd = (opts->flags & GIT_REPOSITORY_INIT_BARE) ? NULL : git_buf_cstr(&wd_path);\n\tif (valid_repository_path(&repo_path)) {\n\n\t\tif ((opts->flags & GIT_REPOSITORY_INIT_NO_REINIT) != 0) {\n\t\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\t\"Attempt to reinitialize '%s'\", given_repo);\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\topts->flags |= GIT_REPOSITORY_INIT__IS_REINIT;\n\n\t\terror = repo_init_config(\n\t\t\trepo_path.ptr, wd, opts->flags, opts->mode);\n\n\t\t/* TODO: reinitialize the templates */\n\t}\n\telse {\n\t\tif (!(error = repo_init_structure(\n\t\t\t\trepo_path.ptr, wd, opts)) &&\n\t\t\t!(error = repo_init_config(\n\t\t\t\trepo_path.ptr, wd, opts->flags, opts->mode)))\n\t\t\terror = repo_init_create_head(\n\t\t\t\trepo_path.ptr, opts->initial_head);\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = git_repository_open(out, repo_path.ptr);\n\n\tif (!error && opts->origin_url)\n\t\terror = repo_init_create_origin(*out, opts->origin_url);\n\ncleanup:\n\tgit_buf_free(&repo_path);\n\tgit_buf_free(&wd_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join3",
          "args": [
            "&repodir",
            "'/'",
            "git_repository_path(parent_repo)",
            "\"modules\"",
            "path"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "657-716",
          "snippet": "int git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "parent_repo"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&workdir",
            "git_repository_workdir(parent_repo)",
            "path"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "parent_repo"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic int submodule_repo_init(\n\tgit_repository **out,\n\tgit_repository *parent_repo,\n\tconst char *path,\n\tconst char *url,\n\tbool use_gitlink)\n{\n\tint error = 0;\n\tgit_buf workdir = GIT_BUF_INIT, repodir = GIT_BUF_INIT;\n\tgit_repository_init_options initopt = GIT_REPOSITORY_INIT_OPTIONS_INIT;\n\tgit_repository *subrepo = NULL;\n\n\terror = git_buf_joinpath(&workdir, git_repository_workdir(parent_repo), path);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tinitopt.flags = GIT_REPOSITORY_INIT_MKPATH | GIT_REPOSITORY_INIT_NO_REINIT;\n\tinitopt.origin_url = url;\n\n\t/* init submodule repository and add origin remote as needed */\n\n\t/* New style: sub-repo goes in <repo-dir>/modules/<name>/ with a\n\t * gitlink in the sub-repo workdir directory to that repository\n\t *\n\t * Old style: sub-repo goes directly into repo/<name>/.git/\n\t */\n\t if (use_gitlink) {\n\t\terror = git_buf_join3(\n\t\t\t&repodir, '/', git_repository_path(parent_repo), \"modules\", path);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\n\t\tinitopt.workdir_path = workdir.ptr;\n\t\tinitopt.flags |=\n\t\t\tGIT_REPOSITORY_INIT_NO_DOTGIT_DIR |\n\t\t\tGIT_REPOSITORY_INIT_RELATIVE_GITLINK;\n\n\t\terror = git_repository_init_ext(&subrepo, repodir.ptr, &initopt);\n\t} else\n\t\terror = git_repository_init_ext(&subrepo, workdir.ptr, &initopt);\n\ncleanup:\n\tgit_buf_free(&workdir);\n\tgit_buf_free(&repodir);\n\n\t*out = subrepo;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_submodule_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "497-547",
    "snippet": "int git_submodule_foreach(\n\tgit_repository *repo,\n\tgit_submodule_cb callback,\n\tvoid *payload)\n{\n\tgit_vector snapshot = GIT_VECTOR_INIT;\n\tgit_strmap *submodules;\n\tgit_submodule *sm;\n\tint error;\n\tsize_t i;\n\n\tif ((error = git_strmap_alloc(&submodules)) < 0)\n\t\treturn error;\n\n\tif ((error = all_submodules(repo, submodules)) < 0)\n\t\tgoto done;\n\n\tif (!(error = git_vector_init(\n\t\t\t&snapshot, kh_size(submodules), submodule_cmp))) {\n\n\t\tgit_strmap_foreach_value(submodules, sm, {\n\t\t\tif ((error = git_vector_insert(&snapshot, sm)) < 0)\n\t\t\t\tbreak;\n\t\t\tGIT_REFCOUNT_INC(sm);\n\t\t});\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tgit_vector_uniq(&snapshot, submodule_free_dup);\n\n\tgit_vector_foreach(&snapshot, i, sm) {\n\t\tif ((error = callback(sm, sm->name, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tgit_vector_foreach(&snapshot, i, sm)\n\t\tgit_submodule_free(sm);\n\tgit_vector_free(&snapshot);\n\n\tgit_strmap_foreach_value(submodules, sm, {\n\t\tgit_submodule_free(sm);\n\t});\n\tgit_strmap_free(submodules);\n\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_each(const git_config_entry *entry, void *payload);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_strmap_free",
          "args": [
            "submodules"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_foreach_value",
          "args": [
            "submodules",
            "sm",
            "{\n\t\tgit_submodule_free(sm);\n\t}"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&snapshot"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&snapshot",
            "i",
            "sm"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "sm",
            "sm->name",
            "payload"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "git_packbuilder_set_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack-objects.c",
          "lines": "1715-1724",
          "snippet": "int git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)\n{\n\tif (!pb)\n\t\treturn -1;\n\n\tpb->progress_cb = progress_cb;\n\tpb->progress_cb_payload = progress_cb_payload;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/config.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/tag.h\"",
            "#include \"git2/commit.h\"",
            "#include \"git2/pack.h\"",
            "#include \"commit_list.h\"",
            "#include \"revwalk.h\"",
            "#include \"util.h\"",
            "#include \"tree.h\"",
            "#include \"thread-utils.h\"",
            "#include \"pack.h\"",
            "#include \"netops.h\"",
            "#include \"iterator.h\"",
            "#include \"delta.h\"",
            "#include \"zstream.h\"",
            "#include \"pack-objects.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n#include \"git2/indexer.h\"\n#include \"git2/tag.h\"\n#include \"git2/commit.h\"\n#include \"git2/pack.h\"\n#include \"commit_list.h\"\n#include \"revwalk.h\"\n#include \"util.h\"\n#include \"tree.h\"\n#include \"thread-utils.h\"\n#include \"pack.h\"\n#include \"netops.h\"\n#include \"iterator.h\"\n#include \"delta.h\"\n#include \"zstream.h\"\n#include \"pack-objects.h\"\n\nint git_packbuilder_set_callbacks(git_packbuilder *pb, git_packbuilder_progress progress_cb, void *progress_cb_payload)\n{\n\tif (!pb)\n\t\treturn -1;\n\n\tpb->progress_cb = progress_cb;\n\tpb->progress_cb_payload = progress_cb_payload;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&snapshot",
            "i",
            "sm"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_uniq",
          "args": [
            "&snapshot",
            "submodule_free_dup"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_uniq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "258-279",
          "snippet": "void git_vector_uniq(git_vector *v, void  (*git_free_cb)(void *))\n{\n\tgit_vector_cmp cmp;\n\tsize_t i, j;\n\n\tif (v->length <= 1)\n\t\treturn;\n\n\tgit_vector_sort(v);\n\tcmp = v->_cmp ? v->_cmp : strict_comparison;\n\n\tfor (i = 0, j = 1 ; j < v->length; ++j)\n\t\tif (!cmp(v->contents[i], v->contents[j])) {\n\t\t\tif (git_free_cb)\n\t\t\t\tgit_free_cb(v->contents[i]);\n\n\t\t\tv->contents[i] = v->contents[j];\n\t\t} else\n\t\t\tv->contents[++i] = v->contents[j];\n\n\tv->length -= j - i - 1;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_uniq(git_vector *v, void  (*git_free_cb)(void *))\n{\n\tgit_vector_cmp cmp;\n\tsize_t i, j;\n\n\tif (v->length <= 1)\n\t\treturn;\n\n\tgit_vector_sort(v);\n\tcmp = v->_cmp ? v->_cmp : strict_comparison;\n\n\tfor (i = 0, j = 1 ; j < v->length; ++j)\n\t\tif (!cmp(v->contents[i], v->contents[j])) {\n\t\t\tif (git_free_cb)\n\t\t\t\tgit_free_cb(v->contents[i]);\n\n\t\t\tv->contents[i] = v->contents[j];\n\t\t} else\n\t\t\tv->contents[++i] = v->contents[j];\n\n\tv->length -= j - i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_foreach_value",
          "args": [
            "submodules",
            "sm",
            "{\n\t\t\tif ((error = git_vector_insert(&snapshot, sm)) < 0)\n\t\t\t\tbreak;\n\t\t\tGIT_REFCOUNT_INC(sm);\n\t\t}"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "sm"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&snapshot",
            "sm"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&snapshot",
            "kh_size(submodules)",
            "submodule_cmp"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_size",
          "args": [
            "submodules"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "all_submodules",
          "args": [
            "repo",
            "submodules"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "all_submodules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "418-495",
          "snippet": "static int all_submodules(git_repository *repo, git_strmap *map)\n{\n\tint error = 0;\n\tgit_index *idx = NULL;\n\tgit_tree *head = NULL;\n\tconst char *wd = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_submodule *sm;\n\tgit_config *mods = NULL;\n\tuint32_t mask;\n\n\tassert(repo && map);\n\n\t/* get sources that we will need to check */\n\tif (git_repository_index(&idx, repo) < 0)\n\t\tgiterr_clear();\n\tif (git_repository_head_tree(&head, repo) < 0)\n\t\tgiterr_clear();\n\n\twd = git_repository_workdir(repo);\n\tif (wd && (error = git_buf_joinpath(&path, wd, GIT_MODULES_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* clear submodule flags that are to be refreshed */\n\tmask = 0;\n\tmask |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\tGIT_SUBMODULE_STATUS__INDEX_FLAGS |\n\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID |\n\t\tGIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\n\tmask |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\tmask |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\tif (mask != 0)\n\t\tmask |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS__WD_FLAGS |\n\t\t\tGIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\t/* add submodule information from .gitmodules */\n\tif (wd) {\n\t\tlfc_data data = { 0 };\n\t\tdata.map = map;\n\t\tdata.repo = repo;\n\n\t\tif ((mods = gitmodules_snapshot(repo)) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tdata.mods = mods;\n\t\tif ((error = git_config_foreach(\n\t\t\t    mods, submodule_load_each, &data)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add back submodule information from index */\n\tif (idx) {\n\t\tif ((error = submodules_from_index(map, idx, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add submodule information from HEAD */\n\tif (head) {\n\t\tif ((error = submodules_from_head(map, head, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* shallow scan submodules in work tree as needed */\n\tif (wd && mask != 0) {\n\t\tgit_strmap_foreach_value(map, sm, {\n\t\t\t\tsubmodule_load_from_wd_lite(sm);\n\t\t\t});\n\t}\n\ncleanup:\n\tgit_config_free(mods);\n\t/* TODO: if we got an error, mark submodule config as invalid? */\n\tgit_index_free(idx);\n\tgit_tree_free(head);\n\tgit_buf_free(&path);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_MODULES_FILE \".gitmodules\""
          ],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int all_submodules(git_repository *repo, git_strmap *map)\n{\n\tint error = 0;\n\tgit_index *idx = NULL;\n\tgit_tree *head = NULL;\n\tconst char *wd = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_submodule *sm;\n\tgit_config *mods = NULL;\n\tuint32_t mask;\n\n\tassert(repo && map);\n\n\t/* get sources that we will need to check */\n\tif (git_repository_index(&idx, repo) < 0)\n\t\tgiterr_clear();\n\tif (git_repository_head_tree(&head, repo) < 0)\n\t\tgiterr_clear();\n\n\twd = git_repository_workdir(repo);\n\tif (wd && (error = git_buf_joinpath(&path, wd, GIT_MODULES_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* clear submodule flags that are to be refreshed */\n\tmask = 0;\n\tmask |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\tGIT_SUBMODULE_STATUS__INDEX_FLAGS |\n\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID |\n\t\tGIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\n\tmask |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\tmask |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\tif (mask != 0)\n\t\tmask |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS__WD_FLAGS |\n\t\t\tGIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\t/* add submodule information from .gitmodules */\n\tif (wd) {\n\t\tlfc_data data = { 0 };\n\t\tdata.map = map;\n\t\tdata.repo = repo;\n\n\t\tif ((mods = gitmodules_snapshot(repo)) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tdata.mods = mods;\n\t\tif ((error = git_config_foreach(\n\t\t\t    mods, submodule_load_each, &data)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add back submodule information from index */\n\tif (idx) {\n\t\tif ((error = submodules_from_index(map, idx, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add submodule information from HEAD */\n\tif (head) {\n\t\tif ((error = submodules_from_head(map, head, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* shallow scan submodules in work tree as needed */\n\tif (wd && mask != 0) {\n\t\tgit_strmap_foreach_value(map, sm, {\n\t\t\t\tsubmodule_load_from_wd_lite(sm);\n\t\t\t});\n\t}\n\ncleanup:\n\tgit_config_free(mods);\n\t/* TODO: if we got an error, mark submodule config as invalid? */\n\tgit_index_free(idx);\n\tgit_tree_free(head);\n\tgit_buf_free(&path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_alloc",
          "args": [
            "&submodules"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_each(const git_config_entry *entry, void *payload);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_foreach(\n\tgit_repository *repo,\n\tgit_submodule_cb callback,\n\tvoid *payload)\n{\n\tgit_vector snapshot = GIT_VECTOR_INIT;\n\tgit_strmap *submodules;\n\tgit_submodule *sm;\n\tint error;\n\tsize_t i;\n\n\tif ((error = git_strmap_alloc(&submodules)) < 0)\n\t\treturn error;\n\n\tif ((error = all_submodules(repo, submodules)) < 0)\n\t\tgoto done;\n\n\tif (!(error = git_vector_init(\n\t\t\t&snapshot, kh_size(submodules), submodule_cmp))) {\n\n\t\tgit_strmap_foreach_value(submodules, sm, {\n\t\t\tif ((error = git_vector_insert(&snapshot, sm)) < 0)\n\t\t\t\tbreak;\n\t\t\tGIT_REFCOUNT_INC(sm);\n\t\t});\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tgit_vector_uniq(&snapshot, submodule_free_dup);\n\n\tgit_vector_foreach(&snapshot, i, sm) {\n\t\tif ((error = callback(sm, sm->name, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\tgit_vector_foreach(&snapshot, i, sm)\n\t\tgit_submodule_free(sm);\n\tgit_vector_free(&snapshot);\n\n\tgit_strmap_foreach_value(submodules, sm, {\n\t\tgit_submodule_free(sm);\n\t});\n\tgit_strmap_free(submodules);\n\n\treturn error;\n}"
  },
  {
    "function_name": "all_submodules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "418-495",
    "snippet": "static int all_submodules(git_repository *repo, git_strmap *map)\n{\n\tint error = 0;\n\tgit_index *idx = NULL;\n\tgit_tree *head = NULL;\n\tconst char *wd = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_submodule *sm;\n\tgit_config *mods = NULL;\n\tuint32_t mask;\n\n\tassert(repo && map);\n\n\t/* get sources that we will need to check */\n\tif (git_repository_index(&idx, repo) < 0)\n\t\tgiterr_clear();\n\tif (git_repository_head_tree(&head, repo) < 0)\n\t\tgiterr_clear();\n\n\twd = git_repository_workdir(repo);\n\tif (wd && (error = git_buf_joinpath(&path, wd, GIT_MODULES_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* clear submodule flags that are to be refreshed */\n\tmask = 0;\n\tmask |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\tGIT_SUBMODULE_STATUS__INDEX_FLAGS |\n\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID |\n\t\tGIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\n\tmask |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\tmask |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\tif (mask != 0)\n\t\tmask |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS__WD_FLAGS |\n\t\t\tGIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\t/* add submodule information from .gitmodules */\n\tif (wd) {\n\t\tlfc_data data = { 0 };\n\t\tdata.map = map;\n\t\tdata.repo = repo;\n\n\t\tif ((mods = gitmodules_snapshot(repo)) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tdata.mods = mods;\n\t\tif ((error = git_config_foreach(\n\t\t\t    mods, submodule_load_each, &data)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add back submodule information from index */\n\tif (idx) {\n\t\tif ((error = submodules_from_index(map, idx, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add submodule information from HEAD */\n\tif (head) {\n\t\tif ((error = submodules_from_head(map, head, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* shallow scan submodules in work tree as needed */\n\tif (wd && mask != 0) {\n\t\tgit_strmap_foreach_value(map, sm, {\n\t\t\t\tsubmodule_load_from_wd_lite(sm);\n\t\t\t});\n\t}\n\ncleanup:\n\tgit_config_free(mods);\n\t/* TODO: if we got an error, mark submodule config as invalid? */\n\tgit_index_free(idx);\n\tgit_tree_free(head);\n\tgit_buf_free(&path);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_MODULES_FILE \".gitmodules\""
    ],
    "globals_used": [
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "head"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "idx"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "mods"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_foreach_value",
          "args": [
            "map",
            "sm",
            "{\n\t\t\t\tsubmodule_load_from_wd_lite(sm);\n\t\t\t}"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submodule_load_from_wd_lite",
          "args": [
            "sm"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_load_from_wd_lite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1816-1831",
          "snippet": "static int submodule_load_from_wd_lite(git_submodule *sm)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&path, git_repository_workdir(sm->repo), sm->path) < 0)\n\t\treturn -1;\n\n\tif (git_path_isdir(path.ptr))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\tif (git_path_contains(&path, DOT_GIT))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD;\n\n\tgit_buf_free(&path);\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_load_from_wd_lite(git_submodule *sm)\n{\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&path, git_repository_workdir(sm->repo), sm->path) < 0)\n\t\treturn -1;\n\n\tif (git_path_isdir(path.ptr))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__WD_SCANNED;\n\n\tif (git_path_contains(&path, DOT_GIT))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_WD;\n\n\tgit_buf_free(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodules_from_head",
          "args": [
            "map",
            "head",
            "mods"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "submodules_from_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "367-409",
          "snippet": "static int submodules_from_head(git_strmap *map, git_tree *head, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_tree(&i, head, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_head_data(sm, entry->mode, &entry->id);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_tree_owner(head), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_head_data(\n                                       sm, entry->mode, &entry->id);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic int submodules_from_head(git_strmap *map, git_tree *head, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_tree(&i, head, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_head_data(sm, entry->mode, &entry->id);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_tree_owner(head), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_head_data(\n                                       sm, entry->mode, &entry->id);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodules_from_index",
          "args": [
            "map",
            "idx",
            "mods"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "submodules_from_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "324-365",
          "snippet": "static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_index(&i, git_index_owner(idx), idx, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_index_entry(sm, entry);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_index_owner(idx), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_index_entry(sm, entry);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_index(&i, git_index_owner(idx), idx, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_index_entry(sm, entry);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_index_owner(idx), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_index_entry(sm, entry);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_foreach",
          "args": [
            "mods",
            "submodule_load_each",
            "&data"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "497-501",
          "snippet": "int git_config_foreach(\n\tconst git_config *cfg, git_config_foreach_cb cb, void *payload)\n{\n\treturn git_config_foreach_match(cfg, NULL, cb, payload);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_foreach(\n\tconst git_config *cfg, git_config_foreach_cb cb, void *payload)\n{\n\treturn git_config_foreach_match(cfg, NULL, cb, payload);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitmodules_snapshot",
          "args": [
            "repo"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "gitmodules_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1838-1860",
          "snippet": "static git_config *gitmodules_snapshot(git_repository *repo)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_config *mods = NULL, *snap = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (git_config_open_ondisk(&mods, path.ptr) < 0)\n\t\t\tmods = NULL;\n\t}\n\n\tgit_buf_free(&path);\n\n\tif (mods) {\n\t\tgit_config_snapshot(&snap, mods);\n\t\tgit_config_free(mods);\n\t}\n\n\treturn snap;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_MODULES_FILE \".gitmodules\""
          ],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config *gitmodules_snapshot(git_repository *repo)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_config *mods = NULL, *snap = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (git_config_open_ondisk(&mods, path.ptr) < 0)\n\t\t\tmods = NULL;\n\t}\n\n\tgit_buf_free(&path);\n\n\tif (mods) {\n\t\tgit_config_snapshot(&snap, mods);\n\t\tgit_config_free(mods);\n\t}\n\n\treturn snap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "wd",
            "GIT_MODULES_FILE"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&head",
            "repo"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&idx",
            "repo"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && map"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int all_submodules(git_repository *repo, git_strmap *map)\n{\n\tint error = 0;\n\tgit_index *idx = NULL;\n\tgit_tree *head = NULL;\n\tconst char *wd = NULL;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_submodule *sm;\n\tgit_config *mods = NULL;\n\tuint32_t mask;\n\n\tassert(repo && map);\n\n\t/* get sources that we will need to check */\n\tif (git_repository_index(&idx, repo) < 0)\n\t\tgiterr_clear();\n\tif (git_repository_head_tree(&head, repo) < 0)\n\t\tgiterr_clear();\n\n\twd = git_repository_workdir(repo);\n\tif (wd && (error = git_buf_joinpath(&path, wd, GIT_MODULES_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* clear submodule flags that are to be refreshed */\n\tmask = 0;\n\tmask |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\tGIT_SUBMODULE_STATUS__INDEX_FLAGS |\n\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID |\n\t\tGIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\n\tmask |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\tmask |= GIT_SUBMODULE_STATUS_IN_CONFIG;\n\tif (mask != 0)\n\t\tmask |= GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\tGIT_SUBMODULE_STATUS__WD_SCANNED |\n\t\t\tGIT_SUBMODULE_STATUS__WD_FLAGS |\n\t\t\tGIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\t/* add submodule information from .gitmodules */\n\tif (wd) {\n\t\tlfc_data data = { 0 };\n\t\tdata.map = map;\n\t\tdata.repo = repo;\n\n\t\tif ((mods = gitmodules_snapshot(repo)) == NULL)\n\t\t\tgoto cleanup;\n\n\t\tdata.mods = mods;\n\t\tif ((error = git_config_foreach(\n\t\t\t    mods, submodule_load_each, &data)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add back submodule information from index */\n\tif (idx) {\n\t\tif ((error = submodules_from_index(map, idx, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* add submodule information from HEAD */\n\tif (head) {\n\t\tif ((error = submodules_from_head(map, head, mods)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\t/* shallow scan submodules in work tree as needed */\n\tif (wd && mask != 0) {\n\t\tgit_strmap_foreach_value(map, sm, {\n\t\t\t\tsubmodule_load_from_wd_lite(sm);\n\t\t\t});\n\t}\n\ncleanup:\n\tgit_config_free(mods);\n\t/* TODO: if we got an error, mark submodule config as invalid? */\n\tgit_index_free(idx);\n\tgit_tree_free(head);\n\tgit_buf_free(&path);\n\treturn error;\n}"
  },
  {
    "function_name": "submodules_from_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "367-409",
    "snippet": "static int submodules_from_head(git_strmap *map, git_tree *head, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_tree(&i, head, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_head_data(sm, entry->mode, &entry->id);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_tree_owner(head), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_head_data(\n                                       sm, entry->mode, &entry->id);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);",
      "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "i"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_update_from_head_data",
          "args": [
            "sm",
            "entry->mode",
            "&entry->id"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_from_head_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1393-1404",
          "snippet": "static void submodule_update_from_head_data(\n\tgit_submodule *sm, mode_t mode, const git_oid *id)\n{\n\tif (!S_ISGITLINK(mode))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n\telse {\n\t\tgit_oid_cpy(&sm->head_oid, id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\t}\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic void submodule_update_from_head_data(\n\tgit_submodule *sm, mode_t mode, const git_oid *id)\n{\n\tif (!S_ISGITLINK(mode))\n\t\tsm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n\telse {\n\t\tgit_oid_cpy(&sm->head_oid, id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_HEAD |\n\t\t\tGIT_SUBMODULE_STATUS__HEAD_OID_VALID;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_get_or_create",
          "args": [
            "&sm",
            "git_tree_owner(head)",
            "map",
            "name.ptr ? name.ptr : entry->path"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_get_or_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "292-322",
          "snippet": "static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tgit_submodule *sm = NULL;\n\n\tpos = git_strmap_lookup_index(map, name);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\tsm = git_strmap_value_at(map, pos);\n\t\tgoto done;\n\t}\n\n\t/* if the submodule doesn't exist yet in the map, create it */\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tpos = kh_put(str, map, sm->name, &error);\n\t/* nobody can beat us to adding it */\n\tassert(error != 0);\n\tif (error < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tgit_strmap_set_value_at(map, pos, sm);\n\ndone:\n\tGIT_REFCOUNT_INC(sm);\n\t*out = sm;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tgit_submodule *sm = NULL;\n\n\tpos = git_strmap_lookup_index(map, name);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\tsm = git_strmap_value_at(map, pos);\n\t\tgoto done;\n\t}\n\n\t/* if the submodule doesn't exist yet in the map, create it */\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tpos = kh_put(str, map, sm->name, &error);\n\t/* nobody can beat us to adding it */\n\tassert(error != 0);\n\tif (error < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tgit_strmap_set_value_at(map, pos, sm);\n\ndone:\n\tGIT_REFCOUNT_INC(sm);\n\t*out = sm;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "head"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "entry->mode"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "entry->mode"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "map",
            "pos"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "map",
            "pos"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "map",
            "name.ptr"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_from_path",
          "args": [
            "&name",
            "cfg",
            "entry->path"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "name_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "153-185",
          "snippet": "static int name_from_path(git_buf *out, git_config *cfg, const char *path)\n{\n\tconst char *key = \"submodule\\\\..*\\\\.path\";\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\tint error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *fdot, *ldot;\n\t\t/* TODO: this should maybe be strcasecmp on a case-insensitive fs */\n\t\tif (strcmp(path, entry->value) != 0)\n\t\t\tcontinue;\n\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\n\t\tgit_buf_clear(out);\n\t\tgit_buf_put(out, fdot + 1, ldot - fdot - 1);\n\t\tgoto cleanup;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"could not find a submodule name for '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tgit_config_iterator_free(iter);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\n\nstatic int name_from_path(git_buf *out, git_config *cfg, const char *path)\n{\n\tconst char *key = \"submodule\\\\..*\\\\.path\";\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\tint error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *fdot, *ldot;\n\t\t/* TODO: this should maybe be strcasecmp on a case-insensitive fs */\n\t\tif (strcmp(path, entry->value) != 0)\n\t\t\tcontinue;\n\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\n\t\tgit_buf_clear(out);\n\t\tgit_buf_put(out, fdot + 1, ldot - fdot - 1);\n\t\tgoto cleanup;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"could not find a submodule name for '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tgit_config_iterator_free(iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&name"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "map",
            "entry->path"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "&entry",
            "i"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&i",
            "head",
            "NULL"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic int submodules_from_head(git_strmap *map, git_tree *head, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_tree(&i, head, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_head_data(sm, entry->mode, &entry->id);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__HEAD_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_tree_owner(head), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_head_data(\n                                       sm, entry->mode, &entry->id);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}"
  },
  {
    "function_name": "submodules_from_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "324-365",
    "snippet": "static int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_index(&i, git_index_owner(idx), idx, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_index_entry(sm, entry);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_index_owner(idx), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_index_entry(sm, entry);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "i"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_update_from_index_entry",
          "args": [
            "sm",
            "entry"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_update_from_index_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1354-1371",
          "snippet": "static void submodule_update_from_index_entry(\n\tgit_submodule *sm, const git_index_entry *ie)\n{\n\tbool already_found = (sm->flags & GIT_SUBMODULE_STATUS_IN_INDEX) != 0;\n\n\tif (!S_ISGITLINK(ie->mode)) {\n\t\tif (!already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n\t} else {\n\t\tif (already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\t\telse\n\t\t\tgit_oid_cpy(&sm->index_oid, &ie->id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID;\n\t}\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_index_entry(git_submodule *sm, const git_index_entry *ie);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nstatic void submodule_update_from_index_entry(\n\tgit_submodule *sm, const git_index_entry *ie)\n{\n\tbool already_found = (sm->flags & GIT_SUBMODULE_STATUS_IN_INDEX) != 0;\n\n\tif (!S_ISGITLINK(ie->mode)) {\n\t\tif (!already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n\t} else {\n\t\tif (already_found)\n\t\t\tsm->flags |= GIT_SUBMODULE_STATUS__INDEX_MULTIPLE_ENTRIES;\n\t\telse\n\t\t\tgit_oid_cpy(&sm->index_oid, &ie->id);\n\n\t\tsm->flags |= GIT_SUBMODULE_STATUS_IN_INDEX |\n\t\t\tGIT_SUBMODULE_STATUS__INDEX_OID_VALID;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_get_or_create",
          "args": [
            "&sm",
            "git_index_owner(idx)",
            "map",
            "name.ptr ? name.ptr : entry->path"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_get_or_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "292-322",
          "snippet": "static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tgit_submodule *sm = NULL;\n\n\tpos = git_strmap_lookup_index(map, name);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\tsm = git_strmap_value_at(map, pos);\n\t\tgoto done;\n\t}\n\n\t/* if the submodule doesn't exist yet in the map, create it */\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tpos = kh_put(str, map, sm->name, &error);\n\t/* nobody can beat us to adding it */\n\tassert(error != 0);\n\tif (error < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tgit_strmap_set_value_at(map, pos, sm);\n\ndone:\n\tGIT_REFCOUNT_INC(sm);\n\t*out = sm;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tgit_submodule *sm = NULL;\n\n\tpos = git_strmap_lookup_index(map, name);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\tsm = git_strmap_value_at(map, pos);\n\t\tgoto done;\n\t}\n\n\t/* if the submodule doesn't exist yet in the map, create it */\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tpos = kh_put(str, map, sm->name, &error);\n\t/* nobody can beat us to adding it */\n\tassert(error != 0);\n\tif (error < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tgit_strmap_set_value_at(map, pos, sm);\n\ndone:\n\tGIT_REFCOUNT_INC(sm);\n\t*out = sm;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "idx"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "entry->mode"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "entry->mode"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "map",
            "pos"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "map",
            "pos"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "map",
            "name.ptr"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_from_path",
          "args": [
            "&name",
            "cfg",
            "entry->path"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "name_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "153-185",
          "snippet": "static int name_from_path(git_buf *out, git_config *cfg, const char *path)\n{\n\tconst char *key = \"submodule\\\\..*\\\\.path\";\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\tint error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *fdot, *ldot;\n\t\t/* TODO: this should maybe be strcasecmp on a case-insensitive fs */\n\t\tif (strcmp(path, entry->value) != 0)\n\t\t\tcontinue;\n\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\n\t\tgit_buf_clear(out);\n\t\tgit_buf_put(out, fdot + 1, ldot - fdot - 1);\n\t\tgoto cleanup;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"could not find a submodule name for '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tgit_config_iterator_free(iter);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static int submodule_read_config(git_submodule *sm, git_config *cfg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\n\nstatic int name_from_path(git_buf *out, git_config *cfg, const char *path)\n{\n\tconst char *key = \"submodule\\\\..*\\\\.path\";\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\tint error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *fdot, *ldot;\n\t\t/* TODO: this should maybe be strcasecmp on a case-insensitive fs */\n\t\tif (strcmp(path, entry->value) != 0)\n\t\t\tcontinue;\n\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\n\t\tgit_buf_clear(out);\n\t\tgit_buf_put(out, fdot + 1, ldot - fdot - 1);\n\t\tgoto cleanup;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"could not find a submodule name for '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tgit_config_iterator_free(iter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&name"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "map",
            "entry->path"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "&entry",
            "i"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&i",
            "git_index_owner(idx)",
            "idx",
            "NULL"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodules_from_index(git_strmap *map, git_index *idx, git_config *cfg)\n{\n       int error;\n       git_iterator *i;\n       const git_index_entry *entry;\n       git_buf name = GIT_BUF_INIT;\n\n       if ((error = git_iterator_for_index(&i, git_index_owner(idx), idx, NULL)) < 0)\n               return error;\n\n       while (!(error = git_iterator_advance(&entry, i))) {\n               khiter_t pos = git_strmap_lookup_index(map, entry->path);\n               git_submodule *sm;\n\n\t       git_buf_clear(&name);\n\t       if (!name_from_path(&name, cfg, entry->path)) {\n\t\t       git_strmap_lookup_index(map, name.ptr);\n\t       }\n\n               if (git_strmap_valid_index(map, pos)) {\n                       sm = git_strmap_value_at(map, pos);\n\n                       if (S_ISGITLINK(entry->mode))\n                               submodule_update_from_index_entry(sm, entry);\n                       else\n                               sm->flags |= GIT_SUBMODULE_STATUS__INDEX_NOT_SUBMODULE;\n               } else if (S_ISGITLINK(entry->mode)) {\n                       if (!submodule_get_or_create(&sm, git_index_owner(idx), map, name.ptr ? name.ptr : entry->path)) {\n                               submodule_update_from_index_entry(sm, entry);\n                               git_submodule_free(sm);\n                       }\n               }\n       }\n\n       if (error == GIT_ITEROVER)\n               error = 0;\n\n       git_buf_free(&name);\n       git_iterator_free(i);\n\n       return error;\n}"
  },
  {
    "function_name": "submodule_get_or_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "292-322",
    "snippet": "static int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tgit_submodule *sm = NULL;\n\n\tpos = git_strmap_lookup_index(map, name);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\tsm = git_strmap_value_at(map, pos);\n\t\tgoto done;\n\t}\n\n\t/* if the submodule doesn't exist yet in the map, create it */\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tpos = kh_put(str, map, sm->name, &error);\n\t/* nobody can beat us to adding it */\n\tassert(error != 0);\n\tif (error < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tgit_strmap_set_value_at(map, pos, sm);\n\ndone:\n\tGIT_REFCOUNT_INC(sm);\n\t*out = sm;\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "sm"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_set_value_at",
          "args": [
            "map",
            "pos",
            "sm"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "error != 0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_put",
          "args": [
            "str",
            "map",
            "sm->name",
            "&error"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submodule_alloc",
          "args": [
            "&sm",
            "repo",
            "name"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1562-1591",
          "snippet": "static int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_strmap_value_at",
          "args": [
            "map",
            "pos"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_valid_index",
          "args": [
            "map",
            "pos"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_strmap_lookup_index",
          "args": [
            "map",
            "name"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_get_or_create(git_submodule **out, git_repository *repo, git_strmap *map, const char *name)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tgit_submodule *sm = NULL;\n\n\tpos = git_strmap_lookup_index(map, name);\n\tif (git_strmap_valid_index(map, pos)) {\n\t\tsm = git_strmap_value_at(map, pos);\n\t\tgoto done;\n\t}\n\n\t/* if the submodule doesn't exist yet in the map, create it */\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tpos = kh_put(str, map, sm->name, &error);\n\t/* nobody can beat us to adding it */\n\tassert(error != 0);\n\tif (error < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tgit_strmap_set_value_at(map, pos, sm);\n\ndone:\n\tGIT_REFCOUNT_INC(sm);\n\t*out = sm;\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_free_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "287-290",
    "snippet": "static void submodule_free_dup(void *sm)\n{\n\tgit_submodule_free(sm);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic void submodule_free_dup(void *sm)\n{\n\tgit_submodule_free(sm);\n}"
  },
  {
    "function_name": "git_submodule_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "187-285",
    "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static git_config *gitmodules_snapshot(git_repository *repo);",
      "static int get_url_base(git_buf *url, git_repository *repo);",
      "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_set_lookup_error",
          "args": [
            "error",
            "name"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_set_lookup_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "120-128",
          "snippet": "static void submodule_set_lookup_error(int error, const char *name)\n{\n\tif (!error)\n\t\treturn;\n\n\tgiterr_set(GITERR_SUBMODULE, (error == GIT_ENOTFOUND) ?\n\t\t\"No submodule named '%s'\" :\n\t\t\"Submodule '%s' has not been added yet\", name);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\n\nstatic void submodule_set_lookup_error(int error, const char *name)\n{\n\tif (!error)\n\t\treturn;\n\n\tgiterr_set(GITERR_SUBMODULE, (error == GIT_ENOTFOUND) ?\n\t\t\"No submodule named '%s'\" :\n\t\t\"Submodule '%s' has not been added yet\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "path.ptr"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join3",
          "args": [
            "&path",
            "'/'",
            "git_repository_workdir(repo)",
            "name",
            "DOT_GIT"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "657-716",
          "snippet": "int git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_location",
          "args": [
            "&location",
            "sm"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1549-1555",
          "snippet": "int git_submodule_location(unsigned int *location, git_submodule *sm)\n{\n\tassert(location && sm);\n\n\treturn git_submodule__status(\n\t\tlocation, NULL, NULL, NULL, sm, GIT_SUBMODULE_IGNORE_ALL);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_location(unsigned int *location, git_submodule *sm)\n{\n\tassert(location && sm);\n\n\treturn git_submodule__status(\n\t\tlocation, NULL, NULL, NULL, sm, GIT_SUBMODULE_IGNORE_ALL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_reload",
          "args": [
            "sm",
            "false"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1427-1460",
          "snippet": "int git_submodule_reload(git_submodule *sm, int force)\n{\n\tint error = 0;\n\tgit_config *mods;\n\n\tGIT_UNUSED(force);\n\n\tassert(sm);\n\n\tif (!git_repository_is_bare(sm->repo)) {\n\t\t/* refresh config data */\n\t\tmods = gitmodules_snapshot(sm->repo);\n\t\tif (mods != NULL) {\n\t\t\terror = submodule_read_config(sm, mods);\n\t\t\tgit_config_free(mods);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* refresh wd data */\n\t\tsm->flags &=\n\t\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_FLAGS);\n\n\t\terror = submodule_load_from_wd_lite(sm);\n\t}\n\n\tif (error == 0 && (error = submodule_update_index(sm)) == 0)\n\t\terror = submodule_update_head(sm);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_reload(git_submodule *sm, int force)\n{\n\tint error = 0;\n\tgit_config *mods;\n\n\tGIT_UNUSED(force);\n\n\tassert(sm);\n\n\tif (!git_repository_is_bare(sm->repo)) {\n\t\t/* refresh config data */\n\t\tmods = gitmodules_snapshot(sm->repo);\n\t\tif (mods != NULL) {\n\t\t\terror = submodule_read_config(sm, mods);\n\t\t\tgit_config_free(mods);\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* refresh wd data */\n\t\tsm->flags &=\n\t\t\t~(GIT_SUBMODULE_STATUS_IN_WD |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_OID_VALID |\n\t\t\t  GIT_SUBMODULE_STATUS__WD_FLAGS);\n\n\t\terror = submodule_load_from_wd_lite(sm);\n\t}\n\n\tif (error == 0 && (error = submodule_update_index(sm)) == 0)\n\t\terror = submodule_update_head(sm);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&path"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sm->name"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_free",
          "args": [
            "mods"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "17-21",
          "snippet": "GIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(void) git_config_file_free(git_config_backend *cfg)\n{\n\tif (cfg)\n\t\tcfg->free(cfg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_file_foreach_match",
          "args": [
            "mods",
            "pattern",
            "find_by_path",
            "&data"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_file_foreach_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_file.h",
          "lines": "49-56",
          "snippet": "GIT_INLINE(int) git_config_file_foreach_match(\n\tgit_config_backend *cfg,\n\tconst char *regexp,\n\tint (*fn)(const git_config_entry *entry, void *data),\n\tvoid *data)\n{\n\treturn git_config_backend_foreach_match(cfg, regexp, fn, data);\n}",
          "includes": [
            "#include \"git2/config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/config.h\"\n\nGIT_INLINE(int) git_config_file_foreach_match(\n\tgit_config_backend *cfg,\n\tconst char *regexp,\n\tint (*fn)(const git_config_entry *entry, void *data),\n\tvoid *data)\n{\n\treturn git_config_backend_foreach_match(cfg, regexp, fn, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_gitmodules",
          "args": [
            "repo",
            "GITMODULES_EXISTING"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "open_gitmodules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1862-1889",
          "snippet": "static git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_MODULES_FILE \".gitmodules\""
          ],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\n#define GIT_MODULES_FILE \".gitmodules\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\n\nstatic git_config_backend *open_gitmodules(\n\tgit_repository *repo,\n\tint okay_to_create)\n{\n\tconst char *workdir = git_repository_workdir(repo);\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_config_backend *mods = NULL;\n\n\tif (workdir != NULL) {\n\t\tif (git_buf_joinpath(&path, workdir, GIT_MODULES_FILE) != 0)\n\t\t\treturn NULL;\n\n\t\tif (okay_to_create || git_path_isfile(path.ptr)) {\n\t\t\t/* git_config_file__ondisk should only fail if OOM */\n\t\t\tif (git_config_file__ondisk(&mods, path.ptr) < 0)\n\t\t\t\tmods = NULL;\n\t\t\t/* open should only fail here if the file is malformed */\n\t\t\telse if (git_config_file_open(mods, GIT_CONFIG_LEVEL_LOCAL) < 0) {\n\t\t\t\tgit_config_file_free(mods);\n\t\t\t\tmods = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\n\treturn mods;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&path",
            "name"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "submodule_alloc",
          "args": [
            "&sm",
            "repo",
            "name"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "submodule_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1562-1591",
          "snippet": "static int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_alloc(\n\tgit_submodule **out, git_repository *repo, const char *name)\n{\n\tsize_t namelen;\n\tgit_submodule *sm;\n\n\tif (!name || !(namelen = strlen(name))) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"Invalid submodule name\");\n\t\treturn -1;\n\t}\n\n\tsm = git__calloc(1, sizeof(git_submodule));\n\tGITERR_CHECK_ALLOC(sm);\n\n\tsm->name = sm->path = git__strdup(name);\n\tif (!sm->name) {\n\t\tgit__free(sm);\n\t\treturn -1;\n\t}\n\n\tGIT_REFCOUNT_INC(sm);\n\tsm->ignore = sm->ignore_default = GIT_SUBMODULE_IGNORE_NONE;\n\tsm->update = sm->update_default = GIT_SUBMODULE_UPDATE_CHECKOUT;\n\tsm->fetch_recurse = sm->fetch_recurse_default = GIT_SUBMODULE_RECURSE_NO;\n\tsm->repo   = repo;\n\tsm->branch = NULL;\n\n\t*out = sm;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && name"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "name_from_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "153-185",
    "snippet": "static int name_from_path(git_buf *out, git_config *cfg, const char *path)\n{\n\tconst char *key = \"submodule\\\\..*\\\\.path\";\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\tint error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *fdot, *ldot;\n\t\t/* TODO: this should maybe be strcasecmp on a case-insensitive fs */\n\t\tif (strcmp(path, entry->value) != 0)\n\t\t\tcontinue;\n\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\n\t\tgit_buf_clear(out);\n\t\tgit_buf_put(out, fdot + 1, ldot - fdot - 1);\n\t\tgoto cleanup;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"could not find a submodule name for '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tgit_config_iterator_free(iter);\n\treturn error;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_read_config(git_submodule *sm, git_config *cfg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_iterator_free",
          "args": [
            "iter"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1063-1069",
          "snippet": "void git_config_iterator_free(git_config_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_iterator_free(git_config_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "\"could not find a submodule name for '%s'\"",
            "path"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "out",
            "fdot + 1",
            "ldot - fdot - 1"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "out"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "entry->name",
            "'.'"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "entry->name",
            "'.'"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "path",
            "entry->value"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_next",
          "args": [
            "&entry",
            "iter"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "1058-1061",
          "snippet": "int git_config_next(git_config_entry **entry, git_config_iterator *iter)\n{\n\treturn iter->next(entry, iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_next(git_config_entry **entry, git_config_iterator *iter)\n{\n\treturn iter->next(entry, iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_iterator_glob_new",
          "args": [
            "&iter",
            "cfg",
            "key"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_iterator_glob_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "470-495",
          "snippet": "int git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)\n{\n\tall_iter *iter;\n\tint result;\n\n\tif (regexp == NULL)\n\t\treturn git_config_iterator_new(out, cfg);\n\n\titer = git__calloc(1, sizeof(all_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tif ((result = regcomp(&iter->regex, regexp, REG_EXTENDED)) != 0) {\n\t\tgiterr_set_regex(&iter->regex, result);\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\titer->parent.next = all_iter_glob_next;\n\titer->parent.free = all_iter_glob_free;\n\titer->i = cfg->files.length;\n\titer->cfg = cfg;\n\n\t*out = (git_config_iterator *) iter;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config_iterator_glob_new(git_config_iterator **out, const git_config *cfg, const char *regexp)\n{\n\tall_iter *iter;\n\tint result;\n\n\tif (regexp == NULL)\n\t\treturn git_config_iterator_new(out, cfg);\n\n\titer = git__calloc(1, sizeof(all_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tif ((result = regcomp(&iter->regex, regexp, REG_EXTENDED)) != 0) {\n\t\tgiterr_set_regex(&iter->regex, result);\n\t\tgit__free(iter);\n\t\treturn -1;\n\t}\n\n\titer->parent.next = all_iter_glob_next;\n\titer->parent.free = all_iter_glob_free;\n\titer->i = cfg->files.length;\n\titer->cfg = cfg;\n\n\t*out = (git_config_iterator *) iter;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_read_config(git_submodule *sm, git_config *cfg);\n\nstatic int name_from_path(git_buf *out, git_config *cfg, const char *path)\n{\n\tconst char *key = \"submodule\\\\..*\\\\.path\";\n\tgit_config_iterator *iter;\n\tgit_config_entry *entry;\n\tint error;\n\n\tif ((error = git_config_iterator_glob_new(&iter, cfg, key)) < 0)\n\t\treturn error;\n\n\twhile ((error = git_config_next(&entry, iter)) == 0) {\n\t\tconst char *fdot, *ldot;\n\t\t/* TODO: this should maybe be strcasecmp on a case-insensitive fs */\n\t\tif (strcmp(path, entry->value) != 0)\n\t\t\tcontinue;\n\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\n\t\tgit_buf_clear(out);\n\t\tgit_buf_put(out, fdot + 1, ldot - fdot - 1);\n\t\tgoto cleanup;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_set(GITERR_SUBMODULE, \"could not find a submodule name for '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\ncleanup:\n\tgit_config_iterator_free(iter);\n\treturn error;\n}"
  },
  {
    "function_name": "find_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "135-148",
    "snippet": "static int find_by_path(const git_config_entry *entry, void *payload)\n{\n\tfbp_data *data = payload;\n\n\tif (!strcmp(entry->value, data->path)) {\n\t\tconst char *fdot, *ldot;\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\t\tdata->name = git__strndup(fdot + 1, ldot - fdot - 1);\n\t\tGITERR_CHECK_ALLOC(data->name);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_load_each(const git_config_entry *entry, void *payload);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "data->name"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "fdot + 1",
            "ldot - fdot - 1"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "entry->name",
            "'.'"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "entry->name",
            "'.'"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry->value",
            "data->path"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_load_each(const git_config_entry *entry, void *payload);\n\nstatic int find_by_path(const git_config_entry *entry, void *payload)\n{\n\tfbp_data *data = payload;\n\n\tif (!strcmp(entry->value, data->path)) {\n\t\tconst char *fdot, *ldot;\n\t\tfdot = strchr(entry->name, '.');\n\t\tldot = strrchr(entry->name, '.');\n\t\tdata->name = git__strndup(fdot + 1, ldot - fdot - 1);\n\t\tGITERR_CHECK_ALLOC(data->name);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "submodule_set_lookup_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "120-128",
    "snippet": "static void submodule_set_lookup_error(int error, const char *name)\n{\n\tif (!error)\n\t\treturn;\n\n\tgiterr_set(GITERR_SUBMODULE, (error == GIT_ENOTFOUND) ?\n\t\t\"No submodule named '%s'\" :\n\t\t\"Submodule '%s' has not been added yet\", name);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SUBMODULE",
            "(error == GIT_ENOTFOUND) ?\n\t\t\"No submodule named '%s'\" :\n\t\t\"Submodule '%s' has not been added yet\"",
            "name"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\n\nstatic void submodule_set_lookup_error(int error, const char *name)\n{\n\tif (!error)\n\t\treturn;\n\n\tgiterr_set(GITERR_SUBMODULE, (error == GIT_ENOTFOUND) ?\n\t\t\"No submodule named '%s'\" :\n\t\t\"Submodule '%s' has not been added yet\", name);\n}"
  },
  {
    "function_name": "submodule_config_key_trunc_puts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "109-114",
    "snippet": "static int submodule_config_key_trunc_puts(git_buf *key, const char *suffix)\n{\n\tssize_t idx = git_buf_rfind(key, '.');\n\tgit_buf_truncate(key, (size_t)(idx + 1));\n\treturn git_buf_puts(key, suffix);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "key",
            "suffix"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "key",
            "(size_t)(idx + 1)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rfind",
          "args": [
            "key",
            "'.'"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rfind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "158-163",
          "snippet": "GIT_INLINE(ssize_t) git_buf_rfind(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_config_key_trunc_puts(git_buf *key, const char *suffix)\n{\n\tssize_t idx = git_buf_rfind(key, '.');\n\tgit_buf_truncate(key, (size_t)(idx + 1));\n\treturn git_buf_puts(key, suffix);\n}"
  },
  {
    "function_name": "submodule_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "104-107",
    "snippet": "static int submodule_cmp(const void *a, const void *b)\n{\n\treturn strcmp(((git_submodule *)a)->name, ((git_submodule *)b)->name);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
      "static int submodule_load_from_wd_lite(git_submodule *);",
      "static void submodule_get_index_status(unsigned int *, git_submodule *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "((git_submodule *)a)->name",
            "((git_submodule *)b)->name"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nstatic int submodule_cmp(const void *a, const void *b)\n{\n\treturn strcmp(((git_submodule *)a)->name, ((git_submodule *)b)->name);\n}"
  },
  {
    "function_name": "str_equal_no_trailing_slash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "73-85",
    "snippet": "static kh_inline int str_equal_no_trailing_slash(const char *a, const char *b)\n{\n\tsize_t alen = a ? strlen(a) : 0;\n\tsize_t blen = b ? strlen(b) : 0;\n\n\tif (alen > 0 && a[alen - 1] == '/')\n\t\talen--;\n\tif (blen > 0 && b[blen - 1] == '/')\n\t\tblen--;\n\n\treturn (alen == 0 && blen == 0) ||\n\t\t(alen == blen && strncmp(a, b, alen) == 0);\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "a",
            "b",
            "alen"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "b"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "a"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic kh_inline int str_equal_no_trailing_slash(const char *a, const char *b)\n{\n\tsize_t alen = a ? strlen(a) : 0;\n\tsize_t blen = b ? strlen(b) : 0;\n\n\tif (alen > 0 && a[alen - 1] == '/')\n\t\talen--;\n\tif (blen > 0 && b[blen - 1] == '/')\n\t\tblen--;\n\n\treturn (alen == 0 && blen == 0) ||\n\t\t(alen == blen && strncmp(a, b, alen) == 0);\n}"
  },
  {
    "function_name": "str_hash_no_trailing_slash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
    "lines": "62-71",
    "snippet": "static kh_inline khint_t str_hash_no_trailing_slash(const char *s)\n{\n\tkhint_t h;\n\n\tfor (h = 0; *s; ++s)\n\t\tif (s[1] != '\\0' || *s != '/')\n\t\t\th = (h << 5) - h + *s;\n\n\treturn h;\n}",
    "includes": [
      "#include \"index.h\"",
      "#include \"path.h\"",
      "#include \"iterator.h\"",
      "#include \"tree.h\"",
      "#include \"submodule.h\"",
      "#include \"repository.h\"",
      "#include \"config.h\"",
      "#include \"config_file.h\"",
      "#include \"posix.h\"",
      "#include \"vector.h\"",
      "#include \"buf_text.h\"",
      "#include \"buffer.h\"",
      "#include \"git2/index.h\"",
      "#include \"git2/types.h\"",
      "#include \"git2/sys/config.h\"",
      "#include \"git2/config.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic kh_inline khint_t str_hash_no_trailing_slash(const char *s)\n{\n\tkhint_t h;\n\n\tfor (h = 0; *s; ++s)\n\t\tif (s[1] != '\\0' || *s != '/')\n\t\t\th = (h << 5) - h + *s;\n\n\treturn h;\n}"
  }
]