[
  {
    "function_name": "git_buf_splice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "738-768",
    "snippet": "int git_buf_splice(\n\tgit_buf *buf,\n\tsize_t where,\n\tsize_t nb_to_remove,\n\tconst char *data,\n\tsize_t nb_to_insert)\n{\n\tchar *splice_loc;\n\tsize_t new_size, alloc_size;\n\n\tassert(buf && where <= buf->size && nb_to_remove <= buf->size - where);\n\n\tsplice_loc = buf->ptr + where;\n\n\t/* Ported from git.git\n\t * https://github.com/git/git/blob/16eed7c/strbuf.c#L159-176\n\t */\n\tGITERR_CHECK_ALLOC_ADD(&new_size, (buf->size - nb_to_remove), nb_to_insert);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_size, new_size, 1);\n\tENSURE_SIZE(buf, alloc_size);\n\n\tmemmove(splice_loc + nb_to_insert,\n\t\tsplice_loc + nb_to_remove,\n\t\tbuf->size - where - nb_to_remove);\n\n\tmemcpy(splice_loc, data, nb_to_insert);\n\n\tbuf->size = new_size;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "splice_loc",
            "data",
            "nb_to_insert"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "splice_loc + nb_to_insert",
            "splice_loc + nb_to_remove",
            "buf->size - where - nb_to_remove"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "alloc_size"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_size",
            "new_size",
            "1"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "(buf->size - nb_to_remove)",
            "nb_to_insert"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf && where <= buf->size && nb_to_remove <= buf->size - where"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_splice(\n\tgit_buf *buf,\n\tsize_t where,\n\tsize_t nb_to_remove,\n\tconst char *data,\n\tsize_t nb_to_insert)\n{\n\tchar *splice_loc;\n\tsize_t new_size, alloc_size;\n\n\tassert(buf && where <= buf->size && nb_to_remove <= buf->size - where);\n\n\tsplice_loc = buf->ptr + where;\n\n\t/* Ported from git.git\n\t * https://github.com/git/git/blob/16eed7c/strbuf.c#L159-176\n\t */\n\tGITERR_CHECK_ALLOC_ADD(&new_size, (buf->size - nb_to_remove), nb_to_insert);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_size, new_size, 1);\n\tENSURE_SIZE(buf, alloc_size);\n\n\tmemmove(splice_loc + nb_to_insert,\n\t\tsplice_loc + nb_to_remove,\n\t\tbuf->size - where - nb_to_remove);\n\n\tmemcpy(splice_loc, data, nb_to_insert);\n\n\tbuf->size = new_size;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "731-736",
    "snippet": "int git_buf_cmp(const git_buf *a, const git_buf *b)\n{\n\tint result = memcmp(a->ptr, b->ptr, min(a->size, b->size));\n\treturn (result != 0) ? result :\n\t\t(a->size < b->size) ? -1 : (a->size > b->size) ? 1 : 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->ptr",
            "b->ptr",
            "min(a->size, b->size)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "a->size",
            "b->size"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_cmp(const git_buf *a, const git_buf *b)\n{\n\tint result = memcmp(a->ptr, b->ptr, min(a->size, b->size));\n\treturn (result != 0) ? result :\n\t\t(a->size < b->size) ? -1 : (a->size > b->size) ? 1 : 0;\n}"
  },
  {
    "function_name": "git_buf_rtrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "718-729",
    "snippet": "void git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "buf->ptr[buf->size - 1]"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
  },
  {
    "function_name": "git_buf_join3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "657-716",
    "snippet": "int git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt",
            "str_c",
            "len_c"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt",
            "str_b",
            "len_b"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt",
            "str_a",
            "len_a"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "buf",
            "len_total"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&len_total",
            "len_total",
            "1"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&len_total",
            "len_total",
            "len_c"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&len_total",
            "len_total",
            "sep_b"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&len_total",
            "len_total",
            "len_b"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&len_total",
            "len_a",
            "sep_a"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_c < buf->ptr || str_c >= buf->ptr + buf->size"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_b < buf->ptr || str_b >= buf->ptr + buf->size"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_a < buf->ptr || str_a >= buf->ptr + buf->size"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_c"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_b"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_a"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "607-655",
    "snippet": "int git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf->ptr + strlen_a + need_sep",
            "str_b",
            "strlen_b"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->ptr",
            "str_a",
            "strlen_a"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf->ptr"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "buf",
            "alloc_len"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "1"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "need_sep"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "strlen_a",
            "strlen_b"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "str_b < buf->ptr || str_b >= buf->ptr + buf->size"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_b"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str_a"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_join_n",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "519-605",
    "snippet": "int git_buf_join_n(git_buf *buf, char separator, int nbuf, ...)\n{\n\tva_list ap;\n\tint i;\n\tsize_t total_size = 0, original_size = buf->size;\n\tchar *out, *original = buf->ptr;\n\n\tif (buf->size > 0 && buf->ptr[buf->size - 1] != separator)\n\t\t++total_size; /* space for initial separator */\n\n\t/* Make two passes to avoid multiple reallocation */\n\n\tva_start(ap, nbuf);\n\tfor (i = 0; i < nbuf; ++i) {\n\t\tconst char* segment;\n\t\tsize_t segment_len;\n\n\t\tsegment = va_arg(ap, const char *);\n\t\tif (!segment)\n\t\t\tcontinue;\n\n\t\tsegment_len = strlen(segment);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&total_size, total_size, segment_len);\n\n\t\tif (segment_len == 0 || segment[segment_len - 1] != separator)\n\t\t\tGITERR_CHECK_ALLOC_ADD(&total_size, total_size, 1);\n\t}\n\tva_end(ap);\n\n\t/* expand buffer if needed */\n\tif (total_size == 0)\n\t\treturn 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&total_size, total_size, 1);\n\tif (git_buf_grow_by(buf, total_size) < 0)\n\t\treturn -1;\n\n\tout = buf->ptr + buf->size;\n\n\t/* append separator to existing buf if needed */\n\tif (buf->size > 0 && out[-1] != separator)\n\t\t*out++ = separator;\n\n\tva_start(ap, nbuf);\n\tfor (i = 0; i < nbuf; ++i) {\n\t\tconst char* segment;\n\t\tsize_t segment_len;\n\n\t\tsegment = va_arg(ap, const char *);\n\t\tif (!segment)\n\t\t\tcontinue;\n\n\t\t/* deal with join that references buffer's original content */\n\t\tif (segment >= original && segment < original + original_size) {\n\t\t\tsize_t offset = (segment - original);\n\t\t\tsegment = buf->ptr + offset;\n\t\t\tsegment_len = original_size - offset;\n\t\t} else {\n\t\t\tsegment_len = strlen(segment);\n\t\t}\n\n\t\t/* skip leading separators */\n\t\tif (out > buf->ptr && out[-1] == separator)\n\t\t\twhile (segment_len > 0 && *segment == separator) {\n\t\t\t\tsegment++;\n\t\t\t\tsegment_len--;\n\t\t\t}\n\n\t\t/* copy over next buffer */\n\t\tif (segment_len > 0) {\n\t\t\tmemmove(out, segment, segment_len);\n\t\t\tout += segment_len;\n\t\t}\n\n\t\t/* append trailing separator (except for last item) */\n\t\tif (i < nbuf - 1 && out > buf->ptr && out[-1] != separator)\n\t\t\t*out++ = separator;\n\t}\n\tva_end(ap);\n\n\t/* set size based on num characters actually written */\n\tbuf->size = out - buf->ptr;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "out",
            "segment",
            "segment_len"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "segment"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ap",
            "constchar *"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "nbuf"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow_by",
          "args": [
            "buf",
            "total_size"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&total_size",
            "total_size",
            "1"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&total_size",
            "total_size",
            "1"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&total_size",
            "total_size",
            "segment_len"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "segment"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "ap",
            "constchar *"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "nbuf"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join_n(git_buf *buf, char separator, int nbuf, ...)\n{\n\tva_list ap;\n\tint i;\n\tsize_t total_size = 0, original_size = buf->size;\n\tchar *out, *original = buf->ptr;\n\n\tif (buf->size > 0 && buf->ptr[buf->size - 1] != separator)\n\t\t++total_size; /* space for initial separator */\n\n\t/* Make two passes to avoid multiple reallocation */\n\n\tva_start(ap, nbuf);\n\tfor (i = 0; i < nbuf; ++i) {\n\t\tconst char* segment;\n\t\tsize_t segment_len;\n\n\t\tsegment = va_arg(ap, const char *);\n\t\tif (!segment)\n\t\t\tcontinue;\n\n\t\tsegment_len = strlen(segment);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&total_size, total_size, segment_len);\n\n\t\tif (segment_len == 0 || segment[segment_len - 1] != separator)\n\t\t\tGITERR_CHECK_ALLOC_ADD(&total_size, total_size, 1);\n\t}\n\tva_end(ap);\n\n\t/* expand buffer if needed */\n\tif (total_size == 0)\n\t\treturn 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&total_size, total_size, 1);\n\tif (git_buf_grow_by(buf, total_size) < 0)\n\t\treturn -1;\n\n\tout = buf->ptr + buf->size;\n\n\t/* append separator to existing buf if needed */\n\tif (buf->size > 0 && out[-1] != separator)\n\t\t*out++ = separator;\n\n\tva_start(ap, nbuf);\n\tfor (i = 0; i < nbuf; ++i) {\n\t\tconst char* segment;\n\t\tsize_t segment_len;\n\n\t\tsegment = va_arg(ap, const char *);\n\t\tif (!segment)\n\t\t\tcontinue;\n\n\t\t/* deal with join that references buffer's original content */\n\t\tif (segment >= original && segment < original + original_size) {\n\t\t\tsize_t offset = (segment - original);\n\t\t\tsegment = buf->ptr + offset;\n\t\t\tsegment_len = original_size - offset;\n\t\t} else {\n\t\t\tsegment_len = strlen(segment);\n\t\t}\n\n\t\t/* skip leading separators */\n\t\tif (out > buf->ptr && out[-1] == separator)\n\t\t\twhile (segment_len > 0 && *segment == separator) {\n\t\t\t\tsegment++;\n\t\t\t\tsegment_len--;\n\t\t\t}\n\n\t\t/* copy over next buffer */\n\t\tif (segment_len > 0) {\n\t\t\tmemmove(out, segment, segment_len);\n\t\t\tout += segment_len;\n\t\t}\n\n\t\t/* append trailing separator (except for last item) */\n\t\tif (i < nbuf - 1 && out > buf->ptr && out[-1] != separator)\n\t\t\t*out++ = separator;\n\t}\n\tva_end(ap);\n\n\t/* set size based on num characters actually written */\n\tbuf->size = out - buf->ptr;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_attach_notowned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "505-517",
    "snippet": "void git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "buf",
            "0"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "buf"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_is_allocated",
          "args": [
            "buf"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_is_allocated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "26-29",
          "snippet": "GIT_INLINE(bool) git_buf_is_allocated(const git_buf *buf)\n{\n\treturn (buf->ptr != NULL && buf->asize > 0);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_is_allocated(const git_buf *buf)\n{\n\treturn (buf->ptr != NULL && buf->asize > 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}"
  },
  {
    "function_name": "git_buf_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "489-503",
    "snippet": "void git_buf_attach(git_buf *buf, char *ptr, size_t asize)\n{\n\tgit_buf_free(buf);\n\n\tif (ptr) {\n\t\tbuf->ptr = ptr;\n\t\tbuf->size = strlen(ptr);\n\t\tif (asize)\n\t\t\tbuf->asize = (asize < buf->size) ? buf->size + 1 : asize;\n\t\telse /* pass 0 to fall back on strlen + 1 */\n\t\t\tbuf->asize = buf->size + 1;\n\t} else {\n\t\tgit_buf_grow(buf, asize);\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "buf",
            "asize"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "buf"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_attach(git_buf *buf, char *ptr, size_t asize)\n{\n\tgit_buf_free(buf);\n\n\tif (ptr) {\n\t\tbuf->ptr = ptr;\n\t\tbuf->size = strlen(ptr);\n\t\tif (asize)\n\t\t\tbuf->asize = (asize < buf->size) ? buf->size + 1 : asize;\n\t\telse /* pass 0 to fall back on strlen + 1 */\n\t\t\tbuf->asize = buf->size + 1;\n\t} else {\n\t\tgit_buf_grow(buf, asize);\n\t}\n}"
  },
  {
    "function_name": "git_buf_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "477-487",
    "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__oom[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "buf",
            "0"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
  },
  {
    "function_name": "git_buf_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "470-475",
    "snippet": "void git_buf_swap(git_buf *buf_a, git_buf *buf_b)\n{\n\tgit_buf t = *buf_a;\n\t*buf_a = *buf_b;\n\t*buf_b = t;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_swap(git_buf *buf_a, git_buf *buf_b)\n{\n\tgit_buf t = *buf_a;\n\t*buf_a = *buf_b;\n\t*buf_b = t;\n}"
  },
  {
    "function_name": "git_buf_rtruncate_at_char",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "464-468",
    "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "buf",
            "idx < 0 ? 0 : (size_t)idx"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rfind_next",
          "args": [
            "buf",
            "separator"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rfind_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "150-156",
          "snippet": "GIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
  },
  {
    "function_name": "git_buf_shorten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "456-462",
    "snippet": "void git_buf_shorten(git_buf *buf, size_t amount)\n{\n\tif (buf->size > amount)\n\t\tgit_buf_truncate(buf, buf->size - amount);\n\telse\n\t\tgit_buf_clear(buf);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "buf",
            "buf->size - amount"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_shorten(git_buf *buf, size_t amount)\n{\n\tif (buf->size > amount)\n\t\tgit_buf_truncate(buf, buf->size - amount);\n\telse\n\t\tgit_buf_clear(buf);\n}"
  },
  {
    "function_name": "git_buf_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "446-454",
    "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
  },
  {
    "function_name": "git_buf_consume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "436-444",
    "snippet": "void git_buf_consume(git_buf *buf, const char *end)\n{\n\tif (end > buf->ptr && end <= buf->ptr + buf->size) {\n\t\tsize_t consumed = end - buf->ptr;\n\t\tmemmove(buf->ptr, end, buf->size - consumed);\n\t\tbuf->size -= consumed;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->ptr",
            "end",
            "buf->size - consumed"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_consume(git_buf *buf, const char *end)\n{\n\tif (end > buf->ptr && end <= buf->ptr + buf->size) {\n\t\tsize_t consumed = end - buf->ptr;\n\t\tmemmove(buf->ptr, end, buf->size - consumed);\n\t\tbuf->size -= consumed;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n}"
  },
  {
    "function_name": "git_buf_copy_cstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "418-434",
    "snippet": "void git_buf_copy_cstr(char *data, size_t datasize, const git_buf *buf)\n{\n\tsize_t copylen;\n\n\tassert(data && datasize && buf);\n\n\tdata[0] = '\\0';\n\n\tif (buf->size == 0 || buf->asize <= 0)\n\t\treturn;\n\n\tcopylen = buf->size;\n\tif (copylen > datasize - 1)\n\t\tcopylen = datasize - 1;\n\tmemmove(data, buf->ptr, copylen);\n\tdata[copylen] = '\\0';\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "data",
            "buf->ptr",
            "copylen"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "data && datasize && buf"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_copy_cstr(char *data, size_t datasize, const git_buf *buf)\n{\n\tsize_t copylen;\n\n\tassert(data && datasize && buf);\n\n\tdata[0] = '\\0';\n\n\tif (buf->size == 0 || buf->asize <= 0)\n\t\treturn;\n\n\tcopylen = buf->size;\n\tif (copylen > datasize - 1)\n\t\tcopylen = datasize - 1;\n\tmemmove(data, buf->ptr, copylen);\n\tdata[copylen] = '\\0';\n}"
  },
  {
    "function_name": "git_buf_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "406-416",
    "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_vprintf",
          "args": [
            "buf",
            "format",
            "ap"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "366-404",
          "snippet": "int git_buf_vprintf(git_buf *buf, const char *format, va_list ap)\n{\n\tsize_t expected_size, new_size;\n\tint len;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&expected_size, strlen(format), 2);\n\tGITERR_CHECK_ALLOC_ADD(&expected_size, expected_size, buf->size);\n\tENSURE_SIZE(buf, expected_size);\n\n\twhile (1) {\n\t\tva_list args;\n\t\tva_copy(args, ap);\n\n\t\tlen = p_vsnprintf(\n\t\t\tbuf->ptr + buf->size,\n\t\t\tbuf->asize - buf->size,\n\t\t\tformat, args\n\t\t);\n\n\t\tva_end(args);\n\n\t\tif (len < 0) {\n\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((size_t)len + 1 <= buf->asize - buf->size) {\n\t\t\tbuf->size += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_vprintf(git_buf *buf, const char *format, va_list ap)\n{\n\tsize_t expected_size, new_size;\n\tint len;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&expected_size, strlen(format), 2);\n\tGITERR_CHECK_ALLOC_ADD(&expected_size, expected_size, buf->size);\n\tENSURE_SIZE(buf, expected_size);\n\n\twhile (1) {\n\t\tva_list args;\n\t\tva_copy(args, ap);\n\n\t\tlen = p_vsnprintf(\n\t\t\tbuf->ptr + buf->size,\n\t\t\tbuf->asize - buf->size,\n\t\t\tformat, args\n\t\t);\n\n\t\tva_end(args);\n\n\t\tif (len < 0) {\n\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((size_t)len + 1 <= buf->asize - buf->size) {\n\t\t\tbuf->size += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "format"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
  },
  {
    "function_name": "git_buf_vprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "366-404",
    "snippet": "int git_buf_vprintf(git_buf *buf, const char *format, va_list ap)\n{\n\tsize_t expected_size, new_size;\n\tint len;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&expected_size, strlen(format), 2);\n\tGITERR_CHECK_ALLOC_ADD(&expected_size, expected_size, buf->size);\n\tENSURE_SIZE(buf, expected_size);\n\n\twhile (1) {\n\t\tva_list args;\n\t\tva_copy(args, ap);\n\n\t\tlen = p_vsnprintf(\n\t\t\tbuf->ptr + buf->size,\n\t\t\tbuf->asize - buf->size,\n\t\t\tformat, args\n\t\t);\n\n\t\tva_end(args);\n\n\t\tif (len < 0) {\n\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((size_t)len + 1 <= buf->asize - buf->size) {\n\t\t\tbuf->size += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__oom[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "new_size"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "new_size",
            "1"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "buf->size",
            "len"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "buf->ptr"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_vsnprintf",
          "args": [
            "buf->ptr + buf->size",
            "buf->asize - buf->size",
            "format",
            "args"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "p_vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "525-546",
          "snippet": "int p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_copy",
          "args": [
            "args",
            "ap"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "expected_size"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&expected_size",
            "expected_size",
            "buf->size"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&expected_size",
            "strlen(format)",
            "2"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "format"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_vprintf(git_buf *buf, const char *format, va_list ap)\n{\n\tsize_t expected_size, new_size;\n\tint len;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&expected_size, strlen(format), 2);\n\tGITERR_CHECK_ALLOC_ADD(&expected_size, expected_size, buf->size);\n\tENSURE_SIZE(buf, expected_size);\n\n\twhile (1) {\n\t\tva_list args;\n\t\tva_copy(args, ap);\n\n\t\tlen = p_vsnprintf(\n\t\t\tbuf->ptr + buf->size,\n\t\t\tbuf->asize - buf->size,\n\t\t\tformat, args\n\t\t);\n\n\t\tva_end(args);\n\n\t\tif (len < 0) {\n\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((size_t)len + 1 <= buf->asize - buf->size) {\n\t\t\tbuf->size += len;\n\t\t\tbreak;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_encode_base85",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "327-364",
    "snippet": "int git_buf_encode_base85(git_buf *buf, const char *data, size_t len)\n{\n\tsize_t blocks = (len / 4) + !!(len % 4), alloclen;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, blocks, 5);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, buf->size);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\n\tENSURE_SIZE(buf, alloclen);\n\n\twhile (len) {\n\t\tuint32_t acc = 0;\n\t\tchar b85[5];\n\t\tint i;\n\n\t\tfor (i = 24; i >= 0; i -= 8) {\n\t\t\tuint8_t ch = *data++;\n\t\t\tacc |= ch << i;\n\n\t\t\tif (--len == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 4; i >= 0; i--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\n\t\t\tb85[i] = b85str[val];\n\t\t}\n\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tbuf->ptr[buf->size++] = b85[i];\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char b85str[] =\n\t\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "alloclen"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "1"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "buf->size"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&alloclen",
            "blocks",
            "5"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nstatic const char b85str[] =\n\t\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\";\n\nint git_buf_encode_base85(git_buf *buf, const char *data, size_t len)\n{\n\tsize_t blocks = (len / 4) + !!(len % 4), alloclen;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, blocks, 5);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, buf->size);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\n\tENSURE_SIZE(buf, alloclen);\n\n\twhile (len) {\n\t\tuint32_t acc = 0;\n\t\tchar b85[5];\n\t\tint i;\n\n\t\tfor (i = 24; i >= 0; i -= 8) {\n\t\t\tuint8_t ch = *data++;\n\t\t\tacc |= ch << i;\n\n\t\t\tif (--len == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 4; i >= 0; i--) {\n\t\t\tint val = acc % 85;\n\t\t\tacc /= 85;\n\n\t\t\tb85[i] = b85str[val];\n\t\t}\n\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tbuf->ptr[buf->size++] = b85[i];\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_decode_base64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "292-322",
    "snippet": "int git_buf_decode_base64(git_buf *buf, const char *base64, size_t len)\n{\n\tsize_t i;\n\tint8_t a, b, c, d;\n\tsize_t orig_size = buf->size, new_size;\n\n\tassert(len % 4 == 0);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, (len / 4 * 3), buf->size);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\tENSURE_SIZE(buf, new_size);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tif ((a = BASE64_DECODE_VALUE(base64[i])) < 0 ||\n\t\t\t(b = BASE64_DECODE_VALUE(base64[i+1])) < 0 ||\n\t\t\t(c = BASE64_DECODE_VALUE(base64[i+2])) < 0 ||\n\t\t\t(d = BASE64_DECODE_VALUE(base64[i+3])) < 0) {\n\t\t\tbuf->size = orig_size;\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t\t\tgiterr_set(GITERR_INVALID, \"Invalid base64 input\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf->ptr[buf->size++] = ((a << 2) | (b & 0x30) >> 4);\n\t\tbuf->ptr[buf->size++] = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);\n\t\tbuf->ptr[buf->size++] = (c & 0x03) << 6 | (d & 0x3f);\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Invalid base64 input\""
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BASE64_DECODE_VALUE",
          "args": [
            "base64[i+3]"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE64_DECODE_VALUE",
          "args": [
            "base64[i+2]"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE64_DECODE_VALUE",
          "args": [
            "base64[i+1]"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASE64_DECODE_VALUE",
          "args": [
            "base64[i]"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "new_size"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "new_size",
            "1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "(len / 4 * 3)",
            "buf->size"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len % 4 == 0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_decode_base64(git_buf *buf, const char *base64, size_t len)\n{\n\tsize_t i;\n\tint8_t a, b, c, d;\n\tsize_t orig_size = buf->size, new_size;\n\n\tassert(len % 4 == 0);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, (len / 4 * 3), buf->size);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\tENSURE_SIZE(buf, new_size);\n\n\tfor (i = 0; i < len; i += 4) {\n\t\tif ((a = BASE64_DECODE_VALUE(base64[i])) < 0 ||\n\t\t\t(b = BASE64_DECODE_VALUE(base64[i+1])) < 0 ||\n\t\t\t(c = BASE64_DECODE_VALUE(base64[i+2])) < 0 ||\n\t\t\t(d = BASE64_DECODE_VALUE(base64[i+3])) < 0) {\n\t\t\tbuf->size = orig_size;\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t\t\tgiterr_set(GITERR_INVALID, \"Invalid base64 input\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbuf->ptr[buf->size++] = ((a << 2) | (b & 0x30) >> 4);\n\t\tbuf->ptr[buf->size++] = ((b & 0x0f) << 4) | ((c & 0x3c) >> 2);\n\t\tbuf->ptr[buf->size++] = (c & 0x03) << 6 | (d & 0x3f);\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_encode_base64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "234-274",
    "snippet": "int git_buf_encode_base64(git_buf *buf, const char *data, size_t len)\n{\n\tsize_t extra = len % 3;\n\tuint8_t *write, a, b, c;\n\tconst uint8_t *read = (const uint8_t *)data;\n\tsize_t blocks = (len / 3) + !!extra, alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&blocks, blocks, 1);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, blocks, 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, buf->size);\n\n\tENSURE_SIZE(buf, alloclen);\n\twrite = (uint8_t *)&buf->ptr[buf->size];\n\n\t/* convert each run of 3 bytes into 4 output bytes */\n\tfor (len -= extra; len > 0; len -= 3) {\n\t\ta = *read++;\n\t\tb = *read++;\n\t\tc = *read++;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = base64_encode[(b & 0x0f) << 2 | c >> 6];\n\t\t*write++ = base64_encode[c & 0x3f];\n\t}\n\n\tif (extra > 0) {\n\t\ta = *read++;\n\t\tb = (extra > 1) ? *read++ : 0;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = (extra > 1) ? base64_encode[(b & 0x0f) << 2] : '=';\n\t\t*write++ = '=';\n\t}\n\n\tbuf->size = ((char *)write) - buf->ptr;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char base64_encode[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "alloclen"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "buf->size"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&alloclen",
            "blocks",
            "4"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&blocks",
            "blocks",
            "1"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nstatic const char base64_encode[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nint git_buf_encode_base64(git_buf *buf, const char *data, size_t len)\n{\n\tsize_t extra = len % 3;\n\tuint8_t *write, a, b, c;\n\tconst uint8_t *read = (const uint8_t *)data;\n\tsize_t blocks = (len / 3) + !!extra, alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&blocks, blocks, 1);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, blocks, 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, buf->size);\n\n\tENSURE_SIZE(buf, alloclen);\n\twrite = (uint8_t *)&buf->ptr[buf->size];\n\n\t/* convert each run of 3 bytes into 4 output bytes */\n\tfor (len -= extra; len > 0; len -= 3) {\n\t\ta = *read++;\n\t\tb = *read++;\n\t\tc = *read++;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = base64_encode[(b & 0x0f) << 2 | c >> 6];\n\t\t*write++ = base64_encode[c & 0x3f];\n\t}\n\n\tif (extra > 0) {\n\t\ta = *read++;\n\t\tb = (extra > 1) ? *read++ : 0;\n\n\t\t*write++ = base64_encode[a >> 2];\n\t\t*write++ = base64_encode[(a & 0x03) << 4 | b >> 4];\n\t\t*write++ = (extra > 1) ? base64_encode[(b & 0x0f) << 2] : '=';\n\t\t*write++ = '=';\n\t}\n\n\tbuf->size = ((char *)write) - buf->ptr;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_puts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "225-229",
    "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "buf",
            "string",
            "strlen(string)"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "string"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
  },
  {
    "function_name": "git_buf_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "208-223",
    "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->ptr + buf->size",
            "data",
            "len"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "new_size"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "new_size",
            "1"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "buf->size",
            "len"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "data"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_putcn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "196-206",
    "snippet": "int git_buf_putcn(git_buf *buf, char c, size_t len)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\tENSURE_SIZE(buf, new_size);\n\tmemset(buf->ptr + buf->size, c, len);\n\tbuf->size += len;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf->ptr + buf->size",
            "c",
            "len"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "new_size"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "new_size",
            "1"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "buf->size",
            "len"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putcn(git_buf *buf, char c, size_t len)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\tENSURE_SIZE(buf, new_size);\n\tmemset(buf->ptr + buf->size, c, len);\n\tbuf->size += len;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_putc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "186-194",
    "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "new_size"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "buf->size",
            "2"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_sets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "181-184",
    "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "buf",
            "string",
            "string ? strlen(string) : 0"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
  },
  {
    "function_name": "git_buf_contains_nul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "176-179",
    "snippet": "int git_buf_contains_nul(const git_buf *buf)\n{\n\treturn git_buf_text_contains_nul(buf);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_contains_nul",
          "args": [
            "buf"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_contains_nul",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "213-216",
          "snippet": "bool git_buf_text_contains_nul(const git_buf *buf)\n{\n\treturn (memchr(buf->ptr, '\\0', buf->size) != NULL);\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_contains_nul(const git_buf *buf)\n{\n\treturn (memchr(buf->ptr, '\\0', buf->size) != NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_contains_nul(const git_buf *buf)\n{\n\treturn git_buf_text_contains_nul(buf);\n}"
  },
  {
    "function_name": "git_buf_is_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "171-174",
    "snippet": "int git_buf_is_binary(const git_buf *buf)\n{\n\treturn git_buf_text_is_binary(buf);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_is_binary",
          "args": [
            "buf"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_is_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "185-211",
          "snippet": "bool git_buf_text_is_binary(const git_buf *buf)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tgit_bom_t bom;\n\tint printable = 0, nonprintable = 0;\n\n\tscan += git_buf_text_detect_bom(&bom, buf, 0);\n\n\tif (bom > GIT_BOM_UTF8)\n\t\treturn 1;\n\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\t/* Printable characters are those above SPACE (0x1F) excluding DEL,\n\t\t * and including BS, ESC and FF.\n\t\t */\n\t\tif ((c > 0x1F && c != 127) || c == '\\b' || c == '\\033' || c == '\\014')\n\t\t\tprintable++;\n\t\telse if (c == '\\0')\n\t\t\treturn true;\n\t\telse if (!git__isspace(c))\n\t\t\tnonprintable++;\n\t}\n\n\treturn ((printable >> 7) < nonprintable);\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_is_binary(const git_buf *buf)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tgit_bom_t bom;\n\tint printable = 0, nonprintable = 0;\n\n\tscan += git_buf_text_detect_bom(&bom, buf, 0);\n\n\tif (bom > GIT_BOM_UTF8)\n\t\treturn 1;\n\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\t/* Printable characters are those above SPACE (0x1F) excluding DEL,\n\t\t * and including BS, ESC and FF.\n\t\t */\n\t\tif ((c > 0x1F && c != 127) || c == '\\b' || c == '\\033' || c == '\\014')\n\t\t\tprintable++;\n\t\telse if (c == '\\0')\n\t\t\treturn true;\n\t\telse if (!git__isspace(c))\n\t\t\tnonprintable++;\n\t}\n\n\treturn ((printable >> 7) < nonprintable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_is_binary(const git_buf *buf)\n{\n\treturn git_buf_text_is_binary(buf);\n}"
  },
  {
    "function_name": "git_buf_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "150-169",
    "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->ptr",
            "data",
            "len"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ENSURE_SIZE",
          "args": [
            "buf",
            "alloclen"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "len",
            "1"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "137-148",
    "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__initbuf[1];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
  },
  {
    "function_name": "git_buf_sanitize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "128-135",
    "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__initbuf[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "buf->size == 0 && buf->asize == 0"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
  },
  {
    "function_name": "git_buf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "118-126",
    "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__oom[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "buf",
            "0"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "buf->ptr"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
  },
  {
    "function_name": "git_buf_grow_by",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "106-116",
    "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__oom[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_try_grow",
          "args": [
            "buffer",
            "newsize",
            "true"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_try_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "35-99",
          "snippet": "int git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];",
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\nchar git_buf__oom[1];\n\nint git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&newsize",
            "buffer->size",
            "additional_size"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
  },
  {
    "function_name": "git_buf_grow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "101-104",
    "snippet": "int git_buf_grow(git_buf *buffer, size_t target_size)\n{\n\treturn git_buf_try_grow(buffer, target_size, true);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_try_grow",
          "args": [
            "buffer",
            "target_size",
            "true"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_try_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "35-99",
          "snippet": "int git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];",
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\nchar git_buf__oom[1];\n\nint git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_grow(git_buf *buffer, size_t target_size)\n{\n\treturn git_buf_try_grow(buffer, target_size, true);\n}"
  },
  {
    "function_name": "git_buf_try_grow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "35-99",
    "snippet": "int git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__initbuf[1];",
      "char git_buf__oom[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "buf->ptr"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__realloc",
          "args": [
            "new_ptr",
            "new_size"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "git__realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "215-220",
          "snippet": "GIT_INLINE(void *) git__realloc(void *ptr, size_t size)\n{\n\tvoid *new_ptr = realloc(ptr, size);\n\tif (!new_ptr) giterr_set_oom();\n\treturn new_ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__realloc(void *ptr, size_t size)\n{\n\tvoid *new_ptr = realloc(ptr, size);\n\tif (!new_ptr) giterr_set_oom();\n\treturn new_ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_oom",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "45-48",
          "snippet": "void giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nvoid giterr_set_oom(void)\n{\n\tGIT_GLOBAL->last_error = &g_git_oom_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"cannot grow a borrowed buffer\""
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\nchar git_buf__oom[1];\n\nint git_buf_try_grow(\n\tgit_buf *buf, size_t target_size, bool mark_oom)\n{\n\tchar *new_ptr;\n\tsize_t new_size;\n\n\tif (buf->ptr == git_buf__oom)\n\t\treturn -1;\n\n\tif (buf->asize == 0 && buf->size != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"cannot grow a borrowed buffer\");\n\t\treturn GIT_EINVALID;\n\t}\n\n\tif (!target_size)\n\t\ttarget_size = buf->size;\n\n\tif (target_size <= buf->asize)\n\t\treturn 0;\n\n\tif (buf->asize == 0) {\n\t\tnew_size = target_size;\n\t\tnew_ptr = NULL;\n\t} else {\n\t\tnew_size = buf->asize;\n\t\tnew_ptr = buf->ptr;\n\t}\n\n\t/* grow the buffer size by 1.5, until it's big enough\n\t * to fit our target size */\n\twhile (new_size < target_size)\n\t\tnew_size = (new_size << 1) - (new_size >> 1);\n\n\t/* round allocation up to multiple of 8 */\n\tnew_size = (new_size + 7) & ~7;\n\n\tif (new_size < buf->size) {\n\t\tif (mark_oom)\n\t\t\tbuf->ptr = git_buf__oom;\n\n\t\tgiterr_set_oom();\n\t\treturn -1;\n\t}\n\n\tnew_ptr = git__realloc(new_ptr, new_size);\n\n\tif (!new_ptr) {\n\t\tif (mark_oom) {\n\t\t\tif (buf->ptr && (buf->ptr != git_buf__initbuf))\n\t\t\t\tgit__free(buf->ptr);\n\t\t\tbuf->ptr = git_buf__oom;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tbuf->asize = new_size;\n\tbuf->ptr   = new_ptr;\n\n\t/* truncate the existing buffer size if necessary */\n\tif (buf->size >= buf->asize)\n\t\tbuf->size = buf->asize - 1;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
    "lines": "25-33",
    "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"buf_text.h\"",
      "#include \"git2/buffer.h\"",
      "#include \"posix.h\"",
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char git_buf__initbuf[1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "buf",
            "initial_size"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
  }
]