[
  {
    "function_name": "git_buf_text_gather_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "268-315",
    "snippet": "bool git_buf_text_gather_stats(\n\tgit_buf_text_stats *stats, const git_buf *buf, bool skip_bom)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tint skip;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\t/* BOM detection */\n\tskip = git_buf_text_detect_bom(&stats->bom, buf, 0);\n\tif (skip_bom)\n\t\tscan += skip;\n\n\t/* Ignore EOF character */\n\tif (buf->size > 0 && end[-1] == '\\032')\n\t\tend--;\n\n\t/* Counting loop */\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\tif (c > 0x1F && c != 0x7F)\n\t\t\tstats->printable++;\n\t\telse switch (c) {\n\t\t\tcase '\\0':\n\t\t\t\tstats->nul++;\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tstats->lf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tstats->cr++;\n\t\t\t\tif (scan < end && *scan == '\\n')\n\t\t\t\t\tstats->crlf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\t': case '\\f': case '\\v': case '\\b': case 0x1b: /*ESC*/\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn (stats->nul > 0 ||\n\t\t((stats->printable >> 7) < stats->nonprintable));\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_detect_bom",
          "args": [
            "&stats->bom",
            "buf",
            "0"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_detect_bom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "218-266",
          "snippet": "int git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(*stats)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_gather_stats(\n\tgit_buf_text_stats *stats, const git_buf *buf, bool skip_bom)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tint skip;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\t/* BOM detection */\n\tskip = git_buf_text_detect_bom(&stats->bom, buf, 0);\n\tif (skip_bom)\n\t\tscan += skip;\n\n\t/* Ignore EOF character */\n\tif (buf->size > 0 && end[-1] == '\\032')\n\t\tend--;\n\n\t/* Counting loop */\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\tif (c > 0x1F && c != 0x7F)\n\t\t\tstats->printable++;\n\t\telse switch (c) {\n\t\t\tcase '\\0':\n\t\t\t\tstats->nul++;\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\tcase '\\n':\n\t\t\t\tstats->lf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\r':\n\t\t\t\tstats->cr++;\n\t\t\t\tif (scan < end && *scan == '\\n')\n\t\t\t\t\tstats->crlf++;\n\t\t\t\tbreak;\n\t\t\tcase '\\t': case '\\f': case '\\v': case '\\b': case 0x1b: /*ESC*/\n\t\t\t\tstats->printable++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstats->nonprintable++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\treturn (stats->nul > 0 ||\n\t\t((stats->printable >> 7) < stats->nonprintable));\n}"
  },
  {
    "function_name": "git_buf_text_detect_bom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "218-266",
    "snippet": "int git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_text_contains_nul",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "213-216",
    "snippet": "bool git_buf_text_contains_nul(const git_buf *buf)\n{\n\treturn (memchr(buf->ptr, '\\0', buf->size) != NULL);\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf->ptr",
            "'\\0'",
            "buf->size"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_contains_nul(const git_buf *buf)\n{\n\treturn (memchr(buf->ptr, '\\0', buf->size) != NULL);\n}"
  },
  {
    "function_name": "git_buf_text_is_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "185-211",
    "snippet": "bool git_buf_text_is_binary(const git_buf *buf)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tgit_bom_t bom;\n\tint printable = 0, nonprintable = 0;\n\n\tscan += git_buf_text_detect_bom(&bom, buf, 0);\n\n\tif (bom > GIT_BOM_UTF8)\n\t\treturn 1;\n\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\t/* Printable characters are those above SPACE (0x1F) excluding DEL,\n\t\t * and including BS, ESC and FF.\n\t\t */\n\t\tif ((c > 0x1F && c != 127) || c == '\\b' || c == '\\033' || c == '\\014')\n\t\t\tprintable++;\n\t\telse if (c == '\\0')\n\t\t\treturn true;\n\t\telse if (!git__isspace(c))\n\t\t\tnonprintable++;\n\t}\n\n\treturn ((printable >> 7) < nonprintable);\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "c"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_text_detect_bom",
          "args": [
            "&bom",
            "buf",
            "0"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_detect_bom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "218-266",
          "snippet": "int git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_detect_bom(git_bom_t *bom, const git_buf *buf, size_t offset)\n{\n\tconst char *ptr;\n\tsize_t len;\n\n\t*bom = GIT_BOM_NONE;\n\t/* need at least 2 bytes after offset to look for any BOM */\n\tif (buf->size < offset + 2)\n\t\treturn 0;\n\n\tptr = buf->ptr + offset;\n\tlen = buf->size - offset;\n\n\tswitch (*ptr++) {\n\tcase 0:\n\t\tif (len >= 4 && ptr[0] == 0 && ptr[1] == '\\xFE' && ptr[2] == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF32_BE;\n\t\t\treturn 4;\n\t\t}\n\t\tbreak;\n\tcase '\\xEF':\n\t\tif (len >= 3 && ptr[0] == '\\xBB' && ptr[1] == '\\xBF') {\n\t\t\t*bom = GIT_BOM_UTF8;\n\t\t\treturn 3;\n\t\t}\n\t\tbreak;\n\tcase '\\xFE':\n\t\tif (*ptr == '\\xFF') {\n\t\t\t*bom = GIT_BOM_UTF16_BE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tcase '\\xFF':\n\t\tif (*ptr != '\\xFE')\n\t\t\tbreak;\n\t\tif (len >= 4 && ptr[1] == 0 && ptr[2] == 0) {\n\t\t\t*bom = GIT_BOM_UTF32_LE;\n\t\t\treturn 4;\n\t\t} else {\n\t\t\t*bom = GIT_BOM_UTF16_LE;\n\t\t\treturn 2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_is_binary(const git_buf *buf)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tgit_bom_t bom;\n\tint printable = 0, nonprintable = 0;\n\n\tscan += git_buf_text_detect_bom(&bom, buf, 0);\n\n\tif (bom > GIT_BOM_UTF8)\n\t\treturn 1;\n\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\t/* Printable characters are those above SPACE (0x1F) excluding DEL,\n\t\t * and including BS, ESC and FF.\n\t\t */\n\t\tif ((c > 0x1F && c != 127) || c == '\\b' || c == '\\033' || c == '\\014')\n\t\t\tprintable++;\n\t\telse if (c == '\\0')\n\t\t\treturn true;\n\t\telse if (!git__isspace(c))\n\t\t\tnonprintable++;\n\t}\n\n\treturn ((printable >> 7) < nonprintable);\n}"
  },
  {
    "function_name": "git_buf_text_common_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "155-183",
    "snippet": "int git_buf_text_common_prefix(git_buf *buf, const git_strarray *strings)\n{\n\tsize_t i;\n\tconst char *str, *pfx;\n\n\tgit_buf_clear(buf);\n\n\tif (!strings || !strings->count)\n\t\treturn 0;\n\n\t/* initialize common prefix to first string */\n\tif (git_buf_sets(buf, strings->strings[0]) < 0)\n\t\treturn -1;\n\n\t/* go through the rest of the strings, truncating to shared prefix */\n\tfor (i = 1; i < strings->count; ++i) {\n\n\t\tfor (str = strings->strings[i], pfx = buf->ptr;\n\t\t\t *str && *str == *pfx; str++, pfx++)\n\t\t\t/* scanning */;\n\n\t\tgit_buf_truncate(buf, pfx - buf->ptr);\n\n\t\tif (!buf->size)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "buf",
            "pfx - buf->ptr"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "buf",
            "strings->strings[0]"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_common_prefix(git_buf *buf, const git_strarray *strings)\n{\n\tsize_t i;\n\tconst char *str, *pfx;\n\n\tgit_buf_clear(buf);\n\n\tif (!strings || !strings->count)\n\t\treturn 0;\n\n\t/* initialize common prefix to first string */\n\tif (git_buf_sets(buf, strings->strings[0]) < 0)\n\t\treturn -1;\n\n\t/* go through the rest of the strings, truncating to shared prefix */\n\tfor (i = 1; i < strings->count; ++i) {\n\n\t\tfor (str = strings->strings[i], pfx = buf->ptr;\n\t\t\t *str && *str == *pfx; str++, pfx++)\n\t\t\t/* scanning */;\n\n\t\tgit_buf_truncate(buf, pfx - buf->ptr);\n\n\t\tif (!buf->size)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_text_lf_to_crlf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "111-153",
    "snippet": "int git_buf_text_lf_to_crlf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *start = src->ptr;\n\tconst char *end = start + src->size;\n\tconst char *scan = start;\n\tconst char *next = memchr(scan, '\\n', src->size);\n\tsize_t alloclen;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* attempt to reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, src->size, src->size >> 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tif (git_buf_grow(tgt, alloclen) < 0)\n\t\treturn -1;\n\ttgt->size = 0;\n\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\n', end - scan)) {\n\t\tsize_t copylen = next - scan;\n\n\t\t/* if we find mixed line endings, carry on */\n\t\tif (copylen && next[-1] == '\\r')\n\t\t\tcopylen--;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, copylen, 3);\n\t\tif (git_buf_grow_by(tgt, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tif (copylen) {\n\t\t\tmemcpy(tgt->ptr + tgt->size, scan, copylen);\n\t\t\ttgt->size += copylen;\n\t\t}\n\n\t\ttgt->ptr[tgt->size++] = '\\r';\n\t\ttgt->ptr[tgt->size++] = '\\n';\n\t}\n\n\ttgt->ptr[tgt->size] = '\\0';\n\treturn git_buf_put(tgt, scan, end - scan);\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "tgt",
            "scan",
            "end - scan"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt->ptr + tgt->size",
            "scan",
            "copylen"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow_by",
          "args": [
            "tgt",
            "alloclen"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "copylen",
            "3"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "scan",
            "'\\n'",
            "end - scan"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "1"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "src->size",
            "src->size >> 4"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "tgt",
            "src->ptr",
            "src->size"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tgt != src"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "scan",
            "'\\n'",
            "src->size"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_lf_to_crlf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *start = src->ptr;\n\tconst char *end = start + src->size;\n\tconst char *scan = start;\n\tconst char *next = memchr(scan, '\\n', src->size);\n\tsize_t alloclen;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* attempt to reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, src->size, src->size >> 4);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tif (git_buf_grow(tgt, alloclen) < 0)\n\t\treturn -1;\n\ttgt->size = 0;\n\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\n', end - scan)) {\n\t\tsize_t copylen = next - scan;\n\n\t\t/* if we find mixed line endings, carry on */\n\t\tif (copylen && next[-1] == '\\r')\n\t\t\tcopylen--;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, copylen, 3);\n\t\tif (git_buf_grow_by(tgt, alloclen) < 0)\n\t\t\treturn -1;\n\n\t\tif (copylen) {\n\t\t\tmemcpy(tgt->ptr + tgt->size, scan, copylen);\n\t\t\ttgt->size += copylen;\n\t\t}\n\n\t\ttgt->ptr[tgt->size++] = '\\r';\n\t\ttgt->ptr[tgt->size++] = '\\n';\n\t}\n\n\ttgt->ptr[tgt->size] = '\\0';\n\treturn git_buf_put(tgt, scan, end - scan);\n}"
  },
  {
    "function_name": "git_buf_text_crlf_to_lf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "64-109",
    "snippet": "int git_buf_text_crlf_to_lf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *scan = src->ptr;\n\tconst char *scan_end = src->ptr + src->size;\n\tconst char *next = memchr(scan, '\\r', src->size);\n\tsize_t new_size;\n\tchar *out;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&new_size, src->size, 1);\n\tif (git_buf_grow(tgt, new_size) < 0)\n\t\treturn -1;\n\n\tout = tgt->ptr;\n\ttgt->size = 0;\n\n\t/* Find the next \\r and copy whole chunk up to there to tgt */\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\r', scan_end - scan)) {\n\t\tif (next > scan) {\n\t\t\tsize_t copylen = (size_t)(next - scan);\n\t\t\tmemcpy(out, scan, copylen);\n\t\t\tout += copylen;\n\t\t}\n\n\t\t/* Do not drop \\r unless it is followed by \\n */\n\t\tif (next + 1 == scan_end || next[1] != '\\n')\n\t\t\t*out++ = '\\r';\n\t}\n\n\t/* Copy remaining input into dest */\n\tif (scan < scan_end) {\n\t\tsize_t remaining = (size_t)(scan_end - scan);\n\t\tmemcpy(out, scan, remaining);\n\t\tout += remaining;\n\t}\n\n\ttgt->size = (size_t)(out - tgt->ptr);\n\ttgt->ptr[tgt->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "scan",
            "remaining"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out",
            "scan",
            "copylen"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "scan",
            "'\\r'",
            "scan_end - scan"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "tgt",
            "new_size"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&new_size",
            "src->size",
            "1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "tgt",
            "src->ptr",
            "src->size"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tgt != src"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "scan",
            "'\\r'",
            "src->size"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_crlf_to_lf(git_buf *tgt, const git_buf *src)\n{\n\tconst char *scan = src->ptr;\n\tconst char *scan_end = src->ptr + src->size;\n\tconst char *next = memchr(scan, '\\r', src->size);\n\tsize_t new_size;\n\tchar *out;\n\n\tassert(tgt != src);\n\n\tif (!next)\n\t\treturn git_buf_set(tgt, src->ptr, src->size);\n\n\t/* reduce reallocs while in the loop */\n\tGITERR_CHECK_ALLOC_ADD(&new_size, src->size, 1);\n\tif (git_buf_grow(tgt, new_size) < 0)\n\t\treturn -1;\n\n\tout = tgt->ptr;\n\ttgt->size = 0;\n\n\t/* Find the next \\r and copy whole chunk up to there to tgt */\n\tfor (; next; scan = next + 1, next = memchr(scan, '\\r', scan_end - scan)) {\n\t\tif (next > scan) {\n\t\t\tsize_t copylen = (size_t)(next - scan);\n\t\t\tmemcpy(out, scan, copylen);\n\t\t\tout += copylen;\n\t\t}\n\n\t\t/* Do not drop \\r unless it is followed by \\n */\n\t\tif (next + 1 == scan_end || next[1] != '\\n')\n\t\t\t*out++ = '\\r';\n\t}\n\n\t/* Copy remaining input into dest */\n\tif (scan < scan_end) {\n\t\tsize_t remaining = (size_t)(scan_end - scan);\n\t\tmemcpy(out, scan, remaining);\n\t\tout += remaining;\n\t}\n\n\ttgt->size = (size_t)(out - tgt->ptr);\n\ttgt->ptr[tgt->size] = '\\0';\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_buf_text_unescape",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "59-62",
    "snippet": "void git_buf_text_unescape(git_buf *buf)\n{\n\tbuf->size = git__unescape(buf->ptr);\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__unescape",
          "args": [
            "buf->ptr"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "git__unescape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "593-612",
          "snippet": "size_t git__unescape(char *str)\n{\n\tchar *scan, *pos = str;\n\n\tif (!str)\n\t\treturn 0;\n\n\tfor (scan = str; *scan; pos++, scan++) {\n\t\tif (*scan == '\\\\' && *(scan + 1) != '\\0')\n\t\t\tscan++; /* skip '\\' but include next char */\n\t\tif (pos != scan)\n\t\t\t*pos = *scan;\n\t}\n\n\tif (pos != scan) {\n\t\t*pos = '\\0';\n\t}\n\n\treturn (pos - str);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nsize_t git__unescape(char *str)\n{\n\tchar *scan, *pos = str;\n\n\tif (!str)\n\t\treturn 0;\n\n\tfor (scan = str; *scan; pos++, scan++) {\n\t\tif (*scan == '\\\\' && *(scan + 1) != '\\0')\n\t\t\tscan++; /* skip '\\' but include next char */\n\t\tif (pos != scan)\n\t\t\t*pos = *scan;\n\t}\n\n\tif (pos != scan) {\n\t\t*pos = '\\0';\n\t}\n\n\treturn (pos - str);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nvoid git_buf_text_unescape(git_buf *buf)\n{\n\tbuf->size = git__unescape(buf->ptr);\n}"
  },
  {
    "function_name": "git_buf_text_puts_escaped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
    "lines": "9-57",
    "snippet": "int git_buf_text_puts_escaped(\n\tgit_buf *buf,\n\tconst char *string,\n\tconst char *esc_chars,\n\tconst char *esc_with)\n{\n\tconst char *scan;\n\tsize_t total = 0, esc_len = strlen(esc_with), count, alloclen;\n\n\tif (!string)\n\t\treturn 0;\n\n\tfor (scan = string; *scan; ) {\n\t\t/* count run of non-escaped characters */\n\t\tcount = strcspn(scan, esc_chars);\n\t\ttotal += count;\n\t\tscan += count;\n\t\t/* count run of escaped characters */\n\t\tcount = strspn(scan, esc_chars);\n\t\ttotal += count * (esc_len + 1);\n\t\tscan += count;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, total, 1);\n\tif (git_buf_grow_by(buf, alloclen) < 0)\n\t\treturn -1;\n\n\tfor (scan = string; *scan; ) {\n\t\tcount = strcspn(scan, esc_chars);\n\n\t\tmemmove(buf->ptr + buf->size, scan, count);\n\t\tscan += count;\n\t\tbuf->size += count;\n\n\t\tfor (count = strspn(scan, esc_chars); count > 0; --count) {\n\t\t\t/* copy escape sequence */\n\t\t\tmemmove(buf->ptr + buf->size, esc_with, esc_len);\n\t\t\tbuf->size += esc_len;\n\t\t\t/* copy character to be escaped */\n\t\t\tbuf->ptr[buf->size] = *scan;\n\t\t\tbuf->size++;\n\t\t\tscan++;\n\t\t}\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buf_text.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->ptr + buf->size",
            "esc_with",
            "esc_len"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "scan",
            "esc_chars"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf->ptr + buf->size",
            "scan",
            "count"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "scan",
            "esc_chars"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_grow_by",
          "args": [
            "buf",
            "alloclen"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "total",
            "1"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "scan",
            "esc_chars"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "scan",
            "esc_chars"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "esc_with"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_puts_escaped(\n\tgit_buf *buf,\n\tconst char *string,\n\tconst char *esc_chars,\n\tconst char *esc_with)\n{\n\tconst char *scan;\n\tsize_t total = 0, esc_len = strlen(esc_with), count, alloclen;\n\n\tif (!string)\n\t\treturn 0;\n\n\tfor (scan = string; *scan; ) {\n\t\t/* count run of non-escaped characters */\n\t\tcount = strcspn(scan, esc_chars);\n\t\ttotal += count;\n\t\tscan += count;\n\t\t/* count run of escaped characters */\n\t\tcount = strspn(scan, esc_chars);\n\t\ttotal += count * (esc_len + 1);\n\t\tscan += count;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, total, 1);\n\tif (git_buf_grow_by(buf, alloclen) < 0)\n\t\treturn -1;\n\n\tfor (scan = string; *scan; ) {\n\t\tcount = strcspn(scan, esc_chars);\n\n\t\tmemmove(buf->ptr + buf->size, scan, count);\n\t\tscan += count;\n\t\tbuf->size += count;\n\n\t\tfor (count = strspn(scan, esc_chars); count > 0; --count) {\n\t\t\t/* copy escape sequence */\n\t\t\tmemmove(buf->ptr + buf->size, esc_with, esc_len);\n\t\t\tbuf->size += esc_len;\n\t\t\t/* copy character to be escaped */\n\t\t\tbuf->ptr[buf->size] = *scan;\n\t\t\tbuf->size++;\n\t\t\tscan++;\n\t\t}\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
  }
]