[
  {
    "function_name": "git__delta_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
    "lines": "83-166",
    "snippet": "int git__delta_apply(\n\tgit_rawobj *out,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t/* Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\tout->data = res_dp;\n\tout->len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base.\n\t\t\t */\n\t\t\tsize_t off = 0, len = 0;\n\n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= *delta++ << 24UL;\n\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n\t\t\tif (!len)\t\tlen = 0x10000;\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/* cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings.\n\t\t\t */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(out->data);\n\tout->data = NULL;\n\tgiterr_set(GITERR_INVALID, \"Failed to apply delta\");\n\treturn -1;\n}",
    "includes": [
      "#include \"delta-apply.h\"",
      "#include \"git2/odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Failed to apply delta\""
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "out->data"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res_dp",
            "delta",
            "cmd"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res_dp",
            "base + off",
            "len"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "res_dp"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "alloc_sz"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_sz",
            "res_sz",
            "1"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hdr_sz",
          "args": [
            "&res_sz",
            "&delta",
            "delta_end"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "hdr_sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
          "lines": "18-37",
          "snippet": "static int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"delta-apply.h\"",
            "#include \"git2/odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nstatic int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nint git__delta_apply(\n\tgit_rawobj *out,\n\tconst unsigned char *base,\n\tsize_t base_len,\n\tconst unsigned char *delta,\n\tsize_t delta_len)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tsize_t base_sz, res_sz, alloc_sz;\n\tunsigned char *res_dp;\n\n\t/* Check that the base size matches the data we were given;\n\t * if not we would underflow while accessing data from the\n\t * base object, resulting in data corruption or segfault.\n\t */\n\tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tif (hdr_sz(&res_sz, &delta, delta_end) < 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to apply delta. Base size does not match given data\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);\n\tres_dp = git__malloc(alloc_sz);\n\tGITERR_CHECK_ALLOC(res_dp);\n\n\tres_dp[res_sz] = '\\0';\n\tout->data = res_dp;\n\tout->len = res_sz;\n\n\twhile (delta < delta_end) {\n\t\tunsigned char cmd = *delta++;\n\t\tif (cmd & 0x80) {\n\t\t\t/* cmd is a copy instruction; copy from the base.\n\t\t\t */\n\t\t\tsize_t off = 0, len = 0;\n\n\t\t\tif (cmd & 0x01) off = *delta++;\n\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n\t\t\tif (cmd & 0x08) off |= *delta++ << 24UL;\n\n\t\t\tif (cmd & 0x10) len = *delta++;\n\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n\t\t\tif (!len)\t\tlen = 0x10000;\n\n\t\t\tif (base_len < off + len || res_sz < len)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, base + off, len);\n\t\t\tres_dp += len;\n\t\t\tres_sz -= len;\n\n\t\t} else if (cmd) {\n\t\t\t/* cmd is a literal insert instruction; copy from\n\t\t\t * the delta stream itself.\n\t\t\t */\n\t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n\t\t\t\tgoto fail;\n\t\t\tmemcpy(res_dp, delta, cmd);\n\t\t\tdelta += cmd;\n\t\t\tres_dp += cmd;\n\t\t\tres_sz -= cmd;\n\n\t\t} else {\n\t\t\t/* cmd == 0 is reserved for future encodings.\n\t\t\t */\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (delta != delta_end || res_sz)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgit__free(out->data);\n\tout->data = NULL;\n\tgiterr_set(GITERR_INVALID, \"Failed to apply delta\");\n\treturn -1;\n}"
  },
  {
    "function_name": "git__delta_read_header_fromstream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
    "lines": "53-81",
    "snippet": "int git__delta_read_header_fromstream(size_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\n\t\tif (read == 0)\n\t\t\tbreak;\n\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\n\t\tlen += read;\n\t}\n\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t    (hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"delta-apply.h\"",
      "#include \"git2/odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define DELTA_HEADER_BUFFER_LEN 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr_sz",
          "args": [
            "res_sz",
            "&delta",
            "delta_end"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "hdr_sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
          "lines": "18-37",
          "snippet": "static int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"delta-apply.h\"",
            "#include \"git2/odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nstatic int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_packfile_stream_read",
          "args": [
            "stream",
            "&buffer[len]",
            "buffer_len - len"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "git_packfile_stream_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pack.c",
          "lines": "801-839",
          "snippet": "ssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}",
          "includes": [
            "#include <zlib.h>",
            "#include \"oid.h\"",
            "#include \"fileops.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"pack.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_open(struct git_pack_file *p);",
            "static int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <zlib.h>\n#include \"oid.h\"\n#include \"fileops.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"pack.h\"\n#include \"odb.h\"\n#include \"common.h\"\n\nstatic int packfile_open(struct git_pack_file *p);\nstatic int pack_entry_find_offset(\n\t\tgit_off_t *offset_out,\n\t\tgit_oid *found_oid,\n\t\tstruct git_pack_file *p,\n\t\tconst git_oid *short_oid,\n\t\tsize_t len);\n\nssize_t git_packfile_stream_read(git_packfile_stream *obj, void *buffer, size_t len)\n{\n\tunsigned char *in;\n\tsize_t written;\n\tint st;\n\n\tif (obj->done)\n\t\treturn 0;\n\n\tin = pack_window_open(obj->p, &obj->mw, obj->curpos, &obj->zstream.avail_in);\n\tif (in == NULL)\n\t\treturn GIT_EBUFS;\n\n\tobj->zstream.next_out = buffer;\n\tobj->zstream.avail_out = (unsigned int)len;\n\tobj->zstream.next_in = in;\n\n\tst = inflate(&obj->zstream, Z_SYNC_FLUSH);\n\tgit_mwindow_close(&obj->mw);\n\n\tobj->curpos += obj->zstream.next_in - in;\n\twritten = len - obj->zstream.avail_out;\n\n\tif (st != Z_OK && st != Z_STREAM_END) {\n\t\tgiterr_set(GITERR_ZLIB, \"error reading from the zlib stream\");\n\t\treturn -1;\n\t}\n\n\tif (st == Z_STREAM_END)\n\t\tobj->done = 1;\n\n\n\t/* If we didn't write anything out but we're not done, we need more data */\n\tif (!written && st != Z_STREAM_END)\n\t\treturn GIT_EBUFS;\n\n\treturn written;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\n#define DELTA_HEADER_BUFFER_LEN 16\n\nint git__delta_read_header_fromstream(size_t *base_sz, size_t *res_sz, git_packfile_stream *stream)\n{\n\tstatic const size_t buffer_len = DELTA_HEADER_BUFFER_LEN;\n\tunsigned char buffer[DELTA_HEADER_BUFFER_LEN];\n\tconst unsigned char *delta, *delta_end;\n\tsize_t len;\n\tssize_t read;\n\n\tlen = read = 0;\n\twhile (len < buffer_len) {\n\t\tread = git_packfile_stream_read(stream, &buffer[len], buffer_len - len);\n\n\t\tif (read == 0)\n\t\t\tbreak;\n\n\t\tif (read == GIT_EBUFS)\n\t\t\tcontinue;\n\n\t\tlen += read;\n\t}\n\n\tdelta = buffer;\n\tdelta_end = delta + len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t    (hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git__delta_read_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
    "lines": "39-50",
    "snippet": "int git__delta_read_header(\n\tconst unsigned char *delta,\n\tsize_t delta_len,\n\tsize_t *base_sz,\n\tsize_t *res_sz)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t    (hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"delta-apply.h\"",
      "#include \"git2/odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hdr_sz",
          "args": [
            "res_sz",
            "&delta",
            "delta_end"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "hdr_sz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
          "lines": "18-37",
          "snippet": "static int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}",
          "includes": [
            "#include \"delta-apply.h\"",
            "#include \"git2/odb.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nstatic int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nint git__delta_read_header(\n\tconst unsigned char *delta,\n\tsize_t delta_len,\n\tsize_t *base_sz,\n\tsize_t *res_sz)\n{\n\tconst unsigned char *delta_end = delta + delta_len;\n\tif ((hdr_sz(base_sz, &delta, delta_end) < 0) ||\n\t    (hdr_sz(res_sz, &delta, delta_end) < 0))\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "hdr_sz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/delta-apply.c",
    "lines": "18-37",
    "snippet": "static int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}",
    "includes": [
      "#include \"delta-apply.h\"",
      "#include \"git2/odb.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"delta-apply.h\"\n#include \"git2/odb.h\"\n#include \"common.h\"\n\nstatic int hdr_sz(\n\tsize_t *size,\n\tconst unsigned char **delta,\n\tconst unsigned char *end)\n{\n\tconst unsigned char *d = *delta;\n\tsize_t r = 0;\n\tunsigned int c, shift = 0;\n\n\tdo {\n\t\tif (d == end)\n\t\t\treturn -1;\n\t\tc = *d++;\n\t\tr |= (c & 0x7f) << shift;\n\t\tshift += 7;\n\t} while (c & 0x80);\n\t*delta = d;\n\t*size = r;\n\treturn 0;\n}"
  }
]