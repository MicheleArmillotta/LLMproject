[
  {
    "function_name": "p_fnmatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
    "lines": "230-234",
    "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_fnmatchx",
          "args": [
            "pattern",
            "string",
            "flags",
            "64"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatchx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "61-174",
          "snippet": "static int\np_fnmatchx(const char *pattern, const char *string, int flags, size_t recurs)\n{\n\t\tconst char *stringstart;\n\t\tchar *newp;\n\t\tchar c, test;\n\t\tint recurs_flags = flags & ~FNM_PERIOD;\n\n\t\tif (recurs-- == 0)\n\t\t\t\treturn FNM_NORES;\n\n\t\tfor (stringstart = string;;)\n\t\t\t\tswitch (c = *pattern++) {\n\t\t\t\tcase EOS:\n\t\t\t\t\t\tif ((flags & FNM_LEADING_DIR) && *string == '/')\n\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\treturn (*string == EOS ? 0 : FNM_NOMATCH);\n\t\t\t\tcase '?':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\t\tc = *pattern;\n\n\t\t\t\t\t\t/* Let '**' override PATHNAME match for this segment.\n\t\t\t\t\t\t * It will be restored if/when we recurse below.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (c == '*') {\n\t\t\t\t\t\t\tflags &= ~FNM_PATHNAME;\n\t\t\t\t\t\t\twhile (c == '*')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t\tif (c == '/')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\t/* Optimize for pattern with * at end or before /. */\n\t\t\t\t\t\tif (c == EOS) {\n\t\t\t\t\t\t\t\tif (flags & FNM_PATHNAME)\n\t\t\t\t\t\t\t\t\t\treturn ((flags & FNM_LEADING_DIR) ||\n\t\t\t\t\t\t\t\t\t\t\tstrchr(string, '/') == NULL ?\n\t\t\t\t\t\t\t\t\t\t\t0 : FNM_NOMATCH);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\t} else if (c == '/' && (flags & FNM_PATHNAME)) {\n\t\t\t\t\t\t\t\tif ((string = strchr(string, '/')) == NULL)\n\t\t\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* General case, use recursion. */\n\t\t\t\t\t\twhile ((test = *string) != EOS) {\n\t\t\t\t\t\t\t\tint e;\n\n\t\t\t\t\t\t\t\te = p_fnmatchx(pattern, string, recurs_flags, recurs);\n\t\t\t\t\t\t\t\tif (e != FNM_NOMATCH)\n\t\t\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\t\tif (test == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t++string;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\tcase '[':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\tswitch (rangematch(pattern, *string, flags, &newp)) {\n\t\t\t\t\t\tcase RANGE_ERROR:\n\t\t\t\t\t\t\t\t/* not a good range, treat as normal text */\n\t\t\t\t\t\t\t\tgoto normal;\n\t\t\t\t\t\tcase RANGE_MATCH:\n\t\t\t\t\t\t\t\tpattern = newp;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RANGE_NOMATCH:\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (!(flags & FNM_NOESCAPE)) {\n\t\t\t\t\t\t\t\tif ((c = *pattern++) == EOS) {\n\t\t\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\t\t\t--pattern;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\tnormal:\n\t\t\t\t\t\tif (c != *string && !((flags & FNM_CASEFOLD) &&\n\t\t\t\t\t\t\t\t\t(git__tolower((unsigned char)c) ==\n\t\t\t\t\t\t\t\t\tgit__tolower((unsigned char)*string))))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t/* NOTREACHED */\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [
            "#define RANGE_ERROR\t\t(-1)",
            "#define RANGE_NOMATCH\t\t0",
            "#define RANGE_MATCH\t\t1",
            "#define EOS\t\t'\\0'"
          ],
          "globals_used": [
            "static int rangematch(const char *, char, int, char **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#define RANGE_ERROR\t\t(-1)\n#define RANGE_NOMATCH\t\t0\n#define RANGE_MATCH\t\t1\n#define EOS\t\t'\\0'\n\nstatic int rangematch(const char *, char, int, char **);\n\nstatic int\np_fnmatchx(const char *pattern, const char *string, int flags, size_t recurs)\n{\n\t\tconst char *stringstart;\n\t\tchar *newp;\n\t\tchar c, test;\n\t\tint recurs_flags = flags & ~FNM_PERIOD;\n\n\t\tif (recurs-- == 0)\n\t\t\t\treturn FNM_NORES;\n\n\t\tfor (stringstart = string;;)\n\t\t\t\tswitch (c = *pattern++) {\n\t\t\t\tcase EOS:\n\t\t\t\t\t\tif ((flags & FNM_LEADING_DIR) && *string == '/')\n\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\treturn (*string == EOS ? 0 : FNM_NOMATCH);\n\t\t\t\tcase '?':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\t\tc = *pattern;\n\n\t\t\t\t\t\t/* Let '**' override PATHNAME match for this segment.\n\t\t\t\t\t\t * It will be restored if/when we recurse below.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (c == '*') {\n\t\t\t\t\t\t\tflags &= ~FNM_PATHNAME;\n\t\t\t\t\t\t\twhile (c == '*')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t\tif (c == '/')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\t/* Optimize for pattern with * at end or before /. */\n\t\t\t\t\t\tif (c == EOS) {\n\t\t\t\t\t\t\t\tif (flags & FNM_PATHNAME)\n\t\t\t\t\t\t\t\t\t\treturn ((flags & FNM_LEADING_DIR) ||\n\t\t\t\t\t\t\t\t\t\t\tstrchr(string, '/') == NULL ?\n\t\t\t\t\t\t\t\t\t\t\t0 : FNM_NOMATCH);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\t} else if (c == '/' && (flags & FNM_PATHNAME)) {\n\t\t\t\t\t\t\t\tif ((string = strchr(string, '/')) == NULL)\n\t\t\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* General case, use recursion. */\n\t\t\t\t\t\twhile ((test = *string) != EOS) {\n\t\t\t\t\t\t\t\tint e;\n\n\t\t\t\t\t\t\t\te = p_fnmatchx(pattern, string, recurs_flags, recurs);\n\t\t\t\t\t\t\t\tif (e != FNM_NOMATCH)\n\t\t\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\t\tif (test == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t++string;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\tcase '[':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\tswitch (rangematch(pattern, *string, flags, &newp)) {\n\t\t\t\t\t\tcase RANGE_ERROR:\n\t\t\t\t\t\t\t\t/* not a good range, treat as normal text */\n\t\t\t\t\t\t\t\tgoto normal;\n\t\t\t\t\t\tcase RANGE_MATCH:\n\t\t\t\t\t\t\t\tpattern = newp;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RANGE_NOMATCH:\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (!(flags & FNM_NOESCAPE)) {\n\t\t\t\t\t\t\t\tif ((c = *pattern++) == EOS) {\n\t\t\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\t\t\t--pattern;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\tnormal:\n\t\t\t\t\t\tif (c != *string && !((flags & FNM_CASEFOLD) &&\n\t\t\t\t\t\t\t\t\t(git__tolower((unsigned char)c) ==\n\t\t\t\t\t\t\t\t\tgit__tolower((unsigned char)*string))))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t/* NOTREACHED */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
  },
  {
    "function_name": "rangematch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
    "lines": "176-228",
    "snippet": "static int\nrangematch(const char *pattern, char test, int flags, char **newp)\n{\n\t\tint negate, ok;\n\t\tchar c, c2;\n\n\t\t/*\n\t\t\t* A bracket expression starting with an unquoted circumflex\n\t\t\t* character produces unspecified results (IEEE 1003.2-1992,\n\t\t\t* 3.13.2). This implementation treats it like '!', for\n\t\t\t* consistency with the regular expression syntax.\n\t\t\t* J.T. Conklin (conklin@ngai.kaleida.com)\n\t\t\t*/\n\t\tif ((negate = (*pattern == '!' || *pattern == '^')) != 0)\n\t\t\t\t++pattern;\n\n\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\ttest = (char)git__tolower((unsigned char)test);\n\n\t\t/*\n\t\t\t* A right bracket shall lose its special meaning and represent\n\t\t\t* itself in a bracket expression if it occurs first in the list.\n\t\t\t* -- POSIX.2 2.8.3.2\n\t\t\t*/\n\t\tok = 0;\n\t\tc = *pattern++;\n\t\tdo {\n\t\t\t\tif (c == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\tc = *pattern++;\n\t\t\t\tif (c == EOS)\n\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\tif (c == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\treturn (RANGE_NOMATCH);\n\t\t\t\tif ((flags & FNM_CASEFOLD))\n\t\t\t\t\t\tc = (char)git__tolower((unsigned char)c);\n\t\t\t\tif (*pattern == '-'\n\t\t\t\t\t&& (c2 = *(pattern+1)) != EOS && c2 != ']') {\n\t\t\t\t\t\tpattern += 2;\n\t\t\t\t\t\tif (c2 == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\t\t\tc2 = *pattern++;\n\t\t\t\t\t\tif (c2 == EOS)\n\t\t\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\t\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\t\t\t\t\tc2 = (char)git__tolower((unsigned char)c2);\n\t\t\t\t\t\tif (c <= test && test <= c2)\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t} else if (c == test)\n\t\t\t\t\t\tok = 1;\n\t\t} while ((c = *pattern++) != ']');\n\n\t\t*newp = (char *)pattern;\n\t\treturn (ok == negate ? RANGE_NOMATCH : RANGE_MATCH);\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [
      "#define RANGE_ERROR\t\t(-1)",
      "#define RANGE_NOMATCH\t\t0",
      "#define RANGE_MATCH\t\t1",
      "#define EOS\t\t'\\0'"
    ],
    "globals_used": [
      "static int rangematch(const char *, char, int, char **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__tolower",
          "args": [
            "(unsigned char)c2"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "git__tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "285-288",
          "snippet": "GIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#define RANGE_ERROR\t\t(-1)\n#define RANGE_NOMATCH\t\t0\n#define RANGE_MATCH\t\t1\n#define EOS\t\t'\\0'\n\nstatic int rangematch(const char *, char, int, char **);\n\nstatic int\nrangematch(const char *pattern, char test, int flags, char **newp)\n{\n\t\tint negate, ok;\n\t\tchar c, c2;\n\n\t\t/*\n\t\t\t* A bracket expression starting with an unquoted circumflex\n\t\t\t* character produces unspecified results (IEEE 1003.2-1992,\n\t\t\t* 3.13.2). This implementation treats it like '!', for\n\t\t\t* consistency with the regular expression syntax.\n\t\t\t* J.T. Conklin (conklin@ngai.kaleida.com)\n\t\t\t*/\n\t\tif ((negate = (*pattern == '!' || *pattern == '^')) != 0)\n\t\t\t\t++pattern;\n\n\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\ttest = (char)git__tolower((unsigned char)test);\n\n\t\t/*\n\t\t\t* A right bracket shall lose its special meaning and represent\n\t\t\t* itself in a bracket expression if it occurs first in the list.\n\t\t\t* -- POSIX.2 2.8.3.2\n\t\t\t*/\n\t\tok = 0;\n\t\tc = *pattern++;\n\t\tdo {\n\t\t\t\tif (c == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\tc = *pattern++;\n\t\t\t\tif (c == EOS)\n\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\tif (c == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\treturn (RANGE_NOMATCH);\n\t\t\t\tif ((flags & FNM_CASEFOLD))\n\t\t\t\t\t\tc = (char)git__tolower((unsigned char)c);\n\t\t\t\tif (*pattern == '-'\n\t\t\t\t\t&& (c2 = *(pattern+1)) != EOS && c2 != ']') {\n\t\t\t\t\t\tpattern += 2;\n\t\t\t\t\t\tif (c2 == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\t\t\tc2 = *pattern++;\n\t\t\t\t\t\tif (c2 == EOS)\n\t\t\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\t\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\t\t\t\t\tc2 = (char)git__tolower((unsigned char)c2);\n\t\t\t\t\t\tif (c <= test && test <= c2)\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t} else if (c == test)\n\t\t\t\t\t\tok = 1;\n\t\t} while ((c = *pattern++) != ']');\n\n\t\t*newp = (char *)pattern;\n\t\treturn (ok == negate ? RANGE_NOMATCH : RANGE_MATCH);\n}"
  },
  {
    "function_name": "p_fnmatchx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
    "lines": "61-174",
    "snippet": "static int\np_fnmatchx(const char *pattern, const char *string, int flags, size_t recurs)\n{\n\t\tconst char *stringstart;\n\t\tchar *newp;\n\t\tchar c, test;\n\t\tint recurs_flags = flags & ~FNM_PERIOD;\n\n\t\tif (recurs-- == 0)\n\t\t\t\treturn FNM_NORES;\n\n\t\tfor (stringstart = string;;)\n\t\t\t\tswitch (c = *pattern++) {\n\t\t\t\tcase EOS:\n\t\t\t\t\t\tif ((flags & FNM_LEADING_DIR) && *string == '/')\n\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\treturn (*string == EOS ? 0 : FNM_NOMATCH);\n\t\t\t\tcase '?':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\t\tc = *pattern;\n\n\t\t\t\t\t\t/* Let '**' override PATHNAME match for this segment.\n\t\t\t\t\t\t * It will be restored if/when we recurse below.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (c == '*') {\n\t\t\t\t\t\t\tflags &= ~FNM_PATHNAME;\n\t\t\t\t\t\t\twhile (c == '*')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t\tif (c == '/')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\t/* Optimize for pattern with * at end or before /. */\n\t\t\t\t\t\tif (c == EOS) {\n\t\t\t\t\t\t\t\tif (flags & FNM_PATHNAME)\n\t\t\t\t\t\t\t\t\t\treturn ((flags & FNM_LEADING_DIR) ||\n\t\t\t\t\t\t\t\t\t\t\tstrchr(string, '/') == NULL ?\n\t\t\t\t\t\t\t\t\t\t\t0 : FNM_NOMATCH);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\t} else if (c == '/' && (flags & FNM_PATHNAME)) {\n\t\t\t\t\t\t\t\tif ((string = strchr(string, '/')) == NULL)\n\t\t\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* General case, use recursion. */\n\t\t\t\t\t\twhile ((test = *string) != EOS) {\n\t\t\t\t\t\t\t\tint e;\n\n\t\t\t\t\t\t\t\te = p_fnmatchx(pattern, string, recurs_flags, recurs);\n\t\t\t\t\t\t\t\tif (e != FNM_NOMATCH)\n\t\t\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\t\tif (test == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t++string;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\tcase '[':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\tswitch (rangematch(pattern, *string, flags, &newp)) {\n\t\t\t\t\t\tcase RANGE_ERROR:\n\t\t\t\t\t\t\t\t/* not a good range, treat as normal text */\n\t\t\t\t\t\t\t\tgoto normal;\n\t\t\t\t\t\tcase RANGE_MATCH:\n\t\t\t\t\t\t\t\tpattern = newp;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RANGE_NOMATCH:\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (!(flags & FNM_NOESCAPE)) {\n\t\t\t\t\t\t\t\tif ((c = *pattern++) == EOS) {\n\t\t\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\t\t\t--pattern;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\tnormal:\n\t\t\t\t\t\tif (c != *string && !((flags & FNM_CASEFOLD) &&\n\t\t\t\t\t\t\t\t\t(git__tolower((unsigned char)c) ==\n\t\t\t\t\t\t\t\t\tgit__tolower((unsigned char)*string))))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t/* NOTREACHED */\n}",
    "includes": [
      "#include \"fnmatch.h\"",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <ctype.h>"
    ],
    "macros_used": [
      "#define RANGE_ERROR\t\t(-1)",
      "#define RANGE_NOMATCH\t\t0",
      "#define RANGE_MATCH\t\t1",
      "#define EOS\t\t'\\0'"
    ],
    "globals_used": [
      "static int rangematch(const char *, char, int, char **);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__tolower",
          "args": [
            "(unsigned char)*string"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "git__tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "285-288",
          "snippet": "GIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rangematch",
          "args": [
            "pattern",
            "*string",
            "flags",
            "&newp"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "rangematch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "176-228",
          "snippet": "static int\nrangematch(const char *pattern, char test, int flags, char **newp)\n{\n\t\tint negate, ok;\n\t\tchar c, c2;\n\n\t\t/*\n\t\t\t* A bracket expression starting with an unquoted circumflex\n\t\t\t* character produces unspecified results (IEEE 1003.2-1992,\n\t\t\t* 3.13.2). This implementation treats it like '!', for\n\t\t\t* consistency with the regular expression syntax.\n\t\t\t* J.T. Conklin (conklin@ngai.kaleida.com)\n\t\t\t*/\n\t\tif ((negate = (*pattern == '!' || *pattern == '^')) != 0)\n\t\t\t\t++pattern;\n\n\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\ttest = (char)git__tolower((unsigned char)test);\n\n\t\t/*\n\t\t\t* A right bracket shall lose its special meaning and represent\n\t\t\t* itself in a bracket expression if it occurs first in the list.\n\t\t\t* -- POSIX.2 2.8.3.2\n\t\t\t*/\n\t\tok = 0;\n\t\tc = *pattern++;\n\t\tdo {\n\t\t\t\tif (c == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\tc = *pattern++;\n\t\t\t\tif (c == EOS)\n\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\tif (c == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\treturn (RANGE_NOMATCH);\n\t\t\t\tif ((flags & FNM_CASEFOLD))\n\t\t\t\t\t\tc = (char)git__tolower((unsigned char)c);\n\t\t\t\tif (*pattern == '-'\n\t\t\t\t\t&& (c2 = *(pattern+1)) != EOS && c2 != ']') {\n\t\t\t\t\t\tpattern += 2;\n\t\t\t\t\t\tif (c2 == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\t\t\tc2 = *pattern++;\n\t\t\t\t\t\tif (c2 == EOS)\n\t\t\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\t\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\t\t\t\t\tc2 = (char)git__tolower((unsigned char)c2);\n\t\t\t\t\t\tif (c <= test && test <= c2)\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t} else if (c == test)\n\t\t\t\t\t\tok = 1;\n\t\t} while ((c = *pattern++) != ']');\n\n\t\t*newp = (char *)pattern;\n\t\treturn (ok == negate ? RANGE_NOMATCH : RANGE_MATCH);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [
            "#define RANGE_ERROR\t\t(-1)",
            "#define RANGE_NOMATCH\t\t0",
            "#define RANGE_MATCH\t\t1",
            "#define EOS\t\t'\\0'"
          ],
          "globals_used": [
            "static int rangematch(const char *, char, int, char **);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#define RANGE_ERROR\t\t(-1)\n#define RANGE_NOMATCH\t\t0\n#define RANGE_MATCH\t\t1\n#define EOS\t\t'\\0'\n\nstatic int rangematch(const char *, char, int, char **);\n\nstatic int\nrangematch(const char *pattern, char test, int flags, char **newp)\n{\n\t\tint negate, ok;\n\t\tchar c, c2;\n\n\t\t/*\n\t\t\t* A bracket expression starting with an unquoted circumflex\n\t\t\t* character produces unspecified results (IEEE 1003.2-1992,\n\t\t\t* 3.13.2). This implementation treats it like '!', for\n\t\t\t* consistency with the regular expression syntax.\n\t\t\t* J.T. Conklin (conklin@ngai.kaleida.com)\n\t\t\t*/\n\t\tif ((negate = (*pattern == '!' || *pattern == '^')) != 0)\n\t\t\t\t++pattern;\n\n\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\ttest = (char)git__tolower((unsigned char)test);\n\n\t\t/*\n\t\t\t* A right bracket shall lose its special meaning and represent\n\t\t\t* itself in a bracket expression if it occurs first in the list.\n\t\t\t* -- POSIX.2 2.8.3.2\n\t\t\t*/\n\t\tok = 0;\n\t\tc = *pattern++;\n\t\tdo {\n\t\t\t\tif (c == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\tc = *pattern++;\n\t\t\t\tif (c == EOS)\n\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\tif (c == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\treturn (RANGE_NOMATCH);\n\t\t\t\tif ((flags & FNM_CASEFOLD))\n\t\t\t\t\t\tc = (char)git__tolower((unsigned char)c);\n\t\t\t\tif (*pattern == '-'\n\t\t\t\t\t&& (c2 = *(pattern+1)) != EOS && c2 != ']') {\n\t\t\t\t\t\tpattern += 2;\n\t\t\t\t\t\tif (c2 == '\\\\' && !(flags & FNM_NOESCAPE))\n\t\t\t\t\t\t\t\tc2 = *pattern++;\n\t\t\t\t\t\tif (c2 == EOS)\n\t\t\t\t\t\t\t\treturn (RANGE_ERROR);\n\t\t\t\t\t\tif (flags & FNM_CASEFOLD)\n\t\t\t\t\t\t\t\tc2 = (char)git__tolower((unsigned char)c2);\n\t\t\t\t\t\tif (c <= test && test <= c2)\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t} else if (c == test)\n\t\t\t\t\t\tok = 1;\n\t\t} while ((c = *pattern++) != ']');\n\n\t\t*newp = (char *)pattern;\n\t\treturn (ok == negate ? RANGE_NOMATCH : RANGE_MATCH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fnmatchx",
          "args": [
            "pattern",
            "string",
            "recurs_flags",
            "recurs"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatchx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "61-174",
          "snippet": "static int\np_fnmatchx(const char *pattern, const char *string, int flags, size_t recurs)\n{\n\t\tconst char *stringstart;\n\t\tchar *newp;\n\t\tchar c, test;\n\t\tint recurs_flags = flags & ~FNM_PERIOD;\n\n\t\tif (recurs-- == 0)\n\t\t\t\treturn FNM_NORES;\n\n\t\tfor (stringstart = string;;)\n\t\t\t\tswitch (c = *pattern++) {\n\t\t\t\tcase EOS:\n\t\t\t\t\t\tif ((flags & FNM_LEADING_DIR) && *string == '/')\n\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\treturn (*string == EOS ? 0 : FNM_NOMATCH);\n\t\t\t\tcase '?':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\t\tc = *pattern;\n\n\t\t\t\t\t\t/* Let '**' override PATHNAME match for this segment.\n\t\t\t\t\t\t * It will be restored if/when we recurse below.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (c == '*') {\n\t\t\t\t\t\t\tflags &= ~FNM_PATHNAME;\n\t\t\t\t\t\t\twhile (c == '*')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t\tif (c == '/')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\t/* Optimize for pattern with * at end or before /. */\n\t\t\t\t\t\tif (c == EOS) {\n\t\t\t\t\t\t\t\tif (flags & FNM_PATHNAME)\n\t\t\t\t\t\t\t\t\t\treturn ((flags & FNM_LEADING_DIR) ||\n\t\t\t\t\t\t\t\t\t\t\tstrchr(string, '/') == NULL ?\n\t\t\t\t\t\t\t\t\t\t\t0 : FNM_NOMATCH);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\t} else if (c == '/' && (flags & FNM_PATHNAME)) {\n\t\t\t\t\t\t\t\tif ((string = strchr(string, '/')) == NULL)\n\t\t\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* General case, use recursion. */\n\t\t\t\t\t\twhile ((test = *string) != EOS) {\n\t\t\t\t\t\t\t\tint e;\n\n\t\t\t\t\t\t\t\te = p_fnmatchx(pattern, string, recurs_flags, recurs);\n\t\t\t\t\t\t\t\tif (e != FNM_NOMATCH)\n\t\t\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\t\tif (test == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t++string;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\tcase '[':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\tswitch (rangematch(pattern, *string, flags, &newp)) {\n\t\t\t\t\t\tcase RANGE_ERROR:\n\t\t\t\t\t\t\t\t/* not a good range, treat as normal text */\n\t\t\t\t\t\t\t\tgoto normal;\n\t\t\t\t\t\tcase RANGE_MATCH:\n\t\t\t\t\t\t\t\tpattern = newp;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RANGE_NOMATCH:\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (!(flags & FNM_NOESCAPE)) {\n\t\t\t\t\t\t\t\tif ((c = *pattern++) == EOS) {\n\t\t\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\t\t\t--pattern;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\tnormal:\n\t\t\t\t\t\tif (c != *string && !((flags & FNM_CASEFOLD) &&\n\t\t\t\t\t\t\t\t\t(git__tolower((unsigned char)c) ==\n\t\t\t\t\t\t\t\t\tgit__tolower((unsigned char)*string))))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t/* NOTREACHED */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "string",
            "'/'"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "string",
            "'/'"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\n#define RANGE_ERROR\t\t(-1)\n#define RANGE_NOMATCH\t\t0\n#define RANGE_MATCH\t\t1\n#define EOS\t\t'\\0'\n\nstatic int rangematch(const char *, char, int, char **);\n\nstatic int\np_fnmatchx(const char *pattern, const char *string, int flags, size_t recurs)\n{\n\t\tconst char *stringstart;\n\t\tchar *newp;\n\t\tchar c, test;\n\t\tint recurs_flags = flags & ~FNM_PERIOD;\n\n\t\tif (recurs-- == 0)\n\t\t\t\treturn FNM_NORES;\n\n\t\tfor (stringstart = string;;)\n\t\t\t\tswitch (c = *pattern++) {\n\t\t\t\tcase EOS:\n\t\t\t\t\t\tif ((flags & FNM_LEADING_DIR) && *string == '/')\n\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\treturn (*string == EOS ? 0 : FNM_NOMATCH);\n\t\t\t\tcase '?':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\t\tc = *pattern;\n\n\t\t\t\t\t\t/* Let '**' override PATHNAME match for this segment.\n\t\t\t\t\t\t * It will be restored if/when we recurse below.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (c == '*') {\n\t\t\t\t\t\t\tflags &= ~FNM_PATHNAME;\n\t\t\t\t\t\t\twhile (c == '*')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t\tif (c == '/')\n\t\t\t\t\t\t\t\tc = *++pattern;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\t/* Optimize for pattern with * at end or before /. */\n\t\t\t\t\t\tif (c == EOS) {\n\t\t\t\t\t\t\t\tif (flags & FNM_PATHNAME)\n\t\t\t\t\t\t\t\t\t\treturn ((flags & FNM_LEADING_DIR) ||\n\t\t\t\t\t\t\t\t\t\t\tstrchr(string, '/') == NULL ?\n\t\t\t\t\t\t\t\t\t\t\t0 : FNM_NOMATCH);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\treturn (0);\n\t\t\t\t\t\t} else if (c == '/' && (flags & FNM_PATHNAME)) {\n\t\t\t\t\t\t\t\tif ((string = strchr(string, '/')) == NULL)\n\t\t\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* General case, use recursion. */\n\t\t\t\t\t\twhile ((test = *string) != EOS) {\n\t\t\t\t\t\t\t\tint e;\n\n\t\t\t\t\t\t\t\te = p_fnmatchx(pattern, string, recurs_flags, recurs);\n\t\t\t\t\t\t\t\tif (e != FNM_NOMATCH)\n\t\t\t\t\t\t\t\t\t\treturn e;\n\t\t\t\t\t\t\t\tif (test == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t++string;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\tcase '[':\n\t\t\t\t\t\tif (*string == EOS)\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '/' && (flags & FNM_PATHNAME))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\tif (*string == '.' && (flags & FNM_PERIOD) &&\n\t\t\t\t\t\t\t(string == stringstart ||\n\t\t\t\t\t\t\t((flags & FNM_PATHNAME) && *(string - 1) == '/')))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\n\t\t\t\t\t\tswitch (rangematch(pattern, *string, flags, &newp)) {\n\t\t\t\t\t\tcase RANGE_ERROR:\n\t\t\t\t\t\t\t\t/* not a good range, treat as normal text */\n\t\t\t\t\t\t\t\tgoto normal;\n\t\t\t\t\t\tcase RANGE_MATCH:\n\t\t\t\t\t\t\t\tpattern = newp;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase RANGE_NOMATCH:\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\tcase '\\\\':\n\t\t\t\t\t\tif (!(flags & FNM_NOESCAPE)) {\n\t\t\t\t\t\t\t\tif ((c = *pattern++) == EOS) {\n\t\t\t\t\t\t\t\t\t\tc = '\\\\';\n\t\t\t\t\t\t\t\t\t\t--pattern;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\tnormal:\n\t\t\t\t\t\tif (c != *string && !((flags & FNM_CASEFOLD) &&\n\t\t\t\t\t\t\t\t\t(git__tolower((unsigned char)c) ==\n\t\t\t\t\t\t\t\t\tgit__tolower((unsigned char)*string))))\n\t\t\t\t\t\t\t\treturn (FNM_NOMATCH);\n\t\t\t\t\t\t++string;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t/* NOTREACHED */\n}"
  }
]