[
  {
    "function_name": "git_blob_filtered_content",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "349-375",
    "snippet": "int git_blob_filtered_content(\n\tgit_buf *out,\n\tgit_blob *blob,\n\tconst char *path,\n\tint check_for_binary_data)\n{\n\tint error = 0;\n\tgit_filter_list *fl = NULL;\n\n\tassert(blob && path && out);\n\n\tgit_buf_sanitize(out);\n\n\tif (check_for_binary_data && git_blob_is_binary(blob))\n\t\treturn 0;\n\n\tif (!(error = git_filter_list_load(\n\t\t\t&fl, git_blob_owner(blob), blob, path,\n\t\t\tGIT_FILTER_TO_WORKTREE, GIT_FILTER_DEFAULT))) {\n\n\t\terror = git_filter_list_apply_to_blob(out, fl, blob);\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filter_list_free",
          "args": [
            "fl"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "589-604",
          "snippet": "void git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_apply_to_blob",
          "args": [
            "out",
            "fl",
            "blob"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_apply_to_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "769-785",
          "snippet": "int git_filter_list_apply_to_blob(\n\tgit_buf *out,\n\tgit_filter_list *filters,\n\tgit_blob *blob)\n{\n\tstruct buf_stream writer;\n\tint error;\n\n\tbuf_stream_init(&writer, out);\n\n\tif ((error = git_filter_list_stream_blob(\n\t\tfilters, blob, &writer.parent)) < 0)\n\t\t\treturn error;\n\n\tassert(writer.complete);\n\treturn error;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_apply_to_blob(\n\tgit_buf *out,\n\tgit_filter_list *filters,\n\tgit_blob *blob)\n{\n\tstruct buf_stream writer;\n\tint error;\n\n\tbuf_stream_init(&writer, out);\n\n\tif ((error = git_filter_list_stream_blob(\n\t\tfilters, blob, &writer.parent)) < 0)\n\t\t\treturn error;\n\n\tassert(writer.complete);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_load",
          "args": [
            "&fl",
            "git_blob_owner(blob)",
            "blob",
            "path",
            "GIT_FILTER_TO_WORKTREE",
            "GIT_FILTER_DEFAULT"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "573-587",
          "snippet": "int git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_owner",
          "args": [
            "blob"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "126-129",
          "snippet": "git_repository *git_blob_owner(const git_blob *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_blob_owner(const git_blob *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_is_binary",
          "args": [
            "blob"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_is_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "337-347",
          "snippet": "int git_blob_is_binary(const git_blob *blob)\n{\n\tgit_buf content = GIT_BUF_INIT;\n\n\tassert(blob);\n\n\tgit_buf_attach_notowned(&content, blob->odb_object->buffer,\n\t\tmin(blob->odb_object->cached.size,\n\t\tGIT_FILTER_BYTES_TO_CHECK_NUL));\n\treturn git_buf_text_is_binary(&content);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_is_binary(const git_blob *blob)\n{\n\tgit_buf content = GIT_BUF_INIT;\n\n\tassert(blob);\n\n\tgit_buf_attach_notowned(&content, blob->odb_object->buffer,\n\t\tmin(blob->odb_object->cached.size,\n\t\tGIT_FILTER_BYTES_TO_CHECK_NUL));\n\treturn git_buf_text_is_binary(&content);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blob && path && out"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_filtered_content(\n\tgit_buf *out,\n\tgit_blob *blob,\n\tconst char *path,\n\tint check_for_binary_data)\n{\n\tint error = 0;\n\tgit_filter_list *fl = NULL;\n\n\tassert(blob && path && out);\n\n\tgit_buf_sanitize(out);\n\n\tif (check_for_binary_data && git_blob_is_binary(blob))\n\t\treturn 0;\n\n\tif (!(error = git_filter_list_load(\n\t\t\t&fl, git_blob_owner(blob), blob, path,\n\t\t\tGIT_FILTER_TO_WORKTREE, GIT_FILTER_DEFAULT))) {\n\n\t\terror = git_filter_list_apply_to_blob(out, fl, blob);\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_blob_is_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "337-347",
    "snippet": "int git_blob_is_binary(const git_blob *blob)\n{\n\tgit_buf content = GIT_BUF_INIT;\n\n\tassert(blob);\n\n\tgit_buf_attach_notowned(&content, blob->odb_object->buffer,\n\t\tmin(blob->odb_object->cached.size,\n\t\tGIT_FILTER_BYTES_TO_CHECK_NUL));\n\treturn git_buf_text_is_binary(&content);\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_is_binary",
          "args": [
            "&content"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_is_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "185-211",
          "snippet": "bool git_buf_text_is_binary(const git_buf *buf)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tgit_bom_t bom;\n\tint printable = 0, nonprintable = 0;\n\n\tscan += git_buf_text_detect_bom(&bom, buf, 0);\n\n\tif (bom > GIT_BOM_UTF8)\n\t\treturn 1;\n\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\t/* Printable characters are those above SPACE (0x1F) excluding DEL,\n\t\t * and including BS, ESC and FF.\n\t\t */\n\t\tif ((c > 0x1F && c != 127) || c == '\\b' || c == '\\033' || c == '\\014')\n\t\t\tprintable++;\n\t\telse if (c == '\\0')\n\t\t\treturn true;\n\t\telse if (!git__isspace(c))\n\t\t\tnonprintable++;\n\t}\n\n\treturn ((printable >> 7) < nonprintable);\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nbool git_buf_text_is_binary(const git_buf *buf)\n{\n\tconst char *scan = buf->ptr, *end = buf->ptr + buf->size;\n\tgit_bom_t bom;\n\tint printable = 0, nonprintable = 0;\n\n\tscan += git_buf_text_detect_bom(&bom, buf, 0);\n\n\tif (bom > GIT_BOM_UTF8)\n\t\treturn 1;\n\n\twhile (scan < end) {\n\t\tunsigned char c = *scan++;\n\n\t\t/* Printable characters are those above SPACE (0x1F) excluding DEL,\n\t\t * and including BS, ESC and FF.\n\t\t */\n\t\tif ((c > 0x1F && c != 127) || c == '\\b' || c == '\\033' || c == '\\014')\n\t\t\tprintable++;\n\t\telse if (c == '\\0')\n\t\t\treturn true;\n\t\telse if (!git__isspace(c))\n\t\t\tnonprintable++;\n\t}\n\n\treturn ((printable >> 7) < nonprintable);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_attach_notowned",
          "args": [
            "&content",
            "blob->odb_object->buffer",
            "min(blob->odb_object->cached.size,\n\t\tGIT_FILTER_BYTES_TO_CHECK_NUL)"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_attach_notowned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "505-517",
          "snippet": "void git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_attach_notowned(git_buf *buf, const char *ptr, size_t size)\n{\n\tif (git_buf_is_allocated(buf))\n\t\tgit_buf_free(buf);\n\n\tif (!size) {\n\t\tgit_buf_init(buf, 0);\n\t} else {\n\t\tbuf->ptr = (char *)ptr;\n\t\tbuf->asize = 0;\n\t\tbuf->size = size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "blob->odb_object->cached.size",
            "GIT_FILTER_BYTES_TO_CHECK_NUL"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blob"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_is_binary(const git_blob *blob)\n{\n\tgit_buf content = GIT_BUF_INIT;\n\n\tassert(blob);\n\n\tgit_buf_attach_notowned(&content, blob->odb_object->buffer,\n\t\tmin(blob->odb_object->cached.size,\n\t\tGIT_FILTER_BYTES_TO_CHECK_NUL));\n\treturn git_buf_text_is_binary(&content);\n}"
  },
  {
    "function_name": "git_blob_create_fromchunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "279-335",
    "snippet": "int git_blob_create_fromchunks(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *hintpath,\n\tint (*source_cb)(char *content, size_t max_length, void *payload),\n\tvoid *payload)\n{\n\tint error;\n\tchar *content = NULL;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(id && repo && source_cb);\n\n\tif ((error = git_buf_joinpath(\n\t\t\t&path, git_repository_path(repo), GIT_OBJECTS_DIR \"streamed\")) < 0)\n\t\tgoto cleanup;\n\n\tcontent = git__malloc(BUFFER_SIZE);\n\tGITERR_CHECK_ALLOC(content);\n\n\tif ((error = git_filebuf_open(\n\t\t\t&file, git_buf_cstr(&path), GIT_FILEBUF_TEMPORARY, 0666)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\tint read_bytes = source_cb(content, BUFFER_SIZE, payload);\n\n\t\tif (!read_bytes)\n\t\t\tbreak;\n\n\t\tif (read_bytes > BUFFER_SIZE) {\n\t\t\tgiterr_set(GITERR_OBJECT, \"Invalid chunk size while creating blob\");\n\t\t\terror = GIT_EBUFS;\n\t\t} else if (read_bytes < 0) {\n\t\t\terror = giterr_set_after_callback(read_bytes);\n\t\t} else {\n\t\t\terror = git_filebuf_write(&file, content, read_bytes);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_filebuf_flush(&file)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_blob__create_from_paths(\n\t\tid, NULL, repo, file.path_lock, hintpath, 0, hintpath != NULL);\n\ncleanup:\n\tgit_buf_free(&path);\n\tgit_filebuf_cleanup(&file);\n\tgit__free(content);\n\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [
      "#define BUFFER_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "content"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob__create_from_paths",
          "args": [
            "id",
            "NULL",
            "repo",
            "file.path_lock",
            "hintpath",
            "0",
            "hintpath != NULL"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob__create_from_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "155-244",
          "snippet": "int git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_flush",
          "args": [
            "&file"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "142-145",
          "snippet": "int git_filebuf_flush(git_filebuf *file)\n{\n\treturn flush_buffer(file);\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_flush(git_filebuf *file)\n{\n\treturn flush_buffer(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&file",
            "content",
            "read_bytes"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "read_bytes"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"Invalid chunk size while creating blob\""
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "source_cb",
          "args": [
            "content",
            "BUFFER_SIZE",
            "payload"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "git_buf_cstr(&path)",
            "GIT_FILEBUF_TEMPORARY",
            "0666"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "content"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "BUFFER_SIZE"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "git_repository_path(repo)",
            "GIT_OBJECTS_DIR \"streamed\""
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_path",
          "args": [
            "repo"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1822-1826",
          "snippet": "const char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_path(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->path_repository;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "id && repo && source_cb"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\n#define BUFFER_SIZE 4096\n\nint git_blob_create_fromchunks(\n\tgit_oid *id,\n\tgit_repository *repo,\n\tconst char *hintpath,\n\tint (*source_cb)(char *content, size_t max_length, void *payload),\n\tvoid *payload)\n{\n\tint error;\n\tchar *content = NULL;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(id && repo && source_cb);\n\n\tif ((error = git_buf_joinpath(\n\t\t\t&path, git_repository_path(repo), GIT_OBJECTS_DIR \"streamed\")) < 0)\n\t\tgoto cleanup;\n\n\tcontent = git__malloc(BUFFER_SIZE);\n\tGITERR_CHECK_ALLOC(content);\n\n\tif ((error = git_filebuf_open(\n\t\t\t&file, git_buf_cstr(&path), GIT_FILEBUF_TEMPORARY, 0666)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\tint read_bytes = source_cb(content, BUFFER_SIZE, payload);\n\n\t\tif (!read_bytes)\n\t\t\tbreak;\n\n\t\tif (read_bytes > BUFFER_SIZE) {\n\t\t\tgiterr_set(GITERR_OBJECT, \"Invalid chunk size while creating blob\");\n\t\t\terror = GIT_EBUFS;\n\t\t} else if (read_bytes < 0) {\n\t\t\terror = giterr_set_after_callback(read_bytes);\n\t\t} else {\n\t\t\terror = git_filebuf_write(&file, content, read_bytes);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_filebuf_flush(&file)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_blob__create_from_paths(\n\t\tid, NULL, repo, file.path_lock, hintpath, 0, hintpath != NULL);\n\ncleanup:\n\tgit_buf_free(&path);\n\tgit_filebuf_cleanup(&file);\n\tgit__free(content);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_blob_create_fromdisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "252-275",
    "snippet": "int git_blob_create_fromdisk(\n\tgit_oid *id, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tconst char *workdir, *hintpath;\n\n\tif ((error = git_path_prettify(&full_path, path, NULL)) < 0) {\n\t\tgit_buf_free(&full_path);\n\t\treturn error;\n\t}\n\n\thintpath = git_buf_cstr(&full_path);\n\tworkdir  = git_repository_workdir(repo);\n\n\tif (workdir && !git__prefixcmp(hintpath, workdir))\n\t\thintpath += strlen(workdir);\n\n\terror = git_blob__create_from_paths(\n\t\tid, NULL, repo, git_buf_cstr(&full_path), hintpath, 0, true);\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&full_path"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob__create_from_paths",
          "args": [
            "id",
            "NULL",
            "repo",
            "git_buf_cstr(&full_path)",
            "hintpath",
            "0",
            "true"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob__create_from_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "155-244",
          "snippet": "int git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&full_path"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "workdir"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "hintpath",
            "workdir"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_prettify",
          "args": [
            "&full_path",
            "path",
            "NULL"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_prettify_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "335-339",
          "snippet": "int git_path_prettify_dir(git_buf *path_out, const char *path, const char *base)\n{\n\tint error = git_path_prettify(path_out, path, base);\n\treturn (error < 0) ? error : git_path_to_dir(path_out);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_prettify_dir(git_buf *path_out, const char *path, const char *base)\n{\n\tint error = git_path_prettify(path_out, path, base);\n\treturn (error < 0) ? error : git_path_to_dir(path_out);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_create_fromdisk(\n\tgit_oid *id, git_repository *repo, const char *path)\n{\n\tint error;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tconst char *workdir, *hintpath;\n\n\tif ((error = git_path_prettify(&full_path, path, NULL)) < 0) {\n\t\tgit_buf_free(&full_path);\n\t\treturn error;\n\t}\n\n\thintpath = git_buf_cstr(&full_path);\n\tworkdir  = git_repository_workdir(repo);\n\n\tif (workdir && !git__prefixcmp(hintpath, workdir))\n\t\thintpath += strlen(workdir);\n\n\terror = git_blob__create_from_paths(\n\t\tid, NULL, repo, git_buf_cstr(&full_path), hintpath, 0, true);\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}"
  },
  {
    "function_name": "git_blob_create_fromworkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "246-250",
    "snippet": "int git_blob_create_fromworkdir(\n\tgit_oid *id, git_repository *repo, const char *path)\n{\n\treturn git_blob__create_from_paths(id, NULL, repo, NULL, path, 0, true);\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_blob__create_from_paths",
          "args": [
            "id",
            "NULL",
            "repo",
            "NULL",
            "path",
            "0",
            "true"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob__create_from_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "155-244",
          "snippet": "int git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_create_fromworkdir(\n\tgit_oid *id, git_repository *repo, const char *path)\n{\n\treturn git_blob__create_from_paths(id, NULL, repo, NULL, path, 0, true);\n}"
  },
  {
    "function_name": "git_blob__create_from_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "155-244",
    "snippet": "int git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_free",
          "args": [
            "odb"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "619-625",
          "snippet": "void git_odb_free(git_odb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, odb_free);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_free(git_odb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, odb_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_free",
          "args": [
            "fl"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "589-604",
          "snippet": "void git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_file_filtered",
          "args": [
            "id",
            "&size",
            "odb",
            "content_path",
            "fl"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "write_file_filtered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "110-131",
          "snippet": "static int write_file_filtered(\n\tgit_oid *id,\n\tgit_off_t *size,\n\tgit_odb *odb,\n\tconst char *full_path,\n\tgit_filter_list *fl)\n{\n\tint error;\n\tgit_buf tgt = GIT_BUF_INIT;\n\n\terror = git_filter_list_apply_to_file(&tgt, fl, NULL, full_path);\n\n\t/* Write the file to disk if it was properly filtered */\n\tif (!error) {\n\t\t*size = tgt.size;\n\n\t\terror = git_odb_write(id, odb, tgt.ptr, tgt.size, GIT_OBJ_BLOB);\n\t}\n\n\tgit_buf_free(&tgt);\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int write_file_filtered(\n\tgit_oid *id,\n\tgit_off_t *size,\n\tgit_odb *odb,\n\tconst char *full_path,\n\tgit_filter_list *fl)\n{\n\tint error;\n\tgit_buf tgt = GIT_BUF_INIT;\n\n\terror = git_filter_list_apply_to_file(&tgt, fl, NULL, full_path);\n\n\t/* Write the file to disk if it was properly filtered */\n\tif (!error) {\n\t\t*size = tgt.size;\n\n\t\terror = git_odb_write(id, odb, tgt.ptr, tgt.size, GIT_OBJ_BLOB);\n\t}\n\n\tgit_buf_free(&tgt);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_file_stream",
          "args": [
            "id",
            "odb",
            "content_path",
            "size"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "write_file_stream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "73-108",
          "snippet": "static int write_file_stream(\n\tgit_oid *id, git_odb *odb, const char *path, git_off_t file_size)\n{\n\tint fd, error;\n\tchar buffer[FILEIO_BUFSIZE];\n\tgit_odb_stream *stream = NULL;\n\tssize_t read_len = -1;\n\tgit_off_t written = 0;\n\n\tif ((error = git_odb_open_wstream(\n\t\t\t&stream, odb, file_size, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit_odb_stream_free(stream);\n\t\treturn -1;\n\t}\n\n\twhile (!error && (read_len = p_read(fd, buffer, sizeof(buffer))) > 0) {\n\t\terror = git_odb_stream_write(stream, buffer, read_len);\n\t\twritten += read_len;\n\t}\n\n\tp_close(fd);\n\n\tif (written != file_size || read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read file into stream\");\n\t\terror = -1;\n\t}\n\n\tif (!error)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int write_file_stream(\n\tgit_oid *id, git_odb *odb, const char *path, git_off_t file_size)\n{\n\tint fd, error;\n\tchar buffer[FILEIO_BUFSIZE];\n\tgit_odb_stream *stream = NULL;\n\tssize_t read_len = -1;\n\tgit_off_t written = 0;\n\n\tif ((error = git_odb_open_wstream(\n\t\t\t&stream, odb, file_size, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit_odb_stream_free(stream);\n\t\treturn -1;\n\t}\n\n\twhile (!error && (read_len = p_read(fd, buffer, sizeof(buffer))) > 0) {\n\t\terror = git_odb_stream_write(stream, buffer, read_len);\n\t\twritten += read_len;\n\t}\n\n\tp_close(fd);\n\n\tif (written != file_size || read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read file into stream\");\n\t\terror = -1;\n\t}\n\n\tif (!error)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_load",
          "args": [
            "&fl",
            "repo",
            "NULL",
            "hint_path",
            "GIT_FILTER_TO_ODB",
            "GIT_FILTER_DEFAULT"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "573-587",
          "snippet": "int git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_symlink",
          "args": [
            "id",
            "odb",
            "content_path",
            "(size_t)size"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "write_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "133-153",
          "snippet": "static int write_symlink(\n\tgit_oid *id, git_odb *odb, const char *path, size_t link_size)\n{\n\tchar *link_data;\n\tssize_t read_len;\n\tint error;\n\n\tlink_data = git__malloc(link_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(path, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create blob.  Can't read symlink '%s'\", path);\n\t\tgit__free(link_data);\n\t\treturn -1;\n\t}\n\n\terror = git_odb_write(id, odb, (void *)link_data, link_size, GIT_OBJ_BLOB);\n\tgit__free(link_data);\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int write_symlink(\n\tgit_oid *id, git_odb *odb, const char *path, size_t link_size)\n{\n\tchar *link_data;\n\tssize_t read_len;\n\tint error;\n\n\tlink_data = git__malloc(link_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(path, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create blob.  Can't read symlink '%s'\", path);\n\t\tgit__free(link_data);\n\t\treturn -1;\n\t}\n\n\terror = git_odb_write(id, odb, (void *)link_data, link_size, GIT_OBJ_BLOB);\n\tgit__free(link_data);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "out_st",
            "&st",
            "sizeof(st)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_ODB",
            "\"cannot create blob from '%s'; it is a directory\"",
            "content_path"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st.st_mode"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_odb",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "764-771",
          "snippet": "int git_repository_odb(git_odb **out, git_repository *repo)\n{\n\tif (git_repository_odb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb(git_odb **out, git_repository *repo)\n{\n\tif (git_repository_odb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_lstat",
          "args": [
            "content_path",
            "&st"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "634-640",
          "snippet": "int git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_lstat(const char *path, struct stat *st)\n{\n\tif (p_lstat(path, st) == 0)\n\t\treturn 0;\n\n\treturn git_path_set_error(errno, path, \"stat\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "git_repository_workdir(repo)",
            "hint_path"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"create blob from file\""
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "hint_path || !try_load_filters"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "133-153",
    "snippet": "static int write_symlink(\n\tgit_oid *id, git_odb *odb, const char *path, size_t link_size)\n{\n\tchar *link_data;\n\tssize_t read_len;\n\tint error;\n\n\tlink_data = git__malloc(link_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(path, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create blob.  Can't read symlink '%s'\", path);\n\t\tgit__free(link_data);\n\t\treturn -1;\n\t}\n\n\terror = git_odb_write(id, odb, (void *)link_data, link_size, GIT_OBJ_BLOB);\n\tgit__free(link_data);\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "link_data"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_write",
          "args": [
            "id",
            "odb",
            "(void *)link_data",
            "link_size",
            "GIT_OBJ_BLOB"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "984-1024",
          "snippet": "int git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to create blob.  Can't read symlink '%s'\"",
            "path"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_readlink",
          "args": [
            "path",
            "link_data",
            "link_size"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "p_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "251-273",
          "snippet": "int p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "link_data"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "link_size"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int write_symlink(\n\tgit_oid *id, git_odb *odb, const char *path, size_t link_size)\n{\n\tchar *link_data;\n\tssize_t read_len;\n\tint error;\n\n\tlink_data = git__malloc(link_size);\n\tGITERR_CHECK_ALLOC(link_data);\n\n\tread_len = p_readlink(path, link_data, link_size);\n\tif (read_len != (ssize_t)link_size) {\n\t\tgiterr_set(GITERR_OS, \"Failed to create blob.  Can't read symlink '%s'\", path);\n\t\tgit__free(link_data);\n\t\treturn -1;\n\t}\n\n\terror = git_odb_write(id, odb, (void *)link_data, link_size, GIT_OBJ_BLOB);\n\tgit__free(link_data);\n\treturn error;\n}"
  },
  {
    "function_name": "write_file_filtered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "110-131",
    "snippet": "static int write_file_filtered(\n\tgit_oid *id,\n\tgit_off_t *size,\n\tgit_odb *odb,\n\tconst char *full_path,\n\tgit_filter_list *fl)\n{\n\tint error;\n\tgit_buf tgt = GIT_BUF_INIT;\n\n\terror = git_filter_list_apply_to_file(&tgt, fl, NULL, full_path);\n\n\t/* Write the file to disk if it was properly filtered */\n\tif (!error) {\n\t\t*size = tgt.size;\n\n\t\terror = git_odb_write(id, odb, tgt.ptr, tgt.size, GIT_OBJ_BLOB);\n\t}\n\n\tgit_buf_free(&tgt);\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&tgt"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_write",
          "args": [
            "id",
            "odb",
            "tgt.ptr",
            "tgt.size",
            "GIT_OBJ_BLOB"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "984-1024",
          "snippet": "int git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_write(\n\tgit_oid *oid, git_odb *db, const void *data, size_t len, git_otype type)\n{\n\tsize_t i;\n\tint error = GIT_ERROR;\n\tgit_odb_stream *stream;\n\n\tassert(oid && db);\n\n\tgit_odb_hash(oid, data, len, type);\n\tif (git_odb_exists(db, oid))\n\t\treturn 0;\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->write != NULL)\n\t\t\terror = b->write(b, oid, data, len, type);\n\t}\n\n\tif (!error || error == GIT_PASSTHROUGH)\n\t\treturn 0;\n\n\t/* if no backends were able to write the object directly, we try a\n\t * streaming write to the backends; just write the whole object into the\n\t * stream in one push\n\t */\n\tif ((error = git_odb_open_wstream(&stream, db, len, type)) != 0)\n\t\treturn error;\n\n\tstream->write(stream, data, len);\n\terror = stream->finalize_write(stream, oid);\n\tgit_odb_stream_free(stream);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_apply_to_file",
          "args": [
            "&tgt",
            "fl",
            "NULL",
            "full_path"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_apply_to_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "737-754",
          "snippet": "int git_filter_list_apply_to_file(\n\tgit_buf *out,\n\tgit_filter_list *filters,\n\tgit_repository *repo,\n\tconst char *path)\n{\n\tstruct buf_stream writer;\n\tint error;\n\n\tbuf_stream_init(&writer, out);\n\n\tif ((error = git_filter_list_stream_file(\n\t\tfilters, repo, path, &writer.parent)) < 0)\n\t\t\treturn error;\n\n\tassert(writer.complete);\n\treturn error;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_apply_to_file(\n\tgit_buf *out,\n\tgit_filter_list *filters,\n\tgit_repository *repo,\n\tconst char *path)\n{\n\tstruct buf_stream writer;\n\tint error;\n\n\tbuf_stream_init(&writer, out);\n\n\tif ((error = git_filter_list_stream_file(\n\t\tfilters, repo, path, &writer.parent)) < 0)\n\t\t\treturn error;\n\n\tassert(writer.complete);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int write_file_filtered(\n\tgit_oid *id,\n\tgit_off_t *size,\n\tgit_odb *odb,\n\tconst char *full_path,\n\tgit_filter_list *fl)\n{\n\tint error;\n\tgit_buf tgt = GIT_BUF_INIT;\n\n\terror = git_filter_list_apply_to_file(&tgt, fl, NULL, full_path);\n\n\t/* Write the file to disk if it was properly filtered */\n\tif (!error) {\n\t\t*size = tgt.size;\n\n\t\terror = git_odb_write(id, odb, tgt.ptr, tgt.size, GIT_OBJ_BLOB);\n\t}\n\n\tgit_buf_free(&tgt);\n\treturn error;\n}"
  },
  {
    "function_name": "write_file_stream",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "73-108",
    "snippet": "static int write_file_stream(\n\tgit_oid *id, git_odb *odb, const char *path, git_off_t file_size)\n{\n\tint fd, error;\n\tchar buffer[FILEIO_BUFSIZE];\n\tgit_odb_stream *stream = NULL;\n\tssize_t read_len = -1;\n\tgit_off_t written = 0;\n\n\tif ((error = git_odb_open_wstream(\n\t\t\t&stream, odb, file_size, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit_odb_stream_free(stream);\n\t\treturn -1;\n\t}\n\n\twhile (!error && (read_len = p_read(fd, buffer, sizeof(buffer))) > 0) {\n\t\terror = git_odb_stream_write(stream, buffer, read_len);\n\t\twritten += read_len;\n\t}\n\n\tp_close(fd);\n\n\tif (written != file_size || read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read file into stream\");\n\t\terror = -1;\n\t}\n\n\tif (!error)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_stream_free",
          "args": [
            "stream"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1131-1139",
          "snippet": "void git_odb_stream_free(git_odb_stream *stream)\n{\n\tif (stream == NULL)\n\t\treturn;\n\n\tgit_hash_ctx_cleanup(stream->hash_ctx);\n\tgit__free(stream->hash_ctx);\n\tstream->free(stream);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_stream_free(git_odb_stream *stream)\n{\n\tif (stream == NULL)\n\t\treturn;\n\n\tgit_hash_ctx_cleanup(stream->hash_ctx);\n\tgit__free(stream->hash_ctx);\n\tstream->free(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_finalize_write",
          "args": [
            "id",
            "stream"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_finalize_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1112-1124",
          "snippet": "int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)\n{\n\tif (stream->received_bytes != stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_finalize_write()\");\n\n\tgit_hash_final(out, stream->hash_ctx);\n\n\tif (git_odb_exists(stream->backend->odb, out))\n\t\treturn 0;\n\n\treturn stream->finalize_write(stream, out);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)\n{\n\tif (stream->received_bytes != stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_finalize_write()\");\n\n\tgit_hash_final(out, stream->hash_ctx);\n\n\tif (git_odb_exists(stream->backend->odb, out))\n\t\treturn 0;\n\n\treturn stream->finalize_write(stream, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to read file into stream\""
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_write",
          "args": [
            "stream",
            "buffer",
            "read_len"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1099-1110",
          "snippet": "int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)\n{\n\tgit_hash_update(stream->hash_ctx, buffer, len);\n\n\tstream->received_bytes += len;\n\n\tif (stream->received_bytes > stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_write()\");\n\n\treturn stream->write(stream, buffer, len);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)\n{\n\tgit_hash_update(stream->hash_ctx, buffer, len);\n\n\tstream->received_bytes += len;\n\n\tif (stream->received_bytes > stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_write()\");\n\n\treturn stream->write(stream, buffer, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "path"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_open_wstream",
          "args": [
            "&stream",
            "odb",
            "file_size",
            "GIT_OBJ_BLOB"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_open_wstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1035-1084",
          "snippet": "int git_odb_open_wstream(\n\tgit_odb_stream **stream, git_odb *db, git_off_t size, git_otype type)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\tgit_hash_ctx *ctx = NULL;\n\n\tassert(stream && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writestream != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writestream(stream, b, size, type);\n\t\t} else if (b->write != NULL) {\n\t\t\t++writes;\n\t\t\terror = init_fake_wstream(stream, b, size, type);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\terror = 0;\n\t\telse if (!writes)\n\t\t\terror = git_odb__error_unsupported_in_backend(\"write object\");\n\n\t\tgoto done;\n\t}\n\n\tctx = git__malloc(sizeof(git_hash_ctx));\n\tGITERR_CHECK_ALLOC(ctx);\n\n\tif ((error = git_hash_ctx_init(ctx)) < 0)\n\t\tgoto done;\n\n\thash_header(ctx, size, type);\n\t(*stream)->hash_ctx = ctx;\n\n\t(*stream)->declared_size = size;\n\t(*stream)->received_bytes = 0;\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_open_wstream(\n\tgit_odb_stream **stream, git_odb *db, git_off_t size, git_otype type)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\tgit_hash_ctx *ctx = NULL;\n\n\tassert(stream && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writestream != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writestream(stream, b, size, type);\n\t\t} else if (b->write != NULL) {\n\t\t\t++writes;\n\t\t\terror = init_fake_wstream(stream, b, size, type);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\terror = 0;\n\t\telse if (!writes)\n\t\t\terror = git_odb__error_unsupported_in_backend(\"write object\");\n\n\t\tgoto done;\n\t}\n\n\tctx = git__malloc(sizeof(git_hash_ctx));\n\tGITERR_CHECK_ALLOC(ctx);\n\n\tif ((error = git_hash_ctx_init(ctx)) < 0)\n\t\tgoto done;\n\n\thash_header(ctx, size, type);\n\t(*stream)->hash_ctx = ctx;\n\n\t(*stream)->declared_size = size;\n\t(*stream)->received_bytes = 0;\n\ndone:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nstatic int write_file_stream(\n\tgit_oid *id, git_odb *odb, const char *path, git_off_t file_size)\n{\n\tint fd, error;\n\tchar buffer[FILEIO_BUFSIZE];\n\tgit_odb_stream *stream = NULL;\n\tssize_t read_len = -1;\n\tgit_off_t written = 0;\n\n\tif ((error = git_odb_open_wstream(\n\t\t\t&stream, odb, file_size, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((fd = git_futils_open_ro(path)) < 0) {\n\t\tgit_odb_stream_free(stream);\n\t\treturn -1;\n\t}\n\n\twhile (!error && (read_len = p_read(fd, buffer, sizeof(buffer))) > 0) {\n\t\terror = git_odb_stream_write(stream, buffer, read_len);\n\t\twritten += read_len;\n\t}\n\n\tp_close(fd);\n\n\tif (written != file_size || read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read file into stream\");\n\t\terror = -1;\n\t}\n\n\tif (!error)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}"
  },
  {
    "function_name": "git_blob_create_frombuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "53-71",
    "snippet": "int git_blob_create_frombuffer(\n\tgit_oid *id, git_repository *repo, const void *buffer, size_t len)\n{\n\tint error;\n\tgit_odb *odb;\n\tgit_odb_stream *stream;\n\n\tassert(id && repo);\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_open_wstream(&stream, odb, len, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((error = git_odb_stream_write(stream, buffer, len)) == 0)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_stream_free",
          "args": [
            "stream"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1131-1139",
          "snippet": "void git_odb_stream_free(git_odb_stream *stream)\n{\n\tif (stream == NULL)\n\t\treturn;\n\n\tgit_hash_ctx_cleanup(stream->hash_ctx);\n\tgit__free(stream->hash_ctx);\n\tstream->free(stream);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_stream_free(git_odb_stream *stream)\n{\n\tif (stream == NULL)\n\t\treturn;\n\n\tgit_hash_ctx_cleanup(stream->hash_ctx);\n\tgit__free(stream->hash_ctx);\n\tstream->free(stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_finalize_write",
          "args": [
            "id",
            "stream"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_finalize_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1112-1124",
          "snippet": "int git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)\n{\n\tif (stream->received_bytes != stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_finalize_write()\");\n\n\tgit_hash_final(out, stream->hash_ctx);\n\n\tif (git_odb_exists(stream->backend->odb, out))\n\t\treturn 0;\n\n\treturn stream->finalize_write(stream, out);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_stream_finalize_write(git_oid *out, git_odb_stream *stream)\n{\n\tif (stream->received_bytes != stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_finalize_write()\");\n\n\tgit_hash_final(out, stream->hash_ctx);\n\n\tif (git_odb_exists(stream->backend->odb, out))\n\t\treturn 0;\n\n\treturn stream->finalize_write(stream, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_stream_write",
          "args": [
            "stream",
            "buffer",
            "len"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_stream_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1099-1110",
          "snippet": "int git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)\n{\n\tgit_hash_update(stream->hash_ctx, buffer, len);\n\n\tstream->received_bytes += len;\n\n\tif (stream->received_bytes > stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_write()\");\n\n\treturn stream->write(stream, buffer, len);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_stream_write(git_odb_stream *stream, const char *buffer, size_t len)\n{\n\tgit_hash_update(stream->hash_ctx, buffer, len);\n\n\tstream->received_bytes += len;\n\n\tif (stream->received_bytes > stream->declared_size)\n\t\treturn git_odb_stream__invalid_length(stream,\n\t\t\t\"stream_write()\");\n\n\treturn stream->write(stream, buffer, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_open_wstream",
          "args": [
            "&stream",
            "odb",
            "len",
            "GIT_OBJ_BLOB"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_open_wstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "1035-1084",
          "snippet": "int git_odb_open_wstream(\n\tgit_odb_stream **stream, git_odb *db, git_off_t size, git_otype type)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\tgit_hash_ctx *ctx = NULL;\n\n\tassert(stream && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writestream != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writestream(stream, b, size, type);\n\t\t} else if (b->write != NULL) {\n\t\t\t++writes;\n\t\t\terror = init_fake_wstream(stream, b, size, type);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\terror = 0;\n\t\telse if (!writes)\n\t\t\terror = git_odb__error_unsupported_in_backend(\"write object\");\n\n\t\tgoto done;\n\t}\n\n\tctx = git__malloc(sizeof(git_hash_ctx));\n\tGITERR_CHECK_ALLOC(ctx);\n\n\tif ((error = git_hash_ctx_init(ctx)) < 0)\n\t\tgoto done;\n\n\thash_header(ctx, size, type);\n\t(*stream)->hash_ctx = ctx;\n\n\t(*stream)->declared_size = size;\n\t(*stream)->received_bytes = 0;\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_open_wstream(\n\tgit_odb_stream **stream, git_odb *db, git_off_t size, git_otype type)\n{\n\tsize_t i, writes = 0;\n\tint error = GIT_ERROR;\n\tgit_hash_ctx *ctx = NULL;\n\n\tassert(stream && db);\n\n\tfor (i = 0; i < db->backends.length && error < 0; ++i) {\n\t\tbackend_internal *internal = git_vector_get(&db->backends, i);\n\t\tgit_odb_backend *b = internal->backend;\n\n\t\t/* we don't write in alternates! */\n\t\tif (internal->is_alternate)\n\t\t\tcontinue;\n\n\t\tif (b->writestream != NULL) {\n\t\t\t++writes;\n\t\t\terror = b->writestream(stream, b, size, type);\n\t\t} else if (b->write != NULL) {\n\t\t\t++writes;\n\t\t\terror = init_fake_wstream(stream, b, size, type);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\terror = 0;\n\t\telse if (!writes)\n\t\t\terror = git_odb__error_unsupported_in_backend(\"write object\");\n\n\t\tgoto done;\n\t}\n\n\tctx = git__malloc(sizeof(git_hash_ctx));\n\tGITERR_CHECK_ALLOC(ctx);\n\n\tif ((error = git_hash_ctx_init(ctx)) < 0)\n\t\tgoto done;\n\n\thash_header(ctx, size, type);\n\t(*stream)->hash_ctx = ctx;\n\n\t(*stream)->declared_size = size;\n\t(*stream)->received_bytes = 0;\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "id && repo"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_create_frombuffer(\n\tgit_oid *id, git_repository *repo, const void *buffer, size_t len)\n{\n\tint error;\n\tgit_odb *odb;\n\tgit_odb_stream *stream;\n\n\tassert(id && repo);\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_open_wstream(&stream, odb, len, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((error = git_odb_stream_write(stream, buffer, len)) == 0)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}"
  },
  {
    "function_name": "git_blob__parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "45-51",
    "snippet": "int git_blob__parse(void *blob, git_odb_object *odb_obj)\n{\n\tassert(blob);\n\tgit_cached_obj_incref((git_cached_obj *)odb_obj);\n\t((git_blob *)blob)->odb_object = odb_obj;\n\treturn 0;\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_cached_obj_incref",
          "args": [
            "(git_cached_obj *)odb_obj"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "git_cached_obj_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cache.h",
          "lines": "59-63",
          "snippet": "GIT_INLINE(void) git_cached_obj_incref(void *_obj)\n{\n\tgit_cached_obj *obj = _obj;\n\tgit_atomic_inc(&obj->refcount);\n}",
          "includes": [
            "#include \"oidmap.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oidmap.h\"\n#include \"thread-utils.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(void) git_cached_obj_incref(void *_obj)\n{\n\tgit_cached_obj *obj = _obj;\n\tgit_atomic_inc(&obj->refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blob"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__parse(void *blob, git_odb_object *odb_obj)\n{\n\tassert(blob);\n\tgit_cached_obj_incref((git_cached_obj *)odb_obj);\n\t((git_blob *)blob)->odb_object = odb_obj;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_blob__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "39-43",
    "snippet": "void git_blob__free(void *blob)\n{\n\tgit_odb_object_free(((git_blob *)blob)->odb_object);\n\tgit__free(blob);\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "blob"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "((git_blob *)blob)->odb_object"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nvoid git_blob__free(void *blob)\n{\n\tgit_odb_object_free(((git_blob *)blob)->odb_object);\n\tgit__free(blob);\n}"
  },
  {
    "function_name": "git_blob__getbuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "31-37",
    "snippet": "int git_blob__getbuf(git_buf *buffer, git_blob *blob)\n{\n\treturn git_buf_set(\n\t\tbuffer,\n\t\tgit_odb_object_data(blob->odb_object),\n\t\tgit_odb_object_size(blob->odb_object));\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_set",
          "args": [
            "buffer",
            "git_odb_object_data(blob->odb_object)",
            "git_odb_object_size(blob->odb_object)"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "150-169",
          "snippet": "int git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_set(git_buf *buf, const void *data, size_t len)\n{\n\tsize_t alloclen;\n\n\tif (len == 0 || data == NULL) {\n\t\tgit_buf_clear(buf);\n\t} else {\n\t\tif (data != buf->ptr) {\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\t\t\tENSURE_SIZE(buf, alloclen);\n\t\t\tmemmove(buf->ptr, data, len);\n\t\t}\n\n\t\tbuf->size = len;\n\t\tif (buf->asize > buf->size)\n\t\t\tbuf->ptr[buf->size] = '\\0';\n\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_size",
          "args": [
            "blob->odb_object"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "120-123",
          "snippet": "size_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nsize_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_data",
          "args": [
            "blob->odb_object"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "115-118",
          "snippet": "const void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nconst void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__getbuf(git_buf *buffer, git_blob *blob)\n{\n\treturn git_buf_set(\n\t\tbuffer,\n\t\tgit_odb_object_data(blob->odb_object),\n\t\tgit_odb_object_size(blob->odb_object));\n}"
  },
  {
    "function_name": "git_blob_rawsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "25-29",
    "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_object_size",
          "args": [
            "blob->odb_object"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "120-123",
          "snippet": "size_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nsize_t git_odb_object_size(git_odb_object *object)\n{\n\treturn object->cached.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blob"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
  },
  {
    "function_name": "git_blob_rawcontent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
    "lines": "19-23",
    "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
    "includes": [
      "#include \"buf_text.h\"",
      "#include \"filter.h\"",
      "#include \"blob.h\"",
      "#include \"filebuf.h\"",
      "#include \"common.h\"",
      "#include \"git2/odb_backend.h\"",
      "#include \"git2/repository.h\"",
      "#include \"git2/object.h\"",
      "#include \"git2/common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_object_data",
          "args": [
            "blob->odb_object"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "115-118",
          "snippet": "const void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nconst void *git_odb_object_data(git_odb_object *object)\n{\n\treturn object->buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "blob"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
  }
]