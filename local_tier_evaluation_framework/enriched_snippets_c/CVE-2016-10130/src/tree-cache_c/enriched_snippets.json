[
  {
    "function_name": "git_tree_cache_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "264-269",
    "snippet": "int git_tree_cache_write(git_buf *out, git_tree_cache *tree)\n{\n\twrite_tree(out, tree);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "out"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_tree",
          "args": [
            "out",
            "tree"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "write_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "251-262",
          "snippet": "static void write_tree(git_buf *out, git_tree_cache *tree)\n{\n\tsize_t i;\n\n\tgit_buf_printf(out, \"%s%c%\"PRIdZ\" %\"PRIuZ\"\\n\", tree->name, 0, tree->entry_count, tree->children_count);\n\n\tif (tree->entry_count != -1)\n\t\tgit_buf_put(out, (const char *) &tree->oid, GIT_OID_RAWSZ);\n\n\tfor (i = 0; i < tree->children_count; i++)\n\t\twrite_tree(out, tree->children[i]);\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic void write_tree(git_buf *out, git_tree_cache *tree)\n{\n\tsize_t i;\n\n\tgit_buf_printf(out, \"%s%c%\"PRIdZ\" %\"PRIuZ\"\\n\", tree->name, 0, tree->entry_count, tree->children_count);\n\n\tif (tree->entry_count != -1)\n\t\tgit_buf_put(out, (const char *) &tree->oid, GIT_OID_RAWSZ);\n\n\tfor (i = 0; i < tree->children_count; i++)\n\t\twrite_tree(out, tree->children[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_write(git_buf *out, git_tree_cache *tree)\n{\n\twrite_tree(out, tree);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}"
  },
  {
    "function_name": "write_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "251-262",
    "snippet": "static void write_tree(git_buf *out, git_tree_cache *tree)\n{\n\tsize_t i;\n\n\tgit_buf_printf(out, \"%s%c%\"PRIdZ\" %\"PRIuZ\"\\n\", tree->name, 0, tree->entry_count, tree->children_count);\n\n\tif (tree->entry_count != -1)\n\t\tgit_buf_put(out, (const char *) &tree->oid, GIT_OID_RAWSZ);\n\n\tfor (i = 0; i < tree->children_count; i++)\n\t\twrite_tree(out, tree->children[i]);\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_tree",
          "args": [
            "out",
            "tree->children[i]"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "write_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "251-262",
          "snippet": "static void write_tree(git_buf *out, git_tree_cache *tree)\n{\n\tsize_t i;\n\n\tgit_buf_printf(out, \"%s%c%\"PRIdZ\" %\"PRIuZ\"\\n\", tree->name, 0, tree->entry_count, tree->children_count);\n\n\tif (tree->entry_count != -1)\n\t\tgit_buf_put(out, (const char *) &tree->oid, GIT_OID_RAWSZ);\n\n\tfor (i = 0; i < tree->children_count; i++)\n\t\twrite_tree(out, tree->children[i]);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "out",
            "(const char *) &tree->oid",
            "GIT_OID_RAWSZ"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "out",
            "\"%s%c%\"PRIdZ\" %\"PRIuZ\"\\n\"",
            "tree->name",
            "0",
            "tree->entry_count",
            "tree->children_count"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic void write_tree(git_buf *out, git_tree_cache *tree)\n{\n\tsize_t i;\n\n\tgit_buf_printf(out, \"%s%c%\"PRIdZ\" %\"PRIuZ\"\\n\", tree->name, 0, tree->entry_count, tree->children_count);\n\n\tif (tree->entry_count != -1)\n\t\tgit_buf_put(out, (const char *) &tree->oid, GIT_OID_RAWSZ);\n\n\tfor (i = 0; i < tree->children_count; i++)\n\t\twrite_tree(out, tree->children[i]);\n}"
  },
  {
    "function_name": "git_tree_cache_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "232-249",
    "snippet": "int git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tree->name",
            "name",
            "name_len"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tree",
            "0x0",
            "sizeof(git_tree_cache)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tree"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_malloc",
          "args": [
            "pool",
            "sizeof(git_tree_cache) + name_len + 1"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_tree_cache_read_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "217-230",
    "snippet": "int git_tree_cache_read_tree(git_tree_cache **out, const git_tree *tree, git_pool *pool)\n{\n\tint error;\n\tgit_tree_cache *cache;\n\n\tif ((error = git_tree_cache_new(&cache, \"\", pool)) < 0)\n\t\treturn error;\n\n\tif ((error = read_tree_recursive(cache, tree, pool)) < 0)\n\t\treturn error;\n\n\t*out = cache;\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_tree_recursive",
          "args": [
            "cache",
            "tree",
            "pool"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_recursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "159-215",
          "snippet": "static int read_tree_recursive(git_tree_cache *cache, const git_tree *tree, git_pool *pool)\n{\n\tgit_repository *repo;\n\tsize_t i, j, nentries, ntrees;\n\tint error;\n\n\trepo = git_tree_owner(tree);\n\n\tgit_oid_cpy(&cache->oid, git_tree_id(tree));\n\tnentries = git_tree_entrycount(tree);\n\n\t/*\n\t * We make sure we know how many trees we need to allocate for\n\t * so we don't have to realloc and change the pointers for the\n\t * parents.\n\t */\n\tntrees = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) == GIT_FILEMODE_TREE)\n\t\t\tntrees++;\n\t}\n\n\tcache->children_count = ntrees;\n\tcache->children = git_pool_mallocz(pool, ntrees * sizeof(git_tree_cache *));\n\tGITERR_CHECK_ALLOC(cache->children);\n\n\tj = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\t\tgit_tree *subtree;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) != GIT_FILEMODE_TREE) {\n\t\t\tcache->entry_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = git_tree_cache_new(&cache->children[j], git_tree_entry_name(entry), pool)) < 0)\n\t\t\treturn error;\n\n\t\tif ((error = git_tree_lookup(&subtree, repo, git_tree_entry_id(entry))) < 0)\n\t\t\treturn error;\n\n\t\terror = read_tree_recursive(cache->children[j], subtree, pool);\n\t\tgit_tree_free(subtree);\n\t\tcache->entry_count += cache->children[j]->entry_count;\n\t\tj++;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic int read_tree_recursive(git_tree_cache *cache, const git_tree *tree, git_pool *pool)\n{\n\tgit_repository *repo;\n\tsize_t i, j, nentries, ntrees;\n\tint error;\n\n\trepo = git_tree_owner(tree);\n\n\tgit_oid_cpy(&cache->oid, git_tree_id(tree));\n\tnentries = git_tree_entrycount(tree);\n\n\t/*\n\t * We make sure we know how many trees we need to allocate for\n\t * so we don't have to realloc and change the pointers for the\n\t * parents.\n\t */\n\tntrees = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) == GIT_FILEMODE_TREE)\n\t\t\tntrees++;\n\t}\n\n\tcache->children_count = ntrees;\n\tcache->children = git_pool_mallocz(pool, ntrees * sizeof(git_tree_cache *));\n\tGITERR_CHECK_ALLOC(cache->children);\n\n\tj = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\t\tgit_tree *subtree;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) != GIT_FILEMODE_TREE) {\n\t\t\tcache->entry_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = git_tree_cache_new(&cache->children[j], git_tree_entry_name(entry), pool)) < 0)\n\t\t\treturn error;\n\n\t\tif ((error = git_tree_lookup(&subtree, repo, git_tree_entry_id(entry))) < 0)\n\t\t\treturn error;\n\n\t\terror = read_tree_recursive(cache->children[j], subtree, pool);\n\t\tgit_tree_free(subtree);\n\t\tcache->entry_count += cache->children[j]->entry_count;\n\t\tj++;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_cache_new",
          "args": [
            "&cache",
            "\"\"",
            "pool"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "232-249",
          "snippet": "int git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_read_tree(git_tree_cache **out, const git_tree *tree, git_pool *pool)\n{\n\tint error;\n\tgit_tree_cache *cache;\n\n\tif ((error = git_tree_cache_new(&cache, \"\", pool)) < 0)\n\t\treturn error;\n\n\tif ((error = read_tree_recursive(cache, tree, pool)) < 0)\n\t\treturn error;\n\n\t*out = cache;\n\treturn 0;\n}"
  },
  {
    "function_name": "read_tree_recursive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "159-215",
    "snippet": "static int read_tree_recursive(git_tree_cache *cache, const git_tree *tree, git_pool *pool)\n{\n\tgit_repository *repo;\n\tsize_t i, j, nentries, ntrees;\n\tint error;\n\n\trepo = git_tree_owner(tree);\n\n\tgit_oid_cpy(&cache->oid, git_tree_id(tree));\n\tnentries = git_tree_entrycount(tree);\n\n\t/*\n\t * We make sure we know how many trees we need to allocate for\n\t * so we don't have to realloc and change the pointers for the\n\t * parents.\n\t */\n\tntrees = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) == GIT_FILEMODE_TREE)\n\t\t\tntrees++;\n\t}\n\n\tcache->children_count = ntrees;\n\tcache->children = git_pool_mallocz(pool, ntrees * sizeof(git_tree_cache *));\n\tGITERR_CHECK_ALLOC(cache->children);\n\n\tj = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\t\tgit_tree *subtree;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) != GIT_FILEMODE_TREE) {\n\t\t\tcache->entry_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = git_tree_cache_new(&cache->children[j], git_tree_entry_name(entry), pool)) < 0)\n\t\t\treturn error;\n\n\t\tif ((error = git_tree_lookup(&subtree, repo, git_tree_entry_id(entry))) < 0)\n\t\t\treturn error;\n\n\t\terror = read_tree_recursive(cache->children[j], subtree, pool);\n\t\tgit_tree_free(subtree);\n\t\tcache->entry_count += cache->children[j]->entry_count;\n\t\tj++;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "subtree"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_recursive",
          "args": [
            "cache->children[j]",
            "subtree",
            "pool"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_recursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "159-215",
          "snippet": "static int read_tree_recursive(git_tree_cache *cache, const git_tree *tree, git_pool *pool)\n{\n\tgit_repository *repo;\n\tsize_t i, j, nentries, ntrees;\n\tint error;\n\n\trepo = git_tree_owner(tree);\n\n\tgit_oid_cpy(&cache->oid, git_tree_id(tree));\n\tnentries = git_tree_entrycount(tree);\n\n\t/*\n\t * We make sure we know how many trees we need to allocate for\n\t * so we don't have to realloc and change the pointers for the\n\t * parents.\n\t */\n\tntrees = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) == GIT_FILEMODE_TREE)\n\t\t\tntrees++;\n\t}\n\n\tcache->children_count = ntrees;\n\tcache->children = git_pool_mallocz(pool, ntrees * sizeof(git_tree_cache *));\n\tGITERR_CHECK_ALLOC(cache->children);\n\n\tj = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\t\tgit_tree *subtree;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) != GIT_FILEMODE_TREE) {\n\t\t\tcache->entry_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = git_tree_cache_new(&cache->children[j], git_tree_entry_name(entry), pool)) < 0)\n\t\t\treturn error;\n\n\t\tif ((error = git_tree_lookup(&subtree, repo, git_tree_entry_id(entry))) < 0)\n\t\t\treturn error;\n\n\t\terror = read_tree_recursive(cache->children[j], subtree, pool);\n\t\tgit_tree_free(subtree);\n\t\tcache->entry_count += cache->children[j]->entry_count;\n\t\tj++;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_lookup",
          "args": [
            "&subtree",
            "repo",
            "git_tree_entry_id(entry)"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "49-52",
          "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_id",
          "args": [
            "entry"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "278-282",
          "snippet": "const git_oid *git_tree_entry_id(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->oid;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_tree_entry_id(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_cache_new",
          "args": [
            "&cache->children[j]",
            "git_tree_entry_name(entry)",
            "pool"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "232-249",
          "snippet": "int git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_name",
          "args": [
            "entry"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "272-276",
          "snippet": "const char *git_tree_entry_name(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->filename;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst char *git_tree_entry_name(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->filename;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_filemode",
          "args": [
            "entry"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_filemode_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "267-270",
          "snippet": "git_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *entry)\n{\n\treturn entry->attr;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\ngit_filemode_t git_tree_entry_filemode_raw(const git_tree_entry *entry)\n{\n\treturn entry->attr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_byindex",
          "args": [
            "tree",
            "i"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "324-329",
          "snippet": "const git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_array_get(tree->entries, idx);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_array_get(tree->entries, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cache->children"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "pool",
            "ntrees * sizeof(git_tree_cache *)"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entrycount",
          "args": [
            "tree"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "382-386",
          "snippet": "size_t git_tree_entrycount(const git_tree *tree)\n{\n\tassert(tree);\n\treturn tree->entries.size;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nsize_t git_tree_entrycount(const git_tree *tree)\n{\n\tassert(tree);\n\treturn tree->entries.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&cache->oid",
            "git_tree_id(tree)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_id",
          "args": [
            "tree"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "64-67",
          "snippet": "const git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_tree_id(const git_tree *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "tree"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic int read_tree_recursive(git_tree_cache *cache, const git_tree *tree, git_pool *pool)\n{\n\tgit_repository *repo;\n\tsize_t i, j, nentries, ntrees;\n\tint error;\n\n\trepo = git_tree_owner(tree);\n\n\tgit_oid_cpy(&cache->oid, git_tree_id(tree));\n\tnentries = git_tree_entrycount(tree);\n\n\t/*\n\t * We make sure we know how many trees we need to allocate for\n\t * so we don't have to realloc and change the pointers for the\n\t * parents.\n\t */\n\tntrees = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) == GIT_FILEMODE_TREE)\n\t\t\tntrees++;\n\t}\n\n\tcache->children_count = ntrees;\n\tcache->children = git_pool_mallocz(pool, ntrees * sizeof(git_tree_cache *));\n\tGITERR_CHECK_ALLOC(cache->children);\n\n\tj = 0;\n\tfor (i = 0; i < nentries; i++) {\n\t\tconst git_tree_entry *entry;\n\t\tgit_tree *subtree;\n\n\t\tentry = git_tree_entry_byindex(tree, i);\n\t\tif (git_tree_entry_filemode(entry) != GIT_FILEMODE_TREE) {\n\t\t\tcache->entry_count++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = git_tree_cache_new(&cache->children[j], git_tree_entry_name(entry), pool)) < 0)\n\t\t\treturn error;\n\n\t\tif ((error = git_tree_lookup(&subtree, repo, git_tree_entry_id(entry))) < 0)\n\t\t\treturn error;\n\n\t\terror = read_tree_recursive(cache->children[j], subtree, pool);\n\t\tgit_tree_free(subtree);\n\t\tcache->entry_count += cache->children[j]->entry_count;\n\t\tj++;\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_tree_cache_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "144-157",
    "snippet": "int git_tree_cache_read(git_tree_cache **tree, const char *buffer, size_t buffer_size, git_pool *pool)\n{\n\tconst char *buffer_end = buffer + buffer_size;\n\n\tif (read_tree_internal(tree, &buffer, buffer_end, pool) < 0)\n\t\treturn -1;\n\n\tif (buffer < buffer_end) {\n\t\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index (unexpected trailing data)\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Corrupted TREE extension in index (unexpected trailing data)\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_internal",
          "args": [
            "tree",
            "&buffer",
            "buffer_end",
            "pool"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "73-142",
          "snippet": "static int read_tree_internal(git_tree_cache **out,\n\t\t\t      const char **buffer_in, const char *buffer_end,\n\t\t\t      git_pool *pool)\n{\n\tgit_tree_cache *tree = NULL;\n\tconst char *name_start, *buffer;\n\tint count;\n\n\tbuffer = name_start = *buffer_in;\n\n\tif ((buffer = memchr(buffer, '\\0', buffer_end - buffer)) == NULL)\n\t\tgoto corrupted;\n\n\tif (++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\tif (git_tree_cache_new(&tree, name_start, pool) < 0)\n\t\treturn -1;\n\n\t/* Blank-terminated ASCII decimal number of entries in this tree */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0)\n\t\tgoto corrupted;\n\n\ttree->entry_count = count;\n\n\tif (*buffer != ' ' || ++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\t /* Number of children of the tree, newline-terminated */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0 || count < 0)\n\t\tgoto corrupted;\n\n\ttree->children_count = count;\n\n\tif (*buffer != '\\n' || ++buffer > buffer_end)\n\t\tgoto corrupted;\n\n\t/* The SHA1 is only there if it's not invalidated */\n\tif (tree->entry_count >= 0) {\n\t\t/* 160-bit SHA-1 for this tree and it's children */\n\t\tif (buffer + GIT_OID_RAWSZ > buffer_end)\n\t\t\tgoto corrupted;\n\n\t\tgit_oid_fromraw(&tree->oid, (const unsigned char *)buffer);\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\t/* Parse children: */\n\tif (tree->children_count > 0) {\n\t\tunsigned int i;\n\n\t\ttree->children = git_pool_malloc(pool, tree->children_count * sizeof(git_tree_cache *));\n\t\tGITERR_CHECK_ALLOC(tree->children);\n\n\t\tmemset(tree->children, 0x0, tree->children_count * sizeof(git_tree_cache *));\n\n\t\tfor (i = 0; i < tree->children_count; ++i) {\n\t\t\tif (read_tree_internal(&tree->children[i], &buffer, buffer_end, pool) < 0)\n\t\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\t*buffer_in = buffer;\n\t*out = tree;\n\treturn 0;\n\n corrupted:\n\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index\");\n\treturn -1;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic int read_tree_internal(git_tree_cache **out,\n\t\t\t      const char **buffer_in, const char *buffer_end,\n\t\t\t      git_pool *pool)\n{\n\tgit_tree_cache *tree = NULL;\n\tconst char *name_start, *buffer;\n\tint count;\n\n\tbuffer = name_start = *buffer_in;\n\n\tif ((buffer = memchr(buffer, '\\0', buffer_end - buffer)) == NULL)\n\t\tgoto corrupted;\n\n\tif (++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\tif (git_tree_cache_new(&tree, name_start, pool) < 0)\n\t\treturn -1;\n\n\t/* Blank-terminated ASCII decimal number of entries in this tree */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0)\n\t\tgoto corrupted;\n\n\ttree->entry_count = count;\n\n\tif (*buffer != ' ' || ++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\t /* Number of children of the tree, newline-terminated */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0 || count < 0)\n\t\tgoto corrupted;\n\n\ttree->children_count = count;\n\n\tif (*buffer != '\\n' || ++buffer > buffer_end)\n\t\tgoto corrupted;\n\n\t/* The SHA1 is only there if it's not invalidated */\n\tif (tree->entry_count >= 0) {\n\t\t/* 160-bit SHA-1 for this tree and it's children */\n\t\tif (buffer + GIT_OID_RAWSZ > buffer_end)\n\t\t\tgoto corrupted;\n\n\t\tgit_oid_fromraw(&tree->oid, (const unsigned char *)buffer);\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\t/* Parse children: */\n\tif (tree->children_count > 0) {\n\t\tunsigned int i;\n\n\t\ttree->children = git_pool_malloc(pool, tree->children_count * sizeof(git_tree_cache *));\n\t\tGITERR_CHECK_ALLOC(tree->children);\n\n\t\tmemset(tree->children, 0x0, tree->children_count * sizeof(git_tree_cache *));\n\n\t\tfor (i = 0; i < tree->children_count; ++i) {\n\t\t\tif (read_tree_internal(&tree->children[i], &buffer, buffer_end, pool) < 0)\n\t\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\t*buffer_in = buffer;\n\t*out = tree;\n\treturn 0;\n\n corrupted:\n\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index\");\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_read(git_tree_cache **tree, const char *buffer, size_t buffer_size, git_pool *pool)\n{\n\tconst char *buffer_end = buffer + buffer_size;\n\n\tif (read_tree_internal(tree, &buffer, buffer_end, pool) < 0)\n\t\treturn -1;\n\n\tif (buffer < buffer_end) {\n\t\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index (unexpected trailing data)\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "read_tree_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "73-142",
    "snippet": "static int read_tree_internal(git_tree_cache **out,\n\t\t\t      const char **buffer_in, const char *buffer_end,\n\t\t\t      git_pool *pool)\n{\n\tgit_tree_cache *tree = NULL;\n\tconst char *name_start, *buffer;\n\tint count;\n\n\tbuffer = name_start = *buffer_in;\n\n\tif ((buffer = memchr(buffer, '\\0', buffer_end - buffer)) == NULL)\n\t\tgoto corrupted;\n\n\tif (++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\tif (git_tree_cache_new(&tree, name_start, pool) < 0)\n\t\treturn -1;\n\n\t/* Blank-terminated ASCII decimal number of entries in this tree */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0)\n\t\tgoto corrupted;\n\n\ttree->entry_count = count;\n\n\tif (*buffer != ' ' || ++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\t /* Number of children of the tree, newline-terminated */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0 || count < 0)\n\t\tgoto corrupted;\n\n\ttree->children_count = count;\n\n\tif (*buffer != '\\n' || ++buffer > buffer_end)\n\t\tgoto corrupted;\n\n\t/* The SHA1 is only there if it's not invalidated */\n\tif (tree->entry_count >= 0) {\n\t\t/* 160-bit SHA-1 for this tree and it's children */\n\t\tif (buffer + GIT_OID_RAWSZ > buffer_end)\n\t\t\tgoto corrupted;\n\n\t\tgit_oid_fromraw(&tree->oid, (const unsigned char *)buffer);\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\t/* Parse children: */\n\tif (tree->children_count > 0) {\n\t\tunsigned int i;\n\n\t\ttree->children = git_pool_malloc(pool, tree->children_count * sizeof(git_tree_cache *));\n\t\tGITERR_CHECK_ALLOC(tree->children);\n\n\t\tmemset(tree->children, 0x0, tree->children_count * sizeof(git_tree_cache *));\n\n\t\tfor (i = 0; i < tree->children_count; ++i) {\n\t\t\tif (read_tree_internal(&tree->children[i], &buffer, buffer_end, pool) < 0)\n\t\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\t*buffer_in = buffer;\n\t*out = tree;\n\treturn 0;\n\n corrupted:\n\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index\");\n\treturn -1;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Corrupted TREE extension in index\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_internal",
          "args": [
            "&tree->children[i]",
            "&buffer",
            "buffer_end",
            "pool"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "73-142",
          "snippet": "static int read_tree_internal(git_tree_cache **out,\n\t\t\t      const char **buffer_in, const char *buffer_end,\n\t\t\t      git_pool *pool)\n{\n\tgit_tree_cache *tree = NULL;\n\tconst char *name_start, *buffer;\n\tint count;\n\n\tbuffer = name_start = *buffer_in;\n\n\tif ((buffer = memchr(buffer, '\\0', buffer_end - buffer)) == NULL)\n\t\tgoto corrupted;\n\n\tif (++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\tif (git_tree_cache_new(&tree, name_start, pool) < 0)\n\t\treturn -1;\n\n\t/* Blank-terminated ASCII decimal number of entries in this tree */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0)\n\t\tgoto corrupted;\n\n\ttree->entry_count = count;\n\n\tif (*buffer != ' ' || ++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\t /* Number of children of the tree, newline-terminated */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0 || count < 0)\n\t\tgoto corrupted;\n\n\ttree->children_count = count;\n\n\tif (*buffer != '\\n' || ++buffer > buffer_end)\n\t\tgoto corrupted;\n\n\t/* The SHA1 is only there if it's not invalidated */\n\tif (tree->entry_count >= 0) {\n\t\t/* 160-bit SHA-1 for this tree and it's children */\n\t\tif (buffer + GIT_OID_RAWSZ > buffer_end)\n\t\t\tgoto corrupted;\n\n\t\tgit_oid_fromraw(&tree->oid, (const unsigned char *)buffer);\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\t/* Parse children: */\n\tif (tree->children_count > 0) {\n\t\tunsigned int i;\n\n\t\ttree->children = git_pool_malloc(pool, tree->children_count * sizeof(git_tree_cache *));\n\t\tGITERR_CHECK_ALLOC(tree->children);\n\n\t\tmemset(tree->children, 0x0, tree->children_count * sizeof(git_tree_cache *));\n\n\t\tfor (i = 0; i < tree->children_count; ++i) {\n\t\t\tif (read_tree_internal(&tree->children[i], &buffer, buffer_end, pool) < 0)\n\t\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\t*buffer_in = buffer;\n\t*out = tree;\n\treturn 0;\n\n corrupted:\n\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index\");\n\treturn -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tree->children",
            "0x0",
            "tree->children_count * sizeof(git_tree_cache *)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tree->children"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_malloc",
          "args": [
            "pool",
            "tree->children_count * sizeof(git_tree_cache *)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "&tree->oid",
            "(const unsigned char *)buffer"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strtol32",
          "args": [
            "&count",
            "buffer",
            "&buffer",
            "10"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "git__strtol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "149-167",
          "snippet": "int git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_cache_new",
          "args": [
            "&tree",
            "name_start",
            "pool"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "232-249",
          "snippet": "int git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_new(git_tree_cache **out, const char *name, git_pool *pool)\n{\n\tsize_t name_len;\n\tgit_tree_cache *tree;\n\n\tname_len = strlen(name);\n\ttree = git_pool_malloc(pool, sizeof(git_tree_cache) + name_len + 1);\n\tGITERR_CHECK_ALLOC(tree);\n\n\tmemset(tree, 0x0, sizeof(git_tree_cache));\n\t/* NUL-terminated tree name */\n\ttree->namelen = name_len;\n\tmemcpy(tree->name, name, name_len);\n\ttree->name[name_len] = '\\0';\n\n\t*out = tree;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buffer",
            "'\\0'",
            "buffer_end - buffer"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic int read_tree_internal(git_tree_cache **out,\n\t\t\t      const char **buffer_in, const char *buffer_end,\n\t\t\t      git_pool *pool)\n{\n\tgit_tree_cache *tree = NULL;\n\tconst char *name_start, *buffer;\n\tint count;\n\n\tbuffer = name_start = *buffer_in;\n\n\tif ((buffer = memchr(buffer, '\\0', buffer_end - buffer)) == NULL)\n\t\tgoto corrupted;\n\n\tif (++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\tif (git_tree_cache_new(&tree, name_start, pool) < 0)\n\t\treturn -1;\n\n\t/* Blank-terminated ASCII decimal number of entries in this tree */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0)\n\t\tgoto corrupted;\n\n\ttree->entry_count = count;\n\n\tif (*buffer != ' ' || ++buffer >= buffer_end)\n\t\tgoto corrupted;\n\n\t /* Number of children of the tree, newline-terminated */\n\tif (git__strtol32(&count, buffer, &buffer, 10) < 0 || count < 0)\n\t\tgoto corrupted;\n\n\ttree->children_count = count;\n\n\tif (*buffer != '\\n' || ++buffer > buffer_end)\n\t\tgoto corrupted;\n\n\t/* The SHA1 is only there if it's not invalidated */\n\tif (tree->entry_count >= 0) {\n\t\t/* 160-bit SHA-1 for this tree and it's children */\n\t\tif (buffer + GIT_OID_RAWSZ > buffer_end)\n\t\t\tgoto corrupted;\n\n\t\tgit_oid_fromraw(&tree->oid, (const unsigned char *)buffer);\n\t\tbuffer += GIT_OID_RAWSZ;\n\t}\n\n\t/* Parse children: */\n\tif (tree->children_count > 0) {\n\t\tunsigned int i;\n\n\t\ttree->children = git_pool_malloc(pool, tree->children_count * sizeof(git_tree_cache *));\n\t\tGITERR_CHECK_ALLOC(tree->children);\n\n\t\tmemset(tree->children, 0x0, tree->children_count * sizeof(git_tree_cache *));\n\n\t\tfor (i = 0; i < tree->children_count; ++i) {\n\t\t\tif (read_tree_internal(&tree->children[i], &buffer, buffer_end, pool) < 0)\n\t\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\t*buffer_in = buffer;\n\t*out = tree;\n\treturn 0;\n\n corrupted:\n\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index\");\n\treturn -1;\n}"
  },
  {
    "function_name": "git_tree_cache_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "51-71",
    "snippet": "const git_tree_cache *git_tree_cache_get(const git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (1) {\n\t\tend = strchr(ptr, '/');\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* Can't find it */\n\t\t\treturn NULL;\n\n\t\tif (end == NULL || *end + 1 == '\\0')\n\t\t\treturn tree;\n\n\t\tptr = end + 1;\n\t}\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "tree",
            "ptr",
            "end"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "12-25",
          "snippet": "static git_tree_cache *find_child(\n\tconst git_tree_cache *tree, const char *path, const char *end)\n{\n\tsize_t i, dirlen = end ? (size_t)(end - path) : strlen(path);\n\n\tfor (i = 0; i < tree->children_count; ++i) {\n\t\tgit_tree_cache *child = tree->children[i];\n\n\t\tif (child->namelen == dirlen && !memcmp(path, child->name, dirlen))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic git_tree_cache *find_child(\n\tconst git_tree_cache *tree, const char *path, const char *end)\n{\n\tsize_t i, dirlen = end ? (size_t)(end - path) : strlen(path);\n\n\tfor (i = 0; i < tree->children_count; ++i) {\n\t\tgit_tree_cache *child = tree->children[i];\n\n\t\tif (child->namelen == dirlen && !memcmp(path, child->name, dirlen))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'/'"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nconst git_tree_cache *git_tree_cache_get(const git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (1) {\n\t\tend = strchr(ptr, '/');\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* Can't find it */\n\t\t\treturn NULL;\n\n\t\tif (end == NULL || *end + 1 == '\\0')\n\t\t\treturn tree;\n\n\t\tptr = end + 1;\n\t}\n}"
  },
  {
    "function_name": "git_tree_cache_invalidate_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "27-49",
    "snippet": "void git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_child",
          "args": [
            "tree",
            "ptr",
            "end"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "find_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "12-25",
          "snippet": "static git_tree_cache *find_child(\n\tconst git_tree_cache *tree, const char *path, const char *end)\n{\n\tsize_t i, dirlen = end ? (size_t)(end - path) : strlen(path);\n\n\tfor (i = 0; i < tree->children_count; ++i) {\n\t\tgit_tree_cache *child = tree->children[i];\n\n\t\tif (child->namelen == dirlen && !memcmp(path, child->name, dirlen))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic git_tree_cache *find_child(\n\tconst git_tree_cache *tree, const char *path, const char *end)\n{\n\tsize_t i, dirlen = end ? (size_t)(end - path) : strlen(path);\n\n\tfor (i = 0; i < tree->children_count; ++i) {\n\t\tgit_tree_cache *child = tree->children[i];\n\n\t\tif (child->namelen == dirlen && !memcmp(path, child->name, dirlen))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "'/'"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nvoid git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}"
  },
  {
    "function_name": "find_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
    "lines": "12-25",
    "snippet": "static git_tree_cache *find_child(\n\tconst git_tree_cache *tree, const char *path, const char *end)\n{\n\tsize_t i, dirlen = end ? (size_t)(end - path) : strlen(path);\n\n\tfor (i = 0; i < tree->children_count; ++i) {\n\t\tgit_tree_cache *child = tree->children[i];\n\n\t\tif (child->namelen == dirlen && !memcmp(path, child->name, dirlen))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"tree.h\"",
      "#include \"pool.h\"",
      "#include \"tree-cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "path",
            "child->name",
            "dirlen"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nstatic git_tree_cache *find_child(\n\tconst git_tree_cache *tree, const char *path, const char *end)\n{\n\tsize_t i, dirlen = end ? (size_t)(end - path) : strlen(path);\n\n\tfor (i = 0; i < tree->children_count; ++i) {\n\t\tgit_tree_cache *child = tree->children[i];\n\n\t\tif (child->namelen == dirlen && !memcmp(path, child->name, dirlen))\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}"
  }
]