[
  {
    "function_name": "git_buf_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "165-169",
    "snippet": "GIT_INLINE(ssize_t) git_buf_find(const git_buf *buf, char ch)\n{\n\tvoid *found = memchr(buf->ptr, ch, buf->size);\n\treturn found ? (ssize_t)((const char *)found - buf->ptr) : -1;\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf->ptr",
            "ch",
            "buf->size"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_find(const git_buf *buf, char ch)\n{\n\tvoid *found = memchr(buf->ptr, ch, buf->size);\n\treturn found ? (ssize_t)((const char *)found - buf->ptr) : -1;\n}"
  },
  {
    "function_name": "git_buf_rfind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "158-163",
    "snippet": "GIT_INLINE(ssize_t) git_buf_rfind(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
  },
  {
    "function_name": "git_buf_rfind_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "150-156",
    "snippet": "GIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
  },
  {
    "function_name": "git_buf_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "141-144",
    "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
  },
  {
    "function_name": "git_buf_cstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "136-139",
    "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
  },
  {
    "function_name": "git_buf_joinpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "131-134",
    "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_join",
          "args": [
            "buf",
            "'/'",
            "a",
            "b"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "607-655",
          "snippet": "int git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
  },
  {
    "function_name": "git_buf_oom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "94-97",
    "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
  },
  {
    "function_name": "git_buf_is_allocated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
    "lines": "26-29",
    "snippet": "GIT_INLINE(bool) git_buf_is_allocated(const git_buf *buf)\n{\n\treturn (buf->ptr != NULL && buf->asize > 0);\n}",
    "includes": [
      "#include \"git2/buffer.h\"",
      "#include \"git2/strarray.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_is_allocated(const git_buf *buf)\n{\n\treturn (buf->ptr != NULL && buf->asize > 0);\n}"
  }
]