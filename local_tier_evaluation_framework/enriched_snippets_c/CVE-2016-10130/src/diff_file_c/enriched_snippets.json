[
  {
    "function_name": "git_diff_file_content__clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "459-464",
    "snippet": "void git_diff_file_content__clear(git_diff_file_content *fc)\n{\n\tgit_diff_file_content__unload(fc);\n\n\t/* for now, nothing else to do */\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_file_content__unload",
          "args": [
            "fc"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_file_content__unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "432-457",
          "snippet": "void git_diff_file_content__unload(git_diff_file_content *fc)\n{\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) == 0)\n\t\treturn;\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_DATA) {\n\t\tgit__free(fc->map.data);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_DATA;\n\t}\n\telse if (fc->flags & GIT_DIFF_FLAG__UNMAP_DATA) {\n\t\tgit_futils_mmap_free(&fc->map);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__UNMAP_DATA;\n\t}\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_BLOB) {\n\t\tgit_blob_free((git_blob *)fc->blob);\n\t\tfc->blob = NULL;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_BLOB;\n\t}\n\n\tfc->flags &= ~GIT_DIFF_FLAG__LOADED;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nvoid git_diff_file_content__unload(git_diff_file_content *fc)\n{\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) == 0)\n\t\treturn;\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_DATA) {\n\t\tgit__free(fc->map.data);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_DATA;\n\t}\n\telse if (fc->flags & GIT_DIFF_FLAG__UNMAP_DATA) {\n\t\tgit_futils_mmap_free(&fc->map);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__UNMAP_DATA;\n\t}\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_BLOB) {\n\t\tgit_blob_free((git_blob *)fc->blob);\n\t\tfc->blob = NULL;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_BLOB;\n\t}\n\n\tfc->flags &= ~GIT_DIFF_FLAG__LOADED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nvoid git_diff_file_content__clear(git_diff_file_content *fc)\n{\n\tgit_diff_file_content__unload(fc);\n\n\t/* for now, nothing else to do */\n}"
  },
  {
    "function_name": "git_diff_file_content__unload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "432-457",
    "snippet": "void git_diff_file_content__unload(git_diff_file_content *fc)\n{\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) == 0)\n\t\treturn;\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_DATA) {\n\t\tgit__free(fc->map.data);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_DATA;\n\t}\n\telse if (fc->flags & GIT_DIFF_FLAG__UNMAP_DATA) {\n\t\tgit_futils_mmap_free(&fc->map);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__UNMAP_DATA;\n\t}\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_BLOB) {\n\t\tgit_blob_free((git_blob *)fc->blob);\n\t\tfc->blob = NULL;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_BLOB;\n\t}\n\n\tfc->flags &= ~GIT_DIFF_FLAG__LOADED;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_blob_free",
          "args": [
            "(git_blob *)fc->blob"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "116-119",
          "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_free",
          "args": [
            "&fc->map"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "294-297",
          "snippet": "void git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_mmap_free(git_map *out)\n{\n\tp_munmap(out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "fc->map.data"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nvoid git_diff_file_content__unload(git_diff_file_content *fc)\n{\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) == 0)\n\t\treturn;\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_DATA) {\n\t\tgit__free(fc->map.data);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_DATA;\n\t}\n\telse if (fc->flags & GIT_DIFF_FLAG__UNMAP_DATA) {\n\t\tgit_futils_mmap_free(&fc->map);\n\t\tfc->map.data = \"\";\n\t\tfc->map.len  = 0;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__UNMAP_DATA;\n\t}\n\n\tif (fc->flags & GIT_DIFF_FLAG__FREE_BLOB) {\n\t\tgit_blob_free((git_blob *)fc->blob);\n\t\tfc->blob = NULL;\n\t\tfc->flags &= ~GIT_DIFF_FLAG__FREE_BLOB;\n\t}\n\n\tfc->flags &= ~GIT_DIFF_FLAG__LOADED;\n}"
  },
  {
    "function_name": "git_diff_file_content__load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "405-430",
    "snippet": "int git_diff_file_content__load(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\treturn 0;\n\n\tif ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0 &&\n\t\t(diff_opts->flags & GIT_DIFF_SHOW_BINARY) == 0)\n\t\treturn 0;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\terror = diff_file_content_load_workdir(fc, diff_opts);\n\telse\n\t\terror = diff_file_content_load_blob(fc, diff_opts);\n\tif (error)\n\t\treturn error;\n\n\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\n\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_file_content_binary_by_content",
          "args": [
            "fc"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_binary_by_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "29-40",
          "snippet": "static void diff_file_content_binary_by_content(git_diff_file_content *fc)\n{\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) != 0)\n\t\treturn;\n\n\tswitch (git_diff_driver_content_is_binary(\n\t\tfc->driver, fc->map.data, fc->map.len)) {\n\tcase 0: fc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY; break;\n\tcase 1: fc->file->flags |= GIT_DIFF_FLAG_BINARY; break;\n\tdefault: break;\n\t}\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic void diff_file_content_binary_by_content(git_diff_file_content *fc)\n{\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) != 0)\n\t\treturn;\n\n\tswitch (git_diff_driver_content_is_binary(\n\t\tfc->driver, fc->map.data, fc->map.len)) {\n\tcase 0: fc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY; break;\n\tcase 1: fc->file->flags |= GIT_DIFF_FLAG_BINARY; break;\n\tdefault: break;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_load_blob",
          "args": [
            "fc",
            "diff_opts"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_load_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "220-260",
          "snippet": "static int diff_file_content_load_blob(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *opts)\n{\n\tint error = 0;\n\tgit_odb_object *odb_obj = NULL;\n\n\tif (git_oid_iszero(&fc->file->id))\n\t\treturn 0;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, false);\n\n\t/* if we don't know size, try to peek at object header first */\n\tif (!fc->file->size) {\n\t\tif ((error = git_diff_file__resolve_zero_size(\n\t\t\t\tfc->file, &odb_obj, fc->repo)) < 0)\n\t\t\treturn error;\n\t}\n\n\tif ((opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\treturn 0;\n\n\tif (odb_obj != NULL) {\n\t\terror = git_object__from_odb_object(\n\t\t\t(git_object **)&fc->blob, fc->repo, odb_obj, GIT_OBJ_BLOB);\n\t\tgit_odb_object_free(odb_obj);\n\t} else {\n\t\terror = git_blob_lookup(\n\t\t\t(git_blob **)&fc->blob, fc->repo, &fc->file->id);\n\t}\n\n\tif (!error) {\n\t\tfc->flags |= GIT_DIFF_FLAG__FREE_BLOB;\n\t\tfc->map.data = (void *)git_blob_rawcontent(fc->blob);\n\t\tfc->map.len  = (size_t)git_blob_rawsize(fc->blob);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_blob(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *opts)\n{\n\tint error = 0;\n\tgit_odb_object *odb_obj = NULL;\n\n\tif (git_oid_iszero(&fc->file->id))\n\t\treturn 0;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, false);\n\n\t/* if we don't know size, try to peek at object header first */\n\tif (!fc->file->size) {\n\t\tif ((error = git_diff_file__resolve_zero_size(\n\t\t\t\tfc->file, &odb_obj, fc->repo)) < 0)\n\t\t\treturn error;\n\t}\n\n\tif ((opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\treturn 0;\n\n\tif (odb_obj != NULL) {\n\t\terror = git_object__from_odb_object(\n\t\t\t(git_object **)&fc->blob, fc->repo, odb_obj, GIT_OBJ_BLOB);\n\t\tgit_odb_object_free(odb_obj);\n\t} else {\n\t\terror = git_blob_lookup(\n\t\t\t(git_blob **)&fc->blob, fc->repo, &fc->file->id);\n\t}\n\n\tif (!error) {\n\t\tfc->flags |= GIT_DIFF_FLAG__FREE_BLOB;\n\t\tfc->map.data = (void *)git_blob_rawcontent(fc->blob);\n\t\tfc->map.len  = (size_t)git_blob_rawsize(fc->blob);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_load_workdir",
          "args": [
            "fc",
            "diff_opts"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_load_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "372-403",
          "snippet": "static int diff_file_content_load_workdir(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, true);\n\n\tif (fc->file->mode == GIT_FILEMODE_TREE)\n\t\treturn 0;\n\n\tif (git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(fc->repo), fc->file->path) < 0)\n\t\treturn -1;\n\n\tif (S_ISLNK(fc->file->mode))\n\t\terror = diff_file_content_load_workdir_symlink(fc, &path);\n\telse\n\t\terror = diff_file_content_load_workdir_file(fc, &path, diff_opts);\n\n\t/* once data is loaded, update OID if we didn't have it previously */\n\tif (!error && (fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0) {\n\t\terror = git_odb_hash(\n\t\t\t&fc->file->id, fc->map.data, fc->map.len, GIT_OBJ_BLOB);\n\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\tgit_buf_free(&path);\n\treturn error;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, true);\n\n\tif (fc->file->mode == GIT_FILEMODE_TREE)\n\t\treturn 0;\n\n\tif (git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(fc->repo), fc->file->path) < 0)\n\t\treturn -1;\n\n\tif (S_ISLNK(fc->file->mode))\n\t\terror = diff_file_content_load_workdir_symlink(fc, &path);\n\telse\n\t\terror = diff_file_content_load_workdir_file(fc, &path, diff_opts);\n\n\t/* once data is loaded, update OID if we didn't have it previously */\n\tif (!error && (fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0) {\n\t\terror = git_odb_hash(\n\t\t\t&fc->file->id, fc->map.data, fc->map.len, GIT_OBJ_BLOB);\n\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\tgit_buf_free(&path);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nint git_diff_file_content__load(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\treturn 0;\n\n\tif ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0 &&\n\t\t(diff_opts->flags & GIT_DIFF_SHOW_BINARY) == 0)\n\t\treturn 0;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_WORKDIR)\n\t\terror = diff_file_content_load_workdir(fc, diff_opts);\n\telse\n\t\terror = diff_file_content_load_blob(fc, diff_opts);\n\tif (error)\n\t\treturn error;\n\n\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\n\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "diff_file_content_load_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "372-403",
    "snippet": "static int diff_file_content_load_workdir(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, true);\n\n\tif (fc->file->mode == GIT_FILEMODE_TREE)\n\t\treturn 0;\n\n\tif (git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(fc->repo), fc->file->path) < 0)\n\t\treturn -1;\n\n\tif (S_ISLNK(fc->file->mode))\n\t\terror = diff_file_content_load_workdir_symlink(fc, &path);\n\telse\n\t\terror = diff_file_content_load_workdir_file(fc, &path, diff_opts);\n\n\t/* once data is loaded, update OID if we didn't have it previously */\n\tif (!error && (fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0) {\n\t\terror = git_odb_hash(\n\t\t\t&fc->file->id, fc->map.data, fc->map.len, GIT_OBJ_BLOB);\n\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\tgit_buf_free(&path);\n\treturn error;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_hash",
          "args": [
            "&fc->file->id",
            "fc->map.data",
            "fc->map.len",
            "GIT_OBJ_BLOB"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "283-294",
          "snippet": "int git_odb_hash(git_oid *id, const void *data, size_t len, git_otype type)\n{\n\tgit_rawobj raw;\n\n\tassert(id);\n\n\traw.data = (void *)data;\n\traw.len = len;\n\traw.type = type;\n\n\treturn git_odb__hashobj(id, &raw);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_hash(git_oid *id, const void *data, size_t len, git_otype type)\n{\n\tgit_rawobj raw;\n\n\tassert(id);\n\n\traw.data = (void *)data;\n\traw.len = len;\n\traw.type = type;\n\n\treturn git_odb__hashobj(id, &raw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_load_workdir_file",
          "args": [
            "fc",
            "&path",
            "diff_opts"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_load_workdir_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "312-370",
          "snippet": "static int diff_file_content_load_workdir_file(\n\tgit_diff_file_content *fc,\n\tgit_buf *path,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_filter_list *fl = NULL;\n\tgit_file fd = git_futils_open_ro(git_buf_cstr(path));\n\tgit_buf raw = GIT_BUF_INIT;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (!fc->file->size &&\n\t\t!(fc->file->size = git_futils_filesize(fd)))\n\t\tgoto cleanup;\n\n\tif ((diff_opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\tgoto cleanup;\n\n\tif ((error = git_filter_list_load(\n\t\t\t&fl, fc->repo, NULL, fc->file->path,\n\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)) < 0)\n\t\tgoto cleanup;\n\n\t/* if there are no filters, try to mmap the file */\n\tif (fl == NULL) {\n\t\tif (!(error = git_futils_mmap_ro(\n\t\t\t\t&fc->map, fd, 0, (size_t)fc->file->size))) {\n\t\t\tfc->flags |= GIT_DIFF_FLAG__UNMAP_DATA;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* if mmap failed, fall through to try readbuffer below */\n\t\tgiterr_clear();\n\t}\n\n\tif (!(error = git_futils_readbuffer_fd(&raw, fd, (size_t)fc->file->size))) {\n\t\tgit_buf out = GIT_BUF_INIT;\n\n\t\terror = git_filter_list_apply_to_data(&out, fl, &raw);\n\n\t\tif (out.ptr != raw.ptr)\n\t\t\tgit_buf_free(&raw);\n\n\t\tif (!error) {\n\t\t\tfc->map.len  = out.size;\n\t\t\tfc->map.data = out.ptr;\n\t\t\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\t\t}\n\t}\n\ncleanup:\n\tgit_filter_list_free(fl);\n\tp_close(fd);\n\n\treturn error;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir_file(\n\tgit_diff_file_content *fc,\n\tgit_buf *path,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_filter_list *fl = NULL;\n\tgit_file fd = git_futils_open_ro(git_buf_cstr(path));\n\tgit_buf raw = GIT_BUF_INIT;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (!fc->file->size &&\n\t\t!(fc->file->size = git_futils_filesize(fd)))\n\t\tgoto cleanup;\n\n\tif ((diff_opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\tgoto cleanup;\n\n\tif ((error = git_filter_list_load(\n\t\t\t&fl, fc->repo, NULL, fc->file->path,\n\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)) < 0)\n\t\tgoto cleanup;\n\n\t/* if there are no filters, try to mmap the file */\n\tif (fl == NULL) {\n\t\tif (!(error = git_futils_mmap_ro(\n\t\t\t\t&fc->map, fd, 0, (size_t)fc->file->size))) {\n\t\t\tfc->flags |= GIT_DIFF_FLAG__UNMAP_DATA;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* if mmap failed, fall through to try readbuffer below */\n\t\tgiterr_clear();\n\t}\n\n\tif (!(error = git_futils_readbuffer_fd(&raw, fd, (size_t)fc->file->size))) {\n\t\tgit_buf out = GIT_BUF_INIT;\n\n\t\terror = git_filter_list_apply_to_data(&out, fl, &raw);\n\n\t\tif (out.ptr != raw.ptr)\n\t\t\tgit_buf_free(&raw);\n\n\t\tif (!error) {\n\t\t\tfc->map.len  = out.size;\n\t\t\tfc->map.data = out.ptr;\n\t\t\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\t\t}\n\t}\n\ncleanup:\n\tgit_filter_list_free(fl);\n\tp_close(fd);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_load_workdir_symlink",
          "args": [
            "fc",
            "&path"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_load_workdir_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "279-310",
          "snippet": "static int diff_file_content_load_workdir_symlink(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tssize_t alloc_len, read_len;\n\tint symlink_supported, error;\n\n\tif ((error = git_repository__cvar(\n\t\t&symlink_supported, fc->repo, GIT_CVAR_SYMLINKS)) < 0)\n\t\treturn -1;\n\n\tif (!symlink_supported)\n\t\treturn diff_file_content_load_workdir_symlink_fake(fc, path);\n\n\t/* link path on disk could be UTF-16, so prepare a buffer that is\n\t * big enough to handle some UTF-8 data expansion\n\t */\n\talloc_len = (ssize_t)(fc->file->size * 2) + 1;\n\n\tfc->map.data = git__calloc(alloc_len, sizeof(char));\n\tGITERR_CHECK_ALLOC(fc->map.data);\n\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tread_len = p_readlink(git_buf_cstr(path), fc->map.data, alloc_len);\n\tif (read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink '%s'\", fc->file->path);\n\t\treturn -1;\n\t}\n\n\tfc->map.len = read_len;\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir_symlink(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tssize_t alloc_len, read_len;\n\tint symlink_supported, error;\n\n\tif ((error = git_repository__cvar(\n\t\t&symlink_supported, fc->repo, GIT_CVAR_SYMLINKS)) < 0)\n\t\treturn -1;\n\n\tif (!symlink_supported)\n\t\treturn diff_file_content_load_workdir_symlink_fake(fc, path);\n\n\t/* link path on disk could be UTF-16, so prepare a buffer that is\n\t * big enough to handle some UTF-8 data expansion\n\t */\n\talloc_len = (ssize_t)(fc->file->size * 2) + 1;\n\n\tfc->map.data = git__calloc(alloc_len, sizeof(char));\n\tGITERR_CHECK_ALLOC(fc->map.data);\n\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tread_len = p_readlink(git_buf_cstr(path), fc->map.data, alloc_len);\n\tif (read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink '%s'\", fc->file->path);\n\t\treturn -1;\n\t}\n\n\tfc->map.len = read_len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "fc->file->mode"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "git_repository_workdir(fc->repo)",
            "fc->file->path"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "fc->repo"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_commit_to_str",
          "args": [
            "fc",
            "true"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_commit_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "167-218",
          "snippet": "static int diff_file_content_commit_to_str(\n\tgit_diff_file_content *fc, bool check_status)\n{\n\tchar oid[GIT_OID_HEXSZ+1];\n\tgit_buf content = GIT_BUF_INIT;\n\tconst char *status = \"\";\n\n\tif (check_status) {\n\t\tint error = 0;\n\t\tgit_submodule *sm = NULL;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_head;\n\n\t\tif ((error = git_submodule_lookup(&sm, fc->repo, fc->file->path)) < 0) {\n\t\t\t/* GIT_EEXISTS means a \"submodule\" that has not been git added */\n\t\t\tif (error == GIT_EEXISTS) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = git_submodule_status(&sm_status, fc->repo, fc->file->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* update OID if we didn't have it previously */\n\t\tif ((fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0 &&\n\t\t\t((sm_head = git_submodule_wd_id(sm)) != NULL ||\n\t\t\t (sm_head = git_submodule_head_id(sm)) != NULL))\n\t\t{\n\t\t\tgit_oid_cpy(&fc->file->id, sm_head);\n\t\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\tif (GIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\tstatus = \"-dirty\";\n\n\t\tgit_submodule_free(sm);\n\t}\n\n\tgit_oid_tostr(oid, sizeof(oid), &fc->file->id);\n\tif (git_buf_printf(&content, \"Subproject commit %s%s\\n\", oid, status) < 0)\n\t\treturn -1;\n\n\tfc->map.len  = git_buf_len(&content);\n\tfc->map.data = git_buf_detach(&content);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_commit_to_str(\n\tgit_diff_file_content *fc, bool check_status)\n{\n\tchar oid[GIT_OID_HEXSZ+1];\n\tgit_buf content = GIT_BUF_INIT;\n\tconst char *status = \"\";\n\n\tif (check_status) {\n\t\tint error = 0;\n\t\tgit_submodule *sm = NULL;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_head;\n\n\t\tif ((error = git_submodule_lookup(&sm, fc->repo, fc->file->path)) < 0) {\n\t\t\t/* GIT_EEXISTS means a \"submodule\" that has not been git added */\n\t\t\tif (error == GIT_EEXISTS) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = git_submodule_status(&sm_status, fc->repo, fc->file->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* update OID if we didn't have it previously */\n\t\tif ((fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0 &&\n\t\t\t((sm_head = git_submodule_wd_id(sm)) != NULL ||\n\t\t\t (sm_head = git_submodule_head_id(sm)) != NULL))\n\t\t{\n\t\t\tgit_oid_cpy(&fc->file->id, sm_head);\n\t\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\tif (GIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\tstatus = \"-dirty\";\n\n\t\tgit_submodule_free(sm);\n\t}\n\n\tgit_oid_tostr(oid, sizeof(oid), &fc->file->id);\n\tif (git_buf_printf(&content, \"Subproject commit %s%s\\n\", oid, status) < 0)\n\t\treturn -1;\n\n\tfc->map.len  = git_buf_len(&content);\n\tfc->map.data = git_buf_detach(&content);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, true);\n\n\tif (fc->file->mode == GIT_FILEMODE_TREE)\n\t\treturn 0;\n\n\tif (git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(fc->repo), fc->file->path) < 0)\n\t\treturn -1;\n\n\tif (S_ISLNK(fc->file->mode))\n\t\terror = diff_file_content_load_workdir_symlink(fc, &path);\n\telse\n\t\terror = diff_file_content_load_workdir_file(fc, &path, diff_opts);\n\n\t/* once data is loaded, update OID if we didn't have it previously */\n\tif (!error && (fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0) {\n\t\terror = git_odb_hash(\n\t\t\t&fc->file->id, fc->map.data, fc->map.len, GIT_OBJ_BLOB);\n\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\tgit_buf_free(&path);\n\treturn error;\n}"
  },
  {
    "function_name": "diff_file_content_load_workdir_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "312-370",
    "snippet": "static int diff_file_content_load_workdir_file(\n\tgit_diff_file_content *fc,\n\tgit_buf *path,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_filter_list *fl = NULL;\n\tgit_file fd = git_futils_open_ro(git_buf_cstr(path));\n\tgit_buf raw = GIT_BUF_INIT;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (!fc->file->size &&\n\t\t!(fc->file->size = git_futils_filesize(fd)))\n\t\tgoto cleanup;\n\n\tif ((diff_opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\tgoto cleanup;\n\n\tif ((error = git_filter_list_load(\n\t\t\t&fl, fc->repo, NULL, fc->file->path,\n\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)) < 0)\n\t\tgoto cleanup;\n\n\t/* if there are no filters, try to mmap the file */\n\tif (fl == NULL) {\n\t\tif (!(error = git_futils_mmap_ro(\n\t\t\t\t&fc->map, fd, 0, (size_t)fc->file->size))) {\n\t\t\tfc->flags |= GIT_DIFF_FLAG__UNMAP_DATA;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* if mmap failed, fall through to try readbuffer below */\n\t\tgiterr_clear();\n\t}\n\n\tif (!(error = git_futils_readbuffer_fd(&raw, fd, (size_t)fc->file->size))) {\n\t\tgit_buf out = GIT_BUF_INIT;\n\n\t\terror = git_filter_list_apply_to_data(&out, fl, &raw);\n\n\t\tif (out.ptr != raw.ptr)\n\t\t\tgit_buf_free(&raw);\n\n\t\tif (!error) {\n\t\t\tfc->map.len  = out.size;\n\t\t\tfc->map.data = out.ptr;\n\t\t\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\t\t}\n\t}\n\ncleanup:\n\tgit_filter_list_free(fl);\n\tp_close(fd);\n\n\treturn error;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_free",
          "args": [
            "fl"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "589-604",
          "snippet": "void git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&raw"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_apply_to_data",
          "args": [
            "&out",
            "fl",
            "&raw"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_apply_to_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "713-735",
          "snippet": "int git_filter_list_apply_to_data(\n\tgit_buf *tgt, git_filter_list *filters, git_buf *src)\n{\n\tstruct buf_stream writer;\n\tint error;\n\n\tgit_buf_sanitize(tgt);\n\tgit_buf_sanitize(src);\n\n\tif (!filters) {\n\t\tgit_buf_attach_notowned(tgt, src->ptr, src->size);\n\t\treturn 0;\n\t}\n\n\tbuf_stream_init(&writer, tgt);\n\n\tif ((error = git_filter_list_stream_data(filters, src,\n\t\t&writer.parent)) < 0)\n\t\t\treturn error;\n\n\tassert(writer.complete);\n\treturn error;\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_apply_to_data(\n\tgit_buf *tgt, git_filter_list *filters, git_buf *src)\n{\n\tstruct buf_stream writer;\n\tint error;\n\n\tgit_buf_sanitize(tgt);\n\tgit_buf_sanitize(src);\n\n\tif (!filters) {\n\t\tgit_buf_attach_notowned(tgt, src->ptr, src->size);\n\t\treturn 0;\n\t}\n\n\tbuf_stream_init(&writer, tgt);\n\n\tif ((error = git_filter_list_stream_data(filters, src,\n\t\t&writer.parent)) < 0)\n\t\t\treturn error;\n\n\tassert(writer.complete);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer_fd",
          "args": [
            "&raw",
            "fd",
            "(size_t)fc->file->size"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "124-153",
          "snippet": "int git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer_fd(git_buf *buf, git_file fd, size_t len)\n{\n\tssize_t read_size = 0;\n\tsize_t alloc_len;\n\n\tgit_buf_clear(buf);\n\n\tif (!git__is_ssizet(len)) {\n\t\tgiterr_set(GITERR_INVALID, \"Read too large.\");\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\n\t/* p_read loops internally to read len bytes */\n\tread_size = p_read(fd, buf->ptr, len);\n\n\tif (read_size != (ssize_t)len) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read descriptor\");\n\t\tgit_buf_free(buf);\n\t\treturn -1;\n\t}\n\n\tbuf->ptr[read_size] = '\\0';\n\tbuf->size = read_size;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mmap_ro",
          "args": [
            "&fc->map",
            "fd",
            "0",
            "(size_t)fc->file->size"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mmap_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "269-272",
          "snippet": "int git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mmap_ro(git_map *out, git_file fd, git_off_t begin, size_t len)\n{\n\treturn p_mmap(out, len, GIT_PROT_READ, GIT_MAP_SHARED, fd, begin);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_load",
          "args": [
            "&fl",
            "fc->repo",
            "NULL",
            "fc->file->path",
            "GIT_FILTER_TO_ODB",
            "GIT_FILTER_ALLOW_UNSAFE"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "573-587",
          "snippet": "int git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_binary_by_size",
          "args": [
            "fc"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_binary_by_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "18-27",
          "snippet": "static bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filesize",
          "args": [
            "fd"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filesize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "98-108",
          "snippet": "git_off_t git_futils_filesize(git_file fd)\n{\n\tstruct stat sb;\n\n\tif (p_fstat(fd, &sb)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to stat file descriptor\");\n\t\treturn -1;\n\t}\n\n\treturn sb.st_size;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\ngit_off_t git_futils_filesize(git_file fd)\n{\n\tstruct stat sb;\n\n\tif (p_fstat(fd, &sb)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to stat file descriptor\");\n\t\treturn -1;\n\t}\n\n\treturn sb.st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "git_buf_cstr(path)"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "path"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir_file(\n\tgit_diff_file_content *fc,\n\tgit_buf *path,\n\tgit_diff_options *diff_opts)\n{\n\tint error = 0;\n\tgit_filter_list *fl = NULL;\n\tgit_file fd = git_futils_open_ro(git_buf_cstr(path));\n\tgit_buf raw = GIT_BUF_INIT;\n\n\tif (fd < 0)\n\t\treturn fd;\n\n\tif (!fc->file->size &&\n\t\t!(fc->file->size = git_futils_filesize(fd)))\n\t\tgoto cleanup;\n\n\tif ((diff_opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\tgoto cleanup;\n\n\tif ((error = git_filter_list_load(\n\t\t\t&fl, fc->repo, NULL, fc->file->path,\n\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)) < 0)\n\t\tgoto cleanup;\n\n\t/* if there are no filters, try to mmap the file */\n\tif (fl == NULL) {\n\t\tif (!(error = git_futils_mmap_ro(\n\t\t\t\t&fc->map, fd, 0, (size_t)fc->file->size))) {\n\t\t\tfc->flags |= GIT_DIFF_FLAG__UNMAP_DATA;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* if mmap failed, fall through to try readbuffer below */\n\t\tgiterr_clear();\n\t}\n\n\tif (!(error = git_futils_readbuffer_fd(&raw, fd, (size_t)fc->file->size))) {\n\t\tgit_buf out = GIT_BUF_INIT;\n\n\t\terror = git_filter_list_apply_to_data(&out, fl, &raw);\n\n\t\tif (out.ptr != raw.ptr)\n\t\t\tgit_buf_free(&raw);\n\n\t\tif (!error) {\n\t\t\tfc->map.len  = out.size;\n\t\t\tfc->map.data = out.ptr;\n\t\t\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\t\t}\n\t}\n\ncleanup:\n\tgit_filter_list_free(fl);\n\tp_close(fd);\n\n\treturn error;\n}"
  },
  {
    "function_name": "diff_file_content_load_workdir_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "279-310",
    "snippet": "static int diff_file_content_load_workdir_symlink(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tssize_t alloc_len, read_len;\n\tint symlink_supported, error;\n\n\tif ((error = git_repository__cvar(\n\t\t&symlink_supported, fc->repo, GIT_CVAR_SYMLINKS)) < 0)\n\t\treturn -1;\n\n\tif (!symlink_supported)\n\t\treturn diff_file_content_load_workdir_symlink_fake(fc, path);\n\n\t/* link path on disk could be UTF-16, so prepare a buffer that is\n\t * big enough to handle some UTF-8 data expansion\n\t */\n\talloc_len = (ssize_t)(fc->file->size * 2) + 1;\n\n\tfc->map.data = git__calloc(alloc_len, sizeof(char));\n\tGITERR_CHECK_ALLOC(fc->map.data);\n\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tread_len = p_readlink(git_buf_cstr(path), fc->map.data, alloc_len);\n\tif (read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink '%s'\", fc->file->path);\n\t\treturn -1;\n\t}\n\n\tfc->map.len = read_len;\n\treturn 0;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to read symlink '%s'\"",
            "fc->file->path"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_readlink",
          "args": [
            "git_buf_cstr(path)",
            "fc->map.data",
            "alloc_len"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "p_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "251-273",
          "snippet": "int p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "path"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "fc->map.data"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "alloc_len",
            "sizeof(char)"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_load_workdir_symlink_fake",
          "args": [
            "fc",
            "path"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_load_workdir_symlink_fake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "262-277",
          "snippet": "static int diff_file_content_load_workdir_symlink_fake(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tgit_buf target = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_futils_readbuffer(&target, path->ptr)) < 0)\n\t\treturn error;\n\n\tfc->map.len = git_buf_len(&target);\n\tfc->map.data = git_buf_detach(&target);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tgit_buf_free(&target);\n\treturn error;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir_symlink_fake(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tgit_buf target = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_futils_readbuffer(&target, path->ptr)) < 0)\n\t\treturn error;\n\n\tfc->map.len = git_buf_len(&target);\n\tfc->map.data = git_buf_detach(&target);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tgit_buf_free(&target);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&symlink_supported",
            "fc->repo",
            "GIT_CVAR_SYMLINKS"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir_symlink(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tssize_t alloc_len, read_len;\n\tint symlink_supported, error;\n\n\tif ((error = git_repository__cvar(\n\t\t&symlink_supported, fc->repo, GIT_CVAR_SYMLINKS)) < 0)\n\t\treturn -1;\n\n\tif (!symlink_supported)\n\t\treturn diff_file_content_load_workdir_symlink_fake(fc, path);\n\n\t/* link path on disk could be UTF-16, so prepare a buffer that is\n\t * big enough to handle some UTF-8 data expansion\n\t */\n\talloc_len = (ssize_t)(fc->file->size * 2) + 1;\n\n\tfc->map.data = git__calloc(alloc_len, sizeof(char));\n\tGITERR_CHECK_ALLOC(fc->map.data);\n\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tread_len = p_readlink(git_buf_cstr(path), fc->map.data, alloc_len);\n\tif (read_len < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to read symlink '%s'\", fc->file->path);\n\t\treturn -1;\n\t}\n\n\tfc->map.len = read_len;\n\treturn 0;\n}"
  },
  {
    "function_name": "diff_file_content_load_workdir_symlink_fake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "262-277",
    "snippet": "static int diff_file_content_load_workdir_symlink_fake(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tgit_buf target = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_futils_readbuffer(&target, path->ptr)) < 0)\n\t\treturn error;\n\n\tfc->map.len = git_buf_len(&target);\n\tfc->map.data = git_buf_detach(&target);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tgit_buf_free(&target);\n\treturn error;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&target"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&target"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&target"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&target",
            "path->ptr"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_workdir_symlink_fake(\n\tgit_diff_file_content *fc, git_buf *path)\n{\n\tgit_buf target = GIT_BUF_INIT;\n\tint error;\n\n\tif ((error = git_futils_readbuffer(&target, path->ptr)) < 0)\n\t\treturn error;\n\n\tfc->map.len = git_buf_len(&target);\n\tfc->map.data = git_buf_detach(&target);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\tgit_buf_free(&target);\n\treturn error;\n}"
  },
  {
    "function_name": "diff_file_content_load_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "220-260",
    "snippet": "static int diff_file_content_load_blob(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *opts)\n{\n\tint error = 0;\n\tgit_odb_object *odb_obj = NULL;\n\n\tif (git_oid_iszero(&fc->file->id))\n\t\treturn 0;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, false);\n\n\t/* if we don't know size, try to peek at object header first */\n\tif (!fc->file->size) {\n\t\tif ((error = git_diff_file__resolve_zero_size(\n\t\t\t\tfc->file, &odb_obj, fc->repo)) < 0)\n\t\t\treturn error;\n\t}\n\n\tif ((opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\treturn 0;\n\n\tif (odb_obj != NULL) {\n\t\terror = git_object__from_odb_object(\n\t\t\t(git_object **)&fc->blob, fc->repo, odb_obj, GIT_OBJ_BLOB);\n\t\tgit_odb_object_free(odb_obj);\n\t} else {\n\t\terror = git_blob_lookup(\n\t\t\t(git_blob **)&fc->blob, fc->repo, &fc->file->id);\n\t}\n\n\tif (!error) {\n\t\tfc->flags |= GIT_DIFF_FLAG__FREE_BLOB;\n\t\tfc->map.data = (void *)git_blob_rawcontent(fc->blob);\n\t\tfc->map.len  = (size_t)git_blob_rawsize(fc->blob);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "fc->blob"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "fc->blob"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_lookup",
          "args": [
            "(git_blob **)&fc->blob",
            "fc->repo",
            "&fc->file->id"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "106-109",
          "snippet": "int git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_blob_lookup(git_blob **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_BLOB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "odb_obj"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__from_odb_object",
          "args": [
            "(git_object **)&fc->blob",
            "fc->repo",
            "odb_obj",
            "GIT_OBJ_BLOB"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__from_odb_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "52-97",
          "snippet": "int git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_binary_by_size",
          "args": [
            "fc"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_binary_by_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "18-27",
          "snippet": "static bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_file__resolve_zero_size",
          "args": [
            "fc->file",
            "&odb_obj",
            "fc->repo"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_file__resolve_zero_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.h",
          "lines": "151-171",
          "snippet": "GIT_INLINE(int) git_diff_file__resolve_zero_size(\n\tgit_diff_file *file, git_odb_object **odb_obj, git_repository *repo)\n{\n\tint error;\n\tgit_odb *odb;\n\tsize_t len;\n\tgit_otype type;\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\treturn error;\n\n\terror = git_odb__read_header_or_object(\n\t\todb_obj, &len, &type, odb, &file->id);\n\n\tgit_odb_free(odb);\n\n\tif (!error)\n\t\tfile->size = (git_off_t)len;\n\n\treturn error;\n}",
          "includes": [
            "#include \"odb.h\"",
            "#include \"pool.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include <stdio.h>",
            "#include \"git2/oid.h\"",
            "#include \"git2/sys/diff.h\"",
            "#include \"git2/diff.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"odb.h\"\n#include \"pool.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include <stdio.h>\n#include \"git2/oid.h\"\n#include \"git2/sys/diff.h\"\n#include \"git2/diff.h\"\n\nGIT_INLINE(int) git_diff_file__resolve_zero_size(\n\tgit_diff_file *file, git_odb_object **odb_obj, git_repository *repo)\n{\n\tint error;\n\tgit_odb *odb;\n\tsize_t len;\n\tgit_otype type;\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\treturn error;\n\n\terror = git_odb__read_header_or_object(\n\t\todb_obj, &len, &type, odb, &file->id);\n\n\tgit_odb_free(odb);\n\n\tif (!error)\n\t\tfile->size = (git_off_t)len;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_commit_to_str",
          "args": [
            "fc",
            "false"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_commit_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "167-218",
          "snippet": "static int diff_file_content_commit_to_str(\n\tgit_diff_file_content *fc, bool check_status)\n{\n\tchar oid[GIT_OID_HEXSZ+1];\n\tgit_buf content = GIT_BUF_INIT;\n\tconst char *status = \"\";\n\n\tif (check_status) {\n\t\tint error = 0;\n\t\tgit_submodule *sm = NULL;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_head;\n\n\t\tif ((error = git_submodule_lookup(&sm, fc->repo, fc->file->path)) < 0) {\n\t\t\t/* GIT_EEXISTS means a \"submodule\" that has not been git added */\n\t\t\tif (error == GIT_EEXISTS) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = git_submodule_status(&sm_status, fc->repo, fc->file->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* update OID if we didn't have it previously */\n\t\tif ((fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0 &&\n\t\t\t((sm_head = git_submodule_wd_id(sm)) != NULL ||\n\t\t\t (sm_head = git_submodule_head_id(sm)) != NULL))\n\t\t{\n\t\t\tgit_oid_cpy(&fc->file->id, sm_head);\n\t\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\tif (GIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\tstatus = \"-dirty\";\n\n\t\tgit_submodule_free(sm);\n\t}\n\n\tgit_oid_tostr(oid, sizeof(oid), &fc->file->id);\n\tif (git_buf_printf(&content, \"Subproject commit %s%s\\n\", oid, status) < 0)\n\t\treturn -1;\n\n\tfc->map.len  = git_buf_len(&content);\n\tfc->map.data = git_buf_detach(&content);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_commit_to_str(\n\tgit_diff_file_content *fc, bool check_status)\n{\n\tchar oid[GIT_OID_HEXSZ+1];\n\tgit_buf content = GIT_BUF_INIT;\n\tconst char *status = \"\";\n\n\tif (check_status) {\n\t\tint error = 0;\n\t\tgit_submodule *sm = NULL;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_head;\n\n\t\tif ((error = git_submodule_lookup(&sm, fc->repo, fc->file->path)) < 0) {\n\t\t\t/* GIT_EEXISTS means a \"submodule\" that has not been git added */\n\t\t\tif (error == GIT_EEXISTS) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = git_submodule_status(&sm_status, fc->repo, fc->file->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* update OID if we didn't have it previously */\n\t\tif ((fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0 &&\n\t\t\t((sm_head = git_submodule_wd_id(sm)) != NULL ||\n\t\t\t (sm_head = git_submodule_head_id(sm)) != NULL))\n\t\t{\n\t\t\tgit_oid_cpy(&fc->file->id, sm_head);\n\t\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\tif (GIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\tstatus = \"-dirty\";\n\n\t\tgit_submodule_free(sm);\n\t}\n\n\tgit_oid_tostr(oid, sizeof(oid), &fc->file->id);\n\tif (git_buf_printf(&content, \"Subproject commit %s%s\\n\", oid, status) < 0)\n\t\treturn -1;\n\n\tfc->map.len  = git_buf_len(&content);\n\tfc->map.data = git_buf_detach(&content);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&fc->file->id"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_load_blob(\n\tgit_diff_file_content *fc,\n\tgit_diff_options *opts)\n{\n\tint error = 0;\n\tgit_odb_object *odb_obj = NULL;\n\n\tif (git_oid_iszero(&fc->file->id))\n\t\treturn 0;\n\n\tif (fc->file->mode == GIT_FILEMODE_COMMIT)\n\t\treturn diff_file_content_commit_to_str(fc, false);\n\n\t/* if we don't know size, try to peek at object header first */\n\tif (!fc->file->size) {\n\t\tif ((error = git_diff_file__resolve_zero_size(\n\t\t\t\tfc->file, &odb_obj, fc->repo)) < 0)\n\t\t\treturn error;\n\t}\n\n\tif ((opts->flags & GIT_DIFF_SHOW_BINARY) == 0 &&\n\t\tdiff_file_content_binary_by_size(fc))\n\t\treturn 0;\n\n\tif (odb_obj != NULL) {\n\t\terror = git_object__from_odb_object(\n\t\t\t(git_object **)&fc->blob, fc->repo, odb_obj, GIT_OBJ_BLOB);\n\t\tgit_odb_object_free(odb_obj);\n\t} else {\n\t\terror = git_blob_lookup(\n\t\t\t(git_blob **)&fc->blob, fc->repo, &fc->file->id);\n\t}\n\n\tif (!error) {\n\t\tfc->flags |= GIT_DIFF_FLAG__FREE_BLOB;\n\t\tfc->map.data = (void *)git_blob_rawcontent(fc->blob);\n\t\tfc->map.len  = (size_t)git_blob_rawsize(fc->blob);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "diff_file_content_commit_to_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "167-218",
    "snippet": "static int diff_file_content_commit_to_str(\n\tgit_diff_file_content *fc, bool check_status)\n{\n\tchar oid[GIT_OID_HEXSZ+1];\n\tgit_buf content = GIT_BUF_INIT;\n\tconst char *status = \"\";\n\n\tif (check_status) {\n\t\tint error = 0;\n\t\tgit_submodule *sm = NULL;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_head;\n\n\t\tif ((error = git_submodule_lookup(&sm, fc->repo, fc->file->path)) < 0) {\n\t\t\t/* GIT_EEXISTS means a \"submodule\" that has not been git added */\n\t\t\tif (error == GIT_EEXISTS) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = git_submodule_status(&sm_status, fc->repo, fc->file->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* update OID if we didn't have it previously */\n\t\tif ((fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0 &&\n\t\t\t((sm_head = git_submodule_wd_id(sm)) != NULL ||\n\t\t\t (sm_head = git_submodule_head_id(sm)) != NULL))\n\t\t{\n\t\t\tgit_oid_cpy(&fc->file->id, sm_head);\n\t\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\tif (GIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\tstatus = \"-dirty\";\n\n\t\tgit_submodule_free(sm);\n\t}\n\n\tgit_oid_tostr(oid, sizeof(oid), &fc->file->id);\n\tif (git_buf_printf(&content, \"Subproject commit %s%s\\n\", oid, status) < 0)\n\t\treturn -1;\n\n\tfc->map.len  = git_buf_len(&content);\n\tfc->map.data = git_buf_detach(&content);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&content"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&content"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&content",
            "\"Subproject commit %s%s\\n\"",
            "oid",
            "status"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr",
          "args": [
            "oid",
            "sizeof(oid)",
            "&fc->file->id"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "119-131",
          "snippet": "char *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_SUBMODULE_STATUS_IS_WD_DIRTY",
          "args": [
            "sm_status"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&fc->file->id",
            "sm_head"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_head_id",
          "args": [
            "sm"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_head_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "943-951",
          "snippet": "const git_oid *git_submodule_head_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID)\n\t\treturn &submodule->head_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_head_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID)\n\t\treturn &submodule->head_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_wd_id",
          "args": [
            "sm"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_wd_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "953-972",
          "snippet": "const git_oid *git_submodule_wd_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\t/* load unless we think we have a valid oid */\n\tif (!(submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)) {\n\t\tgit_repository *subrepo;\n\n\t\t/* calling submodule open grabs the HEAD OID if possible */\n\t\tif (!git_submodule_open_bare(&subrepo, submodule))\n\t\t\tgit_repository_free(subrepo);\n\t\telse\n\t\t\tgiterr_clear();\n\t}\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)\n\t\treturn &submodule->wd_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_wd_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\t/* load unless we think we have a valid oid */\n\tif (!(submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)) {\n\t\tgit_repository *subrepo;\n\n\t\t/* calling submodule open grabs the HEAD OID if possible */\n\t\tif (!git_submodule_open_bare(&subrepo, submodule))\n\t\t\tgit_repository_free(subrepo);\n\t\telse\n\t\t\tgiterr_clear();\n\t}\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)\n\t\treturn &submodule->wd_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_status",
          "args": [
            "&sm_status",
            "fc->repo",
            "fc->file->path",
            "GIT_SUBMODULE_IGNORE_UNSPECIFIED"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1533-1547",
          "snippet": "int git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tgit_submodule *sm;\n\tint error;\n\n\tassert(status && repo && name);\n\n\tif ((error = git_submodule_lookup(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\terror = git_submodule__status(status, NULL, NULL, NULL, sm, ignore);\n\tgit_submodule_free(sm);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_status(unsigned int *status, git_repository *repo, const char *name, git_submodule_ignore_t ignore)\n{\n\tgit_submodule *sm;\n\tint error;\n\n\tassert(status && repo && name);\n\n\tif ((error = git_submodule_lookup(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\terror = git_submodule__status(status, NULL, NULL, NULL, sm, ignore);\n\tgit_submodule_free(sm);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "&sm",
            "fc->repo",
            "fc->file->path"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic int diff_file_content_commit_to_str(\n\tgit_diff_file_content *fc, bool check_status)\n{\n\tchar oid[GIT_OID_HEXSZ+1];\n\tgit_buf content = GIT_BUF_INIT;\n\tconst char *status = \"\";\n\n\tif (check_status) {\n\t\tint error = 0;\n\t\tgit_submodule *sm = NULL;\n\t\tunsigned int sm_status = 0;\n\t\tconst git_oid *sm_head;\n\n\t\tif ((error = git_submodule_lookup(&sm, fc->repo, fc->file->path)) < 0) {\n\t\t\t/* GIT_EEXISTS means a \"submodule\" that has not been git added */\n\t\t\tif (error == GIT_EEXISTS) {\n\t\t\t\tgiterr_clear();\n\t\t\t\terror = 0;\n\t\t\t}\n\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = git_submodule_status(&sm_status, fc->repo, fc->file->path, GIT_SUBMODULE_IGNORE_UNSPECIFIED)) < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn error;\n\t\t}\n\n\t\t/* update OID if we didn't have it previously */\n\t\tif ((fc->file->flags & GIT_DIFF_FLAG_VALID_ID) == 0 &&\n\t\t\t((sm_head = git_submodule_wd_id(sm)) != NULL ||\n\t\t\t (sm_head = git_submodule_head_id(sm)) != NULL))\n\t\t{\n\t\t\tgit_oid_cpy(&fc->file->id, sm_head);\n\t\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\t}\n\n\t\tif (GIT_SUBMODULE_STATUS_IS_WD_DIRTY(sm_status))\n\t\t\tstatus = \"-dirty\";\n\n\t\tgit_submodule_free(sm);\n\t}\n\n\tgit_oid_tostr(oid, sizeof(oid), &fc->file->id);\n\tif (git_buf_printf(&content, \"Subproject commit %s%s\\n\", oid, status) < 0)\n\t\treturn -1;\n\n\tfc->map.len  = git_buf_len(&content);\n\tfc->map.data = git_buf_detach(&content);\n\tfc->flags |= GIT_DIFF_FLAG__FREE_DATA;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_file_content__init_from_src",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "130-165",
    "snippet": "int git_diff_file_content__init_from_src(\n\tgit_diff_file_content *fc,\n\tgit_repository *repo,\n\tconst git_diff_options *opts,\n\tconst git_diff_file_content_src *src,\n\tgit_diff_file *as_file)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tfc->repo = repo;\n\tfc->file = as_file;\n\tfc->blob = src->blob;\n\n\tif (!src->blob && !src->buf) {\n\t\tfc->flags |= GIT_DIFF_FLAG__NO_DATA;\n\t} else {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\tfc->file->mode = GIT_FILEMODE_BLOB;\n\n\t\tif (src->blob) {\n\t\t\tfc->file->size = git_blob_rawsize(src->blob);\n\t\t\tgit_oid_cpy(&fc->file->id, git_blob_id(src->blob));\n\n\t\t\tfc->map.len  = (size_t)fc->file->size;\n\t\t\tfc->map.data = (char *)git_blob_rawcontent(src->blob);\n\t\t} else {\n\t\t\tfc->file->size = src->buflen;\n\t\t\tgit_odb_hash(&fc->file->id, src->buf, src->buflen, GIT_OBJ_BLOB);\n\n\t\t\tfc->map.len  = src->buflen;\n\t\t\tfc->map.data = (char *)src->buf;\n\t\t}\n\t}\n\n\treturn diff_file_content_init_common(fc, opts);\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_file_content_init_common",
          "args": [
            "fc",
            "opts"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "42-87",
          "snippet": "static int diff_file_content_init_common(\n\tgit_diff_file_content *fc, const git_diff_options *opts)\n{\n\tfc->opts_flags = opts ? opts->flags : GIT_DIFF_NORMAL;\n\n\tif (opts && opts->max_size >= 0)\n\t\tfc->opts_max_size = opts->max_size ?\n\t\t\topts->max_size : DIFF_MAX_FILESIZE;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_EMPTY)\n\t\tfc->src = GIT_ITERATOR_TYPE_TREE;\n\n\tif (!fc->driver &&\n\t\tgit_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\t/* give driver a chance to modify options */\n\tgit_diff_driver_update_options(&fc->opts_flags, fc->driver);\n\n\t/* make sure file is conceivable mmap-able */\n\tif ((git_off_t)((size_t)fc->file->size) != fc->file->size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t/* check if user is forcing text diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_TEXT) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY;\n\t}\n\t/* check if user is forcing binary diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_BINARY) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_NOT_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t}\n\n\tdiff_file_content_binary_by_size(fc);\n\n\tif ((fc->flags & GIT_DIFF_FLAG__NO_DATA) != 0) {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->map.len  = 0;\n\t\tfc->map.data = \"\";\n\t}\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define DIFF_MAX_FILESIZE 0x20000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\n#define DIFF_MAX_FILESIZE 0x20000000\n\nstatic int diff_file_content_init_common(\n\tgit_diff_file_content *fc, const git_diff_options *opts)\n{\n\tfc->opts_flags = opts ? opts->flags : GIT_DIFF_NORMAL;\n\n\tif (opts && opts->max_size >= 0)\n\t\tfc->opts_max_size = opts->max_size ?\n\t\t\topts->max_size : DIFF_MAX_FILESIZE;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_EMPTY)\n\t\tfc->src = GIT_ITERATOR_TYPE_TREE;\n\n\tif (!fc->driver &&\n\t\tgit_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\t/* give driver a chance to modify options */\n\tgit_diff_driver_update_options(&fc->opts_flags, fc->driver);\n\n\t/* make sure file is conceivable mmap-able */\n\tif ((git_off_t)((size_t)fc->file->size) != fc->file->size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t/* check if user is forcing text diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_TEXT) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY;\n\t}\n\t/* check if user is forcing binary diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_BINARY) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_NOT_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t}\n\n\tdiff_file_content_binary_by_size(fc);\n\n\tif ((fc->flags & GIT_DIFF_FLAG__NO_DATA) != 0) {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->map.len  = 0;\n\t\tfc->map.data = \"\";\n\t}\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_hash",
          "args": [
            "&fc->file->id",
            "src->buf",
            "src->buflen",
            "GIT_OBJ_BLOB"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "283-294",
          "snippet": "int git_odb_hash(git_oid *id, const void *data, size_t len, git_otype type)\n{\n\tgit_rawobj raw;\n\n\tassert(id);\n\n\traw.data = (void *)data;\n\traw.len = len;\n\traw.type = type;\n\n\treturn git_odb__hashobj(id, &raw);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_hash(git_oid *id, const void *data, size_t len, git_otype type)\n{\n\tgit_rawobj raw;\n\n\tassert(id);\n\n\traw.data = (void *)data;\n\traw.len = len;\n\traw.type = type;\n\n\treturn git_odb__hashobj(id, &raw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "src->blob"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&fc->file->id",
            "git_blob_id(src->blob)"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_id",
          "args": [
            "src->blob"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "121-124",
          "snippet": "const git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "src->blob"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fc",
            "0",
            "sizeof(*fc)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nint git_diff_file_content__init_from_src(\n\tgit_diff_file_content *fc,\n\tgit_repository *repo,\n\tconst git_diff_options *opts,\n\tconst git_diff_file_content_src *src,\n\tgit_diff_file *as_file)\n{\n\tmemset(fc, 0, sizeof(*fc));\n\tfc->repo = repo;\n\tfc->file = as_file;\n\tfc->blob = src->blob;\n\n\tif (!src->blob && !src->buf) {\n\t\tfc->flags |= GIT_DIFF_FLAG__NO_DATA;\n\t} else {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_VALID_ID;\n\t\tfc->file->mode = GIT_FILEMODE_BLOB;\n\n\t\tif (src->blob) {\n\t\t\tfc->file->size = git_blob_rawsize(src->blob);\n\t\t\tgit_oid_cpy(&fc->file->id, git_blob_id(src->blob));\n\n\t\t\tfc->map.len  = (size_t)fc->file->size;\n\t\t\tfc->map.data = (char *)git_blob_rawcontent(src->blob);\n\t\t} else {\n\t\t\tfc->file->size = src->buflen;\n\t\t\tgit_odb_hash(&fc->file->id, src->buf, src->buflen, GIT_OBJ_BLOB);\n\n\t\t\tfc->map.len  = src->buflen;\n\t\t\tfc->map.data = (char *)src->buf;\n\t\t}\n\t}\n\n\treturn diff_file_content_init_common(fc, opts);\n}"
  },
  {
    "function_name": "git_diff_file_content__init_from_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "89-128",
    "snippet": "int git_diff_file_content__init_from_diff(\n\tgit_diff_file_content *fc,\n\tgit_diff *diff,\n\tgit_diff_delta *delta,\n\tbool use_old)\n{\n\tbool has_data = true;\n\n\tmemset(fc, 0, sizeof(*fc));\n\tfc->repo = diff->repo;\n\tfc->file = use_old ? &delta->old_file : &delta->new_file;\n\tfc->src  = use_old ? diff->old_src : diff->new_src;\n\n\tif (git_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_ADDED:\n\t\thas_data = !use_old; break;\n\tcase GIT_DELTA_DELETED:\n\t\thas_data = use_old; break;\n\tcase GIT_DELTA_UNTRACKED:\n\t\thas_data = !use_old &&\n\t\t\t(diff->opts.flags & GIT_DIFF_SHOW_UNTRACKED_CONTENT) != 0;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_MODIFIED:\n\tcase GIT_DELTA_COPIED:\n\tcase GIT_DELTA_RENAMED:\n\t\tbreak;\n\tdefault:\n\t\thas_data = false;\n\t\tbreak;\n\t}\n\n\tif (!has_data)\n\t\tfc->flags |= GIT_DIFF_FLAG__NO_DATA;\n\n\treturn diff_file_content_init_common(fc, &diff->opts);\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_file_content_init_common",
          "args": [
            "fc",
            "&diff->opts"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "42-87",
          "snippet": "static int diff_file_content_init_common(\n\tgit_diff_file_content *fc, const git_diff_options *opts)\n{\n\tfc->opts_flags = opts ? opts->flags : GIT_DIFF_NORMAL;\n\n\tif (opts && opts->max_size >= 0)\n\t\tfc->opts_max_size = opts->max_size ?\n\t\t\topts->max_size : DIFF_MAX_FILESIZE;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_EMPTY)\n\t\tfc->src = GIT_ITERATOR_TYPE_TREE;\n\n\tif (!fc->driver &&\n\t\tgit_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\t/* give driver a chance to modify options */\n\tgit_diff_driver_update_options(&fc->opts_flags, fc->driver);\n\n\t/* make sure file is conceivable mmap-able */\n\tif ((git_off_t)((size_t)fc->file->size) != fc->file->size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t/* check if user is forcing text diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_TEXT) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY;\n\t}\n\t/* check if user is forcing binary diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_BINARY) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_NOT_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t}\n\n\tdiff_file_content_binary_by_size(fc);\n\n\tif ((fc->flags & GIT_DIFF_FLAG__NO_DATA) != 0) {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->map.len  = 0;\n\t\tfc->map.data = \"\";\n\t}\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define DIFF_MAX_FILESIZE 0x20000000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\n#define DIFF_MAX_FILESIZE 0x20000000\n\nstatic int diff_file_content_init_common(\n\tgit_diff_file_content *fc, const git_diff_options *opts)\n{\n\tfc->opts_flags = opts ? opts->flags : GIT_DIFF_NORMAL;\n\n\tif (opts && opts->max_size >= 0)\n\t\tfc->opts_max_size = opts->max_size ?\n\t\t\topts->max_size : DIFF_MAX_FILESIZE;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_EMPTY)\n\t\tfc->src = GIT_ITERATOR_TYPE_TREE;\n\n\tif (!fc->driver &&\n\t\tgit_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\t/* give driver a chance to modify options */\n\tgit_diff_driver_update_options(&fc->opts_flags, fc->driver);\n\n\t/* make sure file is conceivable mmap-able */\n\tif ((git_off_t)((size_t)fc->file->size) != fc->file->size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t/* check if user is forcing text diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_TEXT) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY;\n\t}\n\t/* check if user is forcing binary diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_BINARY) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_NOT_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t}\n\n\tdiff_file_content_binary_by_size(fc);\n\n\tif ((fc->flags & GIT_DIFF_FLAG__NO_DATA) != 0) {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->map.len  = 0;\n\t\tfc->map.data = \"\";\n\t}\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_driver_lookup",
          "args": [
            "&fc->driver",
            "fc->repo",
            "fc->file->path"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_driver_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_driver.c",
          "lines": "359-391",
          "snippet": "int git_diff_driver_lookup(\n\tgit_diff_driver **out, git_repository *repo, const char *path)\n{\n\tint error = 0;\n\tconst char *value;\n\n\tassert(out);\n\t*out = NULL;\n\n\tif (!repo || !path || !strlen(path))\n\t\t/* just use the auto value */;\n\telse if ((error = git_attr_get(&value, repo, 0, path, \"diff\")) < 0)\n\t\t/* return error below */;\n\telse if (GIT_ATTR_UNSPECIFIED(value))\n\t\t/* just use the auto value */;\n\telse if (GIT_ATTR_FALSE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_BINARY];\n\telse if (GIT_ATTR_TRUE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_TEXT];\n\n\t/* otherwise look for driver information in config and build driver */\n\telse if ((error = git_diff_driver_load(out, repo, value)) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\terror = 0;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (!*out)\n\t\t*out = &global_drivers[DIFF_DRIVER_AUTO];\n\n\treturn error;\n}",
          "includes": [
            "#include \"userdiff.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"buf_text.h\"",
            "#include \"map.h\"",
            "#include \"strmap.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"git2/attr.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "enum {\n\tDIFF_DRIVER_AUTO = 0,\n\tDIFF_DRIVER_BINARY = 1,\n\tDIFF_DRIVER_TEXT = 2,\n\tDIFF_DRIVER_PATTERNLIST = 3,\n} git_diff_driver_t;",
            "static git_diff_driver global_drivers[3] = {\n\t{ DIFF_DRIVER_AUTO,   0, 0, },\n\t{ DIFF_DRIVER_BINARY, GIT_DIFF_FORCE_BINARY, 0 },\n\t{ DIFF_DRIVER_TEXT,   GIT_DIFF_FORCE_TEXT, 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"userdiff.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"buf_text.h\"\n#include \"map.h\"\n#include \"strmap.h\"\n#include \"diff_driver.h\"\n#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"git2/attr.h\"\n#include \"common.h\"\n\nenum {\n\tDIFF_DRIVER_AUTO = 0,\n\tDIFF_DRIVER_BINARY = 1,\n\tDIFF_DRIVER_TEXT = 2,\n\tDIFF_DRIVER_PATTERNLIST = 3,\n} git_diff_driver_t;\nstatic git_diff_driver global_drivers[3] = {\n\t{ DIFF_DRIVER_AUTO,   0, 0, },\n\t{ DIFF_DRIVER_BINARY, GIT_DIFF_FORCE_BINARY, 0 },\n\t{ DIFF_DRIVER_TEXT,   GIT_DIFF_FORCE_TEXT, 0 },\n};\n\nint git_diff_driver_lookup(\n\tgit_diff_driver **out, git_repository *repo, const char *path)\n{\n\tint error = 0;\n\tconst char *value;\n\n\tassert(out);\n\t*out = NULL;\n\n\tif (!repo || !path || !strlen(path))\n\t\t/* just use the auto value */;\n\telse if ((error = git_attr_get(&value, repo, 0, path, \"diff\")) < 0)\n\t\t/* return error below */;\n\telse if (GIT_ATTR_UNSPECIFIED(value))\n\t\t/* just use the auto value */;\n\telse if (GIT_ATTR_FALSE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_BINARY];\n\telse if (GIT_ATTR_TRUE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_TEXT];\n\n\t/* otherwise look for driver information in config and build driver */\n\telse if ((error = git_diff_driver_load(out, repo, value)) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\terror = 0;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (!*out)\n\t\t*out = &global_drivers[DIFF_DRIVER_AUTO];\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fc",
            "0",
            "sizeof(*fc)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nint git_diff_file_content__init_from_diff(\n\tgit_diff_file_content *fc,\n\tgit_diff *diff,\n\tgit_diff_delta *delta,\n\tbool use_old)\n{\n\tbool has_data = true;\n\n\tmemset(fc, 0, sizeof(*fc));\n\tfc->repo = diff->repo;\n\tfc->file = use_old ? &delta->old_file : &delta->new_file;\n\tfc->src  = use_old ? diff->old_src : diff->new_src;\n\n\tif (git_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_ADDED:\n\t\thas_data = !use_old; break;\n\tcase GIT_DELTA_DELETED:\n\t\thas_data = use_old; break;\n\tcase GIT_DELTA_UNTRACKED:\n\t\thas_data = !use_old &&\n\t\t\t(diff->opts.flags & GIT_DIFF_SHOW_UNTRACKED_CONTENT) != 0;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_MODIFIED:\n\tcase GIT_DELTA_COPIED:\n\tcase GIT_DELTA_RENAMED:\n\t\tbreak;\n\tdefault:\n\t\thas_data = false;\n\t\tbreak;\n\t}\n\n\tif (!has_data)\n\t\tfc->flags |= GIT_DIFF_FLAG__NO_DATA;\n\n\treturn diff_file_content_init_common(fc, &diff->opts);\n}"
  },
  {
    "function_name": "diff_file_content_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "42-87",
    "snippet": "static int diff_file_content_init_common(\n\tgit_diff_file_content *fc, const git_diff_options *opts)\n{\n\tfc->opts_flags = opts ? opts->flags : GIT_DIFF_NORMAL;\n\n\tif (opts && opts->max_size >= 0)\n\t\tfc->opts_max_size = opts->max_size ?\n\t\t\topts->max_size : DIFF_MAX_FILESIZE;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_EMPTY)\n\t\tfc->src = GIT_ITERATOR_TYPE_TREE;\n\n\tif (!fc->driver &&\n\t\tgit_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\t/* give driver a chance to modify options */\n\tgit_diff_driver_update_options(&fc->opts_flags, fc->driver);\n\n\t/* make sure file is conceivable mmap-able */\n\tif ((git_off_t)((size_t)fc->file->size) != fc->file->size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t/* check if user is forcing text diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_TEXT) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY;\n\t}\n\t/* check if user is forcing binary diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_BINARY) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_NOT_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t}\n\n\tdiff_file_content_binary_by_size(fc);\n\n\tif ((fc->flags & GIT_DIFF_FLAG__NO_DATA) != 0) {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->map.len  = 0;\n\t\tfc->map.data = \"\";\n\t}\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define DIFF_MAX_FILESIZE 0x20000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_file_content_binary_by_content",
          "args": [
            "fc"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_binary_by_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "29-40",
          "snippet": "static void diff_file_content_binary_by_content(git_diff_file_content *fc)\n{\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) != 0)\n\t\treturn;\n\n\tswitch (git_diff_driver_content_is_binary(\n\t\tfc->driver, fc->map.data, fc->map.len)) {\n\tcase 0: fc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY; break;\n\tcase 1: fc->file->flags |= GIT_DIFF_FLAG_BINARY; break;\n\tdefault: break;\n\t}\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic void diff_file_content_binary_by_content(git_diff_file_content *fc)\n{\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) != 0)\n\t\treturn;\n\n\tswitch (git_diff_driver_content_is_binary(\n\t\tfc->driver, fc->map.data, fc->map.len)) {\n\tcase 0: fc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY; break;\n\tcase 1: fc->file->flags |= GIT_DIFF_FLAG_BINARY; break;\n\tdefault: break;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_file_content_binary_by_size",
          "args": [
            "fc"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "diff_file_content_binary_by_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
          "lines": "18-27",
          "snippet": "static bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"fileops.h\"",
            "#include \"odb.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/submodule.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(size_t)fc->file->size"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff_driver_update_options",
          "args": [
            "&fc->opts_flags",
            "fc->driver"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_driver_update_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_driver.c",
          "lines": "409-416",
          "snippet": "void git_diff_driver_update_options(\n\tuint32_t *option_flags, git_diff_driver *driver)\n{\n\tif ((*option_flags & FORCE_DIFFABLE) == 0)\n\t\t*option_flags |= driver->binary_flags;\n\n\t*option_flags |= driver->other_flags;\n}",
          "includes": [
            "#include \"userdiff.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"buf_text.h\"",
            "#include \"map.h\"",
            "#include \"strmap.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"git2/attr.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define FORCE_DIFFABLE (GIT_DIFF_FORCE_TEXT | GIT_DIFF_FORCE_BINARY)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"userdiff.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"buf_text.h\"\n#include \"map.h\"\n#include \"strmap.h\"\n#include \"diff_driver.h\"\n#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"git2/attr.h\"\n#include \"common.h\"\n\n#define FORCE_DIFFABLE (GIT_DIFF_FORCE_TEXT | GIT_DIFF_FORCE_BINARY)\n\nvoid git_diff_driver_update_options(\n\tuint32_t *option_flags, git_diff_driver *driver)\n{\n\tif ((*option_flags & FORCE_DIFFABLE) == 0)\n\t\t*option_flags |= driver->binary_flags;\n\n\t*option_flags |= driver->other_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_driver_lookup",
          "args": [
            "&fc->driver",
            "fc->repo",
            "fc->file->path"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_driver_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_driver.c",
          "lines": "359-391",
          "snippet": "int git_diff_driver_lookup(\n\tgit_diff_driver **out, git_repository *repo, const char *path)\n{\n\tint error = 0;\n\tconst char *value;\n\n\tassert(out);\n\t*out = NULL;\n\n\tif (!repo || !path || !strlen(path))\n\t\t/* just use the auto value */;\n\telse if ((error = git_attr_get(&value, repo, 0, path, \"diff\")) < 0)\n\t\t/* return error below */;\n\telse if (GIT_ATTR_UNSPECIFIED(value))\n\t\t/* just use the auto value */;\n\telse if (GIT_ATTR_FALSE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_BINARY];\n\telse if (GIT_ATTR_TRUE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_TEXT];\n\n\t/* otherwise look for driver information in config and build driver */\n\telse if ((error = git_diff_driver_load(out, repo, value)) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\terror = 0;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (!*out)\n\t\t*out = &global_drivers[DIFF_DRIVER_AUTO];\n\n\treturn error;\n}",
          "includes": [
            "#include \"userdiff.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"buf_text.h\"",
            "#include \"map.h\"",
            "#include \"strmap.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"git2/attr.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "enum {\n\tDIFF_DRIVER_AUTO = 0,\n\tDIFF_DRIVER_BINARY = 1,\n\tDIFF_DRIVER_TEXT = 2,\n\tDIFF_DRIVER_PATTERNLIST = 3,\n} git_diff_driver_t;",
            "static git_diff_driver global_drivers[3] = {\n\t{ DIFF_DRIVER_AUTO,   0, 0, },\n\t{ DIFF_DRIVER_BINARY, GIT_DIFF_FORCE_BINARY, 0 },\n\t{ DIFF_DRIVER_TEXT,   GIT_DIFF_FORCE_TEXT, 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"userdiff.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"buf_text.h\"\n#include \"map.h\"\n#include \"strmap.h\"\n#include \"diff_driver.h\"\n#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"git2/attr.h\"\n#include \"common.h\"\n\nenum {\n\tDIFF_DRIVER_AUTO = 0,\n\tDIFF_DRIVER_BINARY = 1,\n\tDIFF_DRIVER_TEXT = 2,\n\tDIFF_DRIVER_PATTERNLIST = 3,\n} git_diff_driver_t;\nstatic git_diff_driver global_drivers[3] = {\n\t{ DIFF_DRIVER_AUTO,   0, 0, },\n\t{ DIFF_DRIVER_BINARY, GIT_DIFF_FORCE_BINARY, 0 },\n\t{ DIFF_DRIVER_TEXT,   GIT_DIFF_FORCE_TEXT, 0 },\n};\n\nint git_diff_driver_lookup(\n\tgit_diff_driver **out, git_repository *repo, const char *path)\n{\n\tint error = 0;\n\tconst char *value;\n\n\tassert(out);\n\t*out = NULL;\n\n\tif (!repo || !path || !strlen(path))\n\t\t/* just use the auto value */;\n\telse if ((error = git_attr_get(&value, repo, 0, path, \"diff\")) < 0)\n\t\t/* return error below */;\n\telse if (GIT_ATTR_UNSPECIFIED(value))\n\t\t/* just use the auto value */;\n\telse if (GIT_ATTR_FALSE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_BINARY];\n\telse if (GIT_ATTR_TRUE(value))\n\t\t*out = &global_drivers[DIFF_DRIVER_TEXT];\n\n\t/* otherwise look for driver information in config and build driver */\n\telse if ((error = git_diff_driver_load(out, repo, value)) < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\terror = 0;\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif (!*out)\n\t\t*out = &global_drivers[DIFF_DRIVER_AUTO];\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\n#define DIFF_MAX_FILESIZE 0x20000000\n\nstatic int diff_file_content_init_common(\n\tgit_diff_file_content *fc, const git_diff_options *opts)\n{\n\tfc->opts_flags = opts ? opts->flags : GIT_DIFF_NORMAL;\n\n\tif (opts && opts->max_size >= 0)\n\t\tfc->opts_max_size = opts->max_size ?\n\t\t\topts->max_size : DIFF_MAX_FILESIZE;\n\n\tif (fc->src == GIT_ITERATOR_TYPE_EMPTY)\n\t\tfc->src = GIT_ITERATOR_TYPE_TREE;\n\n\tif (!fc->driver &&\n\t\tgit_diff_driver_lookup(&fc->driver, fc->repo, fc->file->path) < 0)\n\t\treturn -1;\n\n\t/* give driver a chance to modify options */\n\tgit_diff_driver_update_options(&fc->opts_flags, fc->driver);\n\n\t/* make sure file is conceivable mmap-able */\n\tif ((git_off_t)((size_t)fc->file->size) != fc->file->size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t/* check if user is forcing text diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_TEXT) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY;\n\t}\n\t/* check if user is forcing binary diff the file */\n\telse if (fc->opts_flags & GIT_DIFF_FORCE_BINARY) {\n\t\tfc->file->flags &= ~GIT_DIFF_FLAG_NOT_BINARY;\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\t}\n\n\tdiff_file_content_binary_by_size(fc);\n\n\tif ((fc->flags & GIT_DIFF_FLAG__NO_DATA) != 0) {\n\t\tfc->flags |= GIT_DIFF_FLAG__LOADED;\n\t\tfc->map.len  = 0;\n\t\tfc->map.data = \"\";\n\t}\n\n\tif ((fc->flags & GIT_DIFF_FLAG__LOADED) != 0)\n\t\tdiff_file_content_binary_by_content(fc);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "diff_file_content_binary_by_content",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "29-40",
    "snippet": "static void diff_file_content_binary_by_content(git_diff_file_content *fc)\n{\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) != 0)\n\t\treturn;\n\n\tswitch (git_diff_driver_content_is_binary(\n\t\tfc->driver, fc->map.data, fc->map.len)) {\n\tcase 0: fc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY; break;\n\tcase 1: fc->file->flags |= GIT_DIFF_FLAG_BINARY; break;\n\tdefault: break;\n\t}\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_driver_content_is_binary",
          "args": [
            "fc->driver",
            "fc->map.data",
            "fc->map.len"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_driver_content_is_binary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_driver.c",
          "lines": "418-438",
          "snippet": "int git_diff_driver_content_is_binary(\n\tgit_diff_driver *driver, const char *content, size_t content_len)\n{\n\tgit_buf search = GIT_BUF_INIT;\n\n\tGIT_UNUSED(driver);\n\n\tgit_buf_attach_notowned(&search, content,\n\t\tmin(content_len, GIT_FILTER_BYTES_TO_CHECK_NUL));\n\n\t/* TODO: provide encoding / binary detection callbacks that can\n\t * be UTF-8 aware, etc.  For now, instead of trying to be smart,\n\t * let's just use the simple NUL-byte detection that core git uses.\n\t */\n\n\t/* previously was: if (git_buf_text_is_binary(&search)) */\n\tif (git_buf_text_contains_nul(&search))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"userdiff.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"buf_text.h\"",
            "#include \"map.h\"",
            "#include \"strmap.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"git2/attr.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"userdiff.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"buf_text.h\"\n#include \"map.h\"\n#include \"strmap.h\"\n#include \"diff_driver.h\"\n#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"git2/attr.h\"\n#include \"common.h\"\n\nint git_diff_driver_content_is_binary(\n\tgit_diff_driver *driver, const char *content, size_t content_len)\n{\n\tgit_buf search = GIT_BUF_INIT;\n\n\tGIT_UNUSED(driver);\n\n\tgit_buf_attach_notowned(&search, content,\n\t\tmin(content_len, GIT_FILTER_BYTES_TO_CHECK_NUL));\n\n\t/* TODO: provide encoding / binary detection callbacks that can\n\t * be UTF-8 aware, etc.  For now, instead of trying to be smart,\n\t * let's just use the simple NUL-byte detection that core git uses.\n\t */\n\n\t/* previously was: if (git_buf_text_is_binary(&search)) */\n\tif (git_buf_text_contains_nul(&search))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic void diff_file_content_binary_by_content(git_diff_file_content *fc)\n{\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) != 0)\n\t\treturn;\n\n\tswitch (git_diff_driver_content_is_binary(\n\t\tfc->driver, fc->map.data, fc->map.len)) {\n\tcase 0: fc->file->flags |= GIT_DIFF_FLAG_NOT_BINARY; break;\n\tcase 1: fc->file->flags |= GIT_DIFF_FLAG_BINARY; break;\n\tdefault: break;\n\t}\n}"
  },
  {
    "function_name": "diff_file_content_binary_by_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_file.c",
    "lines": "18-27",
    "snippet": "static bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}",
    "includes": [
      "#include \"filter.h\"",
      "#include \"fileops.h\"",
      "#include \"odb.h\"",
      "#include \"diff_file.h\"",
      "#include \"diff.h\"",
      "#include \"git2/submodule.h\"",
      "#include \"git2/blob.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"filter.h\"\n#include \"fileops.h\"\n#include \"odb.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/submodule.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic bool diff_file_content_binary_by_size(git_diff_file_content *fc)\n{\n\t/* if we have diff opts, check max_size vs file size */\n\tif ((fc->file->flags & DIFF_FLAGS_KNOWN_BINARY) == 0 &&\n\t\tfc->opts_max_size > 0 &&\n\t\tfc->file->size > fc->opts_max_size)\n\t\tfc->file->flags |= GIT_DIFF_FLAG_BINARY;\n\n\treturn ((fc->file->flags & GIT_DIFF_FLAG_BINARY) != 0);\n}"
  }
]