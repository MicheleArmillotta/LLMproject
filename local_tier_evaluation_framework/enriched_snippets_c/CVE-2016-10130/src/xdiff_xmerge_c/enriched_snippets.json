[
  {
    "function_name": "xdl_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "625-678",
    "snippet": "int xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result)\n{\n\txdchange_t *xscr1, *xscr2;\n\txdfenv_t xe1, xe2;\n\tint status;\n\txpparam_t const *xpp = &xmp->xpp;\n\n\tresult->ptr = NULL;\n\tresult->size = 0;\n\n\tif (xdl_do_diff(orig, mf1, xpp, &xe1) < 0) {\n\t\treturn -1;\n\t}\n\tif (xdl_do_diff(orig, mf2, xpp, &xe2) < 0) {\n\t\txdl_free_env(&xe1);\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe1.xdf1, &xe1.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe1.xdf2, &xe1.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe1, &xscr1) < 0) {\n\t\txdl_free_env(&xe1);\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe2.xdf1, &xe2.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe2.xdf2, &xe2.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe2, &xscr2) < 0) {\n\t\txdl_free_script(xscr1);\n\t\txdl_free_env(&xe1);\n\t\txdl_free_env(&xe2);\n\t\treturn -1;\n\t}\n\tstatus = 0;\n\tif (!xscr1) {\n\t\tresult->ptr = xdl_malloc(mf2->size);\n\t\tmemcpy(result->ptr, mf2->ptr, mf2->size);\n\t\tresult->size = mf2->size;\n\t} else if (!xscr2) {\n\t\tresult->ptr = xdl_malloc(mf1->size);\n\t\tmemcpy(result->ptr, mf1->ptr, mf1->size);\n\t\tresult->size = mf1->size;\n\t} else {\n\t\tstatus = xdl_do_merge(&xe1, xscr1,\n\t\t\t\t      &xe2, xscr2,\n\t\t\t\t      xmp, result);\n\t}\n\txdl_free_script(xscr1);\n\txdl_free_script(xscr2);\n\n\txdl_free_env(&xe1);\n\txdl_free_env(&xe2);\n\n\treturn status;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_env",
          "args": [
            "&xe2"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free_script",
          "args": [
            "xscr2"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "537-544",
          "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_do_merge",
          "args": [
            "&xe1",
            "xscr1",
            "&xe2",
            "xscr2",
            "xmp",
            "result"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "458-623",
          "snippet": "static int xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1,\n\t\txdfenv_t *xe2, xdchange_t *xscr2,\n\t\txmparam_t const *xmp, mmbuffer_t *result)\n{\n\txdmerge_t *changes, *c;\n\txpparam_t const *xpp = &xmp->xpp;\n\tconst char *const ancestor_name = xmp->ancestor;\n\tconst char *const name1 = xmp->file1;\n\tconst char *const name2 = xmp->file2;\n\tint i0, i1, i2, chg0, chg1, chg2;\n\tint level = xmp->level;\n\tint style = xmp->style;\n\tint favor = xmp->favor;\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/*\n\t\t * \"diff3 -m\" output does not make sense for anything\n\t\t * more aggressive than XDL_MERGE_EAGER.\n\t\t */\n\t\tif (XDL_MERGE_EAGER < level)\n\t\t\tlevel = XDL_MERGE_EAGER;\n\t}\n\n\tc = changes = NULL;\n\n\twhile (xscr1 && xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\tif (xscr1->i1 + xscr1->chg1 < xscr2->i1) {\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2 - xscr2->i1 + xscr1->i1;\n\t\t\tchg0 = xscr1->chg1;\n\t\t\tchg1 = xscr1->chg2;\n\t\t\tchg2 = xscr1->chg1;\n\t\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr1 = xscr1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (xscr2->i1 + xscr2->chg1 < xscr1->i1) {\n\t\t\ti0 = xscr2->i1;\n\t\t\ti1 = xscr1->i2 - xscr1->i1 + xscr2->i1;\n\t\t\ti2 = xscr2->i2;\n\t\t\tchg0 = xscr2->chg1;\n\t\t\tchg1 = xscr2->chg1;\n\t\t\tchg2 = xscr2->chg2;\n\t\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr2 = xscr2->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == XDL_MERGE_MINIMAL || xscr1->i1 != xscr2->i1 ||\n\t\t\t\txscr1->chg1 != xscr2->chg1 ||\n\t\t\t\txscr1->chg2 != xscr2->chg2 ||\n\t\t\t\txdl_merge_cmp_lines(xe1, xscr1->i2,\n\t\t\t\t\txe2, xscr2->i2,\n\t\t\t\t\txscr1->chg2, xpp->flags)) {\n\t\t\t/* conflict */\n\t\t\tint off = xscr1->i1 - xscr2->i1;\n\t\t\tint ffo = off + xscr1->chg1 - xscr2->chg1;\n\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2;\n\t\t\tif (off > 0) {\n\t\t\t\ti0 -= off;\n\t\t\t\ti1 -= off;\n\t\t\t}\n\t\t\telse\n\t\t\t\ti2 += off;\n\t\t\tchg0 = xscr1->i1 + xscr1->chg1 - i0;\n\t\t\tchg1 = xscr1->i2 + xscr1->chg2 - i1;\n\t\t\tchg2 = xscr2->i2 + xscr2->chg2 - i2;\n\t\t\tif (ffo < 0) {\n\t\t\t\tchg0 -= ffo;\n\t\t\t\tchg1 -= ffo;\n\t\t\t} else\n\t\t\t\tchg2 += ffo;\n\t\t\tif (xdl_append_merge(&c, 0,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ti1 = xscr1->i1 + xscr1->chg1;\n\t\ti2 = xscr2->i1 + xscr2->chg1;\n\n\t\tif (i1 >= i2)\n\t\t\txscr2 = xscr2->next;\n\t\tif (i2 >= i1)\n\t\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr1) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr1->i1;\n\t\ti1 = xscr1->i2;\n\t\ti2 = xscr1->i1 + xe2->xdf2.nrec - xe2->xdf1.nrec;\n\t\tchg0 = xscr1->chg1;\n\t\tchg1 = xscr1->chg2;\n\t\tchg2 = xscr1->chg1;\n\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr2->i1;\n\t\ti1 = xscr2->i1 + xe1->xdf2.nrec - xe1->xdf1.nrec;\n\t\ti2 = xscr2->i2;\n\t\tchg0 = xscr2->chg1;\n\t\tchg1 = xscr2->chg1;\n\t\tchg2 = xscr2->chg2;\n\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr2 = xscr2->next;\n\t}\n\tif (!changes)\n\t\tchanges = c;\n\t/* refine conflicts */\n\tif (XDL_MERGE_ZEALOUS <= level &&\n\t    (xdl_refine_conflicts(xe1, xe2, changes, xpp) < 0 ||\n\t     xdl_simplify_non_conflicts(xe1, changes,\n\t\t\t\t\tXDL_MERGE_ZEALOUS < level) < 0)) {\n\t\txdl_cleanup_merge(changes);\n\t\treturn -1;\n\t}\n\t/* output */\n\tif (result) {\n\t\tint marker_size = xmp->marker_size;\n\t\tsize_t size;\n\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t ancestor_name,\n\t\t\t\t\t\t favor, changes, NULL, style,\n\t\t\t\t\t\t marker_size) < 0)\n\t\t\treturn -1;\n\n\t\tresult->ptr = xdl_malloc(size);\n\t\tif (!result->ptr) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\tresult->size = size;\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t      ancestor_name, favor, changes,\n\t\t\t\t      result->ptr, style, marker_size) < 0)\n\t\t\treturn -1;\n\t}\n\treturn xdl_cleanup_merge(changes);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1,\n\t\txdfenv_t *xe2, xdchange_t *xscr2,\n\t\txmparam_t const *xmp, mmbuffer_t *result)\n{\n\txdmerge_t *changes, *c;\n\txpparam_t const *xpp = &xmp->xpp;\n\tconst char *const ancestor_name = xmp->ancestor;\n\tconst char *const name1 = xmp->file1;\n\tconst char *const name2 = xmp->file2;\n\tint i0, i1, i2, chg0, chg1, chg2;\n\tint level = xmp->level;\n\tint style = xmp->style;\n\tint favor = xmp->favor;\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/*\n\t\t * \"diff3 -m\" output does not make sense for anything\n\t\t * more aggressive than XDL_MERGE_EAGER.\n\t\t */\n\t\tif (XDL_MERGE_EAGER < level)\n\t\t\tlevel = XDL_MERGE_EAGER;\n\t}\n\n\tc = changes = NULL;\n\n\twhile (xscr1 && xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\tif (xscr1->i1 + xscr1->chg1 < xscr2->i1) {\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2 - xscr2->i1 + xscr1->i1;\n\t\t\tchg0 = xscr1->chg1;\n\t\t\tchg1 = xscr1->chg2;\n\t\t\tchg2 = xscr1->chg1;\n\t\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr1 = xscr1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (xscr2->i1 + xscr2->chg1 < xscr1->i1) {\n\t\t\ti0 = xscr2->i1;\n\t\t\ti1 = xscr1->i2 - xscr1->i1 + xscr2->i1;\n\t\t\ti2 = xscr2->i2;\n\t\t\tchg0 = xscr2->chg1;\n\t\t\tchg1 = xscr2->chg1;\n\t\t\tchg2 = xscr2->chg2;\n\t\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr2 = xscr2->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == XDL_MERGE_MINIMAL || xscr1->i1 != xscr2->i1 ||\n\t\t\t\txscr1->chg1 != xscr2->chg1 ||\n\t\t\t\txscr1->chg2 != xscr2->chg2 ||\n\t\t\t\txdl_merge_cmp_lines(xe1, xscr1->i2,\n\t\t\t\t\txe2, xscr2->i2,\n\t\t\t\t\txscr1->chg2, xpp->flags)) {\n\t\t\t/* conflict */\n\t\t\tint off = xscr1->i1 - xscr2->i1;\n\t\t\tint ffo = off + xscr1->chg1 - xscr2->chg1;\n\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2;\n\t\t\tif (off > 0) {\n\t\t\t\ti0 -= off;\n\t\t\t\ti1 -= off;\n\t\t\t}\n\t\t\telse\n\t\t\t\ti2 += off;\n\t\t\tchg0 = xscr1->i1 + xscr1->chg1 - i0;\n\t\t\tchg1 = xscr1->i2 + xscr1->chg2 - i1;\n\t\t\tchg2 = xscr2->i2 + xscr2->chg2 - i2;\n\t\t\tif (ffo < 0) {\n\t\t\t\tchg0 -= ffo;\n\t\t\t\tchg1 -= ffo;\n\t\t\t} else\n\t\t\t\tchg2 += ffo;\n\t\t\tif (xdl_append_merge(&c, 0,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ti1 = xscr1->i1 + xscr1->chg1;\n\t\ti2 = xscr2->i1 + xscr2->chg1;\n\n\t\tif (i1 >= i2)\n\t\t\txscr2 = xscr2->next;\n\t\tif (i2 >= i1)\n\t\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr1) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr1->i1;\n\t\ti1 = xscr1->i2;\n\t\ti2 = xscr1->i1 + xe2->xdf2.nrec - xe2->xdf1.nrec;\n\t\tchg0 = xscr1->chg1;\n\t\tchg1 = xscr1->chg2;\n\t\tchg2 = xscr1->chg1;\n\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr2->i1;\n\t\ti1 = xscr2->i1 + xe1->xdf2.nrec - xe1->xdf1.nrec;\n\t\ti2 = xscr2->i2;\n\t\tchg0 = xscr2->chg1;\n\t\tchg1 = xscr2->chg1;\n\t\tchg2 = xscr2->chg2;\n\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr2 = xscr2->next;\n\t}\n\tif (!changes)\n\t\tchanges = c;\n\t/* refine conflicts */\n\tif (XDL_MERGE_ZEALOUS <= level &&\n\t    (xdl_refine_conflicts(xe1, xe2, changes, xpp) < 0 ||\n\t     xdl_simplify_non_conflicts(xe1, changes,\n\t\t\t\t\tXDL_MERGE_ZEALOUS < level) < 0)) {\n\t\txdl_cleanup_merge(changes);\n\t\treturn -1;\n\t}\n\t/* output */\n\tif (result) {\n\t\tint marker_size = xmp->marker_size;\n\t\tsize_t size;\n\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t ancestor_name,\n\t\t\t\t\t\t favor, changes, NULL, style,\n\t\t\t\t\t\t marker_size) < 0)\n\t\t\treturn -1;\n\n\t\tresult->ptr = xdl_malloc(size);\n\t\tif (!result->ptr) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\tresult->size = size;\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t      ancestor_name, favor, changes,\n\t\t\t\t      result->ptr, style, marker_size) < 0)\n\t\t\treturn -1;\n\t}\n\treturn xdl_cleanup_merge(changes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result->ptr",
            "mf1->ptr",
            "mf1->size"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "mf1->size"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result->ptr",
            "mf2->ptr",
            "mf2->size"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "mf2->size"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_build_script",
          "args": [
            "&xe2",
            "&xscr2"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_build_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "511-534",
          "snippet": "int xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_change_compact",
          "args": [
            "&xe2.xdf2",
            "&xe2.xdf1",
            "xpp->flags"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_change_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "407-508",
          "snippet": "int xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_do_diff",
          "args": [
            "orig",
            "mf2",
            "xpp",
            "&xe2"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "325-387",
          "snippet": "int xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_SNAKE_CNT 20",
            "#define XDL_HEUR_MIN_COST 256",
            "#define XDL_MAX_COST_MIN 256"
          ],
          "globals_used": [
            "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_SNAKE_CNT 20\n#define XDL_HEUR_MIN_COST 256\n#define XDL_MAX_COST_MIN 256\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_merge(mmfile_t *orig, mmfile_t *mf1, mmfile_t *mf2,\n\t\txmparam_t const *xmp, mmbuffer_t *result)\n{\n\txdchange_t *xscr1, *xscr2;\n\txdfenv_t xe1, xe2;\n\tint status;\n\txpparam_t const *xpp = &xmp->xpp;\n\n\tresult->ptr = NULL;\n\tresult->size = 0;\n\n\tif (xdl_do_diff(orig, mf1, xpp, &xe1) < 0) {\n\t\treturn -1;\n\t}\n\tif (xdl_do_diff(orig, mf2, xpp, &xe2) < 0) {\n\t\txdl_free_env(&xe1);\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe1.xdf1, &xe1.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe1.xdf2, &xe1.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe1, &xscr1) < 0) {\n\t\txdl_free_env(&xe1);\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe2.xdf1, &xe2.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe2.xdf2, &xe2.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe2, &xscr2) < 0) {\n\t\txdl_free_script(xscr1);\n\t\txdl_free_env(&xe1);\n\t\txdl_free_env(&xe2);\n\t\treturn -1;\n\t}\n\tstatus = 0;\n\tif (!xscr1) {\n\t\tresult->ptr = xdl_malloc(mf2->size);\n\t\tmemcpy(result->ptr, mf2->ptr, mf2->size);\n\t\tresult->size = mf2->size;\n\t} else if (!xscr2) {\n\t\tresult->ptr = xdl_malloc(mf1->size);\n\t\tmemcpy(result->ptr, mf1->ptr, mf1->size);\n\t\tresult->size = mf1->size;\n\t} else {\n\t\tstatus = xdl_do_merge(&xe1, xscr1,\n\t\t\t\t      &xe2, xscr2,\n\t\t\t\t      xmp, result);\n\t}\n\txdl_free_script(xscr1);\n\txdl_free_script(xscr2);\n\n\txdl_free_env(&xe1);\n\txdl_free_env(&xe2);\n\n\treturn status;\n}"
  },
  {
    "function_name": "xdl_do_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "458-623",
    "snippet": "static int xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1,\n\t\txdfenv_t *xe2, xdchange_t *xscr2,\n\t\txmparam_t const *xmp, mmbuffer_t *result)\n{\n\txdmerge_t *changes, *c;\n\txpparam_t const *xpp = &xmp->xpp;\n\tconst char *const ancestor_name = xmp->ancestor;\n\tconst char *const name1 = xmp->file1;\n\tconst char *const name2 = xmp->file2;\n\tint i0, i1, i2, chg0, chg1, chg2;\n\tint level = xmp->level;\n\tint style = xmp->style;\n\tint favor = xmp->favor;\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/*\n\t\t * \"diff3 -m\" output does not make sense for anything\n\t\t * more aggressive than XDL_MERGE_EAGER.\n\t\t */\n\t\tif (XDL_MERGE_EAGER < level)\n\t\t\tlevel = XDL_MERGE_EAGER;\n\t}\n\n\tc = changes = NULL;\n\n\twhile (xscr1 && xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\tif (xscr1->i1 + xscr1->chg1 < xscr2->i1) {\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2 - xscr2->i1 + xscr1->i1;\n\t\t\tchg0 = xscr1->chg1;\n\t\t\tchg1 = xscr1->chg2;\n\t\t\tchg2 = xscr1->chg1;\n\t\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr1 = xscr1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (xscr2->i1 + xscr2->chg1 < xscr1->i1) {\n\t\t\ti0 = xscr2->i1;\n\t\t\ti1 = xscr1->i2 - xscr1->i1 + xscr2->i1;\n\t\t\ti2 = xscr2->i2;\n\t\t\tchg0 = xscr2->chg1;\n\t\t\tchg1 = xscr2->chg1;\n\t\t\tchg2 = xscr2->chg2;\n\t\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr2 = xscr2->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == XDL_MERGE_MINIMAL || xscr1->i1 != xscr2->i1 ||\n\t\t\t\txscr1->chg1 != xscr2->chg1 ||\n\t\t\t\txscr1->chg2 != xscr2->chg2 ||\n\t\t\t\txdl_merge_cmp_lines(xe1, xscr1->i2,\n\t\t\t\t\txe2, xscr2->i2,\n\t\t\t\t\txscr1->chg2, xpp->flags)) {\n\t\t\t/* conflict */\n\t\t\tint off = xscr1->i1 - xscr2->i1;\n\t\t\tint ffo = off + xscr1->chg1 - xscr2->chg1;\n\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2;\n\t\t\tif (off > 0) {\n\t\t\t\ti0 -= off;\n\t\t\t\ti1 -= off;\n\t\t\t}\n\t\t\telse\n\t\t\t\ti2 += off;\n\t\t\tchg0 = xscr1->i1 + xscr1->chg1 - i0;\n\t\t\tchg1 = xscr1->i2 + xscr1->chg2 - i1;\n\t\t\tchg2 = xscr2->i2 + xscr2->chg2 - i2;\n\t\t\tif (ffo < 0) {\n\t\t\t\tchg0 -= ffo;\n\t\t\t\tchg1 -= ffo;\n\t\t\t} else\n\t\t\t\tchg2 += ffo;\n\t\t\tif (xdl_append_merge(&c, 0,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ti1 = xscr1->i1 + xscr1->chg1;\n\t\ti2 = xscr2->i1 + xscr2->chg1;\n\n\t\tif (i1 >= i2)\n\t\t\txscr2 = xscr2->next;\n\t\tif (i2 >= i1)\n\t\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr1) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr1->i1;\n\t\ti1 = xscr1->i2;\n\t\ti2 = xscr1->i1 + xe2->xdf2.nrec - xe2->xdf1.nrec;\n\t\tchg0 = xscr1->chg1;\n\t\tchg1 = xscr1->chg2;\n\t\tchg2 = xscr1->chg1;\n\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr2->i1;\n\t\ti1 = xscr2->i1 + xe1->xdf2.nrec - xe1->xdf1.nrec;\n\t\ti2 = xscr2->i2;\n\t\tchg0 = xscr2->chg1;\n\t\tchg1 = xscr2->chg1;\n\t\tchg2 = xscr2->chg2;\n\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr2 = xscr2->next;\n\t}\n\tif (!changes)\n\t\tchanges = c;\n\t/* refine conflicts */\n\tif (XDL_MERGE_ZEALOUS <= level &&\n\t    (xdl_refine_conflicts(xe1, xe2, changes, xpp) < 0 ||\n\t     xdl_simplify_non_conflicts(xe1, changes,\n\t\t\t\t\tXDL_MERGE_ZEALOUS < level) < 0)) {\n\t\txdl_cleanup_merge(changes);\n\t\treturn -1;\n\t}\n\t/* output */\n\tif (result) {\n\t\tint marker_size = xmp->marker_size;\n\t\tsize_t size;\n\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t ancestor_name,\n\t\t\t\t\t\t favor, changes, NULL, style,\n\t\t\t\t\t\t marker_size) < 0)\n\t\t\treturn -1;\n\n\t\tresult->ptr = xdl_malloc(size);\n\t\tif (!result->ptr) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\tresult->size = size;\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t      ancestor_name, favor, changes,\n\t\t\t\t      result->ptr, style, marker_size) < 0)\n\t\t\treturn -1;\n\t}\n\treturn xdl_cleanup_merge(changes);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cleanup_merge",
          "args": [
            "changes"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cleanup_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "82-95",
          "snippet": "static int xdl_cleanup_merge(xdmerge_t *c)\n{\n\tint count = 0;\n\txdmerge_t *next_c;\n\n\t/* were there conflicts? */\n\tfor (; c; c = next_c) {\n\t\tif (c->mode == 0)\n\t\t\tcount++;\n\t\tnext_c = c->next;\n\t\tfree(c);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_cleanup_merge(xdmerge_t *c)\n{\n\tint count = 0;\n\txdmerge_t *next_c;\n\n\t/* were there conflicts? */\n\tfor (; c; c = next_c) {\n\t\tif (c->mode == 0)\n\t\t\tcount++;\n\t\tnext_c = c->next;\n\t\tfree(c);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_fill_merge_buffer",
          "args": [
            "&size",
            "xe1",
            "name1",
            "xe2",
            "name2",
            "ancestor_name",
            "favor",
            "changes",
            "result->ptr",
            "style",
            "marker_size"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_fill_merge_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "252-310",
          "snippet": "static int xdl_fill_merge_buffer(size_t *out,\n\t\t\t\t xdfenv_t *xe1, const char *name1,\n\t\t\t\t xdfenv_t *xe2, const char *name2,\n\t\t\t\t const char *ancestor_name,\n\t\t\t\t int favor,\n\t\t\t\t xdmerge_t *m, char *dest, int style,\n\t\t\t\t int marker_size)\n{\n\tsize_t size, copied;\n\tint i;\n\n\t*out = 0;\n\n\tfor (size = i = 0; m; m = m->next) {\n\t\tif (favor && !m->mode)\n\t\t\tm->mode = favor;\n\n\t\tif (m->mode == 0) {\n\t\t\tif (fill_conflict_hunk(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t  ancestor_name,\n\t\t\t\t\t\t  size, i, style, m, dest,\n\t\t\t\t\t\t  marker_size) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse if (m->mode & 3) {\n\t\t\t/* Before conflicting part */\n\t\t\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\treturn -1;\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t\t\t/* Postimage from side #1 */\n\t\t\tif (m->mode & 1) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, (m->mode & 2),\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\n\t\t\t/* Postimage from side #2 */\n\t\t\tif (m->mode & 2) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 0,\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\t\t} else\n\t\t\tcontinue;\n\t\ti = m->i1 + m->chg1;\n\t}\n\n\tif (xdl_recs_copy(&copied, xe1, i, xe1->xdf2.nrec - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t*out = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_fill_merge_buffer(size_t *out,\n\t\t\t\t xdfenv_t *xe1, const char *name1,\n\t\t\t\t xdfenv_t *xe2, const char *name2,\n\t\t\t\t const char *ancestor_name,\n\t\t\t\t int favor,\n\t\t\t\t xdmerge_t *m, char *dest, int style,\n\t\t\t\t int marker_size)\n{\n\tsize_t size, copied;\n\tint i;\n\n\t*out = 0;\n\n\tfor (size = i = 0; m; m = m->next) {\n\t\tif (favor && !m->mode)\n\t\t\tm->mode = favor;\n\n\t\tif (m->mode == 0) {\n\t\t\tif (fill_conflict_hunk(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t  ancestor_name,\n\t\t\t\t\t\t  size, i, style, m, dest,\n\t\t\t\t\t\t  marker_size) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse if (m->mode & 3) {\n\t\t\t/* Before conflicting part */\n\t\t\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\treturn -1;\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t\t\t/* Postimage from side #1 */\n\t\t\tif (m->mode & 1) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, (m->mode & 2),\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\n\t\t\t/* Postimage from side #2 */\n\t\t\tif (m->mode & 2) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 0,\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\t\t} else\n\t\t\tcontinue;\n\t\ti = m->i1 + m->chg1;\n\t}\n\n\tif (xdl_recs_copy(&copied, xe1, i, xe1->xdf2.nrec - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t*out = size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "size"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_simplify_non_conflicts",
          "args": [
            "xe1",
            "changes",
            "XDL_MERGE_ZEALOUS < level"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_simplify_non_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "420-447",
          "snippet": "static int xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m,\n\t\t\t\t      int simplify_if_no_alnum)\n{\n\tint result = 0;\n\n\tif (!m)\n\t\treturn result;\n\tfor (;;) {\n\t\txdmerge_t *next_m = m->next;\n\t\tint begin, end;\n\n\t\tif (!next_m)\n\t\t\treturn result;\n\n\t\tbegin = m->i1 + m->chg1;\n\t\tend = next_m->i1;\n\n\t\tif (m->mode != 0 || next_m->mode != 0 ||\n\t\t    (end - begin > 3 &&\n\t\t     (!simplify_if_no_alnum ||\n\t\t      lines_contain_alnum(xe1, begin, end - begin)))) {\n\t\t\tm = next_m;\n\t\t} else {\n\t\t\tresult++;\n\t\t\txdl_merge_two_conflicts(m);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m,\n\t\t\t\t      int simplify_if_no_alnum)\n{\n\tint result = 0;\n\n\tif (!m)\n\t\treturn result;\n\tfor (;;) {\n\t\txdmerge_t *next_m = m->next;\n\t\tint begin, end;\n\n\t\tif (!next_m)\n\t\t\treturn result;\n\n\t\tbegin = m->i1 + m->chg1;\n\t\tend = next_m->i1;\n\n\t\tif (m->mode != 0 || next_m->mode != 0 ||\n\t\t    (end - begin > 3 &&\n\t\t     (!simplify_if_no_alnum ||\n\t\t      lines_contain_alnum(xe1, begin, end - begin)))) {\n\t\t\tm = next_m;\n\t\t} else {\n\t\t\tresult++;\n\t\t\txdl_merge_two_conflicts(m);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_refine_conflicts",
          "args": [
            "xe1",
            "xe2",
            "changes",
            "xpp"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_refine_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "316-383",
          "snippet": "static int xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m,\n\t\txpparam_t const *xpp)\n{\n\tfor (; m; m = m->next) {\n\t\tmmfile_t t1, t2;\n\t\txdfenv_t xe;\n\t\txdchange_t *xscr, *x;\n\t\tint i1 = m->i1, i2 = m->i2;\n\n\t\t/* let's handle just the conflicts */\n\t\tif (m->mode)\n\t\t\tcontinue;\n\n\t\t/* no sense refining a conflict when one side is empty */\n\t\tif (m->chg1 == 0 || m->chg2 == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This probably does not work outside git, since\n\t\t * we have a very simple mmfile structure.\n\t\t */\n\t\tt1.ptr = (char *)xe1->xdf2.recs[m->i1]->ptr;\n\t\tt1.size = xe1->xdf2.recs[m->i1 + m->chg1 - 1]->ptr\n\t\t\t+ xe1->xdf2.recs[m->i1 + m->chg1 - 1]->size - t1.ptr;\n\t\tt2.ptr = (char *)xe2->xdf2.recs[m->i2]->ptr;\n\t\tt2.size = xe2->xdf2.recs[m->i2 + m->chg2 - 1]->ptr\n\t\t\t+ xe2->xdf2.recs[m->i2 + m->chg2 - 1]->size - t2.ptr;\n\t\tif (xdl_do_diff(&t1, &t2, xpp, &xe) < 0)\n\t\t\treturn -1;\n\t\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t\t    xdl_build_script(&xe, &xscr) < 0) {\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!xscr) {\n\t\t\t/* If this happens, the changes are identical. */\n\t\t\txdl_free_env(&xe);\n\t\t\tm->mode = 4;\n\t\t\tcontinue;\n\t\t}\n\t\tx = xscr;\n\t\tm->i1 = xscr->i1 + i1;\n\t\tm->chg1 = xscr->chg1;\n\t\tm->i2 = xscr->i2 + i2;\n\t\tm->chg2 = xscr->chg2;\n\t\twhile (xscr->next) {\n\t\t\txdmerge_t *m2 = xdl_malloc(sizeof(xdmerge_t));\n\t\t\tif (!m2) {\n\t\t\t\txdl_free_env(&xe);\n\t\t\t\txdl_free_script(x);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr = xscr->next;\n\t\t\tm2->next = m->next;\n\t\t\tm->next = m2;\n\t\t\tm = m2;\n\t\t\tm->mode = 0;\n\t\t\tm->i1 = xscr->i1 + i1;\n\t\t\tm->chg1 = xscr->chg1;\n\t\t\tm->i2 = xscr->i2 + i2;\n\t\t\tm->chg2 = xscr->chg2;\n\t\t}\n\t\txdl_free_env(&xe);\n\t\txdl_free_script(x);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m,\n\t\txpparam_t const *xpp)\n{\n\tfor (; m; m = m->next) {\n\t\tmmfile_t t1, t2;\n\t\txdfenv_t xe;\n\t\txdchange_t *xscr, *x;\n\t\tint i1 = m->i1, i2 = m->i2;\n\n\t\t/* let's handle just the conflicts */\n\t\tif (m->mode)\n\t\t\tcontinue;\n\n\t\t/* no sense refining a conflict when one side is empty */\n\t\tif (m->chg1 == 0 || m->chg2 == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This probably does not work outside git, since\n\t\t * we have a very simple mmfile structure.\n\t\t */\n\t\tt1.ptr = (char *)xe1->xdf2.recs[m->i1]->ptr;\n\t\tt1.size = xe1->xdf2.recs[m->i1 + m->chg1 - 1]->ptr\n\t\t\t+ xe1->xdf2.recs[m->i1 + m->chg1 - 1]->size - t1.ptr;\n\t\tt2.ptr = (char *)xe2->xdf2.recs[m->i2]->ptr;\n\t\tt2.size = xe2->xdf2.recs[m->i2 + m->chg2 - 1]->ptr\n\t\t\t+ xe2->xdf2.recs[m->i2 + m->chg2 - 1]->size - t2.ptr;\n\t\tif (xdl_do_diff(&t1, &t2, xpp, &xe) < 0)\n\t\t\treturn -1;\n\t\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t\t    xdl_build_script(&xe, &xscr) < 0) {\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!xscr) {\n\t\t\t/* If this happens, the changes are identical. */\n\t\t\txdl_free_env(&xe);\n\t\t\tm->mode = 4;\n\t\t\tcontinue;\n\t\t}\n\t\tx = xscr;\n\t\tm->i1 = xscr->i1 + i1;\n\t\tm->chg1 = xscr->chg1;\n\t\tm->i2 = xscr->i2 + i2;\n\t\tm->chg2 = xscr->chg2;\n\t\twhile (xscr->next) {\n\t\t\txdmerge_t *m2 = xdl_malloc(sizeof(xdmerge_t));\n\t\t\tif (!m2) {\n\t\t\t\txdl_free_env(&xe);\n\t\t\t\txdl_free_script(x);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr = xscr->next;\n\t\t\tm2->next = m->next;\n\t\t\tm->next = m2;\n\t\t\tm = m2;\n\t\t\tm->mode = 0;\n\t\t\tm->i1 = xscr->i1 + i1;\n\t\t\tm->chg1 = xscr->chg1;\n\t\t\tm->i2 = xscr->i2 + i2;\n\t\t\tm->chg2 = xscr->chg2;\n\t\t}\n\t\txdl_free_env(&xe);\n\t\txdl_free_script(x);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_append_merge",
          "args": [
            "&c",
            "2",
            "i0",
            "chg0",
            "i1",
            "chg1",
            "i2",
            "chg2"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_append_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "51-80",
          "snippet": "static int xdl_append_merge(xdmerge_t **merge, int mode,\n\t\t\t    long i0, long chg0,\n\t\t\t    long i1, long chg1,\n\t\t\t    long i2, long chg2)\n{\n\txdmerge_t *m = *merge;\n\tif (m && (i1 <= m->i1 + m->chg1 || i2 <= m->i2 + m->chg2)) {\n\t\tif (mode != m->mode)\n\t\t\tm->mode = 0;\n\t\tm->chg0 = i0 + chg0 - m->i0;\n\t\tm->chg1 = i1 + chg1 - m->i1;\n\t\tm->chg2 = i2 + chg2 - m->i2;\n\t} else {\n\t\tm = xdl_malloc(sizeof(xdmerge_t));\n\t\tif (!m)\n\t\t\treturn -1;\n\t\tm->next = NULL;\n\t\tm->mode = mode;\n\t\tm->i0 = i0;\n\t\tm->chg0 = chg0;\n\t\tm->i1 = i1;\n\t\tm->chg1 = chg1;\n\t\tm->i2 = i2;\n\t\tm->chg2 = chg2;\n\t\tif (*merge)\n\t\t\t(*merge)->next = m;\n\t\t*merge = m;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_append_merge(xdmerge_t **merge, int mode,\n\t\t\t    long i0, long chg0,\n\t\t\t    long i1, long chg1,\n\t\t\t    long i2, long chg2)\n{\n\txdmerge_t *m = *merge;\n\tif (m && (i1 <= m->i1 + m->chg1 || i2 <= m->i2 + m->chg2)) {\n\t\tif (mode != m->mode)\n\t\t\tm->mode = 0;\n\t\tm->chg0 = i0 + chg0 - m->i0;\n\t\tm->chg1 = i1 + chg1 - m->i1;\n\t\tm->chg2 = i2 + chg2 - m->i2;\n\t} else {\n\t\tm = xdl_malloc(sizeof(xdmerge_t));\n\t\tif (!m)\n\t\t\treturn -1;\n\t\tm->next = NULL;\n\t\tm->mode = mode;\n\t\tm->i0 = i0;\n\t\tm->chg0 = chg0;\n\t\tm->i1 = i1;\n\t\tm->chg1 = chg1;\n\t\tm->i2 = i2;\n\t\tm->chg2 = chg2;\n\t\tif (*merge)\n\t\t\t(*merge)->next = m;\n\t\t*merge = m;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_merge_cmp_lines",
          "args": [
            "xe1",
            "xscr1->i2",
            "xe2",
            "xscr2->i2",
            "xscr1->chg2",
            "xpp->flags"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_merge_cmp_lines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "97-111",
          "snippet": "static int xdl_merge_cmp_lines(xdfenv_t *xe1, int i1, xdfenv_t *xe2, int i2,\n\t\tint line_count, long flags)\n{\n\tint i;\n\txrecord_t **rec1 = xe1->xdf2.recs + i1;\n\txrecord_t **rec2 = xe2->xdf2.recs + i2;\n\n\tfor (i = 0; i < line_count; i++) {\n\t\tint result = xdl_recmatch(rec1[i]->ptr, rec1[i]->size,\n\t\t\trec2[i]->ptr, rec2[i]->size, flags);\n\t\tif (!result)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_merge_cmp_lines(xdfenv_t *xe1, int i1, xdfenv_t *xe2, int i2,\n\t\tint line_count, long flags)\n{\n\tint i;\n\txrecord_t **rec1 = xe1->xdf2.recs + i1;\n\txrecord_t **rec2 = xe2->xdf2.recs + i2;\n\n\tfor (i = 0; i < line_count; i++) {\n\t\tint result = xdl_recmatch(rec1[i]->ptr, rec1[i]->size,\n\t\t\trec2[i]->ptr, rec2[i]->size, flags);\n\t\tif (!result)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_do_merge(xdfenv_t *xe1, xdchange_t *xscr1,\n\t\txdfenv_t *xe2, xdchange_t *xscr2,\n\t\txmparam_t const *xmp, mmbuffer_t *result)\n{\n\txdmerge_t *changes, *c;\n\txpparam_t const *xpp = &xmp->xpp;\n\tconst char *const ancestor_name = xmp->ancestor;\n\tconst char *const name1 = xmp->file1;\n\tconst char *const name2 = xmp->file2;\n\tint i0, i1, i2, chg0, chg1, chg2;\n\tint level = xmp->level;\n\tint style = xmp->style;\n\tint favor = xmp->favor;\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/*\n\t\t * \"diff3 -m\" output does not make sense for anything\n\t\t * more aggressive than XDL_MERGE_EAGER.\n\t\t */\n\t\tif (XDL_MERGE_EAGER < level)\n\t\t\tlevel = XDL_MERGE_EAGER;\n\t}\n\n\tc = changes = NULL;\n\n\twhile (xscr1 && xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\tif (xscr1->i1 + xscr1->chg1 < xscr2->i1) {\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2 - xscr2->i1 + xscr1->i1;\n\t\t\tchg0 = xscr1->chg1;\n\t\t\tchg1 = xscr1->chg2;\n\t\t\tchg2 = xscr1->chg1;\n\t\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr1 = xscr1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (xscr2->i1 + xscr2->chg1 < xscr1->i1) {\n\t\t\ti0 = xscr2->i1;\n\t\t\ti1 = xscr1->i2 - xscr1->i1 + xscr2->i1;\n\t\t\ti2 = xscr2->i2;\n\t\t\tchg0 = xscr2->chg1;\n\t\t\tchg1 = xscr2->chg1;\n\t\t\tchg2 = xscr2->chg2;\n\t\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr2 = xscr2->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == XDL_MERGE_MINIMAL || xscr1->i1 != xscr2->i1 ||\n\t\t\t\txscr1->chg1 != xscr2->chg1 ||\n\t\t\t\txscr1->chg2 != xscr2->chg2 ||\n\t\t\t\txdl_merge_cmp_lines(xe1, xscr1->i2,\n\t\t\t\t\txe2, xscr2->i2,\n\t\t\t\t\txscr1->chg2, xpp->flags)) {\n\t\t\t/* conflict */\n\t\t\tint off = xscr1->i1 - xscr2->i1;\n\t\t\tint ffo = off + xscr1->chg1 - xscr2->chg1;\n\n\t\t\ti0 = xscr1->i1;\n\t\t\ti1 = xscr1->i2;\n\t\t\ti2 = xscr2->i2;\n\t\t\tif (off > 0) {\n\t\t\t\ti0 -= off;\n\t\t\t\ti1 -= off;\n\t\t\t}\n\t\t\telse\n\t\t\t\ti2 += off;\n\t\t\tchg0 = xscr1->i1 + xscr1->chg1 - i0;\n\t\t\tchg1 = xscr1->i2 + xscr1->chg2 - i1;\n\t\t\tchg2 = xscr2->i2 + xscr2->chg2 - i2;\n\t\t\tif (ffo < 0) {\n\t\t\t\tchg0 -= ffo;\n\t\t\t\tchg1 -= ffo;\n\t\t\t} else\n\t\t\t\tchg2 += ffo;\n\t\t\tif (xdl_append_merge(&c, 0,\n\t\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\t\txdl_cleanup_merge(changes);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\ti1 = xscr1->i1 + xscr1->chg1;\n\t\ti2 = xscr2->i1 + xscr2->chg1;\n\n\t\tif (i1 >= i2)\n\t\t\txscr2 = xscr2->next;\n\t\tif (i2 >= i1)\n\t\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr1) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr1->i1;\n\t\ti1 = xscr1->i2;\n\t\ti2 = xscr1->i1 + xe2->xdf2.nrec - xe2->xdf1.nrec;\n\t\tchg0 = xscr1->chg1;\n\t\tchg1 = xscr1->chg2;\n\t\tchg2 = xscr1->chg1;\n\t\tif (xdl_append_merge(&c, 1,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr1 = xscr1->next;\n\t}\n\twhile (xscr2) {\n\t\tif (!changes)\n\t\t\tchanges = c;\n\t\ti0 = xscr2->i1;\n\t\ti1 = xscr2->i1 + xe1->xdf2.nrec - xe1->xdf1.nrec;\n\t\ti2 = xscr2->i2;\n\t\tchg0 = xscr2->chg1;\n\t\tchg1 = xscr2->chg1;\n\t\tchg2 = xscr2->chg2;\n\t\tif (xdl_append_merge(&c, 2,\n\t\t\t\t     i0, chg0, i1, chg1, i2, chg2)) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\txscr2 = xscr2->next;\n\t}\n\tif (!changes)\n\t\tchanges = c;\n\t/* refine conflicts */\n\tif (XDL_MERGE_ZEALOUS <= level &&\n\t    (xdl_refine_conflicts(xe1, xe2, changes, xpp) < 0 ||\n\t     xdl_simplify_non_conflicts(xe1, changes,\n\t\t\t\t\tXDL_MERGE_ZEALOUS < level) < 0)) {\n\t\txdl_cleanup_merge(changes);\n\t\treturn -1;\n\t}\n\t/* output */\n\tif (result) {\n\t\tint marker_size = xmp->marker_size;\n\t\tsize_t size;\n\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t ancestor_name,\n\t\t\t\t\t\t favor, changes, NULL, style,\n\t\t\t\t\t\t marker_size) < 0)\n\t\t\treturn -1;\n\n\t\tresult->ptr = xdl_malloc(size);\n\t\tif (!result->ptr) {\n\t\t\txdl_cleanup_merge(changes);\n\t\t\treturn -1;\n\t\t}\n\t\tresult->size = size;\n\t\tif (xdl_fill_merge_buffer(&size, xe1, name1, xe2, name2,\n\t\t\t\t      ancestor_name, favor, changes,\n\t\t\t\t      result->ptr, style, marker_size) < 0)\n\t\t\treturn -1;\n\t}\n\treturn xdl_cleanup_merge(changes);\n}"
  },
  {
    "function_name": "xdl_simplify_non_conflicts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "420-447",
    "snippet": "static int xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m,\n\t\t\t\t      int simplify_if_no_alnum)\n{\n\tint result = 0;\n\n\tif (!m)\n\t\treturn result;\n\tfor (;;) {\n\t\txdmerge_t *next_m = m->next;\n\t\tint begin, end;\n\n\t\tif (!next_m)\n\t\t\treturn result;\n\n\t\tbegin = m->i1 + m->chg1;\n\t\tend = next_m->i1;\n\n\t\tif (m->mode != 0 || next_m->mode != 0 ||\n\t\t    (end - begin > 3 &&\n\t\t     (!simplify_if_no_alnum ||\n\t\t      lines_contain_alnum(xe1, begin, end - begin)))) {\n\t\t\tm = next_m;\n\t\t} else {\n\t\t\tresult++;\n\t\t\txdl_merge_two_conflicts(m);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_merge_two_conflicts",
          "args": [
            "m"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_merge_two_conflicts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "406-413",
          "snippet": "static void xdl_merge_two_conflicts(xdmerge_t *m)\n{\n\txdmerge_t *next_m = m->next;\n\tm->chg1 = next_m->i1 + next_m->chg1 - m->i1;\n\tm->chg2 = next_m->i2 + next_m->chg2 - m->i2;\n\tm->next = next_m->next;\n\tfree(next_m);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic void xdl_merge_two_conflicts(xdmerge_t *m)\n{\n\txdmerge_t *next_m = m->next;\n\tm->chg1 = next_m->i1 + next_m->chg1 - m->i1;\n\tm->chg2 = next_m->i2 + next_m->chg2 - m->i2;\n\tm->next = next_m->next;\n\tfree(next_m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lines_contain_alnum",
          "args": [
            "xe1",
            "begin",
            "end - begin"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "lines_contain_alnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "393-400",
          "snippet": "static int lines_contain_alnum(xdfenv_t *xe, int i, int chg)\n{\n\tfor (; chg; chg--, i++)\n\t\tif (line_contains_alnum(xe->xdf2.recs[i]->ptr,\n\t\t\t\txe->xdf2.recs[i]->size))\n\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int lines_contain_alnum(xdfenv_t *xe, int i, int chg)\n{\n\tfor (; chg; chg--, i++)\n\t\tif (line_contains_alnum(xe->xdf2.recs[i]->ptr,\n\t\t\t\txe->xdf2.recs[i]->size))\n\t\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_simplify_non_conflicts(xdfenv_t *xe1, xdmerge_t *m,\n\t\t\t\t      int simplify_if_no_alnum)\n{\n\tint result = 0;\n\n\tif (!m)\n\t\treturn result;\n\tfor (;;) {\n\t\txdmerge_t *next_m = m->next;\n\t\tint begin, end;\n\n\t\tif (!next_m)\n\t\t\treturn result;\n\n\t\tbegin = m->i1 + m->chg1;\n\t\tend = next_m->i1;\n\n\t\tif (m->mode != 0 || next_m->mode != 0 ||\n\t\t    (end - begin > 3 &&\n\t\t     (!simplify_if_no_alnum ||\n\t\t      lines_contain_alnum(xe1, begin, end - begin)))) {\n\t\t\tm = next_m;\n\t\t} else {\n\t\t\tresult++;\n\t\t\txdl_merge_two_conflicts(m);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xdl_merge_two_conflicts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "406-413",
    "snippet": "static void xdl_merge_two_conflicts(xdmerge_t *m)\n{\n\txdmerge_t *next_m = m->next;\n\tm->chg1 = next_m->i1 + next_m->chg1 - m->i1;\n\tm->chg2 = next_m->i2 + next_m->chg2 - m->i2;\n\tm->next = next_m->next;\n\tfree(next_m);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "next_m"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic void xdl_merge_two_conflicts(xdmerge_t *m)\n{\n\txdmerge_t *next_m = m->next;\n\tm->chg1 = next_m->i1 + next_m->chg1 - m->i1;\n\tm->chg2 = next_m->i2 + next_m->chg2 - m->i2;\n\tm->next = next_m->next;\n\tfree(next_m);\n}"
  },
  {
    "function_name": "lines_contain_alnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "393-400",
    "snippet": "static int lines_contain_alnum(xdfenv_t *xe, int i, int chg)\n{\n\tfor (; chg; chg--, i++)\n\t\tif (line_contains_alnum(xe->xdf2.recs[i]->ptr,\n\t\t\t\txe->xdf2.recs[i]->size))\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "line_contains_alnum",
          "args": [
            "xe->xdf2.recs[i]->ptr",
            "xe->xdf2.recs[i]->size"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "line_contains_alnum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "385-391",
          "snippet": "static int line_contains_alnum(const char *ptr, long size)\n{\n\twhile (size--)\n\t\tif (isalnum((unsigned char)*(ptr++)))\n\t\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int line_contains_alnum(const char *ptr, long size)\n{\n\twhile (size--)\n\t\tif (isalnum((unsigned char)*(ptr++)))\n\t\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int lines_contain_alnum(xdfenv_t *xe, int i, int chg)\n{\n\tfor (; chg; chg--, i++)\n\t\tif (line_contains_alnum(xe->xdf2.recs[i]->ptr,\n\t\t\t\txe->xdf2.recs[i]->size))\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "line_contains_alnum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "385-391",
    "snippet": "static int line_contains_alnum(const char *ptr, long size)\n{\n\twhile (size--)\n\t\tif (isalnum((unsigned char)*(ptr++)))\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char)*(ptr++)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int line_contains_alnum(const char *ptr, long size)\n{\n\twhile (size--)\n\t\tif (isalnum((unsigned char)*(ptr++)))\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_refine_conflicts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "316-383",
    "snippet": "static int xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m,\n\t\txpparam_t const *xpp)\n{\n\tfor (; m; m = m->next) {\n\t\tmmfile_t t1, t2;\n\t\txdfenv_t xe;\n\t\txdchange_t *xscr, *x;\n\t\tint i1 = m->i1, i2 = m->i2;\n\n\t\t/* let's handle just the conflicts */\n\t\tif (m->mode)\n\t\t\tcontinue;\n\n\t\t/* no sense refining a conflict when one side is empty */\n\t\tif (m->chg1 == 0 || m->chg2 == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This probably does not work outside git, since\n\t\t * we have a very simple mmfile structure.\n\t\t */\n\t\tt1.ptr = (char *)xe1->xdf2.recs[m->i1]->ptr;\n\t\tt1.size = xe1->xdf2.recs[m->i1 + m->chg1 - 1]->ptr\n\t\t\t+ xe1->xdf2.recs[m->i1 + m->chg1 - 1]->size - t1.ptr;\n\t\tt2.ptr = (char *)xe2->xdf2.recs[m->i2]->ptr;\n\t\tt2.size = xe2->xdf2.recs[m->i2 + m->chg2 - 1]->ptr\n\t\t\t+ xe2->xdf2.recs[m->i2 + m->chg2 - 1]->size - t2.ptr;\n\t\tif (xdl_do_diff(&t1, &t2, xpp, &xe) < 0)\n\t\t\treturn -1;\n\t\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t\t    xdl_build_script(&xe, &xscr) < 0) {\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!xscr) {\n\t\t\t/* If this happens, the changes are identical. */\n\t\t\txdl_free_env(&xe);\n\t\t\tm->mode = 4;\n\t\t\tcontinue;\n\t\t}\n\t\tx = xscr;\n\t\tm->i1 = xscr->i1 + i1;\n\t\tm->chg1 = xscr->chg1;\n\t\tm->i2 = xscr->i2 + i2;\n\t\tm->chg2 = xscr->chg2;\n\t\twhile (xscr->next) {\n\t\t\txdmerge_t *m2 = xdl_malloc(sizeof(xdmerge_t));\n\t\t\tif (!m2) {\n\t\t\t\txdl_free_env(&xe);\n\t\t\t\txdl_free_script(x);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr = xscr->next;\n\t\t\tm2->next = m->next;\n\t\t\tm->next = m2;\n\t\t\tm = m2;\n\t\t\tm->mode = 0;\n\t\t\tm->i1 = xscr->i1 + i1;\n\t\t\tm->chg1 = xscr->chg1;\n\t\t\tm->i2 = xscr->i2 + i2;\n\t\t\tm->chg2 = xscr->chg2;\n\t\t}\n\t\txdl_free_env(&xe);\n\t\txdl_free_script(x);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_free_script",
          "args": [
            "x"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "537-544",
          "snippet": "void xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nvoid xdl_free_script(xdchange_t *xscr) {\n\txdchange_t *xch;\n\n\twhile ((xch = xscr) != NULL) {\n\t\txscr = xscr->next;\n\t\txdl_free(xch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free_env",
          "args": [
            "&xe"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sizeof(xdmerge_t)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_build_script",
          "args": [
            "&xe",
            "&xscr"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_build_script",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "511-534",
          "snippet": "int xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_build_script(xdfenv_t *xe, xdchange_t **xscr) {\n\txdchange_t *cscr = NULL, *xch;\n\tchar *rchg1 = xe->xdf1.rchg, *rchg2 = xe->xdf2.rchg;\n\tlong i1, i2, l1, l2;\n\n\t/*\n\t * Trivial. Collects \"groups\" of changes and creates an edit script.\n\t */\n\tfor (i1 = xe->xdf1.nrec, i2 = xe->xdf2.nrec; i1 >= 0 || i2 >= 0; i1--, i2--)\n\t\tif (rchg1[i1 - 1] || rchg2[i2 - 1]) {\n\t\t\tfor (l1 = i1; rchg1[i1 - 1]; i1--);\n\t\t\tfor (l2 = i2; rchg2[i2 - 1]; i2--);\n\n\t\t\tif (!(xch = xdl_add_change(cscr, i1, i2, l1 - i1, l2 - i2))) {\n\t\t\t\txdl_free_script(cscr);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcscr = xch;\n\t\t}\n\n\t*xscr = cscr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_change_compact",
          "args": [
            "&xe.xdf2",
            "&xe.xdf1",
            "xpp->flags"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_change_compact",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "407-508",
          "snippet": "int xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_change_compact(xdfile_t *xdf, xdfile_t *xdfo, long flags) {\n\tlong ix, ixo, ixs, ixref, grpsiz, nrec = xdf->nrec;\n\tchar *rchg = xdf->rchg, *rchgo = xdfo->rchg;\n\txrecord_t **recs = xdf->recs;\n\n\t/*\n\t * This is the same of what GNU diff does. Move back and forward\n\t * change groups for a consistent and pretty diff output. This also\n\t * helps in finding joinable change groups and reduce the diff size.\n\t */\n\tfor (ix = ixo = 0;;) {\n\t\t/*\n\t\t * Find the first changed line in the to-be-compacted file.\n\t\t * We need to keep track of both indexes, so if we find a\n\t\t * changed lines group on the other file, while scanning the\n\t\t * to-be-compacted file, we need to skip it properly. Note\n\t\t * that loops that are testing for changed lines on rchg* do\n\t\t * not need index bounding since the array is prepared with\n\t\t * a zero at position -1 and N.\n\t\t */\n\t\tfor (; ix < nrec && !rchg[ix]; ix++)\n\t\t\twhile (rchgo[ixo++]);\n\t\tif (ix == nrec)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record the start of a changed-group in the to-be-compacted file\n\t\t * and find the end of it, on both to-be-compacted and other file\n\t\t * indexes (ix and ixo).\n\t\t */\n\t\tixs = ix;\n\t\tfor (ix++; rchg[ix]; ix++);\n\t\tfor (; rchgo[ixo]; ixo++);\n\n\t\tdo {\n\t\t\tgrpsiz = ix - ixs;\n\n\t\t\t/*\n\t\t\t * If the line before the current change group, is equal to\n\t\t\t * the last line of the current change group, shift backward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ixs > 0 && recs[ixs - 1]->ha == recs[ix - 1]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs - 1]->ptr, recs[ixs - 1]->size, recs[ix - 1]->ptr, recs[ix - 1]->size, flags)) {\n\t\t\t\trchg[--ixs] = 1;\n\t\t\t\trchg[--ix] = 0;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index).\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ixs - 1]; ixs--);\n\t\t\t\twhile (rchgo[--ixo]);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Record the end-of-group position in case we are matched\n\t\t\t * with a group of changes in the other file (that is, the\n\t\t\t * change record before the end-of-group index in the other\n\t\t\t * file is set).\n\t\t\t */\n\t\t\tixref = rchgo[ixo - 1] ? ix: nrec;\n\n\t\t\t/*\n\t\t\t * If the first line of the current change group, is equal to\n\t\t\t * the line next of the current change group, shift forward\n\t\t\t * the group.\n\t\t\t */\n\t\t\twhile (ix < nrec && recs[ixs]->ha == recs[ix]->ha &&\n\t\t\t       xdl_recmatch(recs[ixs]->ptr, recs[ixs]->size, recs[ix]->ptr, recs[ix]->size, flags)) {\n\t\t\t\trchg[ixs++] = 0;\n\t\t\t\trchg[ix++] = 1;\n\n\t\t\t\t/*\n\t\t\t\t * This change might have joined two change groups,\n\t\t\t\t * so we try to take this scenario in account by moving\n\t\t\t\t * the start index accordingly (and so the other-file\n\t\t\t\t * end-of-group index). Keep tracking the reference\n\t\t\t\t * index in case we are shifting together with a\n\t\t\t\t * corresponding group of changes in the other file.\n\t\t\t\t */\n\t\t\t\tfor (; rchg[ix]; ix++);\n\t\t\t\twhile (rchgo[++ixo])\n\t\t\t\t\tixref = ix;\n\t\t\t}\n\t\t} while (grpsiz != ix - ixs);\n\n\t\t/*\n\t\t * Try to move back the possibly merged group of changes, to match\n\t\t * the recorded position in the other file.\n\t\t */\n\t\twhile (ixref < ix) {\n\t\t\trchg[--ixs] = 1;\n\t\t\trchg[--ix] = 0;\n\t\t\twhile (rchgo[--ixo]);\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_do_diff",
          "args": [
            "&t1",
            "&t2",
            "xpp",
            "&xe"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_do_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "325-387",
          "snippet": "int xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_SNAKE_CNT 20",
            "#define XDL_HEUR_MIN_COST 256",
            "#define XDL_MAX_COST_MIN 256"
          ],
          "globals_used": [
            "static long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\n#define XDL_SNAKE_CNT 20\n#define XDL_HEUR_MIN_COST 256\n#define XDL_MAX_COST_MIN 256\n\nstatic long xdl_split(unsigned long const *ha1, long off1, long lim1,\n\t\t      unsigned long const *ha2, long off2, long lim2,\n\t\t      long *kvdf, long *kvdb, int need_min, xdpsplit_t *spl,\n\t\t      xdalgoenv_t *xenv);\n\nint xdl_do_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\txdfenv_t *xe) {\n\tsize_t ndiags, allocsize;\n\tlong *kvd, *kvdf, *kvdb;\n\txdalgoenv_t xenv;\n\tdiffdata_t dd1, dd2;\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_PATIENCE_DIFF)\n\t\treturn xdl_do_patience_diff(mf1, mf2, xpp, xe);\n\n\tif (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF)\n\t\treturn xdl_do_histogram_diff(mf1, mf2, xpp, xe);\n\n\tif (xdl_prepare_env(mf1, mf2, xpp, xe) < 0) {\n\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Allocate and setup K vectors to be used by the differential algorithm.\n\t * One is to store the forward path and one to store the backward path.\n\t */\n\tGITERR_CHECK_ALLOC_ADD3(&ndiags, xe->xdf1.nreff, xe->xdf2.nreff, 3);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, ndiags, 2);\n\tGITERR_CHECK_ALLOC_ADD(&allocsize, allocsize, 2);\n\tGITERR_CHECK_ALLOC_MULTIPLY(&allocsize, allocsize, sizeof(long));\n\n\tif (!(kvd = (long *) xdl_malloc(allocsize))) {\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\tkvdf = kvd;\n\tkvdb = kvdf + ndiags;\n\tkvdf += xe->xdf2.nreff + 1;\n\tkvdb += xe->xdf2.nreff + 1;\n\n\txenv.mxcost = xdl_bogosqrt(ndiags);\n\tif (xenv.mxcost < XDL_MAX_COST_MIN)\n\t\txenv.mxcost = XDL_MAX_COST_MIN;\n\txenv.snake_cnt = XDL_SNAKE_CNT;\n\txenv.heur_min = XDL_HEUR_MIN_COST;\n\n\tdd1.nrec = xe->xdf1.nreff;\n\tdd1.ha = xe->xdf1.ha;\n\tdd1.rchg = xe->xdf1.rchg;\n\tdd1.rindex = xe->xdf1.rindex;\n\tdd2.nrec = xe->xdf2.nreff;\n\tdd2.ha = xe->xdf2.ha;\n\tdd2.rchg = xe->xdf2.rchg;\n\tdd2.rindex = xe->xdf2.rindex;\n\n\tif (xdl_recs_cmp(&dd1, 0, dd1.nrec, &dd2, 0, dd2.nrec,\n\t\t\t kvdf, kvdb, (xpp->flags & XDF_NEED_MINIMAL) != 0, &xenv) < 0) {\n\n\t\txdl_free(kvd);\n\t\txdl_free_env(xe);\n\t\treturn -1;\n\t}\n\n\txdl_free(kvd);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_refine_conflicts(xdfenv_t *xe1, xdfenv_t *xe2, xdmerge_t *m,\n\t\txpparam_t const *xpp)\n{\n\tfor (; m; m = m->next) {\n\t\tmmfile_t t1, t2;\n\t\txdfenv_t xe;\n\t\txdchange_t *xscr, *x;\n\t\tint i1 = m->i1, i2 = m->i2;\n\n\t\t/* let's handle just the conflicts */\n\t\tif (m->mode)\n\t\t\tcontinue;\n\n\t\t/* no sense refining a conflict when one side is empty */\n\t\tif (m->chg1 == 0 || m->chg2 == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * This probably does not work outside git, since\n\t\t * we have a very simple mmfile structure.\n\t\t */\n\t\tt1.ptr = (char *)xe1->xdf2.recs[m->i1]->ptr;\n\t\tt1.size = xe1->xdf2.recs[m->i1 + m->chg1 - 1]->ptr\n\t\t\t+ xe1->xdf2.recs[m->i1 + m->chg1 - 1]->size - t1.ptr;\n\t\tt2.ptr = (char *)xe2->xdf2.recs[m->i2]->ptr;\n\t\tt2.size = xe2->xdf2.recs[m->i2 + m->chg2 - 1]->ptr\n\t\t\t+ xe2->xdf2.recs[m->i2 + m->chg2 - 1]->size - t2.ptr;\n\t\tif (xdl_do_diff(&t1, &t2, xpp, &xe) < 0)\n\t\t\treturn -1;\n\t\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t\t    xdl_build_script(&xe, &xscr) < 0) {\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\tif (!xscr) {\n\t\t\t/* If this happens, the changes are identical. */\n\t\t\txdl_free_env(&xe);\n\t\t\tm->mode = 4;\n\t\t\tcontinue;\n\t\t}\n\t\tx = xscr;\n\t\tm->i1 = xscr->i1 + i1;\n\t\tm->chg1 = xscr->chg1;\n\t\tm->i2 = xscr->i2 + i2;\n\t\tm->chg2 = xscr->chg2;\n\t\twhile (xscr->next) {\n\t\t\txdmerge_t *m2 = xdl_malloc(sizeof(xdmerge_t));\n\t\t\tif (!m2) {\n\t\t\t\txdl_free_env(&xe);\n\t\t\t\txdl_free_script(x);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\txscr = xscr->next;\n\t\t\tm2->next = m->next;\n\t\t\tm->next = m2;\n\t\t\tm = m2;\n\t\t\tm->mode = 0;\n\t\t\tm->i1 = xscr->i1 + i1;\n\t\t\tm->chg1 = xscr->chg1;\n\t\t\tm->i2 = xscr->i2 + i2;\n\t\t\tm->chg2 = xscr->chg2;\n\t\t}\n\t\txdl_free_env(&xe);\n\t\txdl_free_script(x);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_fill_merge_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "252-310",
    "snippet": "static int xdl_fill_merge_buffer(size_t *out,\n\t\t\t\t xdfenv_t *xe1, const char *name1,\n\t\t\t\t xdfenv_t *xe2, const char *name2,\n\t\t\t\t const char *ancestor_name,\n\t\t\t\t int favor,\n\t\t\t\t xdmerge_t *m, char *dest, int style,\n\t\t\t\t int marker_size)\n{\n\tsize_t size, copied;\n\tint i;\n\n\t*out = 0;\n\n\tfor (size = i = 0; m; m = m->next) {\n\t\tif (favor && !m->mode)\n\t\t\tm->mode = favor;\n\n\t\tif (m->mode == 0) {\n\t\t\tif (fill_conflict_hunk(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t  ancestor_name,\n\t\t\t\t\t\t  size, i, style, m, dest,\n\t\t\t\t\t\t  marker_size) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse if (m->mode & 3) {\n\t\t\t/* Before conflicting part */\n\t\t\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\treturn -1;\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t\t\t/* Postimage from side #1 */\n\t\t\tif (m->mode & 1) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, (m->mode & 2),\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\n\t\t\t/* Postimage from side #2 */\n\t\t\tif (m->mode & 2) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 0,\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\t\t} else\n\t\t\tcontinue;\n\t\ti = m->i1 + m->chg1;\n\t}\n\n\tif (xdl_recs_copy(&copied, xe1, i, xe1->xdf2.nrec - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t*out = size;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_recs_copy",
          "args": [
            "&copied",
            "xe1",
            "i",
            "xe1->xdf2.nrec - i",
            "0",
            "dest ? dest + size : NULL"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recs_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "146-149",
          "snippet": "static int xdl_recs_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 0, xe, i, count, add_nl, dest);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_recs_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 0, xe, i, count, add_nl, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_conflict_hunk",
          "args": [
            "&size",
            "xe1",
            "name1",
            "xe2",
            "name2",
            "ancestor_name",
            "size",
            "i",
            "style",
            "m",
            "dest",
            "marker_size"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "fill_conflict_hunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "156-250",
          "snippet": "static int fill_conflict_hunk(size_t *out, xdfenv_t *xe1, const char *name1,\n\t\t\t      xdfenv_t *xe2, const char *name2,\n\t\t\t      const char *name3,\n\t\t\t      size_t size, int i, int style,\n\t\t\t      xdmerge_t *m, char *dest, int marker_size)\n{\n\tint marker1_size = (name1 ? (int)strlen(name1) + 1 : 0);\n\tint marker2_size = (name2 ? (int)strlen(name2) + 1 : 0);\n\tint marker3_size = (name3 ? (int)strlen(name3) + 1 : 0);\n\tsize_t copied;\n\n\t*out = 0;\n\n\tif (marker_size <= 0)\n\t\tmarker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\n\t/* Before conflicting part */\n\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker1_size);\n\t} else {\n\t\tmemset(dest + size, '<', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker1_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name1, marker1_size - 1);\n\t\t\tsize += marker1_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #1 */\n\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/* Shared preimage */\n\t\tif (!dest) {\n\t\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker3_size);\n\t\t} else {\n\t\t\tmemset(dest + size, '|', marker_size);\n\t\t\tsize += marker_size;\n\t\t\tif (marker3_size) {\n\t\t\t\tdest[size] = ' ';\n\t\t\t\tmemcpy(dest + size + 1, name3, marker3_size - 1);\n\t\t\t\tsize += marker3_size;\n\t\t\t}\n\t\t\tdest[size++] = '\\n';\n\t\t}\n\n\t\tif (xdl_orig_copy(&copied, xe1, m->i0, m->chg0, 1,\n\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\treturn -1;\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t}\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD3(&size, size, marker_size, 1);\n\t} else {\n\t\tmemset(dest + size, '=', marker_size);\n\t\tsize += marker_size;\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #2 */\n\n\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker2_size);\n\t} else {\n\t\tmemset(dest + size, '>', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker2_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name2, marker2_size - 1);\n\t\t\tsize += marker2_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t*out = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int fill_conflict_hunk(size_t *out, xdfenv_t *xe1, const char *name1,\n\t\t\t      xdfenv_t *xe2, const char *name2,\n\t\t\t      const char *name3,\n\t\t\t      size_t size, int i, int style,\n\t\t\t      xdmerge_t *m, char *dest, int marker_size)\n{\n\tint marker1_size = (name1 ? (int)strlen(name1) + 1 : 0);\n\tint marker2_size = (name2 ? (int)strlen(name2) + 1 : 0);\n\tint marker3_size = (name3 ? (int)strlen(name3) + 1 : 0);\n\tsize_t copied;\n\n\t*out = 0;\n\n\tif (marker_size <= 0)\n\t\tmarker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\n\t/* Before conflicting part */\n\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker1_size);\n\t} else {\n\t\tmemset(dest + size, '<', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker1_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name1, marker1_size - 1);\n\t\t\tsize += marker1_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #1 */\n\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/* Shared preimage */\n\t\tif (!dest) {\n\t\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker3_size);\n\t\t} else {\n\t\t\tmemset(dest + size, '|', marker_size);\n\t\t\tsize += marker_size;\n\t\t\tif (marker3_size) {\n\t\t\t\tdest[size] = ' ';\n\t\t\t\tmemcpy(dest + size + 1, name3, marker3_size - 1);\n\t\t\t\tsize += marker3_size;\n\t\t\t}\n\t\t\tdest[size++] = '\\n';\n\t\t}\n\n\t\tif (xdl_orig_copy(&copied, xe1, m->i0, m->chg0, 1,\n\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\treturn -1;\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t}\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD3(&size, size, marker_size, 1);\n\t} else {\n\t\tmemset(dest + size, '=', marker_size);\n\t\tsize += marker_size;\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #2 */\n\n\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker2_size);\n\t} else {\n\t\tmemset(dest + size, '>', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker2_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name2, marker2_size - 1);\n\t\t\tsize += marker2_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t*out = size;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_fill_merge_buffer(size_t *out,\n\t\t\t\t xdfenv_t *xe1, const char *name1,\n\t\t\t\t xdfenv_t *xe2, const char *name2,\n\t\t\t\t const char *ancestor_name,\n\t\t\t\t int favor,\n\t\t\t\t xdmerge_t *m, char *dest, int style,\n\t\t\t\t int marker_size)\n{\n\tsize_t size, copied;\n\tint i;\n\n\t*out = 0;\n\n\tfor (size = i = 0; m; m = m->next) {\n\t\tif (favor && !m->mode)\n\t\t\tm->mode = favor;\n\n\t\tif (m->mode == 0) {\n\t\t\tif (fill_conflict_hunk(&size, xe1, name1, xe2, name2,\n\t\t\t\t\t\t  ancestor_name,\n\t\t\t\t\t\t  size, i, style, m, dest,\n\t\t\t\t\t\t  marker_size) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\telse if (m->mode & 3) {\n\t\t\t/* Before conflicting part */\n\t\t\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\treturn -1;\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t\t\t/* Postimage from side #1 */\n\t\t\tif (m->mode & 1) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, (m->mode & 2),\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\n\t\t\t/* Postimage from side #2 */\n\t\t\tif (m->mode & 2) {\n\t\t\t\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 0,\n\t\t\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\t\t\treturn -1;\n\t\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t\t\t}\n\t\t} else\n\t\t\tcontinue;\n\t\ti = m->i1 + m->chg1;\n\t}\n\n\tif (xdl_recs_copy(&copied, xe1, i, xe1->xdf2.nrec - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\t*out = size;\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_conflict_hunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "156-250",
    "snippet": "static int fill_conflict_hunk(size_t *out, xdfenv_t *xe1, const char *name1,\n\t\t\t      xdfenv_t *xe2, const char *name2,\n\t\t\t      const char *name3,\n\t\t\t      size_t size, int i, int style,\n\t\t\t      xdmerge_t *m, char *dest, int marker_size)\n{\n\tint marker1_size = (name1 ? (int)strlen(name1) + 1 : 0);\n\tint marker2_size = (name2 ? (int)strlen(name2) + 1 : 0);\n\tint marker3_size = (name3 ? (int)strlen(name3) + 1 : 0);\n\tsize_t copied;\n\n\t*out = 0;\n\n\tif (marker_size <= 0)\n\t\tmarker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\n\t/* Before conflicting part */\n\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker1_size);\n\t} else {\n\t\tmemset(dest + size, '<', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker1_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name1, marker1_size - 1);\n\t\t\tsize += marker1_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #1 */\n\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/* Shared preimage */\n\t\tif (!dest) {\n\t\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker3_size);\n\t\t} else {\n\t\t\tmemset(dest + size, '|', marker_size);\n\t\t\tsize += marker_size;\n\t\t\tif (marker3_size) {\n\t\t\t\tdest[size] = ' ';\n\t\t\t\tmemcpy(dest + size + 1, name3, marker3_size - 1);\n\t\t\t\tsize += marker3_size;\n\t\t\t}\n\t\t\tdest[size++] = '\\n';\n\t\t}\n\n\t\tif (xdl_orig_copy(&copied, xe1, m->i0, m->chg0, 1,\n\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\treturn -1;\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t}\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD3(&size, size, marker_size, 1);\n\t} else {\n\t\tmemset(dest + size, '=', marker_size);\n\t\tsize += marker_size;\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #2 */\n\n\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker2_size);\n\t} else {\n\t\tmemset(dest + size, '>', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker2_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name2, marker2_size - 1);\n\t\t\tsize += marker2_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t*out = size;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest + size + 1",
            "name2",
            "marker2_size - 1"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest + size",
            "'>'",
            "marker_size"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD4",
          "args": [
            "&size",
            "size",
            "marker_size",
            "1",
            "marker2_size"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_recs_copy",
          "args": [
            "&copied",
            "xe2",
            "m->i2",
            "m->chg2",
            "1",
            "dest ? dest + size : NULL"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recs_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "146-149",
          "snippet": "static int xdl_recs_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 0, xe, i, count, add_nl, dest);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_recs_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 0, xe, i, count, add_nl, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest + size",
            "'='",
            "marker_size"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD3",
          "args": [
            "&size",
            "size",
            "marker_size",
            "1"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_orig_copy",
          "args": [
            "&copied",
            "xe1",
            "m->i0",
            "m->chg0",
            "1",
            "dest ? dest + size : NULL"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_orig_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "151-154",
          "snippet": "static int xdl_orig_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 1, xe, i, count, add_nl, dest);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_orig_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 1, xe, i, count, add_nl, dest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest + size + 1",
            "name3",
            "marker3_size - 1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest + size",
            "'|'",
            "marker_size"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD4",
          "args": [
            "&size",
            "size",
            "marker_size",
            "1",
            "marker3_size"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest + size + 1",
            "name1",
            "marker1_size - 1"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest + size",
            "'<'",
            "marker_size"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD4",
          "args": [
            "&size",
            "size",
            "marker_size",
            "1",
            "marker1_size"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "copied"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name3"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name2"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name1"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int fill_conflict_hunk(size_t *out, xdfenv_t *xe1, const char *name1,\n\t\t\t      xdfenv_t *xe2, const char *name2,\n\t\t\t      const char *name3,\n\t\t\t      size_t size, int i, int style,\n\t\t\t      xdmerge_t *m, char *dest, int marker_size)\n{\n\tint marker1_size = (name1 ? (int)strlen(name1) + 1 : 0);\n\tint marker2_size = (name2 ? (int)strlen(name2) + 1 : 0);\n\tint marker3_size = (name3 ? (int)strlen(name3) + 1 : 0);\n\tsize_t copied;\n\n\t*out = 0;\n\n\tif (marker_size <= 0)\n\t\tmarker_size = DEFAULT_CONFLICT_MARKER_SIZE;\n\n\t/* Before conflicting part */\n\tif (xdl_recs_copy(&copied, xe1, i, m->i1 - i, 0,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker1_size);\n\t} else {\n\t\tmemset(dest + size, '<', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker1_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name1, marker1_size - 1);\n\t\t\tsize += marker1_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #1 */\n\tif (xdl_recs_copy(&copied, xe1, m->i1, m->chg1, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (style == XDL_MERGE_DIFF3) {\n\t\t/* Shared preimage */\n\t\tif (!dest) {\n\t\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker3_size);\n\t\t} else {\n\t\t\tmemset(dest + size, '|', marker_size);\n\t\t\tsize += marker_size;\n\t\t\tif (marker3_size) {\n\t\t\t\tdest[size] = ' ';\n\t\t\t\tmemcpy(dest + size + 1, name3, marker3_size - 1);\n\t\t\t\tsize += marker3_size;\n\t\t\t}\n\t\t\tdest[size++] = '\\n';\n\t\t}\n\n\t\tif (xdl_orig_copy(&copied, xe1, m->i0, m->chg0, 1,\n\t\t\t\t      dest ? dest + size : NULL) < 0)\n\t\t\treturn -1;\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\t}\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD3(&size, size, marker_size, 1);\n\t} else {\n\t\tmemset(dest + size, '=', marker_size);\n\t\tsize += marker_size;\n\t\tdest[size++] = '\\n';\n\t}\n\n\t/* Postimage from side #2 */\n\n\tif (xdl_recs_copy(&copied, xe2, m->i2, m->chg2, 1,\n\t\t\t      dest ? dest + size : NULL) < 0)\n\t\treturn -1;\n\tGITERR_CHECK_ALLOC_ADD(&size, size, copied);\n\n\tif (!dest) {\n\t\tGITERR_CHECK_ALLOC_ADD4(&size, size, marker_size, 1, marker2_size);\n\t} else {\n\t\tmemset(dest + size, '>', marker_size);\n\t\tsize += marker_size;\n\t\tif (marker2_size) {\n\t\t\tdest[size] = ' ';\n\t\t\tmemcpy(dest + size + 1, name2, marker2_size - 1);\n\t\t\tsize += marker2_size;\n\t\t}\n\t\tdest[size++] = '\\n';\n\t}\n\n\t*out = size;\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_orig_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "151-154",
    "snippet": "static int xdl_orig_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 1, xe, i, count, add_nl, dest);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recs_copy_0",
          "args": [
            "out",
            "1",
            "xe",
            "i",
            "count",
            "add_nl",
            "dest"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recs_copy_0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "113-144",
          "snippet": "static int xdl_recs_copy_0(size_t *out, int use_orig, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\txrecord_t **recs;\n\tsize_t size = 0;\n\n\t*out = 0;\n\n\trecs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < count; ) {\n\t\tif (dest)\n\t\t\tmemcpy(dest + size, recs[i]->ptr, recs[i]->size);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, recs[i++]->size);\n\t}\n\n\tif (add_nl) {\n\t\ti = recs[count - 1]->size;\n\t\tif (i == 0 || recs[count - 1]->ptr[i - 1] != '\\n') {\n\t\t\tif (dest)\n\t\t\t\tdest[size] = '\\n';\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, 1);\n\t\t}\n\t}\n\n\t*out = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_recs_copy_0(size_t *out, int use_orig, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\txrecord_t **recs;\n\tsize_t size = 0;\n\n\t*out = 0;\n\n\trecs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < count; ) {\n\t\tif (dest)\n\t\t\tmemcpy(dest + size, recs[i]->ptr, recs[i]->size);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, recs[i++]->size);\n\t}\n\n\tif (add_nl) {\n\t\ti = recs[count - 1]->size;\n\t\tif (i == 0 || recs[count - 1]->ptr[i - 1] != '\\n') {\n\t\t\tif (dest)\n\t\t\t\tdest[size] = '\\n';\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, 1);\n\t\t}\n\t}\n\n\t*out = size;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_orig_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 1, xe, i, count, add_nl, dest);\n}"
  },
  {
    "function_name": "xdl_recs_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "146-149",
    "snippet": "static int xdl_recs_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 0, xe, i, count, add_nl, dest);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recs_copy_0",
          "args": [
            "out",
            "0",
            "xe",
            "i",
            "count",
            "add_nl",
            "dest"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recs_copy_0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
          "lines": "113-144",
          "snippet": "static int xdl_recs_copy_0(size_t *out, int use_orig, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\txrecord_t **recs;\n\tsize_t size = 0;\n\n\t*out = 0;\n\n\trecs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < count; ) {\n\t\tif (dest)\n\t\t\tmemcpy(dest + size, recs[i]->ptr, recs[i]->size);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, recs[i++]->size);\n\t}\n\n\tif (add_nl) {\n\t\ti = recs[count - 1]->size;\n\t\tif (i == 0 || recs[count - 1]->ptr[i - 1] != '\\n') {\n\t\t\tif (dest)\n\t\t\t\tdest[size] = '\\n';\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, 1);\n\t\t}\n\t}\n\n\t*out = size;\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_recs_copy_0(size_t *out, int use_orig, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\txrecord_t **recs;\n\tsize_t size = 0;\n\n\t*out = 0;\n\n\trecs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < count; ) {\n\t\tif (dest)\n\t\t\tmemcpy(dest + size, recs[i]->ptr, recs[i]->size);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, recs[i++]->size);\n\t}\n\n\tif (add_nl) {\n\t\ti = recs[count - 1]->size;\n\t\tif (i == 0 || recs[count - 1]->ptr[i - 1] != '\\n') {\n\t\t\tif (dest)\n\t\t\t\tdest[size] = '\\n';\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, 1);\n\t\t}\n\t}\n\n\t*out = size;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_recs_copy(size_t *out, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\treturn xdl_recs_copy_0(out, 0, xe, i, count, add_nl, dest);\n}"
  },
  {
    "function_name": "xdl_recs_copy_0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "113-144",
    "snippet": "static int xdl_recs_copy_0(size_t *out, int use_orig, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\txrecord_t **recs;\n\tsize_t size = 0;\n\n\t*out = 0;\n\n\trecs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < count; ) {\n\t\tif (dest)\n\t\t\tmemcpy(dest + size, recs[i]->ptr, recs[i]->size);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, recs[i++]->size);\n\t}\n\n\tif (add_nl) {\n\t\ti = recs[count - 1]->size;\n\t\tif (i == 0 || recs[count - 1]->ptr[i - 1] != '\\n') {\n\t\t\tif (dest)\n\t\t\t\tdest[size] = '\\n';\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, 1);\n\t\t}\n\t}\n\n\t*out = size;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "1"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&size",
            "size",
            "recs[i++]->size"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest + size",
            "recs[i]->ptr",
            "recs[i]->size"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_recs_copy_0(size_t *out, int use_orig, xdfenv_t *xe, int i, int count, int add_nl, char *dest)\n{\n\txrecord_t **recs;\n\tsize_t size = 0;\n\n\t*out = 0;\n\n\trecs = (use_orig ? xe->xdf1.recs : xe->xdf2.recs) + i;\n\n\tif (count < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < count; ) {\n\t\tif (dest)\n\t\t\tmemcpy(dest + size, recs[i]->ptr, recs[i]->size);\n\n\t\tGITERR_CHECK_ALLOC_ADD(&size, size, recs[i++]->size);\n\t}\n\n\tif (add_nl) {\n\t\ti = recs[count - 1]->size;\n\t\tif (i == 0 || recs[count - 1]->ptr[i - 1] != '\\n') {\n\t\t\tif (dest)\n\t\t\t\tdest[size] = '\\n';\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&size, size, 1);\n\t\t}\n\t}\n\n\t*out = size;\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_merge_cmp_lines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "97-111",
    "snippet": "static int xdl_merge_cmp_lines(xdfenv_t *xe1, int i1, xdfenv_t *xe2, int i2,\n\t\tint line_count, long flags)\n{\n\tint i;\n\txrecord_t **rec1 = xe1->xdf2.recs + i1;\n\txrecord_t **rec2 = xe2->xdf2.recs + i2;\n\n\tfor (i = 0; i < line_count; i++) {\n\t\tint result = xdl_recmatch(rec1[i]->ptr, rec1[i]->size,\n\t\t\trec2[i]->ptr, rec2[i]->size, flags);\n\t\tif (!result)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recmatch",
          "args": [
            "rec1[i]->ptr",
            "rec1[i]->size",
            "rec2[i]->ptr",
            "rec2[i]->size",
            "flags"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "157-223",
          "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_merge_cmp_lines(xdfenv_t *xe1, int i1, xdfenv_t *xe2, int i2,\n\t\tint line_count, long flags)\n{\n\tint i;\n\txrecord_t **rec1 = xe1->xdf2.recs + i1;\n\txrecord_t **rec2 = xe2->xdf2.recs + i2;\n\n\tfor (i = 0; i < line_count; i++) {\n\t\tint result = xdl_recmatch(rec1[i]->ptr, rec1[i]->size,\n\t\t\trec2[i]->ptr, rec2[i]->size, flags);\n\t\tif (!result)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xdl_cleanup_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "82-95",
    "snippet": "static int xdl_cleanup_merge(xdmerge_t *c)\n{\n\tint count = 0;\n\txdmerge_t *next_c;\n\n\t/* were there conflicts? */\n\tfor (; c; c = next_c) {\n\t\tif (c->mode == 0)\n\t\t\tcount++;\n\t\tnext_c = c->next;\n\t\tfree(c);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "c"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_cleanup_merge(xdmerge_t *c)\n{\n\tint count = 0;\n\txdmerge_t *next_c;\n\n\t/* were there conflicts? */\n\tfor (; c; c = next_c) {\n\t\tif (c->mode == 0)\n\t\t\tcount++;\n\t\tnext_c = c->next;\n\t\tfree(c);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "xdl_append_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xmerge.c",
    "lines": "51-80",
    "snippet": "static int xdl_append_merge(xdmerge_t **merge, int mode,\n\t\t\t    long i0, long chg0,\n\t\t\t    long i1, long chg1,\n\t\t\t    long i2, long chg2)\n{\n\txdmerge_t *m = *merge;\n\tif (m && (i1 <= m->i1 + m->chg1 || i2 <= m->i2 + m->chg2)) {\n\t\tif (mode != m->mode)\n\t\t\tm->mode = 0;\n\t\tm->chg0 = i0 + chg0 - m->i0;\n\t\tm->chg1 = i1 + chg1 - m->i1;\n\t\tm->chg2 = i2 + chg2 - m->i2;\n\t} else {\n\t\tm = xdl_malloc(sizeof(xdmerge_t));\n\t\tif (!m)\n\t\t\treturn -1;\n\t\tm->next = NULL;\n\t\tm->mode = mode;\n\t\tm->i0 = i0;\n\t\tm->chg0 = chg0;\n\t\tm->i1 = i1;\n\t\tm->chg1 = chg1;\n\t\tm->i2 = i2;\n\t\tm->chg2 = chg2;\n\t\tif (*merge)\n\t\t\t(*merge)->next = m;\n\t\t*merge = m;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sizeof(xdmerge_t)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xinclude.h\"\n\nstatic int xdl_append_merge(xdmerge_t **merge, int mode,\n\t\t\t    long i0, long chg0,\n\t\t\t    long i1, long chg1,\n\t\t\t    long i2, long chg2)\n{\n\txdmerge_t *m = *merge;\n\tif (m && (i1 <= m->i1 + m->chg1 || i2 <= m->i2 + m->chg2)) {\n\t\tif (mode != m->mode)\n\t\t\tm->mode = 0;\n\t\tm->chg0 = i0 + chg0 - m->i0;\n\t\tm->chg1 = i1 + chg1 - m->i1;\n\t\tm->chg2 = i2 + chg2 - m->i2;\n\t} else {\n\t\tm = xdl_malloc(sizeof(xdmerge_t));\n\t\tif (!m)\n\t\t\treturn -1;\n\t\tm->next = NULL;\n\t\tm->mode = mode;\n\t\tm->i0 = i0;\n\t\tm->chg0 = chg0;\n\t\tm->i1 = i1;\n\t\tm->chg1 = chg1;\n\t\tm->i2 = i2;\n\t\tm->chg2 = chg2;\n\t\tif (*merge)\n\t\t\t(*merge)->next = m;\n\t\t*merge = m;\n\t}\n\treturn 0;\n}"
  }
]