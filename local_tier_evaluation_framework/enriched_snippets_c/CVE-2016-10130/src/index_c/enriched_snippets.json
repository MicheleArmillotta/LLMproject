[
  {
    "function_name": "git_indexwriter_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3433-3439",
    "snippet": "void git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "writer->index"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&writer->file"
          ],
          "line": 3435
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}"
  },
  {
    "function_name": "git_indexwriter_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3399-3431",
    "snippet": "int git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "writer->index"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&writer->index->checksum",
            "&checksum"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Could not read index timestamp\""
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filestamp_check",
          "args": [
            "&writer->index->stamp",
            "writer->index->index_file_path"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1033-1061",
          "snippet": "int git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&writer->file"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_cleanup",
          "args": [
            "writer"
          ],
          "line": 3411
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3433-3439",
          "snippet": "void git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_index",
          "args": [
            "&checksum",
            "writer->index",
            "&writer->file"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "write_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2756-2802",
          "snippet": "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tis_extended = is_index_extended(index);\n\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER;\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int INDEX_VERSION_NUMBER = 2;",
            "static const unsigned int INDEX_VERSION_NUMBER_EXT = 3;",
            "static const unsigned int INDEX_HEADER_SIG = 0x44495243;",
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const unsigned int INDEX_VERSION_NUMBER = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_EXT = 3;\nstatic const unsigned int INDEX_HEADER_SIG = 0x44495243;\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tis_extended = is_index_extended(index);\n\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER;\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&writer->index->reuc"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_indexwriter_init_for_operation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3381-3397",
    "snippet": "int git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_indexwriter_init",
          "args": [
            "writer",
            "index"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3353-3379",
          "snippet": "int git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"The index is locked. This might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nint git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"The index is locked. This might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "repo"
          ],
          "line": 3389
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_indexwriter_init_for_operation(\n\tgit_indexwriter *writer,\n\tgit_repository *repo,\n\tunsigned int *checkout_strategy)\n{\n\tgit_index *index;\n\tint error;\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0 ||\n\t\t(error = git_indexwriter_init(writer, index)) < 0)\n\t\treturn error;\n\n\twriter->should_write = (*checkout_strategy & GIT_CHECKOUT_DONT_WRITE_INDEX) == 0;\n\t*checkout_strategy |= GIT_CHECKOUT_DONT_WRITE_INDEX;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_indexwriter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3353-3379",
    "snippet": "int git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"The index is locked. This might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"The index is locked. This might be due to a concurrent or crashed process\""
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&writer->file",
            "index->index_file_path",
            "GIT_FILEBUF_HASH_CONTENTS",
            "GIT_INDEX_FILE_MODE"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"Failed to write index: The index is in-memory only\""
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "index"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nint git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"The index is locked. This might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_snapshot_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3346-3351",
    "snippet": "int git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_find_in_entries",
          "args": [
            "out",
            "entries",
            "entry_srch",
            "path",
            "path_len",
            "stage"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "index_find_in_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "359-368",
          "snippet": "GIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nGIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}"
  },
  {
    "function_name": "git_index_snapshot_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3337-3344",
    "snippet": "void git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 3343
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_dec",
          "args": [
            "&index->readers"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "182-185",
          "snippet": "GIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_dec(git_atomic *a)\n{\n\treturn --a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "snap"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}"
  },
  {
    "function_name": "git_index_snapshot_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3320-3335",
    "snippet": "int git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 3332
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_dup",
          "args": [
            "snap",
            "&index->entries",
            "index->entries._cmp"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "50-70",
          "snippet": "int git_vector_dup(git_vector *v, const git_vector *src, git_vector_cmp cmp)\n{\n\tsize_t bytes;\n\n\tassert(v && src);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&bytes, src->length, sizeof(void *));\n\n\tv->_alloc_size = src->length;\n\tv->_cmp = cmp ? cmp : src->_cmp;\n\tv->length = src->length;\n\tv->flags  = src->flags;\n\tif (cmp != src->_cmp)\n\t\tgit_vector_set_sorted(v, 0);\n\tv->contents = git__malloc(bytes);\n\tGITERR_CHECK_ALLOC(v->contents);\n\n\tmemcpy(v->contents, src->contents, bytes);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_dup(git_vector *v, const git_vector *src, git_vector_cmp cmp)\n{\n\tsize_t bytes;\n\n\tassert(v && src);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&bytes, src->length, sizeof(void *));\n\n\tv->_alloc_size = src->length;\n\tv->_cmp = cmp ? cmp : src->_cmp;\n\tv->length = src->length;\n\tv->flags  = src->flags;\n\tif (cmp != src->_cmp)\n\t\tgit_vector_set_sorted(v, 0);\n\tv->contents = git__malloc(bytes);\n\tGITERR_CHECK_ALLOC(v->contents);\n\n\tmemcpy(v->contents, src->contents, bytes);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_inc",
          "args": [
            "&index->readers"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "171-174",
          "snippet": "GIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_inc(git_atomic *a)\n{\n\treturn ++a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "index"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_update_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3307-3318",
    "snippet": "int git_index_update_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_wd_diff(index, INDEX_ACTION_UPDATE, pathspec, 0, cb, payload);\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_apply_to_wd_diff",
          "args": [
            "index",
            "INDEX_ACTION_UPDATE",
            "pathspec",
            "0",
            "cb",
            "payload"
          ],
          "line": 3313
        },
        "resolved": true,
        "details": {
          "function_name": "index_apply_to_wd_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3158-3215",
          "snippet": "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\n\nint git_index_update_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_wd_diff(index, INDEX_ACTION_UPDATE, pathspec, 0, cb, payload);\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_remove_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3292-3305",
    "snippet": "int git_index_remove_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_all(\n\t\tindex, INDEX_ACTION_REMOVE, pathspec, cb, payload);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_apply_to_all",
          "args": [
            "index",
            "INDEX_ACTION_REMOVE",
            "pathspec",
            "cb",
            "payload"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "index_apply_to_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3217-3290",
          "snippet": "static int index_apply_to_all(\n\tgit_index *index,\n\tint action,\n\tconst git_strarray *paths,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_pathspec ps;\n\tconst char *match;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(index);\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\tgit_vector_sort(&index->entries);\n\n\tfor (i = 0; !error && i < index->entries.length; ++i) {\n\t\tgit_index_entry *entry = git_vector_get(&index->entries, i);\n\n\t\t/* check if path actually matches */\n\t\tif (!git_pathspec__match(\n\t\t\t\t&ps.pathspec, entry->path, false, (bool)index->ignore_case,\n\t\t\t\t&match, NULL))\n\t\t\tcontinue;\n\n\t\t/* issue notification callback if requested */\n\t\tif (cb && (error = cb(entry->path, match, payload)) != 0) {\n\t\t\tif (error > 0) { /* return > 0 means skip this one */\n\t\t\t\terror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error < 0)   /* return < 0 means abort */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* index manipulation may alter entry, so don't depend on it */\n\t\tif ((error = git_buf_sets(&path, entry->path)) < 0)\n\t\t\tbreak;\n\n\t\tswitch (action) {\n\t\tcase INDEX_ACTION_NONE:\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_UPDATE:\n\t\t\terror = git_index_add_bypath(index, path.ptr);\n\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\tgiterr_clear();\n\n\t\t\t\terror = git_index_remove_bypath(index, path.ptr);\n\n\t\t\t\tif (!error) /* back up foreach if we removed this */\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_REMOVE:\n\t\t\tif (!(error = git_index_remove_bypath(index, path.ptr)))\n\t\t\t\ti--; /* back up foreach if we removed this */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_INVALID, \"Unknown index action %d\", action);\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_apply_to_all(\n\tgit_index *index,\n\tint action,\n\tconst git_strarray *paths,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_pathspec ps;\n\tconst char *match;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(index);\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\tgit_vector_sort(&index->entries);\n\n\tfor (i = 0; !error && i < index->entries.length; ++i) {\n\t\tgit_index_entry *entry = git_vector_get(&index->entries, i);\n\n\t\t/* check if path actually matches */\n\t\tif (!git_pathspec__match(\n\t\t\t\t&ps.pathspec, entry->path, false, (bool)index->ignore_case,\n\t\t\t\t&match, NULL))\n\t\t\tcontinue;\n\n\t\t/* issue notification callback if requested */\n\t\tif (cb && (error = cb(entry->path, match, payload)) != 0) {\n\t\t\tif (error > 0) { /* return > 0 means skip this one */\n\t\t\t\terror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error < 0)   /* return < 0 means abort */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* index manipulation may alter entry, so don't depend on it */\n\t\tif ((error = git_buf_sets(&path, entry->path)) < 0)\n\t\t\tbreak;\n\n\t\tswitch (action) {\n\t\tcase INDEX_ACTION_NONE:\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_UPDATE:\n\t\t\terror = git_index_add_bypath(index, path.ptr);\n\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\tgiterr_clear();\n\n\t\t\t\terror = git_index_remove_bypath(index, path.ptr);\n\n\t\t\t\tif (!error) /* back up foreach if we removed this */\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_REMOVE:\n\t\t\tif (!(error = git_index_remove_bypath(index, path.ptr)))\n\t\t\t\ti--; /* back up foreach if we removed this */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_INVALID, \"Unknown index action %d\", action);\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\n\nint git_index_remove_all(\n\tgit_index *index,\n\tconst git_strarray *pathspec,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = index_apply_to_all(\n\t\tindex, INDEX_ACTION_REMOVE, pathspec, cb, payload);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_apply_to_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3217-3290",
    "snippet": "static int index_apply_to_all(\n\tgit_index *index,\n\tint action,\n\tconst git_strarray *paths,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_pathspec ps;\n\tconst char *match;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(index);\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\tgit_vector_sort(&index->entries);\n\n\tfor (i = 0; !error && i < index->entries.length; ++i) {\n\t\tgit_index_entry *entry = git_vector_get(&index->entries, i);\n\n\t\t/* check if path actually matches */\n\t\tif (!git_pathspec__match(\n\t\t\t\t&ps.pathspec, entry->path, false, (bool)index->ignore_case,\n\t\t\t\t&match, NULL))\n\t\t\tcontinue;\n\n\t\t/* issue notification callback if requested */\n\t\tif (cb && (error = cb(entry->path, match, payload)) != 0) {\n\t\t\tif (error > 0) { /* return > 0 means skip this one */\n\t\t\t\terror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error < 0)   /* return < 0 means abort */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* index manipulation may alter entry, so don't depend on it */\n\t\tif ((error = git_buf_sets(&path, entry->path)) < 0)\n\t\t\tbreak;\n\n\t\tswitch (action) {\n\t\tcase INDEX_ACTION_NONE:\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_UPDATE:\n\t\t\terror = git_index_add_bypath(index, path.ptr);\n\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\tgiterr_clear();\n\n\t\t\t\terror = git_index_remove_bypath(index, path.ptr);\n\n\t\t\t\tif (!error) /* back up foreach if we removed this */\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_REMOVE:\n\t\t\tif (!(error = git_index_remove_bypath(index, path.ptr)))\n\t\t\t\ti--; /* back up foreach if we removed this */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_INVALID, \"Unknown index action %d\", action);\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pathspec__clear",
          "args": [
            "&ps"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "248-254",
          "snippet": "void git_pathspec__clear(git_pathspec *ps)\n{\n\tgit__free(ps->prefix);\n\tgit_pathspec__vfree(&ps->pathspec);\n\tgit_pool_clear(&ps->pool);\n\tmemset(ps, 0, sizeof(*ps));\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nvoid git_pathspec__clear(git_pathspec *ps)\n{\n\tgit__free(ps->prefix);\n\tgit_pathspec__vfree(&ps->pathspec);\n\tgit_pool_clear(&ps->pool);\n\tmemset(ps, 0, sizeof(*ps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Unknown index action %d\"",
            "action"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_remove_bypath",
          "args": [
            "index",
            "path.ptr"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_remove_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1523-1539",
          "snippet": "int git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 3267
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_add_bypath",
          "args": [
            "index",
            "path.ptr"
          ],
          "line": 3264
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1470-1521",
          "snippet": "int git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&path",
            "entry->path"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "entry->path",
            "match",
            "payload"
          ],
          "line": 3247
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2822-2863",
          "snippet": "static int read_tree_cb(\n\tconst char *root, const git_tree_entry *tentry, void *payload)\n{\n\tread_tree_data *data = payload;\n\tgit_index_entry *entry = NULL, *old_entry;\n\tgit_buf path = GIT_BUF_INIT;\n\tsize_t pos;\n\n\tif (git_tree_entry__is_tree(tentry))\n\t\treturn 0;\n\n\tif (git_buf_joinpath(&path, root, tentry->filename) < 0)\n\t\treturn -1;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(data->index), path.ptr, false) < 0)\n\t\treturn -1;\n\n\tentry->mode = tentry->attr;\n\tgit_oid_cpy(&entry->id, git_tree_entry_id(tentry));\n\n\t/* look for corresponding old entry and copy data to new entry */\n\tif (data->old_entries != NULL &&\n\t\t!index_find_in_entries(\n\t\t\t&pos, data->old_entries, data->entry_cmp, path.ptr, 0, 0) &&\n\t\t(old_entry = git_vector_get(data->old_entries, pos)) != NULL &&\n\t\tentry->mode == old_entry->mode &&\n\t\tgit_oid_equal(&entry->id, &old_entry->id))\n\t{\n\t\tindex_entry_cpy(entry, old_entry);\n\t\tentry->flags_extended = 0;\n\t}\n\n\tindex_entry_adjust_namemask(entry, path.size);\n\tgit_buf_free(&path);\n\n\tif (git_vector_insert(data->new_entries, entry) < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int read_tree_cb(\n\tconst char *root, const git_tree_entry *tentry, void *payload)\n{\n\tread_tree_data *data = payload;\n\tgit_index_entry *entry = NULL, *old_entry;\n\tgit_buf path = GIT_BUF_INIT;\n\tsize_t pos;\n\n\tif (git_tree_entry__is_tree(tentry))\n\t\treturn 0;\n\n\tif (git_buf_joinpath(&path, root, tentry->filename) < 0)\n\t\treturn -1;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(data->index), path.ptr, false) < 0)\n\t\treturn -1;\n\n\tentry->mode = tentry->attr;\n\tgit_oid_cpy(&entry->id, git_tree_entry_id(tentry));\n\n\t/* look for corresponding old entry and copy data to new entry */\n\tif (data->old_entries != NULL &&\n\t\t!index_find_in_entries(\n\t\t\t&pos, data->old_entries, data->entry_cmp, path.ptr, 0, 0) &&\n\t\t(old_entry = git_vector_get(data->old_entries, pos)) != NULL &&\n\t\tentry->mode == old_entry->mode &&\n\t\tgit_oid_equal(&entry->id, &old_entry->id))\n\t{\n\t\tindex_entry_cpy(entry, old_entry);\n\t\tentry->flags_extended = 0;\n\t}\n\n\tindex_entry_adjust_namemask(entry, path.size);\n\tgit_buf_free(&path);\n\n\tif (git_vector_insert(data->new_entries, entry) < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pathspec__match",
          "args": [
            "&ps.pathspec",
            "entry->path",
            "false",
            "(bool)index->ignore_case",
            "&match",
            "NULL"
          ],
          "line": 3241
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "196-230",
          "snippet": "bool git_pathspec__match(\n\tconst git_vector *vspec,\n\tconst char *path,\n\tbool disable_fnmatch,\n\tbool casefold,\n\tconst char **matched_pathspec,\n\tsize_t *matched_at)\n{\n\tint result;\n\tsize_t pos;\n\tstruct pathspec_match_context ctxt;\n\n\tif (matched_pathspec)\n\t\t*matched_pathspec = NULL;\n\tif (matched_at)\n\t\t*matched_at = GIT_PATHSPEC_NOMATCH;\n\n\tif (!vspec || !vspec->length)\n\t\treturn true;\n\n\tpathspec_match_context_init(&ctxt, disable_fnmatch, casefold);\n\n\tresult = git_pathspec__match_at(&pos, vspec, &ctxt, path, NULL);\n\tif (result >= 0) {\n\t\tif (matched_pathspec) {\n\t\t\tconst git_attr_fnmatch *match = git_vector_get(vspec, pos);\n\t\t\t*matched_pathspec = match->pattern;\n\t\t}\n\n\t\tif (matched_at)\n\t\t\t*matched_at = pos;\n\t}\n\n\treturn (result > 0);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nbool git_pathspec__match(\n\tconst git_vector *vspec,\n\tconst char *path,\n\tbool disable_fnmatch,\n\tbool casefold,\n\tconst char **matched_pathspec,\n\tsize_t *matched_at)\n{\n\tint result;\n\tsize_t pos;\n\tstruct pathspec_match_context ctxt;\n\n\tif (matched_pathspec)\n\t\t*matched_pathspec = NULL;\n\tif (matched_at)\n\t\t*matched_at = GIT_PATHSPEC_NOMATCH;\n\n\tif (!vspec || !vspec->length)\n\t\treturn true;\n\n\tpathspec_match_context_init(&ctxt, disable_fnmatch, casefold);\n\n\tresult = git_pathspec__match_at(&pos, vspec, &ctxt, path, NULL);\n\tif (result >= 0) {\n\t\tif (matched_pathspec) {\n\t\t\tconst git_attr_fnmatch *match = git_vector_get(vspec, pos);\n\t\t\t*matched_pathspec = match->pattern;\n\t\t}\n\n\t\tif (matched_at)\n\t\t\t*matched_at = pos;\n\t}\n\n\treturn (result > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "i"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pathspec__init",
          "args": [
            "&ps",
            "paths"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "233-246",
          "snippet": "int git_pathspec__init(git_pathspec *ps, const git_strarray *paths)\n{\n\tint error = 0;\n\n\tmemset(ps, 0, sizeof(*ps));\n\n\tps->prefix = git_pathspec_prefix(paths);\n\tgit_pool_init(&ps->pool, 1);\n\n\tif ((error = git_pathspec__vinit(&ps->pathspec, paths, &ps->pool)) < 0)\n\t\tgit_pathspec__clear(ps);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nint git_pathspec__init(git_pathspec *ps, const git_strarray *paths)\n{\n\tint error = 0;\n\n\tmemset(ps, 0, sizeof(*ps));\n\n\tps->prefix = git_pathspec_prefix(paths);\n\tgit_pool_init(&ps->pool, 1);\n\n\tif ((error = git_pathspec__vinit(&ps->pathspec, paths, &ps->pool)) < 0)\n\t\tgit_pathspec__clear(ps);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 3230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_apply_to_all(\n\tgit_index *index,\n\tint action,\n\tconst git_strarray *paths,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_pathspec ps;\n\tconst char *match;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(index);\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\tgit_vector_sort(&index->entries);\n\n\tfor (i = 0; !error && i < index->entries.length; ++i) {\n\t\tgit_index_entry *entry = git_vector_get(&index->entries, i);\n\n\t\t/* check if path actually matches */\n\t\tif (!git_pathspec__match(\n\t\t\t\t&ps.pathspec, entry->path, false, (bool)index->ignore_case,\n\t\t\t\t&match, NULL))\n\t\t\tcontinue;\n\n\t\t/* issue notification callback if requested */\n\t\tif (cb && (error = cb(entry->path, match, payload)) != 0) {\n\t\t\tif (error > 0) { /* return > 0 means skip this one */\n\t\t\t\terror = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (error < 0)   /* return < 0 means abort */\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* index manipulation may alter entry, so don't depend on it */\n\t\tif ((error = git_buf_sets(&path, entry->path)) < 0)\n\t\t\tbreak;\n\n\t\tswitch (action) {\n\t\tcase INDEX_ACTION_NONE:\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_UPDATE:\n\t\t\terror = git_index_add_bypath(index, path.ptr);\n\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\tgiterr_clear();\n\n\t\t\t\terror = git_index_remove_bypath(index, path.ptr);\n\n\t\t\t\tif (!error) /* back up foreach if we removed this */\n\t\t\t\t\ti--;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase INDEX_ACTION_REMOVE:\n\t\t\tif (!(error = git_index_remove_bypath(index, path.ptr)))\n\t\t\t\ti--; /* back up foreach if we removed this */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgiterr_set(GITERR_INVALID, \"Unknown index action %d\", action);\n\t\t\terror = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_buf_free(&path);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_apply_to_wd_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3158-3215",
    "snippet": "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pathspec__clear",
          "args": [
            "&ps"
          ],
          "line": 3213
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "248-254",
          "snippet": "void git_pathspec__clear(git_pathspec *ps)\n{\n\tgit__free(ps->prefix);\n\tgit_pathspec__vfree(&ps->pathspec);\n\tgit_pool_clear(&ps->pool);\n\tmemset(ps, 0, sizeof(*ps));\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nvoid git_pathspec__clear(git_pathspec *ps)\n{\n\tgit__free(ps->prefix);\n\tgit_pathspec__vfree(&ps->pathspec);\n\tgit_pool_clear(&ps->pool);\n\tmemset(ps, 0, sizeof(*ps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_foreach",
          "args": [
            "diff",
            "apply_each_file",
            "NULL",
            "NULL",
            "NULL",
            "&data"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_patch.c",
          "lines": "404-450",
          "snippet": "int git_diff_foreach(\n\tgit_diff *diff,\n\tgit_diff_file_cb file_cb,\n\tgit_diff_binary_cb binary_cb,\n\tgit_diff_hunk_cb hunk_cb,\n\tgit_diff_line_cb data_cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_xdiff_output xo;\n\tsize_t idx;\n\tgit_patch patch;\n\n\tif ((error = diff_required(diff, \"git_diff_foreach\")) < 0)\n\t\treturn error;\n\n\tmemset(&xo, 0, sizeof(xo));\n\tmemset(&patch, 0, sizeof(patch));\n\tdiff_output_init(\n\t\t&xo.output, &diff->opts, file_cb, binary_cb, hunk_cb, data_cb, payload);\n\tgit_xdiff_init(&xo, &diff->opts);\n\n\tgit_vector_foreach(&diff->deltas, idx, patch.delta) {\n\n\t\t/* check flags against patch status */\n\t\tif (git_diff_delta__should_skip(&diff->opts, patch.delta))\n\t\t\tcontinue;\n\n\t\tif (binary_cb || hunk_cb || data_cb) {\n\t\t\tif ((error = diff_patch_init_from_diff(&patch, diff, idx)) != 0 ||\n\t\t\t\t(error = diff_patch_load(&patch, &xo.output)) != 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = diff_patch_invoke_file_callback(&patch, &xo.output)) == 0) {\n\t\t\tif (binary_cb || hunk_cb || data_cb)\n\t\t\t\t\terror = diff_patch_generate(&patch, &xo.output);\n\t\t}\n\n\t\tgit_patch_free(&patch);\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"zstream.h\"",
            "#include \"delta.h\"",
            "#include \"diff_xdiff.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void diff_output_init(\n\tgit_diff_output*, const git_diff_options*, git_diff_file_cb,\n\tgit_diff_binary_cb, git_diff_hunk_cb, git_diff_line_cb, void*);",
            "static void diff_output_to_patch(git_diff_output *, git_patch *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"zstream.h\"\n#include \"delta.h\"\n#include \"diff_xdiff.h\"\n#include \"diff_patch.h\"\n#include \"diff_driver.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic void diff_output_init(\n\tgit_diff_output*, const git_diff_options*, git_diff_file_cb,\n\tgit_diff_binary_cb, git_diff_hunk_cb, git_diff_line_cb, void*);\nstatic void diff_output_to_patch(git_diff_output *, git_patch *);\n\nint git_diff_foreach(\n\tgit_diff *diff,\n\tgit_diff_file_cb file_cb,\n\tgit_diff_binary_cb binary_cb,\n\tgit_diff_hunk_cb hunk_cb,\n\tgit_diff_line_cb data_cb,\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_xdiff_output xo;\n\tsize_t idx;\n\tgit_patch patch;\n\n\tif ((error = diff_required(diff, \"git_diff_foreach\")) < 0)\n\t\treturn error;\n\n\tmemset(&xo, 0, sizeof(xo));\n\tmemset(&patch, 0, sizeof(patch));\n\tdiff_output_init(\n\t\t&xo.output, &diff->opts, file_cb, binary_cb, hunk_cb, data_cb, payload);\n\tgit_xdiff_init(&xo, &diff->opts);\n\n\tgit_vector_foreach(&diff->deltas, idx, patch.delta) {\n\n\t\t/* check flags against patch status */\n\t\tif (git_diff_delta__should_skip(&diff->opts, patch.delta))\n\t\t\tcontinue;\n\n\t\tif (binary_cb || hunk_cb || data_cb) {\n\t\t\tif ((error = diff_patch_init_from_diff(&patch, diff, idx)) != 0 ||\n\t\t\t\t(error = diff_patch_load(&patch, &xo.output)) != 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\tif ((error = diff_patch_invoke_file_callback(&patch, &xo.output)) == 0) {\n\t\t\tif (binary_cb || hunk_cb || data_cb)\n\t\t\t\t\terror = diff_patch_generate(&patch, &xo.output);\n\t\t}\n\n\t\tgit_patch_free(&patch);\n\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&diff",
            "repo",
            "index",
            "&opts"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pathspec__init",
          "args": [
            "&ps",
            "paths"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "233-246",
          "snippet": "int git_pathspec__init(git_pathspec *ps, const git_strarray *paths)\n{\n\tint error = 0;\n\n\tmemset(ps, 0, sizeof(*ps));\n\n\tps->prefix = git_pathspec_prefix(paths);\n\tgit_pool_init(&ps->pool, 1);\n\n\tif ((error = git_pathspec__vinit(&ps->pathspec, paths, &ps->pool)) < 0)\n\t\tgit_pathspec__clear(ps);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nint git_pathspec__init(git_pathspec *ps, const git_strarray *paths)\n{\n\tint error = 0;\n\n\tmemset(ps, 0, sizeof(*ps));\n\n\tps->prefix = git_pathspec_prefix(paths);\n\tgit_pool_init(&ps->pool, 1);\n\n\tif ((error = git_pathspec__vinit(&ps->pathspec, paths, &ps->pool)) < 0)\n\t\tgit_pathspec__clear(ps);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"cannot run update; the index is not backed up by a repository.\""
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}"
  },
  {
    "function_name": "apply_each_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3125-3156",
    "snippet": "static int apply_each_file(const git_diff_delta *delta, float progress, void *payload)\n{\n\tstruct foreach_diff_data *data = payload;\n\tconst char *match, *path;\n\tint error = 0;\n\n\tGIT_UNUSED(progress);\n\n\tpath = delta->old_file.path;\n\n\t/* We only want those which match the pathspecs */\n\tif (!git_pathspec__match(\n\t\t    &data->pathspec->pathspec, path, false, (bool)data->index->ignore_case,\n\t\t    &match, NULL))\n\t\treturn 0;\n\n\tif (data->cb)\n\t\terror = data->cb(path, match, data->payload);\n\n\tif (error > 0) /* skip this entry */\n\t\treturn 0;\n\tif (error < 0) /* actual error */\n\t\treturn error;\n\n\t/* If the workdir item does not exist, remove it from the index. */\n\tif ((delta->new_file.flags & GIT_DIFF_FLAG_EXISTS) == 0)\n\t\terror = git_index_remove_bypath(data->index, path);\n\telse\n\t\terror = git_index_add_bypath(data->index, delta->new_file.path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_add_bypath",
          "args": [
            "data->index",
            "delta->new_file.path"
          ],
          "line": 3153
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1470-1521",
          "snippet": "int git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_remove_bypath",
          "args": [
            "data->index",
            "path"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_remove_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1523-1539",
          "snippet": "int git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->cb",
          "args": [
            "path",
            "match",
            "data->payload"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pathspec__match",
          "args": [
            "&data->pathspec->pathspec",
            "path",
            "false",
            "(bool)data->index->ignore_case",
            "&match",
            "NULL"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "196-230",
          "snippet": "bool git_pathspec__match(\n\tconst git_vector *vspec,\n\tconst char *path,\n\tbool disable_fnmatch,\n\tbool casefold,\n\tconst char **matched_pathspec,\n\tsize_t *matched_at)\n{\n\tint result;\n\tsize_t pos;\n\tstruct pathspec_match_context ctxt;\n\n\tif (matched_pathspec)\n\t\t*matched_pathspec = NULL;\n\tif (matched_at)\n\t\t*matched_at = GIT_PATHSPEC_NOMATCH;\n\n\tif (!vspec || !vspec->length)\n\t\treturn true;\n\n\tpathspec_match_context_init(&ctxt, disable_fnmatch, casefold);\n\n\tresult = git_pathspec__match_at(&pos, vspec, &ctxt, path, NULL);\n\tif (result >= 0) {\n\t\tif (matched_pathspec) {\n\t\t\tconst git_attr_fnmatch *match = git_vector_get(vspec, pos);\n\t\t\t*matched_pathspec = match->pattern;\n\t\t}\n\n\t\tif (matched_at)\n\t\t\t*matched_at = pos;\n\t}\n\n\treturn (result > 0);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nbool git_pathspec__match(\n\tconst git_vector *vspec,\n\tconst char *path,\n\tbool disable_fnmatch,\n\tbool casefold,\n\tconst char **matched_pathspec,\n\tsize_t *matched_at)\n{\n\tint result;\n\tsize_t pos;\n\tstruct pathspec_match_context ctxt;\n\n\tif (matched_pathspec)\n\t\t*matched_pathspec = NULL;\n\tif (matched_at)\n\t\t*matched_at = GIT_PATHSPEC_NOMATCH;\n\n\tif (!vspec || !vspec->length)\n\t\treturn true;\n\n\tpathspec_match_context_init(&ctxt, disable_fnmatch, casefold);\n\n\tresult = git_pathspec__match_at(&pos, vspec, &ctxt, path, NULL);\n\tif (result >= 0) {\n\t\tif (matched_pathspec) {\n\t\t\tconst git_attr_fnmatch *match = git_vector_get(vspec, pos);\n\t\t\t*matched_pathspec = match->pattern;\n\t\t}\n\n\t\tif (matched_at)\n\t\t\t*matched_at = pos;\n\t}\n\n\treturn (result > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "progress"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int apply_each_file(const git_diff_delta *delta, float progress, void *payload)\n{\n\tstruct foreach_diff_data *data = payload;\n\tconst char *match, *path;\n\tint error = 0;\n\n\tGIT_UNUSED(progress);\n\n\tpath = delta->old_file.path;\n\n\t/* We only want those which match the pathspecs */\n\tif (!git_pathspec__match(\n\t\t    &data->pathspec->pathspec, path, false, (bool)data->index->ignore_case,\n\t\t    &match, NULL))\n\t\treturn 0;\n\n\tif (data->cb)\n\t\terror = data->cb(path, match, data->payload);\n\n\tif (error > 0) /* skip this entry */\n\t\treturn 0;\n\tif (error < 0) /* actual error */\n\t\treturn error;\n\n\t/* If the workdir item does not exist, remove it from the index. */\n\tif ((delta->new_file.flags & GIT_DIFF_FLAG_EXISTS) == 0)\n\t\terror = git_index_remove_bypath(data->index, path);\n\telse\n\t\terror = git_index_add_bypath(data->index, delta->new_file.path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_add_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3076-3115",
    "snippet": "int git_index_add_all(\n\tgit_index *index,\n\tconst git_strarray *paths,\n\tunsigned int flags,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_repository *repo;\n\tgit_iterator *wditer = NULL;\n\tgit_pathspec ps;\n\tbool no_fnmatch = (flags & GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH) != 0;\n\n\tassert(index);\n\n\trepo = INDEX_OWNER(index);\n\tif ((error = git_repository__ensure_not_bare(repo, \"index add all\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\t/* optionally check that pathspec doesn't mention any ignored files */\n\tif ((flags & GIT_INDEX_ADD_CHECK_PATHSPEC) != 0 &&\n\t\t(flags & GIT_INDEX_ADD_FORCE) == 0 &&\n\t\t(error = git_ignore__check_pathspec_for_exact_ignores(\n\t\t\trepo, &ps.pathspec, no_fnmatch)) < 0)\n\t\tgoto cleanup;\n\n\terror = index_apply_to_wd_diff(index, INDEX_ACTION_ADDALL, paths, flags, cb, payload);\n\n\tif (error)\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_iterator_free(wditer);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pathspec__clear",
          "args": [
            "&ps"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "248-254",
          "snippet": "void git_pathspec__clear(git_pathspec *ps)\n{\n\tgit__free(ps->prefix);\n\tgit_pathspec__vfree(&ps->pathspec);\n\tgit_pool_clear(&ps->pool);\n\tmemset(ps, 0, sizeof(*ps));\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nvoid git_pathspec__clear(git_pathspec *ps)\n{\n\tgit__free(ps->prefix);\n\tgit_pathspec__vfree(&ps->pathspec);\n\tgit_pool_clear(&ps->pool);\n\tmemset(ps, 0, sizeof(*ps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "wditer"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_apply_to_wd_diff",
          "args": [
            "index",
            "INDEX_ACTION_ADDALL",
            "paths",
            "flags",
            "cb",
            "payload"
          ],
          "line": 3105
        },
        "resolved": true,
        "details": {
          "function_name": "index_apply_to_wd_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3158-3215",
          "snippet": "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload)\n{\n\tint error;\n\tgit_diff *diff;\n\tgit_pathspec ps;\n\tgit_repository *repo;\n\tgit_diff_options opts = GIT_DIFF_OPTIONS_INIT;\n\tstruct foreach_diff_data data = {\n\t\tindex,\n\t\tNULL,\n\t\tflags,\n\t\tcb,\n\t\tpayload,\n\t};\n\n\tassert(index);\n\tassert(action == INDEX_ACTION_UPDATE || action == INDEX_ACTION_ADDALL);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (!repo) {\n\t\treturn create_index_error(-1,\n\t\t\t\"cannot run update; the index is not backed up by a repository.\");\n\t}\n\n\t/*\n\t * We do the matching ourselves intead of passing the list to\n\t * diff because we want to tell the callback which one\n\t * matched, which we do not know if we ask diff to filter for us.\n\t */\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\topts.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tif (action == INDEX_ACTION_ADDALL) {\n\t\topts.flags |= GIT_DIFF_INCLUDE_UNTRACKED |\n\t\t\tGIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\n\t\tif (flags == GIT_INDEX_ADD_FORCE)\n\t\t\topts.flags |= GIT_DIFF_INCLUDE_IGNORED;\n\t}\n\n\tif ((error = git_diff_index_to_workdir(&diff, repo, index, &opts)) < 0)\n\t\tgoto cleanup;\n\n\tdata.pathspec = &ps;\n\terror = git_diff_foreach(diff, apply_each_file, NULL, NULL, NULL, &data);\n\tgit_diff_free(diff);\n\n\tif (error) /* make sure error is set if callback stopped iteration */\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_pathspec__clear(&ps);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_ignore__check_pathspec_for_exact_ignores",
          "args": [
            "repo",
            "&ps.pathspec",
            "no_fnmatch"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__check_pathspec_for_exact_ignores",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "556-611",
          "snippet": "int git_ignore__check_pathspec_for_exact_ignores(\n\tgit_repository *repo,\n\tgit_vector *vspec,\n\tbool no_fnmatch)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *match;\n\tint ignored;\n\tgit_buf path = GIT_BUF_INIT;\n\tconst char *wd, *filename;\n\tgit_index *idx;\n\n\tif ((error = git_repository__ensure_not_bare(\n\t\t\trepo, \"validate pathspec\")) < 0 ||\n\t\t(error = git_repository_index(&idx, repo)) < 0)\n\t\treturn error;\n\n\twd = git_repository_workdir(repo);\n\n\tgit_vector_foreach(vspec, i, match) {\n\t\t/* skip wildcard matches (if they are being used) */\n\t\tif ((match->flags & GIT_ATTR_FNMATCH_HASWILD) != 0 &&\n\t\t\t!no_fnmatch)\n\t\t\tcontinue;\n\n\t\tfilename = match->pattern;\n\n\t\t/* if file is already in the index, it's fine */\n\t\tif (git_index_get_bypath(idx, filename, 0) != NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = git_buf_joinpath(&path, wd, filename)) < 0)\n\t\t\tbreak;\n\n\t\t/* is there a file on disk that matches this exactly? */\n\t\tif (!git_path_isfile(path.ptr))\n\t\t\tcontinue;\n\n\t\t/* is that file ignored? */\n\t\tif ((error = git_ignore_path_is_ignored(&ignored, repo, filename)) < 0)\n\t\t\tbreak;\n\n\t\tif (ignored) {\n\t\t\tgiterr_set(GITERR_INVALID, \"pathspec contains ignored file '%s'\",\n\t\t\t\tfilename);\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_index_free(idx);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__check_pathspec_for_exact_ignores(\n\tgit_repository *repo,\n\tgit_vector *vspec,\n\tbool no_fnmatch)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_attr_fnmatch *match;\n\tint ignored;\n\tgit_buf path = GIT_BUF_INIT;\n\tconst char *wd, *filename;\n\tgit_index *idx;\n\n\tif ((error = git_repository__ensure_not_bare(\n\t\t\trepo, \"validate pathspec\")) < 0 ||\n\t\t(error = git_repository_index(&idx, repo)) < 0)\n\t\treturn error;\n\n\twd = git_repository_workdir(repo);\n\n\tgit_vector_foreach(vspec, i, match) {\n\t\t/* skip wildcard matches (if they are being used) */\n\t\tif ((match->flags & GIT_ATTR_FNMATCH_HASWILD) != 0 &&\n\t\t\t!no_fnmatch)\n\t\t\tcontinue;\n\n\t\tfilename = match->pattern;\n\n\t\t/* if file is already in the index, it's fine */\n\t\tif (git_index_get_bypath(idx, filename, 0) != NULL)\n\t\t\tcontinue;\n\n\t\tif ((error = git_buf_joinpath(&path, wd, filename)) < 0)\n\t\t\tbreak;\n\n\t\t/* is there a file on disk that matches this exactly? */\n\t\tif (!git_path_isfile(path.ptr))\n\t\t\tcontinue;\n\n\t\t/* is that file ignored? */\n\t\tif ((error = git_ignore_path_is_ignored(&ignored, repo, filename)) < 0)\n\t\t\tbreak;\n\n\t\tif (ignored) {\n\t\t\tgiterr_set(GITERR_INVALID, \"pathspec contains ignored file '%s'\",\n\t\t\t\tfilename);\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_index_free(idx);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pathspec__init",
          "args": [
            "&ps",
            "paths"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "233-246",
          "snippet": "int git_pathspec__init(git_pathspec *ps, const git_strarray *paths)\n{\n\tint error = 0;\n\n\tmemset(ps, 0, sizeof(*ps));\n\n\tps->prefix = git_pathspec_prefix(paths);\n\tgit_pool_init(&ps->pool, 1);\n\n\tif ((error = git_pathspec__vinit(&ps->pathspec, paths, &ps->pool)) < 0)\n\t\tgit_pathspec__clear(ps);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nint git_pathspec__init(git_pathspec *ps, const git_strarray *paths)\n{\n\tint error = 0;\n\n\tmemset(ps, 0, sizeof(*ps));\n\n\tps->prefix = git_pathspec_prefix(paths);\n\tgit_pool_init(&ps->pool, 1);\n\n\tif ((error = git_pathspec__vinit(&ps->pathspec, paths, &ps->pool)) < 0)\n\t\tgit_pathspec__clear(ps);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"index add all\""
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\n\nint git_index_add_all(\n\tgit_index *index,\n\tconst git_strarray *paths,\n\tunsigned int flags,\n\tgit_index_matched_path_cb cb,\n\tvoid *payload)\n{\n\tint error;\n\tgit_repository *repo;\n\tgit_iterator *wditer = NULL;\n\tgit_pathspec ps;\n\tbool no_fnmatch = (flags & GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH) != 0;\n\n\tassert(index);\n\n\trepo = INDEX_OWNER(index);\n\tif ((error = git_repository__ensure_not_bare(repo, \"index add all\")) < 0)\n\t\treturn error;\n\n\tif ((error = git_pathspec__init(&ps, paths)) < 0)\n\t\treturn error;\n\n\t/* optionally check that pathspec doesn't mention any ignored files */\n\tif ((flags & GIT_INDEX_ADD_CHECK_PATHSPEC) != 0 &&\n\t\t(flags & GIT_INDEX_ADD_FORCE) == 0 &&\n\t\t(error = git_ignore__check_pathspec_for_exact_ignores(\n\t\t\trepo, &ps.pathspec, no_fnmatch)) < 0)\n\t\tgoto cleanup;\n\n\terror = index_apply_to_wd_diff(index, INDEX_ACTION_ADDALL, paths, flags, cb, payload);\n\n\tif (error)\n\t\tgiterr_set_after_callback(error);\n\ncleanup:\n\tgit_iterator_free(wditer);\n\tgit_pathspec__clear(&ps);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "3064-3067",
    "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
  },
  {
    "function_name": "git_index_read_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2928-3062",
    "snippet": "int git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "new_iterator"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&remove_entries"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_free",
          "args": [
            "new_entries_map"
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entry"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_cache_invalidate_path",
          "args": [
            "index->tree",
            "entry->path"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_invalidate_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "27-49",
          "snippet": "void git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nvoid git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&remove_entries",
            "i",
            "entry"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__swap",
          "args": [
            "index->entries_map",
            "new_entries_map"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_swap",
          "args": [
            "&new_entries",
            "&index->entries"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "305-316",
          "snippet": "void git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_reuc_clear",
          "args": [
            "index"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_reuc_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2115-2125",
          "snippet": "void git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nvoid git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_name_clear",
          "args": [
            "index"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_name_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2011-2022",
          "snippet": "void git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "&new_entry",
            "new_iterator"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"failed to insert entry\""
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&remove_entries",
            "remove_entry"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSERT_IN_MAP_EX",
          "args": [
            "index",
            "new_entries_map",
            "add_entry",
            "error"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_adjust_namemask",
          "args": [
            "add_entry",
            "((struct entry_internal *)add_entry)->pathlen"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_adjust_namemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "845-855",
          "snippet": "static void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_dup_nocache",
          "args": [
            "&add_entry",
            "index",
            "dup_entry"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1016-1026",
          "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&old_entry->id",
            "&new_entry->id"
          ],
          "line": 2991
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_cmp",
          "args": [
            "old_entry",
            "new_entry"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "217-229",
          "snippet": "int git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_current",
          "args": [
            "&new_entry",
            "new_iterator"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_workdir_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2014-2024",
          "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&new_iterator",
            "git_index_owner(new_index)",
            "(git_index *)new_index",
            "&opts"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_owner",
          "args": [
            "new_index"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3064-3067",
          "snippet": "git_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\ngit_repository *git_index_owner(const git_index *index)\n{\n\treturn INDEX_OWNER(index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_resize",
          "args": [
            "idx",
            "new_entries_map",
            "new_index->entries.length"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_resize",
          "args": [
            "idxicase",
            "(khash_t(idxicase) *) new_entries_map",
            "new_index->entries.length"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_idxmap_alloc",
          "args": [
            "&new_entries_map"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&remove_entries",
            "index->entries.length",
            "NULL"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_read_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2865-2926",
    "snippet": "int git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tkh_resize(idx, entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_cache_read_tree",
          "args": [
            "&index->tree",
            "tree",
            "&index->tree_pool"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_read_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "217-230",
          "snippet": "int git_tree_cache_read_tree(git_tree_cache **out, const git_tree *tree, git_pool *pool)\n{\n\tint error;\n\tgit_tree_cache *cache;\n\n\tif ((error = git_tree_cache_new(&cache, \"\", pool)) < 0)\n\t\treturn error;\n\n\tif ((error = read_tree_recursive(cache, tree, pool)) < 0)\n\t\treturn error;\n\n\t*out = cache;\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_read_tree(git_tree_cache **out, const git_tree *tree, git_pool *pool)\n{\n\tint error;\n\tgit_tree_cache *cache;\n\n\tif ((error = git_tree_cache_new(&cache, \"\", pool)) < 0)\n\t\treturn error;\n\n\tif ((error = read_tree_recursive(cache, tree, pool)) < 0)\n\t\treturn error;\n\n\t*out = cache;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_free",
          "args": [
            "entries_map"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&entries"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__swap",
          "args": [
            "index->entries_map",
            "entries_map"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_swap",
          "args": [
            "&entries",
            "&index->entries"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_swap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "305-316",
          "snippet": "void git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_swap(git_vector *a, git_vector *b)\n{\n\tgit_vector t;\n\n\tassert(a && b);\n\n\tif (a != b) {\n\t\tmemcpy(&t, a, sizeof(t));\n\t\tmemcpy(a, b, sizeof(t));\n\t\tmemcpy(b, &t, sizeof(t));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_clear",
          "args": [
            "index"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "526-546",
          "snippet": "int git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&entries"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"failed to insert entry into map\""
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSERT_IN_MAP_EX",
          "args": [
            "index",
            "entries_map",
            "e",
            "error"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&entries",
            "i",
            "e"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_resize",
          "args": [
            "idx",
            "entries_map",
            "entries.length"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_resize",
          "args": [
            "idxicase",
            "(khash_t(idxicase) *) entries_map",
            "entries.length"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_walk",
          "args": [
            "tree",
            "GIT_TREEWALK_POST",
            "read_tree_cb",
            "&data"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "1020-1040",
          "snippet": "int git_tree_walk(\n\tconst git_tree *tree,\n\tgit_treewalk_mode mode,\n\tgit_treewalk_cb callback,\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_buf root_path = GIT_BUF_INIT;\n\n\tif (mode != GIT_TREEWALK_POST && mode != GIT_TREEWALK_PRE) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid walking mode for tree walk\");\n\t\treturn -1;\n\t}\n\n\terror = tree_walk(\n\t\ttree, callback, &root_path, payload, (mode == GIT_TREEWALK_PRE));\n\n\tgit_buf_free(&root_path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_walk(\n\tconst git_tree *tree,\n\tgit_treewalk_mode mode,\n\tgit_treewalk_cb callback,\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_buf root_path = GIT_BUF_INIT;\n\n\tif (mode != GIT_TREEWALK_POST && mode != GIT_TREEWALK_PRE) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid walking mode for tree walk\");\n\t\treturn -1;\n\t}\n\n\terror = tree_walk(\n\t\ttree, callback, &root_path, payload, (mode == GIT_TREEWALK_PRE));\n\n\tgit_buf_free(&root_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&index->tree_pool"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&entries",
            "index->entries._cmp"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_alloc",
          "args": [
            "&entries_map"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_tree(git_index *index, const git_tree *tree)\n{\n\tint error = 0;\n\tgit_vector entries = GIT_VECTOR_INIT;\n\tgit_idxmap *entries_map;\n\tread_tree_data data;\n\tsize_t i;\n\tgit_index_entry *e;\n\n\tif (git_idxmap_alloc(&entries_map) < 0)\n\t\treturn -1;\n\n\tgit_vector_set_cmp(&entries, index->entries._cmp); /* match sort */\n\n\tdata.index = index;\n\tdata.old_entries = &index->entries;\n\tdata.new_entries = &entries;\n\tdata.entry_cmp   = index->entries_search;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_vector_sort(&index->entries);\n\n\tif ((error = git_tree_walk(tree, GIT_TREEWALK_POST, read_tree_cb, &data)) < 0)\n\t\tgoto cleanup;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) entries_map, entries.length);\n\telse\n\t\tkh_resize(idx, entries_map, entries.length);\n\n\tgit_vector_foreach(&entries, i, e) {\n\t\tINSERT_IN_MAP_EX(index, entries_map, e, error);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry into map\");\n\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = 0;\n\n\tgit_vector_sort(&entries);\n\n\tif ((error = git_index_clear(index)) < 0) {\n\t\t/* well, this isn't good */;\n\t} else {\n\t\tgit_vector_swap(&entries, &index->entries);\n\t\tentries_map = git__swap(index->entries_map, entries_map);\n\t}\n\ncleanup:\n\tgit_vector_free(&entries);\n\tgit_idxmap_free(entries_map);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\n\treturn error;\n}"
  },
  {
    "function_name": "read_tree_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2822-2863",
    "snippet": "static int read_tree_cb(\n\tconst char *root, const git_tree_entry *tentry, void *payload)\n{\n\tread_tree_data *data = payload;\n\tgit_index_entry *entry = NULL, *old_entry;\n\tgit_buf path = GIT_BUF_INIT;\n\tsize_t pos;\n\n\tif (git_tree_entry__is_tree(tentry))\n\t\treturn 0;\n\n\tif (git_buf_joinpath(&path, root, tentry->filename) < 0)\n\t\treturn -1;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(data->index), path.ptr, false) < 0)\n\t\treturn -1;\n\n\tentry->mode = tentry->attr;\n\tgit_oid_cpy(&entry->id, git_tree_entry_id(tentry));\n\n\t/* look for corresponding old entry and copy data to new entry */\n\tif (data->old_entries != NULL &&\n\t\t!index_find_in_entries(\n\t\t\t&pos, data->old_entries, data->entry_cmp, path.ptr, 0, 0) &&\n\t\t(old_entry = git_vector_get(data->old_entries, pos)) != NULL &&\n\t\tentry->mode == old_entry->mode &&\n\t\tgit_oid_equal(&entry->id, &old_entry->id))\n\t{\n\t\tindex_entry_cpy(entry, old_entry);\n\t\tentry->flags_extended = 0;\n\t}\n\n\tindex_entry_adjust_namemask(entry, path.size);\n\tgit_buf_free(&path);\n\n\tif (git_vector_insert(data->new_entries, entry) < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);",
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entry"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "data->new_entries",
            "entry"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_adjust_namemask",
          "args": [
            "entry",
            "path.size"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_adjust_namemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "845-855",
          "snippet": "static void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_cpy",
          "args": [
            "entry",
            "old_entry"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_cpy_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1006-1014",
          "snippet": "static void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&entry->id",
            "&old_entry->id"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "data->old_entries",
            "pos"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_find_in_entries",
          "args": [
            "&pos",
            "data->old_entries",
            "data->entry_cmp",
            "path.ptr",
            "0",
            "0"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "index_find_in_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "359-368",
          "snippet": "GIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nGIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry->id",
            "git_tree_entry_id(tentry)"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_id",
          "args": [
            "tentry"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "278-282",
          "snippet": "const git_oid *git_tree_entry_id(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->oid;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_tree_entry_id(const git_tree_entry *entry)\n{\n\tassert(entry);\n\treturn entry->oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_create",
          "args": [
            "&entry",
            "INDEX_OWNER(data->index)",
            "path.ptr",
            "false"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "863-896",
          "snippet": "static int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "data->index"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "root",
            "tentry->filename"
          ],
          "line": 2833
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry__is_tree",
          "args": [
            "tentry"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry__is_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.h",
          "lines": "35-38",
          "snippet": "GIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}",
          "includes": [
            "#include \"pool.h\"",
            "#include \"strmap.h\"",
            "#include \"vector.h\"",
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"git2/tree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pool.h\"\n#include \"strmap.h\"\n#include \"vector.h\"\n#include \"odb.h\"\n#include \"repository.h\"\n#include \"git2/tree.h\"\n\nGIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_apply_to_wd_diff(git_index *index, int action, const git_strarray *paths,\n\t\t\t\t  unsigned int flags,\n\t\t\t\t  git_index_matched_path_cb cb, void *payload);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int read_tree_cb(\n\tconst char *root, const git_tree_entry *tentry, void *payload)\n{\n\tread_tree_data *data = payload;\n\tgit_index_entry *entry = NULL, *old_entry;\n\tgit_buf path = GIT_BUF_INIT;\n\tsize_t pos;\n\n\tif (git_tree_entry__is_tree(tentry))\n\t\treturn 0;\n\n\tif (git_buf_joinpath(&path, root, tentry->filename) < 0)\n\t\treturn -1;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(data->index), path.ptr, false) < 0)\n\t\treturn -1;\n\n\tentry->mode = tentry->attr;\n\tgit_oid_cpy(&entry->id, git_tree_entry_id(tentry));\n\n\t/* look for corresponding old entry and copy data to new entry */\n\tif (data->old_entries != NULL &&\n\t\t!index_find_in_entries(\n\t\t\t&pos, data->old_entries, data->entry_cmp, path.ptr, 0, 0) &&\n\t\t(old_entry = git_vector_get(data->old_entries, pos)) != NULL &&\n\t\tentry->mode == old_entry->mode &&\n\t\tgit_oid_equal(&entry->id, &old_entry->id))\n\t{\n\t\tindex_entry_cpy(entry, old_entry);\n\t\tentry->flags_extended = 0;\n\t}\n\n\tindex_entry_adjust_namemask(entry, path.size);\n\tgit_buf_free(&path);\n\n\tif (git_vector_insert(data->new_entries, entry) < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_entry_is_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2809-2812",
    "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
  },
  {
    "function_name": "git_index_entry_stage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2804-2807",
    "snippet": "int git_index_entry_stage(const git_index_entry *entry)\n{\n\treturn GIT_IDXENTRY_STAGE(entry);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_stage(const git_index_entry *entry)\n{\n\treturn GIT_IDXENTRY_STAGE(entry);\n}"
  },
  {
    "function_name": "write_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2756-2802",
    "snippet": "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tis_extended = is_index_extended(index);\n\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER;\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int INDEX_VERSION_NUMBER = 2;",
      "static const unsigned int INDEX_VERSION_NUMBER_EXT = 3;",
      "static const unsigned int INDEX_HEADER_SIG = 0x44495243;",
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_uptodate",
          "args": [
            "index"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "clear_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2747-2754",
          "snippet": "static void clear_uptodate(git_index *index)\n{\n\tgit_index_entry *entry;\n\tsize_t i;\n\n\tgit_vector_foreach(&index->entries, i, entry)\n\t\tentry->flags_extended &= ~GIT_IDXENTRY_UPTODATE;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void clear_uptodate(git_index *index)\n{\n\tgit_index_entry *entry;\n\tsize_t i;\n\n\tgit_vector_foreach(&index->entries, i, entry)\n\t\tentry->flags_extended &= ~GIT_IDXENTRY_UPTODATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "file",
            "hash_final.id",
            "GIT_OID_RAWSZ"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "checksum",
            "&hash_final"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_hash",
          "args": [
            "&hash_final",
            "file"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "385-399",
          "snippet": "int git_filebuf_hash(git_oid *oid, git_filebuf *file)\n{\n\tassert(oid && file && file->compute_digest);\n\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\treturn -1;\n\n\tgit_hash_final(oid, &file->digest);\n\tgit_hash_ctx_cleanup(&file->digest);\n\tfile->compute_digest = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_hash(git_oid *oid, git_filebuf *file)\n{\n\tassert(oid && file && file->compute_digest);\n\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\treturn -1;\n\n\tgit_hash_final(oid, &file->digest);\n\tgit_hash_ctx_cleanup(&file->digest);\n\tfile->compute_digest = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_reuc_extension",
          "args": [
            "index",
            "file"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "write_reuc_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2698-2722",
          "snippet": "static int write_reuc_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf reuc_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->reuc;\n\tgit_index_reuc_entry *reuc;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, reuc) {\n\t\tif ((error = create_reuc_extension_data(&reuc_buf, reuc)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_UNMERGED_SIG, 4);\n\textension.extension_size = (uint32_t)reuc_buf.size;\n\n\terror = write_extension(file, &extension, &reuc_buf);\n\n\tgit_buf_free(&reuc_buf);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};",
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int write_reuc_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf reuc_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->reuc;\n\tgit_index_reuc_entry *reuc;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, reuc) {\n\t\tif ((error = create_reuc_extension_data(&reuc_buf, reuc)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_UNMERGED_SIG, 4);\n\textension.extension_size = (uint32_t)reuc_buf.size;\n\n\terror = write_extension(file, &extension, &reuc_buf);\n\n\tgit_buf_free(&reuc_buf);\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_name_extension",
          "args": [
            "index",
            "file"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "write_name_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2650-2674",
          "snippet": "static int write_name_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf name_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->names;\n\tgit_index_name_entry *conflict_name;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, conflict_name) {\n\t\tif ((error = create_name_extension_data(&name_buf, conflict_name)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4);\n\textension.extension_size = (uint32_t)name_buf.size;\n\n\terror = write_extension(file, &extension, &name_buf);\n\n\tgit_buf_free(&name_buf);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};",
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_name_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf name_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->names;\n\tgit_index_name_entry *conflict_name;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, conflict_name) {\n\t\tif ((error = create_name_extension_data(&name_buf, conflict_name)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4);\n\textension.extension_size = (uint32_t)name_buf.size;\n\n\terror = write_extension(file, &extension, &name_buf);\n\n\tgit_buf_free(&name_buf);\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_tree_extension",
          "args": [
            "index",
            "file"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "write_tree_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2724-2745",
          "snippet": "static int write_tree_extension(git_index *index, git_filebuf *file)\n{\n\tstruct index_extension extension;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (index->tree == NULL)\n\t\treturn 0;\n\n\tif ((error = git_tree_cache_write(&buf, index->tree)) < 0)\n\t\treturn error;\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_TREECACHE_SIG, 4);\n\textension.extension_size = (uint32_t)buf.size;\n\n\terror = write_extension(file, &extension, &buf);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};",
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_tree_extension(git_index *index, git_filebuf *file)\n{\n\tstruct index_extension extension;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (index->tree == NULL)\n\t\treturn 0;\n\n\tif ((error = git_tree_cache_write(&buf, index->tree)) < 0)\n\t\treturn error;\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_TREECACHE_SIG, 4);\n\textension.extension_size = (uint32_t)buf.size;\n\n\terror = write_extension(file, &extension, &buf);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_entries",
          "args": [
            "index",
            "file"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "write_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2582-2607",
          "snippet": "static int write_entries(git_index *index, git_filebuf *file)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_vector case_sorted, *entries;\n\tgit_index_entry *entry;\n\n\t/* If index->entries is sorted case-insensitively, then we need\n\t * to re-sort it case-sensitively before writing */\n\tif (index->ignore_case) {\n\t\tgit_vector_dup(&case_sorted, &index->entries, git_index_entry_cmp);\n\t\tgit_vector_sort(&case_sorted);\n\t\tentries = &case_sorted;\n\t} else {\n\t\tentries = &index->entries;\n\t}\n\n\tgit_vector_foreach(entries, i, entry)\n\t\tif ((error = write_disk_entry(file, entry)) < 0)\n\t\t\tbreak;\n\n\tif (index->ignore_case)\n\t\tgit_vector_free(&case_sorted);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int write_entries(git_index *index, git_filebuf *file)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_vector case_sorted, *entries;\n\tgit_index_entry *entry;\n\n\t/* If index->entries is sorted case-insensitively, then we need\n\t * to re-sort it case-sensitively before writing */\n\tif (index->ignore_case) {\n\t\tgit_vector_dup(&case_sorted, &index->entries, git_index_entry_cmp);\n\t\tgit_vector_sort(&case_sorted);\n\t\tentries = &case_sorted;\n\t} else {\n\t\tentries = &index->entries;\n\t}\n\n\tgit_vector_foreach(entries, i, entry)\n\t\tif ((error = write_disk_entry(file, entry)) < 0)\n\t\t\tbreak;\n\n\tif (index->ignore_case)\n\t\tgit_vector_free(&case_sorted);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t)index->entries.length"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "index_version_number"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INDEX_HEADER_SIG"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_index_extended",
          "args": [
            "index"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "is_index_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2503-2519",
          "snippet": "static bool is_index_extended(git_index *index)\n{\n\tsize_t i, extended;\n\tgit_index_entry *entry;\n\n\textended = 0;\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tentry->flags &= ~GIT_IDXENTRY_EXTENDED;\n\t\tif (entry->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tentry->flags |= GIT_IDXENTRY_EXTENDED;\n\t\t}\n\t}\n\n\treturn (extended > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic bool is_index_extended(git_index *index)\n{\n\tsize_t i, extended;\n\tgit_index_entry *entry;\n\n\textended = 0;\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tentry->flags &= ~GIT_IDXENTRY_EXTENDED;\n\t\tif (entry->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tentry->flags |= GIT_IDXENTRY_EXTENDED;\n\t\t}\n\t}\n\n\treturn (extended > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && file"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const unsigned int INDEX_VERSION_NUMBER = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_EXT = 3;\nstatic const unsigned int INDEX_HEADER_SIG = 0x44495243;\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file)\n{\n\tgit_oid hash_final;\n\tstruct index_header header;\n\tbool is_extended;\n\tuint32_t index_version_number;\n\n\tassert(index && file);\n\n\tis_extended = is_index_extended(index);\n\tindex_version_number = is_extended ? INDEX_VERSION_NUMBER_EXT : INDEX_VERSION_NUMBER;\n\n\theader.signature = htonl(INDEX_HEADER_SIG);\n\theader.version = htonl(index_version_number);\n\theader.entry_count = htonl((uint32_t)index->entries.length);\n\n\tif (git_filebuf_write(file, &header, sizeof(struct index_header)) < 0)\n\t\treturn -1;\n\n\tif (write_entries(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the tree cache extension */\n\tif (index->tree != NULL && write_tree_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the rename conflict extension */\n\tif (index->names.length > 0 && write_name_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* write the reuc extension */\n\tif (index->reuc.length > 0 && write_reuc_extension(index, file) < 0)\n\t\treturn -1;\n\n\t/* get out the hash for all the contents we've appended to the file */\n\tgit_filebuf_hash(&hash_final, file);\n\tgit_oid_cpy(checksum, &hash_final);\n\n\t/* write it at the end of the file */\n\tif (git_filebuf_write(file, hash_final.id, GIT_OID_RAWSZ) < 0)\n\t\treturn -1;\n\n\t/* file entries are no longer up to date */\n\tclear_uptodate(index);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2747-2754",
    "snippet": "static void clear_uptodate(git_index *index)\n{\n\tgit_index_entry *entry;\n\tsize_t i;\n\n\tgit_vector_foreach(&index->entries, i, entry)\n\t\tentry->flags_extended &= ~GIT_IDXENTRY_UPTODATE;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&index->entries",
            "i",
            "entry"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void clear_uptodate(git_index *index)\n{\n\tgit_index_entry *entry;\n\tsize_t i;\n\n\tgit_vector_foreach(&index->entries, i, entry)\n\t\tentry->flags_extended &= ~GIT_IDXENTRY_UPTODATE;\n}"
  },
  {
    "function_name": "write_tree_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2724-2745",
    "snippet": "static int write_tree_extension(git_index *index, git_filebuf *file)\n{\n\tstruct index_extension extension;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (index->tree == NULL)\n\t\treturn 0;\n\n\tif ((error = git_tree_cache_write(&buf, index->tree)) < 0)\n\t\treturn error;\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_TREECACHE_SIG, 4);\n\textension.extension_size = (uint32_t)buf.size;\n\n\terror = write_extension(file, &extension, &buf);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};",
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extension",
          "args": [
            "file",
            "&extension",
            "&buf"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "write_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2609-2619",
          "snippet": "static int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&extension.signature",
            "INDEX_EXT_TREECACHE_SIG",
            "4"
          ],
          "line": 2737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&extension",
            "0x0",
            "sizeof(struct index_extension)"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_cache_write",
          "args": [
            "&buf",
            "index->tree"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "264-269",
          "snippet": "int git_tree_cache_write(git_buf *out, git_tree_cache *tree)\n{\n\twrite_tree(out, tree);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_write(git_buf *out, git_tree_cache *tree)\n{\n\twrite_tree(out, tree);\n\n\treturn git_buf_oom(out) ? -1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_tree_extension(git_index *index, git_filebuf *file)\n{\n\tstruct index_extension extension;\n\tgit_buf buf = GIT_BUF_INIT;\n\tint error;\n\n\tif (index->tree == NULL)\n\t\treturn 0;\n\n\tif ((error = git_tree_cache_write(&buf, index->tree)) < 0)\n\t\treturn error;\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_TREECACHE_SIG, 4);\n\textension.extension_size = (uint32_t)buf.size;\n\n\terror = write_extension(file, &extension, &buf);\n\n\tgit_buf_free(&buf);\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_reuc_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2698-2722",
    "snippet": "static int write_reuc_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf reuc_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->reuc;\n\tgit_index_reuc_entry *reuc;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, reuc) {\n\t\tif ((error = create_reuc_extension_data(&reuc_buf, reuc)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_UNMERGED_SIG, 4);\n\textension.extension_size = (uint32_t)reuc_buf.size;\n\n\terror = write_extension(file, &extension, &reuc_buf);\n\n\tgit_buf_free(&reuc_buf);\n\ndone:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};",
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&reuc_buf"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extension",
          "args": [
            "file",
            "&extension",
            "&reuc_buf"
          ],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "write_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2609-2619",
          "snippet": "static int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&extension.signature",
            "INDEX_EXT_UNMERGED_SIG",
            "4"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&extension",
            "0x0",
            "sizeof(struct index_extension)"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_reuc_extension_data",
          "args": [
            "&reuc_buf",
            "reuc"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "create_reuc_extension_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2676-2696",
          "snippet": "static int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "out",
            "i",
            "reuc"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int write_reuc_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf reuc_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->reuc;\n\tgit_index_reuc_entry *reuc;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, reuc) {\n\t\tif ((error = create_reuc_extension_data(&reuc_buf, reuc)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_UNMERGED_SIG, 4);\n\textension.extension_size = (uint32_t)reuc_buf.size;\n\n\terror = write_extension(file, &extension, &reuc_buf);\n\n\tgit_buf_free(&reuc_buf);\n\ndone:\n\treturn error;\n}"
  },
  {
    "function_name": "create_reuc_extension_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2676-2696",
    "snippet": "static int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "reuc_buf",
            "(char *)&reuc->oid[i].id",
            "GIT_OID_RAWSZ"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "reuc_buf",
            "\"%o\"",
            "reuc->mode[i]"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "reuc->path"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int create_reuc_extension_data(git_buf *reuc_buf, git_index_reuc_entry *reuc)\n{\n\tint i;\n\tint error = 0;\n\n\tif ((error = git_buf_put(reuc_buf, reuc->path, strlen(reuc->path) + 1)) < 0)\n\t\treturn error;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif ((error = git_buf_printf(reuc_buf, \"%o\", reuc->mode[i])) < 0 ||\n\t\t\t(error = git_buf_put(reuc_buf, \"\\0\", 1)) < 0)\n\t\t\treturn error;\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tif (reuc->mode[i] && (error = git_buf_put(reuc_buf, (char *)&reuc->oid[i].id, GIT_OID_RAWSZ)) < 0)\n\t\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_name_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2650-2674",
    "snippet": "static int write_name_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf name_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->names;\n\tgit_index_name_entry *conflict_name;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, conflict_name) {\n\t\tif ((error = create_name_extension_data(&name_buf, conflict_name)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4);\n\textension.extension_size = (uint32_t)name_buf.size;\n\n\terror = write_extension(file, &extension, &name_buf);\n\n\tgit_buf_free(&name_buf);\n\ndone:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};",
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name_buf"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extension",
          "args": [
            "file",
            "&extension",
            "&name_buf"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "write_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2609-2619",
          "snippet": "static int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&extension.signature",
            "INDEX_EXT_CONFLICT_NAME_SIG",
            "4"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&extension",
            "0x0",
            "sizeof(struct index_extension)"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_name_extension_data",
          "args": [
            "&name_buf",
            "conflict_name"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "create_name_extension_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2621-2648",
          "snippet": "static int create_name_extension_data(git_buf *name_buf, git_index_name_entry *conflict_name)\n{\n\tint error = 0;\n\n\tif (conflict_name->ancestor == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ancestor, strlen(conflict_name->ancestor) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->ours == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ours, strlen(conflict_name->ours) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->theirs == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->theirs, strlen(conflict_name->theirs) + 1);\n\non_error:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_name_extension_data(git_buf *name_buf, git_index_name_entry *conflict_name)\n{\n\tint error = 0;\n\n\tif (conflict_name->ancestor == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ancestor, strlen(conflict_name->ancestor) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->ours == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ours, strlen(conflict_name->ours) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->theirs == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->theirs, strlen(conflict_name->theirs) + 1);\n\non_error:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "out",
            "i",
            "conflict_name"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_name_extension(git_index *index, git_filebuf *file)\n{\n\tgit_buf name_buf = GIT_BUF_INIT;\n\tgit_vector *out = &index->names;\n\tgit_index_name_entry *conflict_name;\n\tstruct index_extension extension;\n\tsize_t i;\n\tint error = 0;\n\n\tgit_vector_foreach(out, i, conflict_name) {\n\t\tif ((error = create_name_extension_data(&name_buf, conflict_name)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tmemset(&extension, 0x0, sizeof(struct index_extension));\n\tmemcpy(&extension.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4);\n\textension.extension_size = (uint32_t)name_buf.size;\n\n\terror = write_extension(file, &extension, &name_buf);\n\n\tgit_buf_free(&name_buf);\n\ndone:\n\treturn error;\n}"
  },
  {
    "function_name": "create_name_extension_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2621-2648",
    "snippet": "static int create_name_extension_data(git_buf *name_buf, git_index_name_entry *conflict_name)\n{\n\tint error = 0;\n\n\tif (conflict_name->ancestor == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ancestor, strlen(conflict_name->ancestor) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->ours == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ours, strlen(conflict_name->ours) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->theirs == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->theirs, strlen(conflict_name->theirs) + 1);\n\non_error:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "name_buf",
            "conflict_name->theirs",
            "strlen(conflict_name->theirs) + 1"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "conflict_name->theirs"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "conflict_name->ours"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "conflict_name->ancestor"
          ],
          "line": 2628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_name_extension_data(git_buf *name_buf, git_index_name_entry *conflict_name)\n{\n\tint error = 0;\n\n\tif (conflict_name->ancestor == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ancestor, strlen(conflict_name->ancestor) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->ours == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->ours, strlen(conflict_name->ours) + 1);\n\n\tif (error != 0)\n\t\tgoto on_error;\n\n\tif (conflict_name->theirs == NULL)\n\t\terror = git_buf_put(name_buf, \"\\0\", 1);\n\telse\n\t\terror = git_buf_put(name_buf, conflict_name->theirs, strlen(conflict_name->theirs) + 1);\n\non_error:\n\treturn error;\n}"
  },
  {
    "function_name": "write_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2609-2619",
    "snippet": "static int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "file",
            "data->ptr",
            "data->size"
          ],
          "line": 2618
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "header->extension_size"
          ],
          "line": 2615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ondisk",
            "header",
            "4"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ondisk",
            "0x0",
            "sizeof(struct index_extension)"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int write_extension(git_filebuf *file, struct index_extension *header, git_buf *data)\n{\n\tstruct index_extension ondisk;\n\n\tmemset(&ondisk, 0x0, sizeof(struct index_extension));\n\tmemcpy(&ondisk, header, 4);\n\tondisk.extension_size = htonl(header->extension_size);\n\n\tgit_filebuf_write(file, &ondisk, sizeof(struct index_extension));\n\treturn git_filebuf_write(file, data->ptr, data->size);\n}"
  },
  {
    "function_name": "write_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2582-2607",
    "snippet": "static int write_entries(git_index *index, git_filebuf *file)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_vector case_sorted, *entries;\n\tgit_index_entry *entry;\n\n\t/* If index->entries is sorted case-insensitively, then we need\n\t * to re-sort it case-sensitively before writing */\n\tif (index->ignore_case) {\n\t\tgit_vector_dup(&case_sorted, &index->entries, git_index_entry_cmp);\n\t\tgit_vector_sort(&case_sorted);\n\t\tentries = &case_sorted;\n\t} else {\n\t\tentries = &index->entries;\n\t}\n\n\tgit_vector_foreach(entries, i, entry)\n\t\tif ((error = write_disk_entry(file, entry)) < 0)\n\t\t\tbreak;\n\n\tif (index->ignore_case)\n\t\tgit_vector_free(&case_sorted);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&case_sorted"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_disk_entry",
          "args": [
            "file",
            "entry"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "write_disk_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2521-2580",
          "snippet": "static int write_disk_entry(git_filebuf *file, git_index_entry *entry)\n{\n\tvoid *mem = NULL;\n\tstruct entry_short *ondisk;\n\tsize_t path_len, disk_size;\n\tchar *path;\n\n\tpath_len = ((struct entry_internal *)entry)->pathlen;\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED)\n\t\tdisk_size = long_entry_size(path_len);\n\telse\n\t\tdisk_size = short_entry_size(path_len);\n\n\tif (git_filebuf_reserve(file, &mem, disk_size) < 0)\n\t\treturn -1;\n\n\tondisk = (struct entry_short *)mem;\n\n\tmemset(ondisk, 0x0, disk_size);\n\n\t/**\n\t * Yes, we have to truncate.\n\t *\n\t * The on-disk format for Index entries clearly defines\n\t * the time and size fields to be 4 bytes each -- so even if\n\t * we store these values with 8 bytes on-memory, they must\n\t * be truncated to 4 bytes before writing to disk.\n\t *\n\t * In 2038 I will be either too dead or too rich to care about this\n\t */\n\tondisk->ctime.seconds = htonl((uint32_t)entry->ctime.seconds);\n\tondisk->mtime.seconds = htonl((uint32_t)entry->mtime.seconds);\n\tondisk->ctime.nanoseconds = htonl(entry->ctime.nanoseconds);\n\tondisk->mtime.nanoseconds = htonl(entry->mtime.nanoseconds);\n\tondisk->dev = htonl(entry->dev);\n\tondisk->ino = htonl(entry->ino);\n\tondisk->mode = htonl(entry->mode);\n\tondisk->uid = htonl(entry->uid);\n\tondisk->gid = htonl(entry->gid);\n\tondisk->file_size = htonl((uint32_t)entry->file_size);\n\n\tgit_oid_cpy(&ondisk->oid, &entry->id);\n\n\tondisk->flags = htons(entry->flags);\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED) {\n\t\tstruct entry_long *ondisk_ext;\n\t\tondisk_ext = (struct entry_long *)ondisk;\n\t\tondisk_ext->flags_extended = htons(entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS);\n\t\tpath = ondisk_ext->path;\n\t}\n\telse\n\t\tpath = ondisk->path;\n\n\tmemcpy(path, entry->path, path_len);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int write_disk_entry(git_filebuf *file, git_index_entry *entry)\n{\n\tvoid *mem = NULL;\n\tstruct entry_short *ondisk;\n\tsize_t path_len, disk_size;\n\tchar *path;\n\n\tpath_len = ((struct entry_internal *)entry)->pathlen;\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED)\n\t\tdisk_size = long_entry_size(path_len);\n\telse\n\t\tdisk_size = short_entry_size(path_len);\n\n\tif (git_filebuf_reserve(file, &mem, disk_size) < 0)\n\t\treturn -1;\n\n\tondisk = (struct entry_short *)mem;\n\n\tmemset(ondisk, 0x0, disk_size);\n\n\t/**\n\t * Yes, we have to truncate.\n\t *\n\t * The on-disk format for Index entries clearly defines\n\t * the time and size fields to be 4 bytes each -- so even if\n\t * we store these values with 8 bytes on-memory, they must\n\t * be truncated to 4 bytes before writing to disk.\n\t *\n\t * In 2038 I will be either too dead or too rich to care about this\n\t */\n\tondisk->ctime.seconds = htonl((uint32_t)entry->ctime.seconds);\n\tondisk->mtime.seconds = htonl((uint32_t)entry->mtime.seconds);\n\tondisk->ctime.nanoseconds = htonl(entry->ctime.nanoseconds);\n\tondisk->mtime.nanoseconds = htonl(entry->mtime.nanoseconds);\n\tondisk->dev = htonl(entry->dev);\n\tondisk->ino = htonl(entry->ino);\n\tondisk->mode = htonl(entry->mode);\n\tondisk->uid = htonl(entry->uid);\n\tondisk->gid = htonl(entry->gid);\n\tondisk->file_size = htonl((uint32_t)entry->file_size);\n\n\tgit_oid_cpy(&ondisk->oid, &entry->id);\n\n\tondisk->flags = htons(entry->flags);\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED) {\n\t\tstruct entry_long *ondisk_ext;\n\t\tondisk_ext = (struct entry_long *)ondisk;\n\t\tondisk_ext->flags_extended = htons(entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS);\n\t\tpath = ondisk_ext->path;\n\t}\n\telse\n\t\tpath = ondisk->path;\n\n\tmemcpy(path, entry->path, path_len);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "entries",
            "i",
            "entry"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&case_sorted"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_dup",
          "args": [
            "&case_sorted",
            "&index->entries",
            "git_index_entry_cmp"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "50-70",
          "snippet": "int git_vector_dup(git_vector *v, const git_vector *src, git_vector_cmp cmp)\n{\n\tsize_t bytes;\n\n\tassert(v && src);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&bytes, src->length, sizeof(void *));\n\n\tv->_alloc_size = src->length;\n\tv->_cmp = cmp ? cmp : src->_cmp;\n\tv->length = src->length;\n\tv->flags  = src->flags;\n\tif (cmp != src->_cmp)\n\t\tgit_vector_set_sorted(v, 0);\n\tv->contents = git__malloc(bytes);\n\tGITERR_CHECK_ALLOC(v->contents);\n\n\tmemcpy(v->contents, src->contents, bytes);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_dup(git_vector *v, const git_vector *src, git_vector_cmp cmp)\n{\n\tsize_t bytes;\n\n\tassert(v && src);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&bytes, src->length, sizeof(void *));\n\n\tv->_alloc_size = src->length;\n\tv->_cmp = cmp ? cmp : src->_cmp;\n\tv->length = src->length;\n\tv->flags  = src->flags;\n\tif (cmp != src->_cmp)\n\t\tgit_vector_set_sorted(v, 0);\n\tv->contents = git__malloc(bytes);\n\tGITERR_CHECK_ALLOC(v->contents);\n\n\tmemcpy(v->contents, src->contents, bytes);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int write_entries(git_index *index, git_filebuf *file)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_vector case_sorted, *entries;\n\tgit_index_entry *entry;\n\n\t/* If index->entries is sorted case-insensitively, then we need\n\t * to re-sort it case-sensitively before writing */\n\tif (index->ignore_case) {\n\t\tgit_vector_dup(&case_sorted, &index->entries, git_index_entry_cmp);\n\t\tgit_vector_sort(&case_sorted);\n\t\tentries = &case_sorted;\n\t} else {\n\t\tentries = &index->entries;\n\t}\n\n\tgit_vector_foreach(entries, i, entry)\n\t\tif ((error = write_disk_entry(file, entry)) < 0)\n\t\t\tbreak;\n\n\tif (index->ignore_case)\n\t\tgit_vector_free(&case_sorted);\n\n\treturn error;\n}"
  },
  {
    "function_name": "write_disk_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2521-2580",
    "snippet": "static int write_disk_entry(git_filebuf *file, git_index_entry *entry)\n{\n\tvoid *mem = NULL;\n\tstruct entry_short *ondisk;\n\tsize_t path_len, disk_size;\n\tchar *path;\n\n\tpath_len = ((struct entry_internal *)entry)->pathlen;\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED)\n\t\tdisk_size = long_entry_size(path_len);\n\telse\n\t\tdisk_size = short_entry_size(path_len);\n\n\tif (git_filebuf_reserve(file, &mem, disk_size) < 0)\n\t\treturn -1;\n\n\tondisk = (struct entry_short *)mem;\n\n\tmemset(ondisk, 0x0, disk_size);\n\n\t/**\n\t * Yes, we have to truncate.\n\t *\n\t * The on-disk format for Index entries clearly defines\n\t * the time and size fields to be 4 bytes each -- so even if\n\t * we store these values with 8 bytes on-memory, they must\n\t * be truncated to 4 bytes before writing to disk.\n\t *\n\t * In 2038 I will be either too dead or too rich to care about this\n\t */\n\tondisk->ctime.seconds = htonl((uint32_t)entry->ctime.seconds);\n\tondisk->mtime.seconds = htonl((uint32_t)entry->mtime.seconds);\n\tondisk->ctime.nanoseconds = htonl(entry->ctime.nanoseconds);\n\tondisk->mtime.nanoseconds = htonl(entry->mtime.nanoseconds);\n\tondisk->dev = htonl(entry->dev);\n\tondisk->ino = htonl(entry->ino);\n\tondisk->mode = htonl(entry->mode);\n\tondisk->uid = htonl(entry->uid);\n\tondisk->gid = htonl(entry->gid);\n\tondisk->file_size = htonl((uint32_t)entry->file_size);\n\n\tgit_oid_cpy(&ondisk->oid, &entry->id);\n\n\tondisk->flags = htons(entry->flags);\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED) {\n\t\tstruct entry_long *ondisk_ext;\n\t\tondisk_ext = (struct entry_long *)ondisk;\n\t\tondisk_ext->flags_extended = htons(entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS);\n\t\tpath = ondisk_ext->path;\n\t}\n\telse\n\t\tpath = ondisk->path;\n\n\tmemcpy(path, entry->path, path_len);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "path",
            "entry->path",
            "path_len"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "entry->flags"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ondisk->oid",
            "&entry->id"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t)entry->file_size"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->gid"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->uid"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->mode"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->ino"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->dev"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->mtime.nanoseconds"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "entry->ctime.nanoseconds"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t)entry->mtime.seconds"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(uint32_t)entry->ctime.seconds"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ondisk",
            "0x0",
            "disk_size"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_filebuf_reserve",
          "args": [
            "file",
            "&mem",
            "disk_size"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "478-500",
          "snippet": "int git_filebuf_reserve(git_filebuf *file, void **buffer, size_t len)\n{\n\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t*buffer = NULL;\n\n\tENSURE_BUF_OK(file);\n\n\tif (len > file->buf_size) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tif (space_left <= len) {\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*buffer = (file->buffer + file->buf_pos);\n\tfile->buf_pos += len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_reserve(git_filebuf *file, void **buffer, size_t len)\n{\n\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t*buffer = NULL;\n\n\tENSURE_BUF_OK(file);\n\n\tif (len > file->buf_size) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tif (space_left <= len) {\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\t}\n\n\t*buffer = (file->buffer + file->buf_pos);\n\tfile->buf_pos += len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "short_entry_size",
          "args": [
            "path_len"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "long_entry_size",
          "args": [
            "path_len"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int write_disk_entry(git_filebuf *file, git_index_entry *entry)\n{\n\tvoid *mem = NULL;\n\tstruct entry_short *ondisk;\n\tsize_t path_len, disk_size;\n\tchar *path;\n\n\tpath_len = ((struct entry_internal *)entry)->pathlen;\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED)\n\t\tdisk_size = long_entry_size(path_len);\n\telse\n\t\tdisk_size = short_entry_size(path_len);\n\n\tif (git_filebuf_reserve(file, &mem, disk_size) < 0)\n\t\treturn -1;\n\n\tondisk = (struct entry_short *)mem;\n\n\tmemset(ondisk, 0x0, disk_size);\n\n\t/**\n\t * Yes, we have to truncate.\n\t *\n\t * The on-disk format for Index entries clearly defines\n\t * the time and size fields to be 4 bytes each -- so even if\n\t * we store these values with 8 bytes on-memory, they must\n\t * be truncated to 4 bytes before writing to disk.\n\t *\n\t * In 2038 I will be either too dead or too rich to care about this\n\t */\n\tondisk->ctime.seconds = htonl((uint32_t)entry->ctime.seconds);\n\tondisk->mtime.seconds = htonl((uint32_t)entry->mtime.seconds);\n\tondisk->ctime.nanoseconds = htonl(entry->ctime.nanoseconds);\n\tondisk->mtime.nanoseconds = htonl(entry->mtime.nanoseconds);\n\tondisk->dev = htonl(entry->dev);\n\tondisk->ino = htonl(entry->ino);\n\tondisk->mode = htonl(entry->mode);\n\tondisk->uid = htonl(entry->uid);\n\tondisk->gid = htonl(entry->gid);\n\tondisk->file_size = htonl((uint32_t)entry->file_size);\n\n\tgit_oid_cpy(&ondisk->oid, &entry->id);\n\n\tondisk->flags = htons(entry->flags);\n\n\tif (entry->flags & GIT_IDXENTRY_EXTENDED) {\n\t\tstruct entry_long *ondisk_ext;\n\t\tondisk_ext = (struct entry_long *)ondisk;\n\t\tondisk_ext->flags_extended = htons(entry->flags_extended &\n\t\t\tGIT_IDXENTRY_EXTENDED_FLAGS);\n\t\tpath = ondisk_ext->path;\n\t}\n\telse\n\t\tpath = ondisk->path;\n\n\tmemcpy(path, entry->path, path_len);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_index_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2503-2519",
    "snippet": "static bool is_index_extended(git_index *index)\n{\n\tsize_t i, extended;\n\tgit_index_entry *entry;\n\n\textended = 0;\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tentry->flags &= ~GIT_IDXENTRY_EXTENDED;\n\t\tif (entry->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tentry->flags |= GIT_IDXENTRY_EXTENDED;\n\t\t}\n\t}\n\n\treturn (extended > 0);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&index->entries",
            "i",
            "entry"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic bool is_index_extended(git_index *index)\n{\n\tsize_t i, extended;\n\tgit_index_entry *entry;\n\n\textended = 0;\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tentry->flags &= ~GIT_IDXENTRY_EXTENDED;\n\t\tif (entry->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS) {\n\t\t\textended++;\n\t\t\tentry->flags |= GIT_IDXENTRY_EXTENDED;\n\t\t}\n\t}\n\n\treturn (extended > 0);\n}"
  },
  {
    "function_name": "parse_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2392-2501",
    "snippet": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tkh_resize(idx, index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;",
      "static const size_t INDEX_HEADER_SIZE = 12;",
      "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);",
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_sorted",
          "args": [
            "&index->entries",
            "!index->ignore_case"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&index->checksum",
            "&checksum_calculated"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_error_invalid",
          "args": [
            "\"calculated checksum does not match expected\""
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "index_error_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2127-2131",
          "snippet": "static int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&checksum_calculated",
            "&checksum_expected"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "&checksum_expected",
            "(const unsigned char *)buffer"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "extension_size"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extension",
          "args": [
            "index",
            "buffer",
            "buffer_size"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "read_extension",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2352-2390",
          "snippet": "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tstruct index_extension dest;\n\tsize_t total_size;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&dest, buffer, sizeof(struct index_extension));\n\tdest.extension_size = ntohl(dest.extension_size);\n\n\ttotal_size = dest.extension_size + sizeof(struct index_extension);\n\n\tif (dest.extension_size > total_size ||\n\t\tbuffer_size < total_size ||\n\t\tbuffer_size - total_size < INDEX_FOOTER_SIZE)\n\t\treturn 0;\n\n\t/* optional extension */\n\tif (dest.signature[0] >= 'A' && dest.signature[0] <= 'Z') {\n\t\t/* tree cache */\n\t\tif (memcmp(dest.signature, INDEX_EXT_TREECACHE_SIG, 4) == 0) {\n\t\t\tif (git_tree_cache_read(&index->tree, buffer + 8, dest.extension_size, &index->tree_pool) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_UNMERGED_SIG, 4) == 0) {\n\t\t\tif (read_reuc(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4) == 0) {\n\t\t\tif (read_conflict_names(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* else, unsupported extension. We cannot parse this, but we can skip\n\t\t * it by returning `total_size */\n\t} else {\n\t\t/* we cannot handle non-ignorable extensions;\n\t\t * in fact they aren't even defined in the standard */\n\t\treturn 0;\n\t}\n\n\treturn total_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;",
            "static const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};",
            "static const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};",
            "static const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};",
            "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);",
            "static int read_header(struct index_header *dest, const void *buffer);",
            "static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};\nstatic const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};\nstatic const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\n\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tstruct index_extension dest;\n\tsize_t total_size;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&dest, buffer, sizeof(struct index_extension));\n\tdest.extension_size = ntohl(dest.extension_size);\n\n\ttotal_size = dest.extension_size + sizeof(struct index_extension);\n\n\tif (dest.extension_size > total_size ||\n\t\tbuffer_size < total_size ||\n\t\tbuffer_size - total_size < INDEX_FOOTER_SIZE)\n\t\treturn 0;\n\n\t/* optional extension */\n\tif (dest.signature[0] >= 'A' && dest.signature[0] <= 'Z') {\n\t\t/* tree cache */\n\t\tif (memcmp(dest.signature, INDEX_EXT_TREECACHE_SIG, 4) == 0) {\n\t\t\tif (git_tree_cache_read(&index->tree, buffer + 8, dest.extension_size, &index->tree_pool) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_UNMERGED_SIG, 4) == 0) {\n\t\t\tif (read_reuc(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4) == 0) {\n\t\t\tif (read_conflict_names(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* else, unsupported extension. We cannot parse this, but we can skip\n\t\t * it by returning `total_size */\n\t} else {\n\t\t/* we cannot handle non-ignorable extensions;\n\t\t * in fact they aren't even defined in the standard */\n\t\treturn 0;\n\t}\n\n\treturn total_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "entry_size"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entry"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSERT_IN_MAP",
          "args": [
            "index",
            "entry",
            "error"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&index->entries",
            "entry"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_entry",
          "args": [
            "&entry",
            "index",
            "buffer",
            "buffer_size"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "read_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2261-2333",
          "snippet": "static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t/* if this is a very long string, we must find its\n\t * real length without overflowing */\n\tif (path_length == 0xFFF) {\n\t\tconst char *path_end;\n\n\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\tif (path_end == NULL)\n\t\t\treturn 0;\n\n\t\tpath_length = path_end - path_ptr;\n\t}\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED)\n\t\tentry_size = long_entry_size(path_length);\n\telse\n\t\tentry_size = short_entry_size(path_length);\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tentry.path = (char *)path_ptr;\n\n\tif (index_entry_dup(out, index, &entry) < 0)\n\t\treturn 0;\n\n\treturn entry_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [
            "#define minimal_entry_size (offsetof(struct entry_short, path))"
          ],
          "globals_used": [
            "static const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;",
            "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);",
            "static int read_header(struct index_header *dest, const void *buffer);",
            "static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\n#define minimal_entry_size (offsetof(struct entry_short, path))\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t/* if this is a very long string, we must find its\n\t * real length without overflowing */\n\tif (path_length == 0xFFF) {\n\t\tconst char *path_end;\n\n\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\tif (path_end == NULL)\n\t\t\treturn 0;\n\n\t\tpath_length = path_end - path_ptr;\n\t}\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED)\n\t\tentry_size = long_entry_size(path_length);\n\telse\n\t\tentry_size = short_entry_size(path_length);\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tentry.path = (char *)path_ptr;\n\n\tif (index_entry_dup(out, index, &entry) < 0)\n\t\treturn 0;\n\n\treturn entry_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kh_resize",
          "args": [
            "idx",
            "index->entries_map",
            "header.entry_count"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kh_resize",
          "args": [
            "idxicase",
            "(khash_t(idxicase) *) index->entries_map",
            "header.entry_count"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!index->entries.length"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "INDEX_HEADER_SIZE"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_header",
          "args": [
            "&header",
            "buffer"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "read_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2335-2350",
          "snippet": "static int read_header(struct index_header *dest, const void *buffer)\n{\n\tconst struct index_header *source = buffer;\n\n\tdest->signature = ntohl(source->signature);\n\tif (dest->signature != INDEX_HEADER_SIG)\n\t\treturn index_error_invalid(\"incorrect header signature\");\n\n\tdest->version = ntohl(source->version);\n\tif (dest->version != INDEX_VERSION_NUMBER_EXT &&\n\t\tdest->version != INDEX_VERSION_NUMBER)\n\t\treturn index_error_invalid(\"incorrect header version\");\n\n\tdest->entry_count = ntohl(source->entry_count);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int INDEX_VERSION_NUMBER = 2;",
            "static const unsigned int INDEX_VERSION_NUMBER_EXT = 3;",
            "static const unsigned int INDEX_HEADER_SIG = 0x44495243;",
            "static int read_header(struct index_header *dest, const void *buffer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const unsigned int INDEX_VERSION_NUMBER = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_EXT = 3;\nstatic const unsigned int INDEX_HEADER_SIG = 0x44495243;\nstatic int read_header(struct index_header *dest, const void *buffer);\n\nstatic int read_header(struct index_header *dest, const void *buffer)\n{\n\tconst struct index_header *source = buffer;\n\n\tdest->signature = ntohl(source->signature);\n\tif (dest->signature != INDEX_HEADER_SIG)\n\t\treturn index_error_invalid(\"incorrect header signature\");\n\n\tdest->version = ntohl(source->version);\n\tif (dest->version != INDEX_VERSION_NUMBER_EXT &&\n\t\tdest->version != INDEX_VERSION_NUMBER)\n\t\treturn index_error_invalid(\"incorrect header version\");\n\n\tdest->entry_count = ntohl(source->entry_count);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_buf",
          "args": [
            "&checksum_calculated",
            "buffer",
            "buffer_size - INDEX_FOOTER_SIZE"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash.c",
          "lines": "11-25",
          "snippet": "int git_hash_buf(git_oid *out, const void *data, size_t len)\n{\n\tgit_hash_ctx ctx;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tif ((error = git_hash_update(&ctx, data, len)) >= 0)\n\t\terror = git_hash_final(out, &ctx);\n\n\tgit_hash_ctx_cleanup(&ctx);\n\t\n\treturn error;\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"common.h\"\n\nint git_hash_buf(git_oid *out, const void *data, size_t len)\n{\n\tgit_hash_ctx ctx;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tif ((error = git_hash_update(&ctx, data, len)) >= 0)\n\t\terror = git_hash_final(out, &ctx);\n\n\tgit_hash_ctx_cleanup(&ctx);\n\t\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic const size_t INDEX_HEADER_SIZE = 12;\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tkh_resize(idx, index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}"
  },
  {
    "function_name": "read_extension",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2352-2390",
    "snippet": "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tstruct index_extension dest;\n\tsize_t total_size;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&dest, buffer, sizeof(struct index_extension));\n\tdest.extension_size = ntohl(dest.extension_size);\n\n\ttotal_size = dest.extension_size + sizeof(struct index_extension);\n\n\tif (dest.extension_size > total_size ||\n\t\tbuffer_size < total_size ||\n\t\tbuffer_size - total_size < INDEX_FOOTER_SIZE)\n\t\treturn 0;\n\n\t/* optional extension */\n\tif (dest.signature[0] >= 'A' && dest.signature[0] <= 'Z') {\n\t\t/* tree cache */\n\t\tif (memcmp(dest.signature, INDEX_EXT_TREECACHE_SIG, 4) == 0) {\n\t\t\tif (git_tree_cache_read(&index->tree, buffer + 8, dest.extension_size, &index->tree_pool) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_UNMERGED_SIG, 4) == 0) {\n\t\t\tif (read_reuc(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4) == 0) {\n\t\t\tif (read_conflict_names(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* else, unsupported extension. We cannot parse this, but we can skip\n\t\t * it by returning `total_size */\n\t} else {\n\t\t/* we cannot handle non-ignorable extensions;\n\t\t * in fact they aren't even defined in the standard */\n\t\treturn 0;\n\t}\n\n\treturn total_size;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;",
      "static const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};",
      "static const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};",
      "static const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};",
      "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);",
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_conflict_names",
          "args": [
            "index",
            "buffer + 8",
            "dest.extension_size"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "read_conflict_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2206-2259",
          "snippet": "static int read_conflict_names(git_index *index, const char *buffer, size_t size)\n{\n\tsize_t len;\n\n\t/* This gets called multiple times, the vector might already be initialized */\n\tif (index->names._alloc_size == 0 &&\n\t\tgit_vector_init(&index->names, 16, conflict_name_cmp) < 0)\n\t\treturn -1;\n\n#define read_conflict_name(ptr) \\\n\tlen = p_strnlen(buffer, size) + 1; \\\n\tif (size < len) { \\\n\t\tindex_error_invalid(\"reading conflict name entries\"); \\\n\t\tgoto out_err; \\\n\t} \\\n\tif (len == 1) \\\n\t\tptr = NULL; \\\n\telse { \\\n\t\tptr = git__malloc(len); \\\n\t\tGITERR_CHECK_ALLOC(ptr); \\\n\t\tmemcpy(ptr, buffer, len); \\\n\t} \\\n\t\\\n\tbuffer += len; \\\n\tsize -= len;\n\n\twhile (size) {\n\t\tgit_index_name_entry *conflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\t\tGITERR_CHECK_ALLOC(conflict_name);\n\n\t\tread_conflict_name(conflict_name->ancestor);\n\t\tread_conflict_name(conflict_name->ours);\n\t\tread_conflict_name(conflict_name->theirs);\n\n\t\tif (git_vector_insert(&index->names, conflict_name) < 0)\n\t\t\tgoto out_err;\n\n\t\tcontinue;\n\nout_err:\n\t\tgit__free(conflict_name->ancestor);\n\t\tgit__free(conflict_name->ours);\n\t\tgit__free(conflict_name->theirs);\n\t\tgit__free(conflict_name);\n\t\treturn -1;\n\t}\n\n#undef read_conflict_name\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->names, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_header(struct index_header *dest, const void *buffer);",
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic bool is_index_extended(git_index *index);\n\nstatic int read_conflict_names(git_index *index, const char *buffer, size_t size)\n{\n\tsize_t len;\n\n\t/* This gets called multiple times, the vector might already be initialized */\n\tif (index->names._alloc_size == 0 &&\n\t\tgit_vector_init(&index->names, 16, conflict_name_cmp) < 0)\n\t\treturn -1;\n\n#define read_conflict_name(ptr) \\\n\tlen = p_strnlen(buffer, size) + 1; \\\n\tif (size < len) { \\\n\t\tindex_error_invalid(\"reading conflict name entries\"); \\\n\t\tgoto out_err; \\\n\t} \\\n\tif (len == 1) \\\n\t\tptr = NULL; \\\n\telse { \\\n\t\tptr = git__malloc(len); \\\n\t\tGITERR_CHECK_ALLOC(ptr); \\\n\t\tmemcpy(ptr, buffer, len); \\\n\t} \\\n\t\\\n\tbuffer += len; \\\n\tsize -= len;\n\n\twhile (size) {\n\t\tgit_index_name_entry *conflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\t\tGITERR_CHECK_ALLOC(conflict_name);\n\n\t\tread_conflict_name(conflict_name->ancestor);\n\t\tread_conflict_name(conflict_name->ours);\n\t\tread_conflict_name(conflict_name->theirs);\n\n\t\tif (git_vector_insert(&index->names, conflict_name) < 0)\n\t\t\tgoto out_err;\n\n\t\tcontinue;\n\nout_err:\n\t\tgit__free(conflict_name->ancestor);\n\t\tgit__free(conflict_name->ours);\n\t\tgit__free(conflict_name->theirs);\n\t\tgit__free(conflict_name);\n\t\treturn -1;\n\t}\n\n#undef read_conflict_name\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->names, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dest.signature",
            "INDEX_EXT_CONFLICT_NAME_SIG",
            "4"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_reuc",
          "args": [
            "index",
            "buffer + 8",
            "dest.extension_size"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "read_reuc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2133-2203",
          "snippet": "static int read_reuc(git_index *index, const char *buffer, size_t size)\n{\n\tconst char *endptr;\n\tsize_t len;\n\tint i;\n\n\t/* If called multiple times, the vector might already be initialized */\n\tif (index->reuc._alloc_size == 0 &&\n\t\tgit_vector_init(&index->reuc, 16, reuc_cmp) < 0)\n\t\treturn -1;\n\n\twhile (size) {\n\t\tgit_index_reuc_entry *lost;\n\n\t\tlen = p_strnlen(buffer, size) + 1;\n\t\tif (size <= len)\n\t\t\treturn index_error_invalid(\"reading reuc entries\");\n\n\t\tlost = reuc_entry_alloc(buffer);\n\t\tGITERR_CHECK_ALLOC(lost);\n\n\t\tsize -= len;\n\t\tbuffer += len;\n\n\t\t/* read 3 ASCII octal numbers for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint64_t tmp;\n\n\t\t\tif (git__strtol64(&tmp, buffer, &endptr, 8) < 0 ||\n\t\t\t\t!endptr || endptr == buffer || *endptr ||\n\t\t\t\ttmp < 0) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tlost->mode[i] = tmp;\n\n\t\t\tlen = (endptr + 1) - buffer;\n\t\t\tif (size <= len) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tbuffer += len;\n\t\t}\n\n\t\t/* read up to 3 OIDs for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!lost->mode[i])\n\t\t\t\tcontinue;\n\t\t\tif (size < 20) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry oid\");\n\t\t\t}\n\n\t\t\tgit_oid_fromraw(&lost->oid[i], (const unsigned char *) buffer);\n\t\t\tsize -= 20;\n\t\t\tbuffer += 20;\n\t\t}\n\n\t\t/* entry was read successfully - insert into reuc vector */\n\t\tif (git_vector_insert(&index->reuc, lost) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->reuc, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int read_header(struct index_header *dest, const void *buffer);",
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int read_reuc(git_index *index, const char *buffer, size_t size)\n{\n\tconst char *endptr;\n\tsize_t len;\n\tint i;\n\n\t/* If called multiple times, the vector might already be initialized */\n\tif (index->reuc._alloc_size == 0 &&\n\t\tgit_vector_init(&index->reuc, 16, reuc_cmp) < 0)\n\t\treturn -1;\n\n\twhile (size) {\n\t\tgit_index_reuc_entry *lost;\n\n\t\tlen = p_strnlen(buffer, size) + 1;\n\t\tif (size <= len)\n\t\t\treturn index_error_invalid(\"reading reuc entries\");\n\n\t\tlost = reuc_entry_alloc(buffer);\n\t\tGITERR_CHECK_ALLOC(lost);\n\n\t\tsize -= len;\n\t\tbuffer += len;\n\n\t\t/* read 3 ASCII octal numbers for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint64_t tmp;\n\n\t\t\tif (git__strtol64(&tmp, buffer, &endptr, 8) < 0 ||\n\t\t\t\t!endptr || endptr == buffer || *endptr ||\n\t\t\t\ttmp < 0) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tlost->mode[i] = tmp;\n\n\t\t\tlen = (endptr + 1) - buffer;\n\t\t\tif (size <= len) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tbuffer += len;\n\t\t}\n\n\t\t/* read up to 3 OIDs for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!lost->mode[i])\n\t\t\t\tcontinue;\n\t\t\tif (size < 20) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry oid\");\n\t\t\t}\n\n\t\t\tgit_oid_fromraw(&lost->oid[i], (const unsigned char *) buffer);\n\t\t\tsize -= 20;\n\t\t\tbuffer += 20;\n\t\t}\n\n\t\t/* entry was read successfully - insert into reuc vector */\n\t\tif (git_vector_insert(&index->reuc, lost) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->reuc, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dest.signature",
            "INDEX_EXT_UNMERGED_SIG",
            "4"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_cache_read",
          "args": [
            "&index->tree",
            "buffer + 8",
            "dest.extension_size",
            "&index->tree_pool"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "144-157",
          "snippet": "int git_tree_cache_read(git_tree_cache **tree, const char *buffer, size_t buffer_size, git_pool *pool)\n{\n\tconst char *buffer_end = buffer + buffer_size;\n\n\tif (read_tree_internal(tree, &buffer, buffer_end, pool) < 0)\n\t\treturn -1;\n\n\tif (buffer < buffer_end) {\n\t\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index (unexpected trailing data)\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nint git_tree_cache_read(git_tree_cache **tree, const char *buffer, size_t buffer_size, git_pool *pool)\n{\n\tconst char *buffer_end = buffer + buffer_size;\n\n\tif (read_tree_internal(tree, &buffer, buffer_end, pool) < 0)\n\t\treturn -1;\n\n\tif (buffer < buffer_end) {\n\t\tgiterr_set(GITERR_INDEX, \"Corrupted TREE extension in index (unexpected trailing data)\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dest.signature",
            "INDEX_EXT_TREECACHE_SIG",
            "4"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "dest.extension_size"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest",
            "buffer",
            "sizeof(struct index_extension)"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic const char INDEX_EXT_TREECACHE_SIG[] = {'T', 'R', 'E', 'E'};\nstatic const char INDEX_EXT_UNMERGED_SIG[] = {'R', 'E', 'U', 'C'};\nstatic const char INDEX_EXT_CONFLICT_NAME_SIG[] = {'N', 'A', 'M', 'E'};\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\n\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tstruct index_extension dest;\n\tsize_t total_size;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&dest, buffer, sizeof(struct index_extension));\n\tdest.extension_size = ntohl(dest.extension_size);\n\n\ttotal_size = dest.extension_size + sizeof(struct index_extension);\n\n\tif (dest.extension_size > total_size ||\n\t\tbuffer_size < total_size ||\n\t\tbuffer_size - total_size < INDEX_FOOTER_SIZE)\n\t\treturn 0;\n\n\t/* optional extension */\n\tif (dest.signature[0] >= 'A' && dest.signature[0] <= 'Z') {\n\t\t/* tree cache */\n\t\tif (memcmp(dest.signature, INDEX_EXT_TREECACHE_SIG, 4) == 0) {\n\t\t\tif (git_tree_cache_read(&index->tree, buffer + 8, dest.extension_size, &index->tree_pool) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_UNMERGED_SIG, 4) == 0) {\n\t\t\tif (read_reuc(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t} else if (memcmp(dest.signature, INDEX_EXT_CONFLICT_NAME_SIG, 4) == 0) {\n\t\t\tif (read_conflict_names(index, buffer + 8, dest.extension_size) < 0)\n\t\t\t\treturn 0;\n\t\t}\n\t\t/* else, unsupported extension. We cannot parse this, but we can skip\n\t\t * it by returning `total_size */\n\t} else {\n\t\t/* we cannot handle non-ignorable extensions;\n\t\t * in fact they aren't even defined in the standard */\n\t\treturn 0;\n\t}\n\n\treturn total_size;\n}"
  },
  {
    "function_name": "read_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2335-2350",
    "snippet": "static int read_header(struct index_header *dest, const void *buffer)\n{\n\tconst struct index_header *source = buffer;\n\n\tdest->signature = ntohl(source->signature);\n\tif (dest->signature != INDEX_HEADER_SIG)\n\t\treturn index_error_invalid(\"incorrect header signature\");\n\n\tdest->version = ntohl(source->version);\n\tif (dest->version != INDEX_VERSION_NUMBER_EXT &&\n\t\tdest->version != INDEX_VERSION_NUMBER)\n\t\treturn index_error_invalid(\"incorrect header version\");\n\n\tdest->entry_count = ntohl(source->entry_count);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int INDEX_VERSION_NUMBER = 2;",
      "static const unsigned int INDEX_VERSION_NUMBER_EXT = 3;",
      "static const unsigned int INDEX_HEADER_SIG = 0x44495243;",
      "static int read_header(struct index_header *dest, const void *buffer);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source->entry_count"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_error_invalid",
          "args": [
            "\"incorrect header version\""
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "index_error_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2127-2131",
          "snippet": "static int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source->version"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source->signature"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const unsigned int INDEX_VERSION_NUMBER = 2;\nstatic const unsigned int INDEX_VERSION_NUMBER_EXT = 3;\nstatic const unsigned int INDEX_HEADER_SIG = 0x44495243;\nstatic int read_header(struct index_header *dest, const void *buffer);\n\nstatic int read_header(struct index_header *dest, const void *buffer)\n{\n\tconst struct index_header *source = buffer;\n\n\tdest->signature = ntohl(source->signature);\n\tif (dest->signature != INDEX_HEADER_SIG)\n\t\treturn index_error_invalid(\"incorrect header signature\");\n\n\tdest->version = ntohl(source->version);\n\tif (dest->version != INDEX_VERSION_NUMBER_EXT &&\n\t\tdest->version != INDEX_VERSION_NUMBER)\n\t\treturn index_error_invalid(\"incorrect header version\");\n\n\tdest->entry_count = ntohl(source->entry_count);\n\treturn 0;\n}"
  },
  {
    "function_name": "read_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2261-2333",
    "snippet": "static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t/* if this is a very long string, we must find its\n\t * real length without overflowing */\n\tif (path_length == 0xFFF) {\n\t\tconst char *path_end;\n\n\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\tif (path_end == NULL)\n\t\t\treturn 0;\n\n\t\tpath_length = path_end - path_ptr;\n\t}\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED)\n\t\tentry_size = long_entry_size(path_length);\n\telse\n\t\tentry_size = short_entry_size(path_length);\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tentry.path = (char *)path_ptr;\n\n\tif (index_entry_dup(out, index, &entry) < 0)\n\t\treturn 0;\n\n\treturn entry_size;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [
      "#define minimal_entry_size (offsetof(struct entry_short, path))"
    ],
    "globals_used": [
      "static const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;",
      "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);",
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_dup",
          "args": [
            "out",
            "index",
            "&entry"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1016-1026",
          "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "short_entry_size",
          "args": [
            "path_length"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "long_entry_size",
          "args": [
            "path_length"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "path_ptr",
            "'\\0'",
            "buffer_size"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&entry.flags_extended",
            "&flags_raw",
            "sizeof(flags_raw)"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "flags_raw"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&flags_raw",
            "(const char *) buffer + flags_offset",
            "sizeof(flags_raw)"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "source.flags"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry.id",
            "&source.oid"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.file_size"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.gid"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.uid"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.mode"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.ino"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.dev"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.mtime.nanoseconds"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.mtime.seconds"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.ctime.nanoseconds"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "source.ctime.seconds"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&source",
            "buffer",
            "sizeof(struct entry_short)"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\n#define minimal_entry_size (offsetof(struct entry_short, path))\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t/* if this is a very long string, we must find its\n\t * real length without overflowing */\n\tif (path_length == 0xFFF) {\n\t\tconst char *path_end;\n\n\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\tif (path_end == NULL)\n\t\t\treturn 0;\n\n\t\tpath_length = path_end - path_ptr;\n\t}\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED)\n\t\tentry_size = long_entry_size(path_length);\n\telse\n\t\tentry_size = short_entry_size(path_length);\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tentry.path = (char *)path_ptr;\n\n\tif (index_entry_dup(out, index, &entry) < 0)\n\t\treturn 0;\n\n\treturn entry_size;\n}"
  },
  {
    "function_name": "read_conflict_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2206-2259",
    "snippet": "static int read_conflict_names(git_index *index, const char *buffer, size_t size)\n{\n\tsize_t len;\n\n\t/* This gets called multiple times, the vector might already be initialized */\n\tif (index->names._alloc_size == 0 &&\n\t\tgit_vector_init(&index->names, 16, conflict_name_cmp) < 0)\n\t\treturn -1;\n\n#define read_conflict_name(ptr) \\\n\tlen = p_strnlen(buffer, size) + 1; \\\n\tif (size < len) { \\\n\t\tindex_error_invalid(\"reading conflict name entries\"); \\\n\t\tgoto out_err; \\\n\t} \\\n\tif (len == 1) \\\n\t\tptr = NULL; \\\n\telse { \\\n\t\tptr = git__malloc(len); \\\n\t\tGITERR_CHECK_ALLOC(ptr); \\\n\t\tmemcpy(ptr, buffer, len); \\\n\t} \\\n\t\\\n\tbuffer += len; \\\n\tsize -= len;\n\n\twhile (size) {\n\t\tgit_index_name_entry *conflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\t\tGITERR_CHECK_ALLOC(conflict_name);\n\n\t\tread_conflict_name(conflict_name->ancestor);\n\t\tread_conflict_name(conflict_name->ours);\n\t\tread_conflict_name(conflict_name->theirs);\n\n\t\tif (git_vector_insert(&index->names, conflict_name) < 0)\n\t\t\tgoto out_err;\n\n\t\tcontinue;\n\nout_err:\n\t\tgit__free(conflict_name->ancestor);\n\t\tgit__free(conflict_name->ours);\n\t\tgit__free(conflict_name->theirs);\n\t\tgit__free(conflict_name);\n\t\treturn -1;\n\t}\n\n#undef read_conflict_name\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->names, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_set_sorted",
          "args": [
            "&index->names",
            "true"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "conflict_name"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&index->names",
            "conflict_name"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_conflict_name",
          "args": [
            "conflict_name->theirs"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_conflict_name",
          "args": [
            "conflict_name->ours"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_conflict_name",
          "args": [
            "conflict_name->ancestor"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "conflict_name"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_index_name_entry)"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&index->names",
            "16",
            "conflict_name_cmp"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic bool is_index_extended(git_index *index);\n\nstatic int read_conflict_names(git_index *index, const char *buffer, size_t size)\n{\n\tsize_t len;\n\n\t/* This gets called multiple times, the vector might already be initialized */\n\tif (index->names._alloc_size == 0 &&\n\t\tgit_vector_init(&index->names, 16, conflict_name_cmp) < 0)\n\t\treturn -1;\n\n#define read_conflict_name(ptr) \\\n\tlen = p_strnlen(buffer, size) + 1; \\\n\tif (size < len) { \\\n\t\tindex_error_invalid(\"reading conflict name entries\"); \\\n\t\tgoto out_err; \\\n\t} \\\n\tif (len == 1) \\\n\t\tptr = NULL; \\\n\telse { \\\n\t\tptr = git__malloc(len); \\\n\t\tGITERR_CHECK_ALLOC(ptr); \\\n\t\tmemcpy(ptr, buffer, len); \\\n\t} \\\n\t\\\n\tbuffer += len; \\\n\tsize -= len;\n\n\twhile (size) {\n\t\tgit_index_name_entry *conflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\t\tGITERR_CHECK_ALLOC(conflict_name);\n\n\t\tread_conflict_name(conflict_name->ancestor);\n\t\tread_conflict_name(conflict_name->ours);\n\t\tread_conflict_name(conflict_name->theirs);\n\n\t\tif (git_vector_insert(&index->names, conflict_name) < 0)\n\t\t\tgoto out_err;\n\n\t\tcontinue;\n\nout_err:\n\t\tgit__free(conflict_name->ancestor);\n\t\tgit__free(conflict_name->ours);\n\t\tgit__free(conflict_name->theirs);\n\t\tgit__free(conflict_name);\n\t\treturn -1;\n\t}\n\n#undef read_conflict_name\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->names, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "read_reuc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2133-2203",
    "snippet": "static int read_reuc(git_index *index, const char *buffer, size_t size)\n{\n\tconst char *endptr;\n\tsize_t len;\n\tint i;\n\n\t/* If called multiple times, the vector might already be initialized */\n\tif (index->reuc._alloc_size == 0 &&\n\t\tgit_vector_init(&index->reuc, 16, reuc_cmp) < 0)\n\t\treturn -1;\n\n\twhile (size) {\n\t\tgit_index_reuc_entry *lost;\n\n\t\tlen = p_strnlen(buffer, size) + 1;\n\t\tif (size <= len)\n\t\t\treturn index_error_invalid(\"reading reuc entries\");\n\n\t\tlost = reuc_entry_alloc(buffer);\n\t\tGITERR_CHECK_ALLOC(lost);\n\n\t\tsize -= len;\n\t\tbuffer += len;\n\n\t\t/* read 3 ASCII octal numbers for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint64_t tmp;\n\n\t\t\tif (git__strtol64(&tmp, buffer, &endptr, 8) < 0 ||\n\t\t\t\t!endptr || endptr == buffer || *endptr ||\n\t\t\t\ttmp < 0) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tlost->mode[i] = tmp;\n\n\t\t\tlen = (endptr + 1) - buffer;\n\t\t\tif (size <= len) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tbuffer += len;\n\t\t}\n\n\t\t/* read up to 3 OIDs for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!lost->mode[i])\n\t\t\t\tcontinue;\n\t\t\tif (size < 20) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry oid\");\n\t\t\t}\n\n\t\t\tgit_oid_fromraw(&lost->oid[i], (const unsigned char *) buffer);\n\t\t\tsize -= 20;\n\t\t\tbuffer += 20;\n\t\t}\n\n\t\t/* entry was read successfully - insert into reuc vector */\n\t\tif (git_vector_insert(&index->reuc, lost) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->reuc, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_set_sorted",
          "args": [
            "&index->reuc",
            "true"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&index->reuc",
            "lost"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromraw",
          "args": [
            "&lost->oid[i]",
            "(const unsigned char *) buffer"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "169-172",
          "snippet": "void git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fromraw(git_oid *out, const unsigned char *raw)\n{\n\tmemcpy(out->id, raw, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_error_invalid",
          "args": [
            "\"reading reuc entry oid\""
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "index_error_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2127-2131",
          "snippet": "static int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_reuc_free",
          "args": [
            "lost"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_reuc_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "320-323",
          "snippet": "static void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strtol64",
          "args": [
            "&tmp",
            "buffer",
            "&endptr",
            "8"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "git__strtol64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "67-147",
          "snippet": "int git__strtol64(int64_t *result, const char *nptr, const char **endptr, int base)\n{\n\tconst char *p;\n\tint64_t n, nn;\n\tint c, ovfl, v, neg, ndig;\n\n\tp = nptr;\n\tneg = 0;\n\tn = 0;\n\tndig = 0;\n\tovfl = 0;\n\n\t/*\n\t * White space\n\t */\n\twhile (git__isspace(*p))\n\t\tp++;\n\n\t/*\n\t * Sign\n\t */\n\tif (*p == '-' || *p == '+')\n\t\tif (*p++ == '-')\n\t\t\tneg = 1;\n\n\t/*\n\t * Base\n\t */\n\tif (base == 0) {\n\t\tif (*p != '0')\n\t\t\tbase = 10;\n\t\telse {\n\t\t\tbase = 8;\n\t\t\tif (p[1] == 'x' || p[1] == 'X') {\n\t\t\t\tp += 2;\n\t\t\t\tbase = 16;\n\t\t\t}\n\t\t}\n\t} else if (base == 16 && *p == '0') {\n\t\tif (p[1] == 'x' || p[1] == 'X')\n\t\t\tp += 2;\n\t} else if (base < 0 || 36 < base)\n\t\tgoto Return;\n\n\t/*\n\t * Non-empty sequence of digits\n\t */\n\tfor (;; p++,ndig++) {\n\t\tc = *p;\n\t\tv = base;\n\t\tif ('0'<=c && c<='9')\n\t\t\tv = c - '0';\n\t\telse if ('a'<=c && c<='z')\n\t\t\tv = c - 'a' + 10;\n\t\telse if ('A'<=c && c<='Z')\n\t\t\tv = c - 'A' + 10;\n\t\tif (v >= base)\n\t\t\tbreak;\n\t\tnn = n * base + (neg ? -v : v);\n\t\tif ((!neg && nn < n) || (neg && nn > n))\n\t\t\tovfl = 1;\n\t\tn = nn;\n\t}\n\nReturn:\n\tif (ndig == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert string to long. Not a number\");\n\t\treturn -1;\n\t}\n\n\tif (endptr)\n\t\t*endptr = p;\n\n\tif (ovfl) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert string to long. Overflow error\");\n\t\treturn -1;\n\t}\n\n\t*result = n;\n\treturn 0;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strtol64(int64_t *result, const char *nptr, const char **endptr, int base)\n{\n\tconst char *p;\n\tint64_t n, nn;\n\tint c, ovfl, v, neg, ndig;\n\n\tp = nptr;\n\tneg = 0;\n\tn = 0;\n\tndig = 0;\n\tovfl = 0;\n\n\t/*\n\t * White space\n\t */\n\twhile (git__isspace(*p))\n\t\tp++;\n\n\t/*\n\t * Sign\n\t */\n\tif (*p == '-' || *p == '+')\n\t\tif (*p++ == '-')\n\t\t\tneg = 1;\n\n\t/*\n\t * Base\n\t */\n\tif (base == 0) {\n\t\tif (*p != '0')\n\t\t\tbase = 10;\n\t\telse {\n\t\t\tbase = 8;\n\t\t\tif (p[1] == 'x' || p[1] == 'X') {\n\t\t\t\tp += 2;\n\t\t\t\tbase = 16;\n\t\t\t}\n\t\t}\n\t} else if (base == 16 && *p == '0') {\n\t\tif (p[1] == 'x' || p[1] == 'X')\n\t\t\tp += 2;\n\t} else if (base < 0 || 36 < base)\n\t\tgoto Return;\n\n\t/*\n\t * Non-empty sequence of digits\n\t */\n\tfor (;; p++,ndig++) {\n\t\tc = *p;\n\t\tv = base;\n\t\tif ('0'<=c && c<='9')\n\t\t\tv = c - '0';\n\t\telse if ('a'<=c && c<='z')\n\t\t\tv = c - 'a' + 10;\n\t\telse if ('A'<=c && c<='Z')\n\t\t\tv = c - 'A' + 10;\n\t\tif (v >= base)\n\t\t\tbreak;\n\t\tnn = n * base + (neg ? -v : v);\n\t\tif ((!neg && nn < n) || (neg && nn > n))\n\t\t\tovfl = 1;\n\t\tn = nn;\n\t}\n\nReturn:\n\tif (ndig == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert string to long. Not a number\");\n\t\treturn -1;\n\t}\n\n\tif (endptr)\n\t\t*endptr = p;\n\n\tif (ovfl) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert string to long. Overflow error\");\n\t\treturn -1;\n\t}\n\n\t*result = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "lost"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuc_entry_alloc",
          "args": [
            "buffer"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "reuc_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "932-952",
          "snippet": "static git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_strnlen",
          "args": [
            "buffer",
            "size"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "p_strnlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/strnlen.h",
          "lines": "16-19",
          "snippet": "GIT_INLINE(size_t) p_strnlen(const char *s, size_t maxlen) {\n\tconst char *end = memchr(s, 0, maxlen);\n\treturn end ? (size_t)(end - s) : maxlen;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(size_t) p_strnlen(const char *s, size_t maxlen) {\n\tconst char *end = memchr(s, 0, maxlen);\n\treturn end ? (size_t)(end - s) : maxlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&index->reuc",
            "16",
            "reuc_cmp"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int read_reuc(git_index *index, const char *buffer, size_t size)\n{\n\tconst char *endptr;\n\tsize_t len;\n\tint i;\n\n\t/* If called multiple times, the vector might already be initialized */\n\tif (index->reuc._alloc_size == 0 &&\n\t\tgit_vector_init(&index->reuc, 16, reuc_cmp) < 0)\n\t\treturn -1;\n\n\twhile (size) {\n\t\tgit_index_reuc_entry *lost;\n\n\t\tlen = p_strnlen(buffer, size) + 1;\n\t\tif (size <= len)\n\t\t\treturn index_error_invalid(\"reading reuc entries\");\n\n\t\tlost = reuc_entry_alloc(buffer);\n\t\tGITERR_CHECK_ALLOC(lost);\n\n\t\tsize -= len;\n\t\tbuffer += len;\n\n\t\t/* read 3 ASCII octal numbers for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tint64_t tmp;\n\n\t\t\tif (git__strtol64(&tmp, buffer, &endptr, 8) < 0 ||\n\t\t\t\t!endptr || endptr == buffer || *endptr ||\n\t\t\t\ttmp < 0) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tlost->mode[i] = tmp;\n\n\t\t\tlen = (endptr + 1) - buffer;\n\t\t\tif (size <= len) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry stage\");\n\t\t\t}\n\n\t\t\tsize -= len;\n\t\t\tbuffer += len;\n\t\t}\n\n\t\t/* read up to 3 OIDs for stage entries */\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!lost->mode[i])\n\t\t\t\tcontinue;\n\t\t\tif (size < 20) {\n\t\t\t\tindex_entry_reuc_free(lost);\n\t\t\t\treturn index_error_invalid(\"reading reuc entry oid\");\n\t\t\t}\n\n\t\t\tgit_oid_fromraw(&lost->oid[i], (const unsigned char *) buffer);\n\t\t\tsize -= 20;\n\t\t\tbuffer += 20;\n\t\t}\n\n\t\t/* entry was read successfully - insert into reuc vector */\n\t\tif (git_vector_insert(&index->reuc, lost) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* entries are guaranteed to be sorted on-disk */\n\tgit_vector_set_sorted(&index->reuc, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "index_error_invalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2127-2131",
    "snippet": "static int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Invalid data in index - %s\"",
            "message"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_error_invalid(const char *message)\n{\n\tgiterr_set(GITERR_INDEX, \"Invalid data in index - %s\", message);\n\treturn -1;\n}"
  },
  {
    "function_name": "git_index_reuc_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2115-2125",
    "snippet": "void git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&index->reuc"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_reuc_free",
          "args": [
            "git__swap(index->reuc.contents[i], NULL)"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_reuc_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "320-323",
          "snippet": "static void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__swap",
          "args": [
            "index->reuc.contents[i]",
            "NULL"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nvoid git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}"
  },
  {
    "function_name": "git_index_reuc_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2099-2113",
    "snippet": "int git_index_reuc_remove(git_index *index, size_t position)\n{\n\tint error;\n\tgit_index_reuc_entry *reuc;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treuc = git_vector_get(&index->reuc, position);\n\terror = git_vector_remove(&index->reuc, position);\n\n\tif (!error)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_reuc_free",
          "args": [
            "reuc"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_reuc_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "320-323",
          "snippet": "static void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&index->reuc",
            "position"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->reuc",
            "position"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_vector_is_sorted(&index->reuc)"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_is_sorted",
          "args": [
            "&index->reuc"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_reuc_remove(git_index *index, size_t position)\n{\n\tint error;\n\tgit_index_reuc_entry *reuc;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treuc = git_vector_get(&index->reuc, position);\n\terror = git_vector_remove(&index->reuc, position);\n\n\tif (!error)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_reuc_get_byindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2090-2097",
    "snippet": "const git_index_reuc_entry *git_index_reuc_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treturn git_vector_get(&index->reuc, n);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->reuc",
            "n"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_vector_is_sorted(&index->reuc)"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_is_sorted",
          "args": [
            "&index->reuc"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nconst git_index_reuc_entry *git_index_reuc_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\treturn git_vector_get(&index->reuc, n);\n}"
  },
  {
    "function_name": "git_index_reuc_get_bypath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2073-2088",
    "snippet": "const git_index_reuc_entry *git_index_reuc_get_bypath(\n\tgit_index *index, const char *path)\n{\n\tsize_t pos;\n\tassert(index && path);\n\n\tif (!index->reuc.length)\n\t\treturn NULL;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tif (git_index_reuc_find(&pos, index, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&index->reuc, pos);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->reuc",
            "pos"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_reuc_find",
          "args": [
            "&pos",
            "index",
            "path"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_reuc_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2068-2071",
          "snippet": "int git_index_reuc_find(size_t *at_pos, git_index *index, const char *path)\n{\n\treturn git_vector_bsearch2(at_pos, &index->reuc, index->reuc_search, path);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_reuc_find(size_t *at_pos, git_index *index, const char *path)\n{\n\treturn git_vector_bsearch2(at_pos, &index->reuc, index->reuc_search, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_vector_is_sorted(&index->reuc)"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_is_sorted",
          "args": [
            "&index->reuc"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nconst git_index_reuc_entry *git_index_reuc_get_bypath(\n\tgit_index *index, const char *path)\n{\n\tsize_t pos;\n\tassert(index && path);\n\n\tif (!index->reuc.length)\n\t\treturn NULL;\n\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tif (git_index_reuc_find(&pos, index, path) < 0)\n\t\treturn NULL;\n\n\treturn git_vector_get(&index->reuc, pos);\n}"
  },
  {
    "function_name": "git_index_reuc_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2068-2071",
    "snippet": "int git_index_reuc_find(size_t *at_pos, git_index *index, const char *path)\n{\n\treturn git_vector_bsearch2(at_pos, &index->reuc, index->reuc_search, path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "at_pos",
            "&index->reuc",
            "index->reuc_search",
            "path"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_reuc_find(size_t *at_pos, git_index *index, const char *path)\n{\n\treturn git_vector_bsearch2(at_pos, &index->reuc, index->reuc_search, path);\n}"
  },
  {
    "function_name": "git_index_reuc_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2050-2066",
    "snippet": "int git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_reuc_free",
          "args": [
            "reuc"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_reuc_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "320-323",
          "snippet": "static void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_reuc_insert",
          "args": [
            "index",
            "reuc"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "index_reuc_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2037-2048",
          "snippet": "static int index_reuc_insert(\n\tgit_index *index,\n\tgit_index_reuc_entry *reuc)\n{\n\tint res;\n\n\tassert(index && reuc && reuc->path != NULL);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tres = git_vector_insert_sorted(&index->reuc, reuc, &index_reuc_on_dup);\n\treturn res == GIT_EEXISTS ? 0 : res;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int index_reuc_insert(\n\tgit_index *index,\n\tgit_index_reuc_entry *reuc)\n{\n\tint res;\n\n\tassert(index && reuc && reuc->path != NULL);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tres = git_vector_insert_sorted(&index->reuc, reuc, &index_reuc_on_dup);\n\treturn res == GIT_EEXISTS ? 0 : res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_reuc_init",
          "args": [
            "&reuc",
            "path",
            "ancestor_mode",
            "ancestor_oid",
            "our_mode",
            "our_oid",
            "their_mode",
            "their_oid"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_reuc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "954-983",
          "snippet": "static int index_entry_reuc_init(git_index_reuc_entry **reuc_out,\n\tconst char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\n\tassert(reuc_out && path);\n\n\t*reuc_out = reuc = reuc_entry_alloc(path);\n\tGITERR_CHECK_ALLOC(reuc);\n\n\tif ((reuc->mode[0] = ancestor_mode) > 0) {\n\t\tassert(ancestor_oid);\n\t\tgit_oid_cpy(&reuc->oid[0], ancestor_oid);\n\t}\n\n\tif ((reuc->mode[1] = our_mode) > 0) {\n\t\tassert(our_oid);\n\t\tgit_oid_cpy(&reuc->oid[1], our_oid);\n\t}\n\n\tif ((reuc->mode[2] = their_mode) > 0) {\n\t\tassert(their_oid);\n\t\tgit_oid_cpy(&reuc->oid[2], their_oid);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int index_entry_reuc_init(git_index_reuc_entry **reuc_out,\n\tconst char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\n\tassert(reuc_out && path);\n\n\t*reuc_out = reuc = reuc_entry_alloc(path);\n\tGITERR_CHECK_ALLOC(reuc);\n\n\tif ((reuc->mode[0] = ancestor_mode) > 0) {\n\t\tassert(ancestor_oid);\n\t\tgit_oid_cpy(&reuc->oid[0], ancestor_oid);\n\t}\n\n\tif ((reuc->mode[1] = our_mode) > 0) {\n\t\tassert(our_oid);\n\t\tgit_oid_cpy(&reuc->oid[1], our_oid);\n\t}\n\n\tif ((reuc->mode[2] = their_mode) > 0) {\n\t\tassert(their_oid);\n\t\tgit_oid_cpy(&reuc->oid[2], their_oid);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_reuc_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2037-2048",
    "snippet": "static int index_reuc_insert(\n\tgit_index *index,\n\tgit_index_reuc_entry *reuc)\n{\n\tint res;\n\n\tassert(index && reuc && reuc->path != NULL);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tres = git_vector_insert_sorted(&index->reuc, reuc, &index_reuc_on_dup);\n\treturn res == GIT_EEXISTS ? 0 : res;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert_sorted",
          "args": [
            "&index->reuc",
            "reuc",
            "&index_reuc_on_dup"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert_sorted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "141-173",
          "snippet": "int git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "git_vector_is_sorted(&index->reuc)"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_is_sorted",
          "args": [
            "&index->reuc"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && reuc && reuc->path != NULL"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int index_reuc_insert(\n\tgit_index *index,\n\tgit_index_reuc_entry *reuc)\n{\n\tint res;\n\n\tassert(index && reuc && reuc->path != NULL);\n\tassert(git_vector_is_sorted(&index->reuc));\n\n\tres = git_vector_insert_sorted(&index->reuc, reuc, &index_reuc_on_dup);\n\treturn res == GIT_EEXISTS ? 0 : res;\n}"
  },
  {
    "function_name": "index_reuc_on_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2030-2035",
    "snippet": "static int index_reuc_on_dup(void **old, void *new)\n{\n\tindex_entry_reuc_free(*old);\n\t*old = new;\n\treturn GIT_EEXISTS;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_reuc_free",
          "args": [
            "*old"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_reuc_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "320-323",
          "snippet": "static void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int index_reuc_on_dup(void **old, void *new)\n{\n\tindex_entry_reuc_free(*old);\n\t*old = new;\n\treturn GIT_EEXISTS;\n}"
  },
  {
    "function_name": "git_index_reuc_entrycount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2024-2028",
    "snippet": "size_t git_index_reuc_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->reuc.length;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nsize_t git_index_reuc_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->reuc.length;\n}"
  },
  {
    "function_name": "git_index_name_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "2011-2022",
    "snippet": "void git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&index->names"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_name_entry_free",
          "args": [
            "conflict_name"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "index_name_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1979-1987",
          "snippet": "static void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&index->names",
            "i",
            "conflict_name"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}"
  },
  {
    "function_name": "git_index_name_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1989-2009",
    "snippet": "int git_index_name_add(git_index *index,\n\tconst char *ancestor, const char *ours, const char *theirs)\n{\n\tgit_index_name_entry *conflict_name;\n\n\tassert((ancestor && ours) || (ancestor && theirs) || (ours && theirs));\n\n\tconflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\tGITERR_CHECK_ALLOC(conflict_name);\n\n\tif ((ancestor && !(conflict_name->ancestor = git__strdup(ancestor))) ||\n\t\t(ours     && !(conflict_name->ours     = git__strdup(ours))) ||\n\t\t(theirs   && !(conflict_name->theirs   = git__strdup(theirs))) ||\n\t\tgit_vector_insert(&index->names, conflict_name) < 0)\n\t{\n\t\tindex_name_entry_free(conflict_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_name_entry_free",
          "args": [
            "conflict_name"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "index_name_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1979-1987",
          "snippet": "static void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&index->names",
            "conflict_name"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "theirs"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "conflict_name"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_index_name_entry)"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(ancestor && ours) || (ancestor && theirs) || (ours && theirs)"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_name_add(git_index *index,\n\tconst char *ancestor, const char *ours, const char *theirs)\n{\n\tgit_index_name_entry *conflict_name;\n\n\tassert((ancestor && ours) || (ancestor && theirs) || (ours && theirs));\n\n\tconflict_name = git__calloc(1, sizeof(git_index_name_entry));\n\tGITERR_CHECK_ALLOC(conflict_name);\n\n\tif ((ancestor && !(conflict_name->ancestor = git__strdup(ancestor))) ||\n\t\t(ours     && !(conflict_name->ours     = git__strdup(ours))) ||\n\t\t(theirs   && !(conflict_name->theirs   = git__strdup(theirs))) ||\n\t\tgit_vector_insert(&index->names, conflict_name) < 0)\n\t{\n\t\tindex_name_entry_free(conflict_name);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "index_name_entry_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1979-1987",
    "snippet": "static void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ne"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_name_entry_free(git_index_name_entry *ne)\n{\n\tif (!ne)\n\t\treturn;\n\tgit__free(ne->ancestor);\n\tgit__free(ne->ours);\n\tgit__free(ne->theirs);\n\tgit__free(ne);\n}"
  },
  {
    "function_name": "git_index_name_get_byindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1970-1977",
    "snippet": "const git_index_name_entry *git_index_name_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\n\tgit_vector_sort(&index->names);\n\treturn git_vector_get(&index->names, n);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->names",
            "n"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->names"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_name_entry *git_index_name_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\n\tgit_vector_sort(&index->names);\n\treturn git_vector_get(&index->names, n);\n}"
  },
  {
    "function_name": "git_index_name_entrycount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1964-1968",
    "snippet": "size_t git_index_name_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->names.length;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nsize_t git_index_name_entrycount(git_index *index)\n{\n\tassert(index);\n\treturn index->names.length;\n}"
  },
  {
    "function_name": "git_index_conflict_iterator_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1956-1962",
    "snippet": "void git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)\n{\n\tif (iterator == NULL)\n\t\treturn;\n\n\tgit__free(iterator);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iterator"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nvoid git_index_conflict_iterator_free(git_index_conflict_iterator *iterator)\n{\n\tif (iterator == NULL)\n\t\treturn;\n\n\tgit__free(iterator);\n}"
  },
  {
    "function_name": "git_index_conflict_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1919-1954",
    "snippet": "int git_index_conflict_next(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index_conflict_iterator *iterator)\n{\n\tconst git_index_entry *entry;\n\tint len;\n\n\tassert(ancestor_out && our_out && their_out && iterator);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\twhile (iterator->cur < iterator->index->entries.length) {\n\t\tentry = git_index_get_byindex(iterator->index, iterator->cur);\n\n\t\tif (git_index_entry_is_conflict(entry)) {\n\t\t\tif ((len = index_conflict__get_byindex(\n\t\t\t\tancestor_out,\n\t\t\t\tour_out,\n\t\t\t\ttheir_out,\n\t\t\t\titerator->index,\n\t\t\t\titerator->cur)) < 0)\n\t\t\t\treturn len;\n\n\t\t\titerator->cur += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\titerator->cur++;\n\t}\n\n\treturn GIT_ITEROVER;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_conflict__get_byindex",
          "args": [
            "ancestor_out",
            "our_out",
            "their_out",
            "iterator->index",
            "iterator->cur"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "index_conflict__get_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1772-1818",
          "snippet": "static int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "entry"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_get_byindex",
          "args": [
            "iterator->index",
            "iterator->cur"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "799-805",
          "snippet": "const git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ancestor_out && our_out && their_out && iterator"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_conflict_next(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index_conflict_iterator *iterator)\n{\n\tconst git_index_entry *entry;\n\tint len;\n\n\tassert(ancestor_out && our_out && their_out && iterator);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\twhile (iterator->cur < iterator->index->entries.length) {\n\t\tentry = git_index_get_byindex(iterator->index, iterator->cur);\n\n\t\tif (git_index_entry_is_conflict(entry)) {\n\t\t\tif ((len = index_conflict__get_byindex(\n\t\t\t\tancestor_out,\n\t\t\t\tour_out,\n\t\t\t\ttheir_out,\n\t\t\t\titerator->index,\n\t\t\t\titerator->cur)) < 0)\n\t\t\t\treturn len;\n\n\t\t\titerator->cur += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\titerator->cur++;\n\t}\n\n\treturn GIT_ITEROVER;\n}"
  },
  {
    "function_name": "git_index_conflict_iterator_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1902-1917",
    "snippet": "int git_index_conflict_iterator_new(\n\tgit_index_conflict_iterator **iterator_out,\n\tgit_index *index)\n{\n\tgit_index_conflict_iterator *it = NULL;\n\n\tassert(iterator_out && index);\n\n\tit = git__calloc(1, sizeof(git_index_conflict_iterator));\n\tGITERR_CHECK_ALLOC(it);\n\n\tit->index = index;\n\n\t*iterator_out = it;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "it"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_index_conflict_iterator)"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iterator_out && index"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_iterator_new(\n\tgit_index_conflict_iterator **iterator_out,\n\tgit_index *index)\n{\n\tgit_index_conflict_iterator *it = NULL;\n\n\tassert(iterator_out && index);\n\n\tit = git__calloc(1, sizeof(git_index_conflict_iterator));\n\tGITERR_CHECK_ALLOC(it);\n\n\tit->index = index;\n\n\t*iterator_out = it;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_has_conflicts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1887-1900",
    "snippet": "int git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&index->entries",
            "i",
            "entry"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_has_conflicts(const git_index *index)\n{\n\tsize_t i;\n\tgit_index_entry *entry;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif (GIT_IDXENTRY_STAGE(entry) > 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_conflict_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1881-1885",
    "snippet": "int git_index_conflict_cleanup(git_index *index)\n{\n\tassert(index);\n\treturn index_conflict_remove(index, NULL);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_conflict_remove",
          "args": [
            "index",
            "NULL"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_conflict_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1875-1879",
          "snippet": "int git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_cleanup(git_index *index)\n{\n\tassert(index);\n\treturn index_conflict_remove(index, NULL);\n}"
  },
  {
    "function_name": "git_index_conflict_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1875-1879",
    "snippet": "int git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_conflict_remove",
          "args": [
            "index",
            "path"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_conflict_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1875-1879",
          "snippet": "int git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}"
  },
  {
    "function_name": "index_conflict_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1848-1873",
    "snippet": "static int index_conflict_remove(git_index *index, const char *path)\n{\n\tsize_t pos = 0;\n\tgit_index_entry *conflict_entry;\n\tint error = 0;\n\n\tif (path != NULL && git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\twhile ((conflict_entry = git_vector_get(&index->entries, pos)) != NULL) {\n\n\t\tif (path != NULL &&\n\t\t\tindex->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(conflict_entry) == 0) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = index_remove_entry(index, pos)) < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_remove_entry",
          "args": [
            "index",
            "pos"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "index_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "503-524",
          "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "conflict_entry"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index->entries_cmp_path",
          "args": [
            "conflict_entry->path",
            "path"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "pos"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_find",
          "args": [
            "&pos",
            "index",
            "path"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1677-1703",
          "snippet": "int git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict_remove(git_index *index, const char *path)\n{\n\tsize_t pos = 0;\n\tgit_index_entry *conflict_entry;\n\tint error = 0;\n\n\tif (path != NULL && git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\twhile ((conflict_entry = git_vector_get(&index->entries, pos)) != NULL) {\n\n\t\tif (path != NULL &&\n\t\t\tindex->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(conflict_entry) == 0) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((error = index_remove_entry(index, pos)) < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_conflict_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1820-1846",
    "snippet": "int git_index_conflict_get(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tconst char *path)\n{\n\tsize_t pos;\n\tint len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index && path);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tif (git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif ((len = index_conflict__get_byindex(\n\t\tancestor_out, our_out, their_out, index, pos)) < 0)\n\t\treturn len;\n\telse if (len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_conflict__get_byindex",
          "args": [
            "ancestor_out",
            "our_out",
            "their_out",
            "index",
            "pos"
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "index_conflict__get_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1772-1818",
          "snippet": "static int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_find",
          "args": [
            "&pos",
            "index",
            "path"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1677-1703",
          "snippet": "int git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ancestor_out && our_out && their_out && index && path"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_get(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tconst char *path)\n{\n\tsize_t pos;\n\tint len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index && path);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tif (git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif ((len = index_conflict__get_byindex(\n\t\tancestor_out, our_out, their_out, index, pos)) < 0)\n\t\treturn len;\n\telse if (len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "index_conflict__get_byindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1772-1818",
    "snippet": "static int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "conflict_entry"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index->entries_cmp_path",
          "args": [
            "conflict_entry->path",
            "path"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "n"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entrycount",
          "args": [
            "index"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "793-797",
          "snippet": "size_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nsize_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ancestor_out && our_out && their_out && index"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict__get_byindex(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tsize_t n)\n{\n\tconst git_index_entry *conflict_entry;\n\tconst char *path = NULL;\n\tsize_t count;\n\tint stage, len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tfor (count = git_index_entrycount(index); n < count; ++n) {\n\t\tconflict_entry = git_vector_get(&index->entries, n);\n\n\t\tif (path && index->entries_cmp_path(conflict_entry->path, path) != 0)\n\t\t\tbreak;\n\n\t\tstage = GIT_IDXENTRY_STAGE(conflict_entry);\n\t\tpath = conflict_entry->path;\n\n\t\tswitch (stage) {\n\t\tcase 3:\n\t\t\t*their_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t*our_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t*ancestor_out = conflict_entry;\n\t\t\tlen++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t};\n\t}\n\n\treturn len;\n}"
  },
  {
    "function_name": "git_index_conflict_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1705-1770",
    "snippet": "int git_index_conflict_add(git_index *index,\n\tconst git_index_entry *ancestor_entry,\n\tconst git_index_entry *our_entry,\n\tconst git_index_entry *their_entry)\n{\n\tgit_index_entry *entries[3] = { 0 };\n\tunsigned short i;\n\tint ret = 0;\n\n\tassert (index);\n\n\tif ((ancestor_entry &&\n\t\t\t(ret = index_entry_dup(&entries[0], index, ancestor_entry)) < 0) ||\n\t\t(our_entry &&\n\t\t\t(ret = index_entry_dup(&entries[1], index, our_entry)) < 0) ||\n\t\t(their_entry &&\n\t\t\t(ret = index_entry_dup(&entries[2], index, their_entry)) < 0))\n\t\tgoto on_error;\n\n\t/* Validate entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] && !valid_filemode(entries[i]->mode)) {\n\t\t\tgiterr_set(GITERR_INDEX, \"invalid filemode for stage %d entry\",\n\t\t\t\ti + 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Remove existing index entries for each path */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = git_index_remove(index, entries[i]->path, 0)) != 0) {\n\t\t\tif (ret != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* Add the conflict entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* Make sure stage is correct */\n\t\tGIT_IDXENTRY_STAGE_SET(entries[i], i + 1);\n\n\t\tif ((ret = index_insert(index, &entries[i], 1, true, true, false)) < 0)\n\t\t\tgoto on_error;\n\n\t\tentries[i] = NULL; /* don't free if later entry fails */\n\t}\n\n\treturn 0;\n\non_error:\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] != NULL)\n\t\t\tindex_entry_free(entries[i]);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entries[i]"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_insert",
          "args": [
            "index",
            "&entries[i]",
            "1",
            "true",
            "true",
            "false"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "index_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1264-1351",
          "snippet": "static int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE_SET",
          "args": [
            "entries[i]",
            "i + 1"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_remove",
          "args": [
            "index",
            "entries[i]->path",
            "0"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_remove_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1622-1651",
          "snippet": "int git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"invalid filemode for stage %d entry\"",
            "i + 1"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_filemode",
          "args": [
            "entries[i]->mode"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "valid_filemode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1379-1385",
          "snippet": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_dup",
          "args": [
            "&entries[2]",
            "index",
            "their_entry"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1016-1026",
          "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_conflict_add(git_index *index,\n\tconst git_index_entry *ancestor_entry,\n\tconst git_index_entry *our_entry,\n\tconst git_index_entry *their_entry)\n{\n\tgit_index_entry *entries[3] = { 0 };\n\tunsigned short i;\n\tint ret = 0;\n\n\tassert (index);\n\n\tif ((ancestor_entry &&\n\t\t\t(ret = index_entry_dup(&entries[0], index, ancestor_entry)) < 0) ||\n\t\t(our_entry &&\n\t\t\t(ret = index_entry_dup(&entries[1], index, our_entry)) < 0) ||\n\t\t(their_entry &&\n\t\t\t(ret = index_entry_dup(&entries[2], index, their_entry)) < 0))\n\t\tgoto on_error;\n\n\t/* Validate entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] && !valid_filemode(entries[i]->mode)) {\n\t\t\tgiterr_set(GITERR_INDEX, \"invalid filemode for stage %d entry\",\n\t\t\t\ti + 1);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Remove existing index entries for each path */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif ((ret = git_index_remove(index, entries[i]->path, 0)) != 0) {\n\t\t\tif (ret != GIT_ENOTFOUND)\n\t\t\t\tgoto on_error;\n\n\t\t\tgiterr_clear();\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\t/* Add the conflict entries */\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] == NULL)\n\t\t\tcontinue;\n\n\t\t/* Make sure stage is correct */\n\t\tGIT_IDXENTRY_STAGE_SET(entries[i], i + 1);\n\n\t\tif ((ret = index_insert(index, &entries[i], 1, true, true, false)) < 0)\n\t\t\tgoto on_error;\n\n\t\tentries[i] = NULL; /* don't free if later entry fails */\n\t}\n\n\treturn 0;\n\non_error:\n\tfor (i = 0; i < 3; i++) {\n\t\tif (entries[i] != NULL)\n\t\t\tindex_entry_free(entries[i]);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "git_index_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1677-1703",
    "snippet": "int git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index->entries_cmp_path",
          "args": [
            "prev->path",
            "path"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "pos - 1"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Index does not contain %s\"",
            "path"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "&pos",
            "&index->entries",
            "index->entries_search_path",
            "path"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_find(size_t *at_pos, git_index *index, const char *path)\n{\n\tsize_t pos;\n\n\tassert(index && path);\n\n\tif (git_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, path) < 0) {\n\t\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Since our binary search only looked at path, we may be in the\n\t * middle of a list of stages.\n\t */\n\tfor (; pos > 0; --pos) {\n\t\tconst git_index_entry *prev = git_vector_get(&index->entries, pos - 1);\n\n\t\tif (index->entries_cmp_path(prev->path, path) != 0)\n\t\t\tbreak;\n\t}\n\n\tif (at_pos)\n\t\t*at_pos = pos;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index__find_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1670-1675",
    "snippet": "int git_index__find_pos(\n\tsize_t *out, git_index *index, const char *path, size_t path_len, int stage)\n{\n\tassert(index && path);\n\treturn index_find(out, index, path, path_len, stage);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_find",
          "args": [
            "out",
            "index",
            "path",
            "path_len",
            "stage"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "370-378",
          "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index__find_pos(\n\tsize_t *out, git_index *index, const char *path, size_t path_len, int stage)\n{\n\tassert(index && path);\n\treturn index_find(out, index, path, path_len, stage);\n}"
  },
  {
    "function_name": "git_index_find_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1653-1668",
    "snippet": "int git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)\n{\n\tint error = 0;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tindex_find(&pos, index, prefix, strlen(prefix), GIT_INDEX_STAGE_ANY);\n\tentry = git_vector_get(&index->entries, pos);\n\tif (!entry || git__prefixcmp(entry->path, prefix) != 0)\n\t\terror = GIT_ENOTFOUND;\n\n\tif (!error && at_pos)\n\t\t*at_pos = pos;\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "entry->path",
            "prefix"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "pos"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_find",
          "args": [
            "&pos",
            "index",
            "prefix",
            "strlen(prefix)",
            "GIT_INDEX_STAGE_ANY"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "370-378",
          "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 1659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_find_prefix(size_t *at_pos, git_index *index, const char *prefix)\n{\n\tint error = 0;\n\tsize_t pos;\n\tconst git_index_entry *entry;\n\n\tindex_find(&pos, index, prefix, strlen(prefix), GIT_INDEX_STAGE_ANY);\n\tentry = git_vector_get(&index->entries, pos);\n\tif (!entry || git__prefixcmp(entry->path, prefix) != 0)\n\t\terror = GIT_ENOTFOUND;\n\n\tif (!error && at_pos)\n\t\t*at_pos = pos;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_remove_directory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1622-1651",
    "snippet": "int git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&pfx"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_remove_entry",
          "args": [
            "index",
            "pos"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "index_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "503-524",
          "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "entry->path",
            "pfx.ptr"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "pos"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_find",
          "args": [
            "&pos",
            "index",
            "pfx.ptr",
            "pfx.size",
            "GIT_INDEX_STAGE_ANY"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "370-378",
          "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "&pfx"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&pfx",
            "dir"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1600-1620",
    "snippet": "int git_index_remove(git_index *index, const char *path, int stage)\n{\n\tint error;\n\tsize_t position;\n\tgit_index_entry remove_key = {{ 0 }};\n\n\tremove_key.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&remove_key, stage);\n\n\tDELETE_IN_MAP(index, &remove_key);\n\n\tif (index_find(&position, index, path, 0, stage) < 0) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX, \"Index does not contain %s at stage %d\", path, stage);\n\t\terror = GIT_ENOTFOUND;\n\t} else {\n\t\terror = index_remove_entry(index, position);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_remove_entry",
          "args": [
            "index",
            "position"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "index_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "503-524",
          "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Index does not contain %s at stage %d\"",
            "path",
            "stage"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_find",
          "args": [
            "&position",
            "index",
            "path",
            "0",
            "stage"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "370-378",
          "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE_IN_MAP",
          "args": [
            "index",
            "&remove_key"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE_SET",
          "args": [
            "&remove_key",
            "stage"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_remove(git_index *index, const char *path, int stage)\n{\n\tint error;\n\tsize_t position;\n\tgit_index_entry remove_key = {{ 0 }};\n\n\tremove_key.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&remove_key, stage);\n\n\tDELETE_IN_MAP(index, &remove_key);\n\n\tif (index_find(&position, index, path, 0, stage) < 0) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX, \"Index does not contain %s at stage %d\", path, stage);\n\t\terror = GIT_ENOTFOUND;\n\t} else {\n\t\terror = index_remove_entry(index, position);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1580-1598",
    "snippet": "int git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_cache_invalidate_path",
          "args": [
            "index->tree",
            "entry->path"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_invalidate_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "27-49",
          "snippet": "void git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nvoid git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_insert",
          "args": [
            "index",
            "&entry",
            "1",
            "true",
            "true",
            "false"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "index_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1264-1351",
          "snippet": "static int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_dup",
          "args": [
            "&entry",
            "index",
            "source_entry"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1016-1026",
          "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"invalid filemode\""
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_filemode",
          "args": [
            "source_entry->mode"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "valid_filemode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1379-1385",
          "snippet": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && source_entry && source_entry->path"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index__fill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1541-1577",
    "snippet": "int git_index__fill(git_index *index, const git_vector *source_entries)\n{\n\tconst git_index_entry *source_entry = NULL;\n\tsize_t i;\n\tint ret = 0;\n\n\tassert(index);\n\n\tif (!source_entries->length)\n\t\treturn 0;\n\n\tgit_vector_size_hint(&index->entries, source_entries->length);\n\tgit_idxmap_resize(index->entries_map, (khint_t)(source_entries->length * 1.3));\n\n\tgit_vector_foreach(source_entries, i, source_entry) {\n\t\tgit_index_entry *entry = NULL;\n\n\t\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0)\n\t\t\tbreak;\n\n\t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);\n\t\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\t\tentry->mode = git_index__create_mode(entry->mode);\n\n\t\tif ((ret = git_vector_insert(&index->entries, entry)) < 0)\n\t\t\tbreak;\n\n\t\tINSERT_IN_MAP(index, entry, ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tgit_vector_sort(&index->entries);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSERT_IN_MAP",
          "args": [
            "index",
            "entry",
            "ret"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&index->entries",
            "entry"
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index__create_mode",
          "args": [
            "entry->mode"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__create_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "334-343",
          "snippet": "unsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_adjust_namemask",
          "args": [
            "entry",
            "((struct entry_internal *)entry)->pathlen"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_adjust_namemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "845-855",
          "snippet": "static void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_dup",
          "args": [
            "&entry",
            "index",
            "source_entry"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1016-1026",
          "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "source_entries",
            "i",
            "source_entry"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_idxmap_resize",
          "args": [
            "index->entries_map",
            "(khint_t)(source_entries->length * 1.3)"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "source_entries->length * 1.3"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_size_hint",
          "args": [
            "&index->entries",
            "source_entries->length"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_size_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "43-48",
          "snippet": "int git_vector_size_hint(git_vector *v, size_t size_hint)\n{\n\tif (v->_alloc_size >= size_hint)\n\t\treturn 0;\n\treturn resize_vector(v, size_hint);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_size_hint(git_vector *v, size_t size_hint)\n{\n\tif (v->_alloc_size >= size_hint)\n\t\treturn 0;\n\treturn resize_vector(v, size_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index__fill(git_index *index, const git_vector *source_entries)\n{\n\tconst git_index_entry *source_entry = NULL;\n\tsize_t i;\n\tint ret = 0;\n\n\tassert(index);\n\n\tif (!source_entries->length)\n\t\treturn 0;\n\n\tgit_vector_size_hint(&index->entries, source_entries->length);\n\tgit_idxmap_resize(index->entries_map, (khint_t)(source_entries->length * 1.3));\n\n\tgit_vector_foreach(source_entries, i, source_entry) {\n\t\tgit_index_entry *entry = NULL;\n\n\t\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0)\n\t\t\tbreak;\n\n\t\tindex_entry_adjust_namemask(entry, ((struct entry_internal *)entry)->pathlen);\n\t\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\t\tentry->mode = git_index__create_mode(entry->mode);\n\n\t\tif ((ret = git_vector_insert(&index->entries, entry)) < 0)\n\t\t\tbreak;\n\n\t\tINSERT_IN_MAP(index, entry, ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tgit_vector_sort(&index->entries);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "git_index_remove_bypath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1523-1539",
    "snippet": "int git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_conflict_to_reuc",
          "args": [
            "index",
            "path"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "index_conflict_to_reuc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1353-1377",
          "snippet": "static int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_remove",
          "args": [
            "index",
            "path",
            "0"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_remove_directory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1622-1651",
          "snippet": "int git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_remove_directory(git_index *index, const char *dir, int stage)\n{\n\tgit_buf pfx = GIT_BUF_INIT;\n\tint error = 0;\n\tsize_t pos;\n\tgit_index_entry *entry;\n\n\tif (!(error = git_buf_sets(&pfx, dir)) &&\n\t\t!(error = git_path_to_dir(&pfx)))\n\t\tindex_find(&pos, index, pfx.ptr, pfx.size, GIT_INDEX_STAGE_ANY);\n\n\twhile (!error) {\n\t\tentry = git_vector_get(&index->entries, pos);\n\t\tif (!entry || git__prefixcmp(entry->path, pfx.ptr) != 0)\n\t\t\tbreak;\n\n\t\tif (GIT_IDXENTRY_STAGE(entry) != stage) {\n\t\t\t++pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\terror = index_remove_entry(index, pos);\n\n\t\t/* removed entry at 'pos' so we don't need to increment */\n\t}\n\n\tgit_buf_free(&pfx);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_remove_bypath(git_index *index, const char *path)\n{\n\tint ret;\n\n\tassert(index && path);\n\n\tif (((ret = git_index_remove(index, path, 0)) < 0 &&\n\t\tret != GIT_ENOTFOUND) ||\n\t\t((ret = index_conflict_to_reuc(index, path)) < 0 &&\n\t\tret != GIT_ENOTFOUND))\n\t\treturn ret;\n\n\tif (ret == GIT_ENOTFOUND)\n\t\tgiterr_clear();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_add_bypath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1470-1521",
    "snippet": "int git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_cache_invalidate_path",
          "args": [
            "index->tree",
            "entry->path"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_invalidate_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "27-49",
          "snippet": "void git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nvoid git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_conflict_to_reuc",
          "args": [
            "index",
            "path"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "index_conflict_to_reuc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1353-1377",
          "snippet": "static int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_add_to_index",
          "args": [
            "sm",
            "false"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_add_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "736-804",
          "snippet": "int git_submodule_add_to_index(git_submodule *sm, int write_index)\n{\n\tint error;\n\tgit_repository *sm_repo = NULL;\n\tgit_index *index;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_commit *head;\n\tgit_index_entry entry;\n\tstruct stat st;\n\n\tassert(sm);\n\n\t/* force reload of wd OID by git_submodule_open */\n\tsm->flags = sm->flags & ~GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(sm->repo), sm->path)) < 0 ||\n\t\t(error = git_submodule_open(&sm_repo, sm)) < 0)\n\t\tgoto cleanup;\n\n\t/* read stat information for submodule working directory */\n\tif (p_stat(path.ptr, &st) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without working directory\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = sm->path;\n\tgit_index_entry__init_from_stat(\n\t\t&entry, &st, !(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE));\n\n\t/* calling git_submodule_open will have set sm->wd_oid if possible */\n\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) == 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without HEAD to index\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\tgit_oid_cpy(&entry.id, &sm->wd_oid);\n\n\tif ((error = git_commit_lookup(&head, sm_repo, &sm->wd_oid)) < 0)\n\t\tgoto cleanup;\n\n\tentry.ctime.seconds = (int32_t)git_commit_time(head);\n\tentry.ctime.nanoseconds = 0;\n\tentry.mtime.seconds = (int32_t)git_commit_time(head);\n\tentry.mtime.nanoseconds = 0;\n\n\tgit_commit_free(head);\n\n\t/* add it */\n\terror = git_index_add(index, &entry);\n\n\t/* write it, if requested */\n\tif (!error && write_index) {\n\t\terror = git_index_write(index);\n\n\t\tif (!error)\n\t\t\tgit_oid_cpy(&sm->index_oid, &sm->wd_oid);\n\t}\n\ncleanup:\n\tgit_repository_free(sm_repo);\n\tgit_buf_free(&path);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_update_from_head_data(git_submodule *sm, mode_t mode, const git_oid *id);\n\nint git_submodule_add_to_index(git_submodule *sm, int write_index)\n{\n\tint error;\n\tgit_repository *sm_repo = NULL;\n\tgit_index *index;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_commit *head;\n\tgit_index_entry entry;\n\tstruct stat st;\n\n\tassert(sm);\n\n\t/* force reload of wd OID by git_submodule_open */\n\tsm->flags = sm->flags & ~GIT_SUBMODULE_STATUS__WD_OID_VALID;\n\n\tif ((error = git_repository_index__weakptr(&index, sm->repo)) < 0 ||\n\t\t(error = git_buf_joinpath(\n\t\t\t&path, git_repository_workdir(sm->repo), sm->path)) < 0 ||\n\t\t(error = git_submodule_open(&sm_repo, sm)) < 0)\n\t\tgoto cleanup;\n\n\t/* read stat information for submodule working directory */\n\tif (p_stat(path.ptr, &st) < 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without working directory\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.path = sm->path;\n\tgit_index_entry__init_from_stat(\n\t\t&entry, &st, !(git_index_caps(index) & GIT_INDEXCAP_NO_FILEMODE));\n\n\t/* calling git_submodule_open will have set sm->wd_oid if possible */\n\tif ((sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) == 0) {\n\t\tgiterr_set(GITERR_SUBMODULE,\n\t\t\t\"Cannot add submodule without HEAD to index\");\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\tgit_oid_cpy(&entry.id, &sm->wd_oid);\n\n\tif ((error = git_commit_lookup(&head, sm_repo, &sm->wd_oid)) < 0)\n\t\tgoto cleanup;\n\n\tentry.ctime.seconds = (int32_t)git_commit_time(head);\n\tentry.ctime.nanoseconds = 0;\n\tentry.mtime.seconds = (int32_t)git_commit_time(head);\n\tentry.mtime.nanoseconds = 0;\n\n\tgit_commit_free(head);\n\n\t/* add it */\n\terror = git_index_add(index, &entry);\n\n\t/* write it, if requested */\n\tif (!error && write_index) {\n\t\terror = git_index_write(index);\n\n\t\tif (!error)\n\t\t\tgit_oid_cpy(&sm->index_oid, &sm->wd_oid);\n\t}\n\ncleanup:\n\tgit_repository_free(sm_repo);\n\tgit_buf_free(&path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_insert",
          "args": [
            "index",
            "&entry",
            "1",
            "false",
            "false",
            "true"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "index_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1264-1351",
          "snippet": "static int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_repo_as_submodule",
          "args": [
            "&entry",
            "index",
            "path"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "add_repo_as_submodule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1430-1468",
          "snippet": "static int add_repo_as_submodule(git_index_entry **out, git_index *index, const char *path)\n{\n\tgit_repository *sub;\n\tgit_buf abspath = GIT_BUF_INIT;\n\tgit_repository *repo = INDEX_OWNER(index);\n\tgit_reference *head;\n\tgit_index_entry *entry;\n\tstruct stat st;\n\tint error;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), path, true) < 0)\n\t\treturn -1;\n\n\tif ((error = git_buf_joinpath(&abspath, git_repository_workdir(repo), path)) < 0)\n\t\treturn error;\n\n\tif ((error = p_stat(abspath.ptr, &st)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to stat repository dir\");\n\t\treturn -1;\n\t}\n\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\tif ((error = git_repository_open(&sub, abspath.ptr)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_head(&head, sub)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&entry->id, git_reference_target(head));\n\tentry->mode = GIT_FILEMODE_COMMIT;\n\n\tgit_reference_free(head);\n\tgit_repository_free(sub);\n\tgit_buf_free(&abspath);\n\n\t*out = entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int add_repo_as_submodule(git_index_entry **out, git_index *index, const char *path)\n{\n\tgit_repository *sub;\n\tgit_buf abspath = GIT_BUF_INIT;\n\tgit_repository *repo = INDEX_OWNER(index);\n\tgit_reference *head;\n\tgit_index_entry *entry;\n\tstruct stat st;\n\tint error;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), path, true) < 0)\n\t\treturn -1;\n\n\tif ((error = git_buf_joinpath(&abspath, git_repository_workdir(repo), path)) < 0)\n\t\treturn error;\n\n\tif ((error = p_stat(abspath.ptr, &st)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to stat repository dir\");\n\t\treturn -1;\n\t}\n\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\tif ((error = git_repository_open(&sub, abspath.ptr)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_head(&head, sub)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&entry->id, git_reference_target(head));\n\tentry->mode = GIT_FILEMODE_COMMIT;\n\n\tgit_reference_free(head);\n\tgit_repository_free(sub);\n\tgit_buf_free(&abspath);\n\n\t*out = entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_state_free",
          "args": [
            "&err"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "184-193",
          "snippet": "void giterr_state_free(git_error_state *state)\n{\n\tif (!state)\n\t\treturn;\n\n\tif (!state->oom)\n\t\tgit__free(state->error_msg.message);\n\n\tmemset(state, 0, sizeof(git_error_state));\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_state_free(git_error_state *state)\n{\n\tif (!state)\n\t\treturn;\n\n\tif (!state->oom)\n\t\tgit__free(state->error_msg.message);\n\n\tmemset(state, 0, sizeof(git_error_state));\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_state_restore",
          "args": [
            "&err"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "165-182",
          "snippet": "int giterr_state_restore(git_error_state *state)\n{\n\tint ret = 0;\n\n\tgiterr_clear();\n\n\tif (state && state->error_msg.message) {\n\t\tif (state->oom)\n\t\t\tgiterr_set_oom();\n\t\telse\n\t\t\tset_error(state->error_msg.klass, state->error_msg.message);\n\n\t\tret = state->error_code;\n\t\tmemset(state, 0, sizeof(git_error_state));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nint giterr_state_restore(git_error_state *state)\n{\n\tint ret = 0;\n\n\tgiterr_clear();\n\n\tif (state && state->error_msg.message) {\n\t\tif (state->oom)\n\t\t\tgiterr_set_oom();\n\t\telse\n\t\t\tset_error(state->error_msg.klass, state->error_msg.message);\n\n\t\tret = state->error_code;\n\t\tmemset(state, 0, sizeof(git_error_state));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "&sm",
            "INDEX_OWNER(index)",
            "path"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_state_capture",
          "args": [
            "&err",
            "ret"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_capture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "139-163",
          "snippet": "int giterr_state_capture(git_error_state *state, int error_code)\n{\n\tgit_error *error = GIT_GLOBAL->last_error;\n\tgit_buf *error_buf = &GIT_GLOBAL->error_buf;\n\n\tmemset(state, 0, sizeof(git_error_state));\n\n\tif (!error_code)\n\t\treturn 0;\n\n\tstate->error_code = error_code;\n\tstate->oom = (error == &g_git_oom_error);\n\n\tif (error) {\n\t\tstate->error_msg.klass = error->klass;\n\n\t\tif (state->oom)\n\t\t\tstate->error_msg.message = g_git_oom_error.message;\n\t\telse\n\t\t\tstate->error_msg.message = git_buf_detach(error_buf);\n\t}\n\n\tgiterr_clear();\n\treturn error_code;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nint giterr_state_capture(git_error_state *state, int error_code)\n{\n\tgit_error *error = GIT_GLOBAL->last_error;\n\tgit_buf *error_buf = &GIT_GLOBAL->error_buf;\n\n\tmemset(state, 0, sizeof(git_error_state));\n\n\tif (!error_code)\n\t\treturn 0;\n\n\tstate->error_code = error_code;\n\tstate->oom = (error == &g_git_oom_error);\n\n\tif (error) {\n\t\tstate->error_msg.klass = error->klass;\n\n\t\tif (state->oom)\n\t\t\tstate->error_msg.message = g_git_oom_error.message;\n\t\telse\n\t\t\tstate->error_msg.message = git_buf_detach(error_buf);\n\t}\n\n\tgiterr_clear();\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_init",
          "args": [
            "&entry",
            "index",
            "path"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "898-930",
          "snippet": "static int index_entry_init(\n\tgit_index_entry **entry_out,\n\tgit_index *index,\n\tconst char *rel_path)\n{\n\tint error = 0;\n\tgit_index_entry *entry = NULL;\n\tstruct stat st;\n\tgit_oid oid;\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), rel_path, true) < 0)\n\t\treturn -1;\n\n\t/* write the blob to disk and get the oid and stat info */\n\terror = git_blob__create_from_paths(\n\t\t&oid, &st, INDEX_OWNER(index), NULL, rel_path, 0, true);\n\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tentry->id = oid;\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\t*entry_out = (git_index_entry *)entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_init(\n\tgit_index_entry **entry_out,\n\tgit_index *index,\n\tconst char *rel_path)\n{\n\tint error = 0;\n\tgit_index_entry *entry = NULL;\n\tstruct stat st;\n\tgit_oid oid;\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), rel_path, true) < 0)\n\t\treturn -1;\n\n\t/* write the blob to disk and get the oid and stat info */\n\terror = git_blob__create_from_paths(\n\t\t&oid, &st, INDEX_OWNER(index), NULL, rel_path, 0, true);\n\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tentry->id = oid;\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\t*entry_out = (git_index_entry *)entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && path"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add_bypath(git_index *index, const char *path)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && path);\n\n\tif ((ret = index_entry_init(&entry, index, path)) == 0)\n\t\tret = index_insert(index, &entry, 1, false, false, true);\n\n\t/* If we were given a directory, let's see if it's a submodule */\n\tif (ret < 0 && ret != GIT_EDIRECTORY)\n\t\treturn ret;\n\n\tif (ret == GIT_EDIRECTORY) {\n\t\tgit_submodule *sm;\n\t\tgit_error_state err;\n\n\t\tgiterr_state_capture(&err, ret);\n\n\t\tret = git_submodule_lookup(&sm, INDEX_OWNER(index), path);\n\t\tif (ret == GIT_ENOTFOUND)\n\t\t\treturn giterr_state_restore(&err);\n\n\t\tgiterr_state_free(&err);\n\n\t\t/*\n\t\t * EEXISTS means that there is a repository at that path, but it's not known\n\t\t * as a submodule. We add its HEAD as an entry and don't register it.\n\t\t */\n\t\tif (ret == GIT_EEXISTS) {\n\t\t\tif ((ret = add_repo_as_submodule(&entry, index, path)) < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif ((ret = index_insert(index, &entry, 1, false, false, true)) < 0)\n\t\t\t\treturn ret;\n\t\t} else if (ret < 0) {\n\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = git_submodule_add_to_index(sm, false);\n\t\t\tgit_submodule_free(sm);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((ret = index_conflict_to_reuc(index, path)) < 0 && ret != GIT_ENOTFOUND)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
  },
  {
    "function_name": "add_repo_as_submodule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1430-1468",
    "snippet": "static int add_repo_as_submodule(git_index_entry **out, git_index *index, const char *path)\n{\n\tgit_repository *sub;\n\tgit_buf abspath = GIT_BUF_INIT;\n\tgit_repository *repo = INDEX_OWNER(index);\n\tgit_reference *head;\n\tgit_index_entry *entry;\n\tstruct stat st;\n\tint error;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), path, true) < 0)\n\t\treturn -1;\n\n\tif ((error = git_buf_joinpath(&abspath, git_repository_workdir(repo), path)) < 0)\n\t\treturn error;\n\n\tif ((error = p_stat(abspath.ptr, &st)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to stat repository dir\");\n\t\treturn -1;\n\t}\n\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\tif ((error = git_repository_open(&sub, abspath.ptr)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_head(&head, sub)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&entry->id, git_reference_target(head));\n\tentry->mode = GIT_FILEMODE_COMMIT;\n\n\tgit_reference_free(head);\n\tgit_repository_free(sub);\n\tgit_buf_free(&abspath);\n\n\t*out = entry;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&abspath"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_free",
          "args": [
            "sub"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "121-148",
          "snippet": "void git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nvoid git_repository_free(git_repository *repo)\n{\n\tsize_t i;\n\n\tif (repo == NULL)\n\t\treturn;\n\n\tgit_repository__cleanup(repo);\n\n\tgit_cache_free(&repo->objects);\n\n\tgit_diff_driver_registry_free(repo->diff_drivers);\n\trepo->diff_drivers = NULL;\n\n\tfor (i = 0; i < repo->reserved_names.size; i++)\n\t\tgit_buf_free(git_array_get(repo->reserved_names, i));\n\tgit_array_clear(repo->reserved_names);\n\n\tgit__free(repo->path_gitlink);\n\tgit__free(repo->path_repository);\n\tgit__free(repo->workdir);\n\tgit__free(repo->namespace);\n\tgit__free(repo->ident_name);\n\tgit__free(repo->ident_email);\n\n\tgit__memzero(repo, sizeof(*repo));\n\tgit__free(repo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "head"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry->id",
            "git_reference_target(head)"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "head"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head",
          "args": [
            "&head",
            "sub"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_open",
          "args": [
            "&sub",
            "abspath.ptr"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "557-561",
          "snippet": "int git_repository_open(git_repository **repo_out, const char *path)\n{\n\treturn git_repository_open_ext(\n\t\trepo_out, path, GIT_REPOSITORY_OPEN_NO_SEARCH, NULL);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_open(git_repository **repo_out, const char *path)\n{\n\treturn git_repository_open_ext(\n\t\trepo_out, path, GIT_REPOSITORY_OPEN_NO_SEARCH, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry__init_from_stat",
          "args": [
            "entry",
            "&st",
            "!index->distrust_filemode"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry__init_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "827-843",
          "snippet": "void git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to stat repository dir\""
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "abspath.ptr",
            "&st"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&abspath",
            "git_repository_workdir(repo)",
            "path"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_create",
          "args": [
            "&entry",
            "INDEX_OWNER(index)",
            "path",
            "true"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "863-896",
          "snippet": "static int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int add_repo_as_submodule(git_index_entry **out, git_index *index, const char *path)\n{\n\tgit_repository *sub;\n\tgit_buf abspath = GIT_BUF_INIT;\n\tgit_repository *repo = INDEX_OWNER(index);\n\tgit_reference *head;\n\tgit_index_entry *entry;\n\tstruct stat st;\n\tint error;\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), path, true) < 0)\n\t\treturn -1;\n\n\tif ((error = git_buf_joinpath(&abspath, git_repository_workdir(repo), path)) < 0)\n\t\treturn error;\n\n\tif ((error = p_stat(abspath.ptr, &st)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"failed to stat repository dir\");\n\t\treturn -1;\n\t}\n\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\tif ((error = git_repository_open(&sub, abspath.ptr)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_head(&head, sub)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(&entry->id, git_reference_target(head));\n\tentry->mode = GIT_FILEMODE_COMMIT;\n\n\tgit_reference_free(head);\n\tgit_repository_free(sub);\n\tgit_buf_free(&abspath);\n\n\t*out = entry;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_add_frombuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1387-1428",
    "snippet": "int git_index_add_frombuffer(\n    git_index *index, const git_index_entry *source_entry,\n    const void *buffer, size_t len)\n{\n\tgit_index_entry *entry = NULL;\n\tint error = 0;\n\tgit_oid id;\n\n\tassert(index && source_entry->path);\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif (index_entry_dup(&entry, index, source_entry) < 0)\n\t\treturn -1;\n\n\terror = git_blob_create_frombuffer(&id, INDEX_OWNER(index), buffer, len);\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tgit_oid_cpy(&entry->id, &id);\n\tentry->file_size = len;\n\n\tif ((error = index_insert(index, &entry, 1, true, true, true)) < 0)\n\t\treturn error;\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((error = index_conflict_to_reuc(index, entry->path)) < 0 && error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_cache_invalidate_path",
          "args": [
            "index->tree",
            "entry->path"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_invalidate_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "27-49",
          "snippet": "void git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nvoid git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_conflict_to_reuc",
          "args": [
            "index",
            "entry->path"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "index_conflict_to_reuc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1353-1377",
          "snippet": "static int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_insert",
          "args": [
            "index",
            "&entry",
            "1",
            "true",
            "true",
            "true"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "index_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1264-1351",
          "snippet": "static int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&entry->id",
            "&id"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entry"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_create_frombuffer",
          "args": [
            "&id",
            "INDEX_OWNER(index)",
            "buffer",
            "len"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_create_frombuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "53-71",
          "snippet": "int git_blob_create_frombuffer(\n\tgit_oid *id, git_repository *repo, const void *buffer, size_t len)\n{\n\tint error;\n\tgit_odb *odb;\n\tgit_odb_stream *stream;\n\n\tassert(id && repo);\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_open_wstream(&stream, odb, len, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((error = git_odb_stream_write(stream, buffer, len)) == 0)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob_create_frombuffer(\n\tgit_oid *id, git_repository *repo, const void *buffer, size_t len)\n{\n\tint error;\n\tgit_odb *odb;\n\tgit_odb_stream *stream;\n\n\tassert(id && repo);\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_open_wstream(&stream, odb, len, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tif ((error = git_odb_stream_write(stream, buffer, len)) == 0)\n\t\terror = git_odb_stream_finalize_write(id, stream);\n\n\tgit_odb_stream_free(stream);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_dup",
          "args": [
            "&entry",
            "index",
            "source_entry"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_dup_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1016-1026",
          "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"invalid filemode\""
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_filemode",
          "args": [
            "source_entry->mode"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "valid_filemode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1379-1385",
          "snippet": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\""
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && source_entry->path"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add_frombuffer(\n    git_index *index, const git_index_entry *source_entry,\n    const void *buffer, size_t len)\n{\n\tgit_index_entry *entry = NULL;\n\tint error = 0;\n\tgit_oid id;\n\n\tassert(index && source_entry->path);\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif (index_entry_dup(&entry, index, source_entry) < 0)\n\t\treturn -1;\n\n\terror = git_blob_create_frombuffer(&id, INDEX_OWNER(index), buffer, len);\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tgit_oid_cpy(&entry->id, &id);\n\tentry->file_size = len;\n\n\tif ((error = index_insert(index, &entry, 1, true, true, true)) < 0)\n\t\treturn error;\n\n\t/* Adding implies conflict was resolved, move conflict entries to REUC */\n\tif ((error = index_conflict_to_reuc(index, entry->path)) < 0 && error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
  },
  {
    "function_name": "valid_filemode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1379-1385",
    "snippet": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_BLOB ||\n\t\tfilemode == GIT_FILEMODE_BLOB_EXECUTABLE ||\n\t\tfilemode == GIT_FILEMODE_LINK ||\n\t\tfilemode == GIT_FILEMODE_COMMIT);\n}"
  },
  {
    "function_name": "index_conflict_to_reuc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1353-1377",
    "snippet": "static int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_conflict_remove",
          "args": [
            "index",
            "path"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_conflict_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1875-1879",
          "snippet": "int git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_remove(git_index *index, const char *path)\n{\n\tassert(index && path);\n\treturn index_conflict_remove(index, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_reuc_add",
          "args": [
            "index",
            "path",
            "ancestor_mode",
            "ancestor_oid",
            "our_mode",
            "our_oid",
            "their_mode",
            "their_oid"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_reuc_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2050-2066",
          "snippet": "int git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_reuc_add(git_index *index, const char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\tint error = 0;\n\n\tassert(index && path);\n\n\tif ((error = index_entry_reuc_init(&reuc, path, ancestor_mode,\n\t\t\tancestor_oid, our_mode, our_oid, their_mode, their_oid)) < 0 ||\n\t\t(error = index_reuc_insert(index, reuc)) < 0)\n\t\tindex_entry_reuc_free(reuc);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_conflict_get",
          "args": [
            "&conflict_entries[0]",
            "&conflict_entries[1]",
            "&conflict_entries[2]",
            "index",
            "path"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_conflict_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1820-1846",
          "snippet": "int git_index_conflict_get(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tconst char *path)\n{\n\tsize_t pos;\n\tint len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index && path);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tif (git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif ((len = index_conflict__get_byindex(\n\t\tancestor_out, our_out, their_out, index, pos)) < 0)\n\t\treturn len;\n\telse if (len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_conflict_get(\n\tconst git_index_entry **ancestor_out,\n\tconst git_index_entry **our_out,\n\tconst git_index_entry **their_out,\n\tgit_index *index,\n\tconst char *path)\n{\n\tsize_t pos;\n\tint len = 0;\n\n\tassert(ancestor_out && our_out && their_out && index && path);\n\n\t*ancestor_out = NULL;\n\t*our_out = NULL;\n\t*their_out = NULL;\n\n\tif (git_index_find(&pos, index, path) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif ((len = index_conflict__get_byindex(\n\t\tancestor_out, our_out, their_out, index, pos)) < 0)\n\t\treturn len;\n\telse if (len == 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_conflict_to_reuc(git_index *index, const char *path)\n{\n\tconst git_index_entry *conflict_entries[3];\n\tint ancestor_mode, our_mode, their_mode;\n\tgit_oid const *ancestor_oid, *our_oid, *their_oid;\n\tint ret;\n\n\tif ((ret = git_index_conflict_get(&conflict_entries[0],\n\t\t&conflict_entries[1], &conflict_entries[2], index, path)) < 0)\n\t\treturn ret;\n\n\tancestor_mode = conflict_entries[0] == NULL ? 0 : conflict_entries[0]->mode;\n\tour_mode = conflict_entries[1] == NULL ? 0 : conflict_entries[1]->mode;\n\ttheir_mode = conflict_entries[2] == NULL ? 0 : conflict_entries[2]->mode;\n\n\tancestor_oid = conflict_entries[0] == NULL ? NULL : &conflict_entries[0]->id;\n\tour_oid = conflict_entries[1] == NULL ? NULL : &conflict_entries[1]->id;\n\ttheir_oid = conflict_entries[2] == NULL ? NULL : &conflict_entries[2]->id;\n\n\tif ((ret = git_index_reuc_add(index, path, ancestor_mode, ancestor_oid,\n\t\tour_mode, our_oid, their_mode, their_oid)) >= 0)\n\t\tret = git_index_conflict_remove(index, path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "index_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1264-1351",
    "snippet": "static int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "*entry_ptr"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INSERT_IN_MAP",
          "args": [
            "index",
            "entry",
            "error"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert_sorted",
          "args": [
            "&index->entries",
            "entry",
            "index_no_dups"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert_sorted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "141-173",
          "snippet": "int git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)existing->path",
            "entry->path",
            "strlen(entry->path)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->path"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_cpy",
          "args": [
            "existing",
            "entry"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_cpy_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1006-1014",
          "snippet": "static void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_file_directory_collision",
          "args": [
            "index",
            "entry",
            "position",
            "replace"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "check_file_directory_collision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1111-1124",
          "snippet": "static int check_file_directory_collision(git_index *index,\n\t\tgit_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = has_file_name(index, entry, pos, ok_to_replace);\n\tretval = retval + has_dir_name(index, entry, ok_to_replace);\n\n\tif (retval) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"'%s' appears as both a file and a directory\", entry->path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int check_file_directory_collision(git_index *index,\n\t\tgit_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = has_file_name(index, entry, pos, ok_to_replace);\n\tretval = retval + has_dir_name(index, entry, ok_to_replace);\n\n\tif (retval) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"'%s' appears as both a file and a directory\", entry->path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__is_valid",
          "args": [
            "INDEX_OWNER(index)",
            "&entry->id",
            "git_object__type_from_filemode(entry->mode)"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__is_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "467-489",
          "snippet": "bool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool git_object__strict_input_validation = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nbool git_object__strict_input_validation = true;\n\nbool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__type_from_filemode",
          "args": [
            "entry->mode"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__type_from_filemode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.h",
          "lines": "38-52",
          "snippet": "GIT_INLINE(git_otype) git_object__type_from_filemode(git_filemode_t mode)\n{\n\tswitch (mode) {\n\tcase GIT_FILEMODE_TREE:\n\t\treturn GIT_OBJ_TREE;\n\tcase GIT_FILEMODE_COMMIT:\n\t\treturn GIT_OBJ_COMMIT;\n\tcase GIT_FILEMODE_BLOB:\n\tcase GIT_FILEMODE_BLOB_EXECUTABLE:\n\tcase GIT_FILEMODE_LINK:\n\t\treturn GIT_OBJ_BLOB;\n\tdefault:\n\t\treturn GIT_OBJ_BAD;\n\t}\n}",
          "includes": [
            "#include \"repository.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n\nGIT_INLINE(git_otype) git_object__type_from_filemode(git_filemode_t mode)\n{\n\tswitch (mode) {\n\tcase GIT_FILEMODE_TREE:\n\t\treturn GIT_OBJ_TREE;\n\tcase GIT_FILEMODE_COMMIT:\n\t\treturn GIT_OBJ_COMMIT;\n\tcase GIT_FILEMODE_BLOB:\n\tcase GIT_FILEMODE_BLOB_EXECUTABLE:\n\tcase GIT_FILEMODE_LINK:\n\t\treturn GIT_OBJ_BLOB;\n\tdefault:\n\t\treturn GIT_OBJ_BAD;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canonicalize_directory_path",
          "args": [
            "index",
            "entry",
            "best"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "canonicalize_directory_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1126-1194",
          "snippet": "static int canonicalize_directory_path(\n\tgit_index *index,\n\tgit_index_entry *entry,\n\tgit_index_entry *existing)\n{\n\tconst git_index_entry *match, *best = NULL;\n\tchar *search, *sep;\n\tsize_t pos, search_len, best_len;\n\n\tif (!index->ignore_case)\n\t\treturn 0;\n\n\t/* item already exists in the index, simply re-use the existing case */\n\tif (existing) {\n\t\tmemcpy((char *)entry->path, existing->path, strlen(existing->path));\n\t\treturn 0;\n\t}\n\n\t/* nothing to do */\n\tif (strchr(entry->path, '/') == NULL)\n\t\treturn 0;\n\n\tif ((search = git__strdup(entry->path)) == NULL)\n\t\treturn -1;\n\n\t/* starting at the parent directory and descending to the root, find the\n\t * common parent directory.\n\t */\n\twhile (!best && (sep = strrchr(search, '/'))) {\n\t\tsep[1] = '\\0';\n\n\t\tsearch_len = strlen(search);\n\n\t\tgit_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, search);\n\n\t\twhile ((match = git_vector_get(&index->entries, pos))) {\n\t\t\tif (GIT_IDXENTRY_STAGE(match) != 0) {\n\t\t\t\t/* conflicts do not contribute to canonical paths */\n\t\t\t} else if (strncmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* prefer an exact match to the input filename */\n\t\t\t\tbest = match;\n\t\t\t\tbest_len = search_len;\n\t\t\t\tbreak;\n\t\t\t} else if (strncasecmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* continue walking, there may be a path with an exact\n\t\t\t\t * (case sensitive) match later in the index, but use this\n\t\t\t\t * as the best match until that happens.\n\t\t\t\t */\n\t\t\t\tif (!best) {\n\t\t\t\t\tbest = match;\n\t\t\t\t\tbest_len = search_len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\n\t\tsep[0] = '\\0';\n\t}\n\n\tif (best)\n\t\tmemcpy((char *)entry->path, best->path, best_len);\n\n\tgit__free(search);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int canonicalize_directory_path(\n\tgit_index *index,\n\tgit_index_entry *entry,\n\tgit_index_entry *existing)\n{\n\tconst git_index_entry *match, *best = NULL;\n\tchar *search, *sep;\n\tsize_t pos, search_len, best_len;\n\n\tif (!index->ignore_case)\n\t\treturn 0;\n\n\t/* item already exists in the index, simply re-use the existing case */\n\tif (existing) {\n\t\tmemcpy((char *)entry->path, existing->path, strlen(existing->path));\n\t\treturn 0;\n\t}\n\n\t/* nothing to do */\n\tif (strchr(entry->path, '/') == NULL)\n\t\treturn 0;\n\n\tif ((search = git__strdup(entry->path)) == NULL)\n\t\treturn -1;\n\n\t/* starting at the parent directory and descending to the root, find the\n\t * common parent directory.\n\t */\n\twhile (!best && (sep = strrchr(search, '/'))) {\n\t\tsep[1] = '\\0';\n\n\t\tsearch_len = strlen(search);\n\n\t\tgit_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, search);\n\n\t\twhile ((match = git_vector_get(&index->entries, pos))) {\n\t\t\tif (GIT_IDXENTRY_STAGE(match) != 0) {\n\t\t\t\t/* conflicts do not contribute to canonical paths */\n\t\t\t} else if (strncmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* prefer an exact match to the input filename */\n\t\t\t\tbest = match;\n\t\t\t\tbest_len = search_len;\n\t\t\t\tbreak;\n\t\t\t} else if (strncasecmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* continue walking, there may be a path with an exact\n\t\t\t\t * (case sensitive) match later in the index, but use this\n\t\t\t\t * as the best match until that happens.\n\t\t\t\t */\n\t\t\t\tif (!best) {\n\t\t\t\t\tbest = match;\n\t\t\t\t\tbest_len = search_len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\n\t\tsep[0] = '\\0';\n\t}\n\n\tif (best)\n\t\tmemcpy((char *)entry->path, best->path, best_len);\n\n\tgit__free(search);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_merge_mode",
          "args": [
            "index",
            "best",
            "entry->mode"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "index_merge_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "345-357",
          "snippet": "static unsigned int index_merge_mode(\n\tgit_index *index, git_index_entry *existing, unsigned int mode)\n{\n\tif (index->no_symlinks && S_ISREG(mode) &&\n\t\texisting && S_ISLNK(existing->mode))\n\t\treturn existing->mode;\n\n\tif (index->distrust_filemode && S_ISREG(mode))\n\t\treturn (existing && S_ISREG(existing->mode)) ?\n\t\t\texisting->mode : git_index__create_mode(0666);\n\n\treturn git_index__create_mode(mode);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic unsigned int index_merge_mode(\n\tgit_index *index, git_index_entry *existing, unsigned int mode)\n{\n\tif (index->no_symlinks && S_ISREG(mode) &&\n\t\texisting && S_ISLNK(existing->mode))\n\t\treturn existing->mode;\n\n\tif (index->distrust_filemode && S_ISREG(mode))\n\t\treturn (existing && S_ISREG(existing->mode)) ?\n\t\t\texisting->mode : git_index__create_mode(0666);\n\n\treturn git_index__create_mode(mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index__create_mode",
          "args": [
            "entry->mode"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__create_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "334-343",
          "snippet": "unsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_existing_and_best",
          "args": [
            "&existing",
            "&position",
            "&best",
            "index",
            "entry"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "index_existing_and_best",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1205-1249",
          "snippet": "static void index_existing_and_best(\n\tgit_index_entry **existing,\n\tsize_t *existing_position,\n\tgit_index_entry **best,\n\tgit_index *index,\n\tconst git_index_entry *entry)\n{\n\tgit_index_entry *e;\n\tsize_t pos;\n\tint error;\n\n\terror = index_find(&pos,\n\t\tindex, entry->path, 0, GIT_IDXENTRY_STAGE(entry));\n\n\tif (error == 0) {\n\t\t*existing = index->entries.contents[pos];\n\t\t*existing_position = pos;\n\t\t*best = index->entries.contents[pos];\n\t\treturn;\n\t}\n\n\t*existing = NULL;\n\t*existing_position = 0;\n\t*best = NULL;\n\n\tif (GIT_IDXENTRY_STAGE(entry) == 0) {\n\t\tfor (; pos < index->entries.length; pos++) {\n\t\t\tint (*strcomp)(const char *a, const char *b) =\n\t\t\t\tindex->ignore_case ? git__strcasecmp : git__strcmp;\n\n\t\t\te = index->entries.contents[pos];\n\n\t\t\tif (strcomp(entry->path, e->path) != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (GIT_IDXENTRY_STAGE(e) == GIT_INDEX_STAGE_ANCESTOR) {\n\t\t\t\t*best = e;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*best = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_existing_and_best(\n\tgit_index_entry **existing,\n\tsize_t *existing_position,\n\tgit_index_entry **best,\n\tgit_index *index,\n\tconst git_index_entry *entry)\n{\n\tgit_index_entry *e;\n\tsize_t pos;\n\tint error;\n\n\terror = index_find(&pos,\n\t\tindex, entry->path, 0, GIT_IDXENTRY_STAGE(entry));\n\n\tif (error == 0) {\n\t\t*existing = index->entries.contents[pos];\n\t\t*existing_position = pos;\n\t\t*best = index->entries.contents[pos];\n\t\treturn;\n\t}\n\n\t*existing = NULL;\n\t*existing_position = 0;\n\t*best = NULL;\n\n\tif (GIT_IDXENTRY_STAGE(entry) == 0) {\n\t\tfor (; pos < index->entries.length; pos++) {\n\t\t\tint (*strcomp)(const char *a, const char *b) =\n\t\t\t\tindex->ignore_case ? git__strcasecmp : git__strcmp;\n\n\t\t\te = index->entries.contents[pos];\n\n\t\t\tif (strcomp(entry->path, e->path) != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (GIT_IDXENTRY_STAGE(e) == GIT_INDEX_STAGE_ANCESTOR) {\n\t\t\t\t*best = e;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*best = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_adjust_namemask",
          "args": [
            "entry",
            "path_length"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_adjust_namemask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "845-855",
          "snippet": "static void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index && entry_ptr"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_insert(\n\tgit_index *index,\n\tgit_index_entry **entry_ptr,\n\tint replace,\n\tbool trust_path,\n\tbool trust_mode,\n\tbool trust_id)\n{\n\tint error = 0;\n\tsize_t path_length, position;\n\tgit_index_entry *existing, *best, *entry;\n\n\tassert(index && entry_ptr);\n\n\tentry = *entry_ptr;\n\n\t/* make sure that the path length flag is correct */\n\tpath_length = ((struct entry_internal *)entry)->pathlen;\n\tindex_entry_adjust_namemask(entry, path_length);\n\n\t/* this entry is now up-to-date and should not be checked for raciness */\n\tentry->flags_extended |= GIT_IDXENTRY_UPTODATE;\n\n\tgit_vector_sort(&index->entries);\n\n\t/* look if an entry with this path already exists, either staged, or (if\n\t * this entry is a regular staged item) as the \"ours\" side of a conflict.\n\t */\n\tindex_existing_and_best(&existing, &position, &best, index, entry);\n\n\t/* update the file mode */\n\tentry->mode = trust_mode ?\n\t\tgit_index__create_mode(entry->mode) :\n\t\tindex_merge_mode(index, best, entry->mode);\n\n\t/* canonicalize the directory name */\n\tif (!trust_path)\n\t\terror = canonicalize_directory_path(index, entry, best);\n\n\t/* ensure that the given id exists (unless it's a submodule) */\n\tif (!error && !trust_id && INDEX_OWNER(index) &&\n\t\t(entry->mode & GIT_FILEMODE_COMMIT) != GIT_FILEMODE_COMMIT) {\n\n\t\tif (!git_object__is_valid(INDEX_OWNER(index), &entry->id,\n\t\t\tgit_object__type_from_filemode(entry->mode)))\n\t\t\terror = -1;\n\t}\n\n\t/* look for tree / blob name collisions, removing conflicts if requested */\n\tif (!error)\n\t\terror = check_file_directory_collision(index, entry, position, replace);\n\n\tif (error < 0)\n\t\t/* skip changes */;\n\n\t/* if we are replacing an existing item, overwrite the existing entry\n\t * and return it in place of the passed in one.\n\t */\n\telse if (existing) {\n\t\tif (replace) {\n\t\t\tindex_entry_cpy(existing, entry);\n\n\t\t\tif (trust_path)\n\t\t\t\tmemcpy((char *)existing->path, entry->path, strlen(entry->path));\n\t\t}\n\n\t\tindex_entry_free(entry);\n\t\t*entry_ptr = entry = existing;\n\t}\n\telse {\n\t\t/* if replace is not requested or no existing entry exists, insert\n\t\t * at the sorted position.  (Since we re-sort after each insert to\n\t\t * check for dups, this is actually cheaper in the long run.)\n\t\t */\n\t\terror = git_vector_insert_sorted(&index->entries, entry, index_no_dups);\n\n\t\tif (error == 0) {\n\t\t\tINSERT_IN_MAP(index, entry, error);\n\t\t}\n\t}\n\n\tif (error < 0) {\n\t\tindex_entry_free(*entry_ptr);\n\t\t*entry_ptr = NULL;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_existing_and_best",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1205-1249",
    "snippet": "static void index_existing_and_best(\n\tgit_index_entry **existing,\n\tsize_t *existing_position,\n\tgit_index_entry **best,\n\tgit_index *index,\n\tconst git_index_entry *entry)\n{\n\tgit_index_entry *e;\n\tsize_t pos;\n\tint error;\n\n\terror = index_find(&pos,\n\t\tindex, entry->path, 0, GIT_IDXENTRY_STAGE(entry));\n\n\tif (error == 0) {\n\t\t*existing = index->entries.contents[pos];\n\t\t*existing_position = pos;\n\t\t*best = index->entries.contents[pos];\n\t\treturn;\n\t}\n\n\t*existing = NULL;\n\t*existing_position = 0;\n\t*best = NULL;\n\n\tif (GIT_IDXENTRY_STAGE(entry) == 0) {\n\t\tfor (; pos < index->entries.length; pos++) {\n\t\t\tint (*strcomp)(const char *a, const char *b) =\n\t\t\t\tindex->ignore_case ? git__strcasecmp : git__strcmp;\n\n\t\t\te = index->entries.contents[pos];\n\n\t\t\tif (strcomp(entry->path, e->path) != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (GIT_IDXENTRY_STAGE(e) == GIT_INDEX_STAGE_ANCESTOR) {\n\t\t\t\t*best = e;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*best = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "e"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcomp",
          "args": [
            "entry->path",
            "e->path"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_find",
          "args": [
            "&pos",
            "index",
            "entry->path",
            "0",
            "GIT_IDXENTRY_STAGE(entry)"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "370-378",
          "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_existing_and_best(\n\tgit_index_entry **existing,\n\tsize_t *existing_position,\n\tgit_index_entry **best,\n\tgit_index *index,\n\tconst git_index_entry *entry)\n{\n\tgit_index_entry *e;\n\tsize_t pos;\n\tint error;\n\n\terror = index_find(&pos,\n\t\tindex, entry->path, 0, GIT_IDXENTRY_STAGE(entry));\n\n\tif (error == 0) {\n\t\t*existing = index->entries.contents[pos];\n\t\t*existing_position = pos;\n\t\t*best = index->entries.contents[pos];\n\t\treturn;\n\t}\n\n\t*existing = NULL;\n\t*existing_position = 0;\n\t*best = NULL;\n\n\tif (GIT_IDXENTRY_STAGE(entry) == 0) {\n\t\tfor (; pos < index->entries.length; pos++) {\n\t\t\tint (*strcomp)(const char *a, const char *b) =\n\t\t\t\tindex->ignore_case ? git__strcasecmp : git__strcmp;\n\n\t\t\te = index->entries.contents[pos];\n\n\t\t\tif (strcomp(entry->path, e->path) != 0)\n\t\t\t\tbreak;\n\n\t\t\tif (GIT_IDXENTRY_STAGE(e) == GIT_INDEX_STAGE_ANCESTOR) {\n\t\t\t\t*best = e;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t*best = e;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "index_no_dups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1196-1203",
    "snippet": "static int index_no_dups(void **old, void *new)\n{\n\tconst git_index_entry *entry = new;\n\tGIT_UNUSED(old);\n\tgiterr_set(GITERR_INDEX, \"'%s' appears multiple times at stage %d\",\n\t\tentry->path, GIT_IDXENTRY_STAGE(entry));\n\treturn GIT_EEXISTS;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"'%s' appears multiple times at stage %d\"",
            "entry->path",
            "GIT_IDXENTRY_STAGE(entry)"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "old"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_no_dups(void **old, void *new)\n{\n\tconst git_index_entry *entry = new;\n\tGIT_UNUSED(old);\n\tgiterr_set(GITERR_INDEX, \"'%s' appears multiple times at stage %d\",\n\t\tentry->path, GIT_IDXENTRY_STAGE(entry));\n\treturn GIT_EEXISTS;\n}"
  },
  {
    "function_name": "canonicalize_directory_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1126-1194",
    "snippet": "static int canonicalize_directory_path(\n\tgit_index *index,\n\tgit_index_entry *entry,\n\tgit_index_entry *existing)\n{\n\tconst git_index_entry *match, *best = NULL;\n\tchar *search, *sep;\n\tsize_t pos, search_len, best_len;\n\n\tif (!index->ignore_case)\n\t\treturn 0;\n\n\t/* item already exists in the index, simply re-use the existing case */\n\tif (existing) {\n\t\tmemcpy((char *)entry->path, existing->path, strlen(existing->path));\n\t\treturn 0;\n\t}\n\n\t/* nothing to do */\n\tif (strchr(entry->path, '/') == NULL)\n\t\treturn 0;\n\n\tif ((search = git__strdup(entry->path)) == NULL)\n\t\treturn -1;\n\n\t/* starting at the parent directory and descending to the root, find the\n\t * common parent directory.\n\t */\n\twhile (!best && (sep = strrchr(search, '/'))) {\n\t\tsep[1] = '\\0';\n\n\t\tsearch_len = strlen(search);\n\n\t\tgit_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, search);\n\n\t\twhile ((match = git_vector_get(&index->entries, pos))) {\n\t\t\tif (GIT_IDXENTRY_STAGE(match) != 0) {\n\t\t\t\t/* conflicts do not contribute to canonical paths */\n\t\t\t} else if (strncmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* prefer an exact match to the input filename */\n\t\t\t\tbest = match;\n\t\t\t\tbest_len = search_len;\n\t\t\t\tbreak;\n\t\t\t} else if (strncasecmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* continue walking, there may be a path with an exact\n\t\t\t\t * (case sensitive) match later in the index, but use this\n\t\t\t\t * as the best match until that happens.\n\t\t\t\t */\n\t\t\t\tif (!best) {\n\t\t\t\t\tbest = match;\n\t\t\t\t\tbest_len = search_len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\n\t\tsep[0] = '\\0';\n\t}\n\n\tif (best)\n\t\tmemcpy((char *)entry->path, best->path, best_len);\n\n\tgit__free(search);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "search"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)entry->path",
            "best->path",
            "best_len"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "search",
            "match->path",
            "search_len"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "search",
            "match->path",
            "search_len"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "match"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "pos"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "&pos",
            "&index->entries",
            "index->entries_search_path",
            "search"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "search"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "search",
            "'/'"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "entry->path"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "entry->path",
            "'/'"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)entry->path",
            "existing->path",
            "strlen(existing->path)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "existing->path"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int canonicalize_directory_path(\n\tgit_index *index,\n\tgit_index_entry *entry,\n\tgit_index_entry *existing)\n{\n\tconst git_index_entry *match, *best = NULL;\n\tchar *search, *sep;\n\tsize_t pos, search_len, best_len;\n\n\tif (!index->ignore_case)\n\t\treturn 0;\n\n\t/* item already exists in the index, simply re-use the existing case */\n\tif (existing) {\n\t\tmemcpy((char *)entry->path, existing->path, strlen(existing->path));\n\t\treturn 0;\n\t}\n\n\t/* nothing to do */\n\tif (strchr(entry->path, '/') == NULL)\n\t\treturn 0;\n\n\tif ((search = git__strdup(entry->path)) == NULL)\n\t\treturn -1;\n\n\t/* starting at the parent directory and descending to the root, find the\n\t * common parent directory.\n\t */\n\twhile (!best && (sep = strrchr(search, '/'))) {\n\t\tsep[1] = '\\0';\n\n\t\tsearch_len = strlen(search);\n\n\t\tgit_vector_bsearch2(\n\t\t\t&pos, &index->entries, index->entries_search_path, search);\n\n\t\twhile ((match = git_vector_get(&index->entries, pos))) {\n\t\t\tif (GIT_IDXENTRY_STAGE(match) != 0) {\n\t\t\t\t/* conflicts do not contribute to canonical paths */\n\t\t\t} else if (strncmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* prefer an exact match to the input filename */\n\t\t\t\tbest = match;\n\t\t\t\tbest_len = search_len;\n\t\t\t\tbreak;\n\t\t\t} else if (strncasecmp(search, match->path, search_len) == 0) {\n\t\t\t\t/* continue walking, there may be a path with an exact\n\t\t\t\t * (case sensitive) match later in the index, but use this\n\t\t\t\t * as the best match until that happens.\n\t\t\t\t */\n\t\t\t\tif (!best) {\n\t\t\t\t\tbest = match;\n\t\t\t\t\tbest_len = search_len;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos++;\n\t\t}\n\n\t\tsep[0] = '\\0';\n\t}\n\n\tif (best)\n\t\tmemcpy((char *)entry->path, best->path, best_len);\n\n\tgit__free(search);\n\treturn 0;\n}"
  },
  {
    "function_name": "check_file_directory_collision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1111-1124",
    "snippet": "static int check_file_directory_collision(git_index *index,\n\t\tgit_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = has_file_name(index, entry, pos, ok_to_replace);\n\tretval = retval + has_dir_name(index, entry, ok_to_replace);\n\n\tif (retval) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"'%s' appears as both a file and a directory\", entry->path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"'%s' appears as both a file and a directory\"",
            "entry->path"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_dir_name",
          "args": [
            "index",
            "entry",
            "ok_to_replace"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "has_dir_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1061-1109",
          "snippet": "static int has_dir_name(git_index *index,\n\t\tconst git_index_entry *entry, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\tconst char *slash = name + strlen(name);\n\n\tfor (;;) {\n\t\tsize_t len, pos;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= entry->path)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tif (!index_find(&pos, index, name, len, stage)) {\n\t\t\tretval = -1;\n\t\t\tif (!ok_to_replace)\n\t\t\t\tbreak;\n\n\t\t\tif (index_remove_entry(index, pos) < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\tfor (; pos < index->entries.length; ++pos) {\n\t\t\tstruct entry_internal *p = index->entries.contents[pos];\n\n\t\t\tif (p->pathlen <= len ||\n\t\t\t    p->path[len] != '/' ||\n\t\t\t    memcmp(p->path, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\n\t\t\tif (GIT_IDXENTRY_STAGE(&p->entry) == stage)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int has_dir_name(git_index *index,\n\t\tconst git_index_entry *entry, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\tconst char *slash = name + strlen(name);\n\n\tfor (;;) {\n\t\tsize_t len, pos;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= entry->path)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tif (!index_find(&pos, index, name, len, stage)) {\n\t\t\tretval = -1;\n\t\t\tif (!ok_to_replace)\n\t\t\t\tbreak;\n\n\t\t\tif (index_remove_entry(index, pos) < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\tfor (; pos < index->entries.length; ++pos) {\n\t\t\tstruct entry_internal *p = index->entries.contents[pos];\n\n\t\t\tif (p->pathlen <= len ||\n\t\t\t    p->path[len] != '/' ||\n\t\t\t    memcmp(p->path, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\n\t\t\tif (GIT_IDXENTRY_STAGE(&p->entry) == stage)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_file_name",
          "args": [
            "index",
            "entry",
            "pos",
            "ok_to_replace"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "has_file_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1028-1055",
          "snippet": "static int has_file_name(git_index *index,\n\t const git_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tsize_t len = strlen(entry->path);\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\n\twhile (pos < index->entries.length) {\n\t\tstruct entry_internal *p = index->entries.contents[pos++];\n\n\t\tif (len >= p->pathlen)\n\t\t\tbreak;\n\t\tif (memcmp(name, p->path, len))\n\t\t\tbreak;\n\t\tif (GIT_IDXENTRY_STAGE(&p->entry) != stage)\n\t\t\tcontinue;\n\t\tif (p->path[len] != '/')\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\n\t\tif (index_remove_entry(index, --pos) < 0)\n\t\t\tbreak;\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int has_file_name(git_index *index,\n\t const git_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tsize_t len = strlen(entry->path);\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\n\twhile (pos < index->entries.length) {\n\t\tstruct entry_internal *p = index->entries.contents[pos++];\n\n\t\tif (len >= p->pathlen)\n\t\t\tbreak;\n\t\tif (memcmp(name, p->path, len))\n\t\t\tbreak;\n\t\tif (GIT_IDXENTRY_STAGE(&p->entry) != stage)\n\t\t\tcontinue;\n\t\tif (p->path[len] != '/')\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\n\t\tif (index_remove_entry(index, --pos) < 0)\n\t\t\tbreak;\n\t}\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int check_file_directory_collision(git_index *index,\n\t\tgit_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = has_file_name(index, entry, pos, ok_to_replace);\n\tretval = retval + has_dir_name(index, entry, ok_to_replace);\n\n\tif (retval) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"'%s' appears as both a file and a directory\", entry->path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "has_dir_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1061-1109",
    "snippet": "static int has_dir_name(git_index *index,\n\t\tconst git_index_entry *entry, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\tconst char *slash = name + strlen(name);\n\n\tfor (;;) {\n\t\tsize_t len, pos;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= entry->path)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tif (!index_find(&pos, index, name, len, stage)) {\n\t\t\tretval = -1;\n\t\t\tif (!ok_to_replace)\n\t\t\t\tbreak;\n\n\t\t\tif (index_remove_entry(index, pos) < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\tfor (; pos < index->entries.length; ++pos) {\n\t\t\tstruct entry_internal *p = index->entries.contents[pos];\n\n\t\t\tif (p->pathlen <= len ||\n\t\t\t    p->path[len] != '/' ||\n\t\t\t    memcmp(p->path, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\n\t\t\tif (GIT_IDXENTRY_STAGE(&p->entry) == stage)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "&p->entry"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "p->path",
            "name",
            "len"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_remove_entry",
          "args": [
            "index",
            "pos"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "index_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "503-524",
          "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_find",
          "args": [
            "&pos",
            "index",
            "name",
            "len",
            "stage"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "index_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "370-378",
          "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int has_dir_name(git_index *index,\n\t\tconst git_index_entry *entry, int ok_to_replace)\n{\n\tint retval = 0;\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\tconst char *slash = name + strlen(name);\n\n\tfor (;;) {\n\t\tsize_t len, pos;\n\n\t\tfor (;;) {\n\t\t\tif (*--slash == '/')\n\t\t\t\tbreak;\n\t\t\tif (slash <= entry->path)\n\t\t\t\treturn retval;\n\t\t}\n\t\tlen = slash - name;\n\n\t\tif (!index_find(&pos, index, name, len, stage)) {\n\t\t\tretval = -1;\n\t\t\tif (!ok_to_replace)\n\t\t\t\tbreak;\n\n\t\t\tif (index_remove_entry(index, pos) < 0)\n\t\t\t\tbreak;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Trivial optimization: if we find an entry that\n\t\t * already matches the sub-directory, then we know\n\t\t * we're ok, and we can exit.\n\t\t */\n\t\tfor (; pos < index->entries.length; ++pos) {\n\t\t\tstruct entry_internal *p = index->entries.contents[pos];\n\n\t\t\tif (p->pathlen <= len ||\n\t\t\t    p->path[len] != '/' ||\n\t\t\t    memcmp(p->path, name, len))\n\t\t\t\tbreak; /* not our subdirectory */\n\n\t\t\tif (GIT_IDXENTRY_STAGE(&p->entry) == stage)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "has_file_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1028-1055",
    "snippet": "static int has_file_name(git_index *index,\n\t const git_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tsize_t len = strlen(entry->path);\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\n\twhile (pos < index->entries.length) {\n\t\tstruct entry_internal *p = index->entries.contents[pos++];\n\n\t\tif (len >= p->pathlen)\n\t\t\tbreak;\n\t\tif (memcmp(name, p->path, len))\n\t\t\tbreak;\n\t\tif (GIT_IDXENTRY_STAGE(&p->entry) != stage)\n\t\t\tcontinue;\n\t\tif (p->path[len] != '/')\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\n\t\tif (index_remove_entry(index, --pos) < 0)\n\t\t\tbreak;\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_remove_entry",
          "args": [
            "index",
            "--pos"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "index_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "503-524",
          "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "&p->entry"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "p->path",
            "len"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->path"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int has_file_name(git_index *index,\n\t const git_index_entry *entry, size_t pos, int ok_to_replace)\n{\n\tint retval = 0;\n\tsize_t len = strlen(entry->path);\n\tint stage = GIT_IDXENTRY_STAGE(entry);\n\tconst char *name = entry->path;\n\n\twhile (pos < index->entries.length) {\n\t\tstruct entry_internal *p = index->entries.contents[pos++];\n\n\t\tif (len >= p->pathlen)\n\t\t\tbreak;\n\t\tif (memcmp(name, p->path, len))\n\t\t\tbreak;\n\t\tif (GIT_IDXENTRY_STAGE(&p->entry) != stage)\n\t\t\tcontinue;\n\t\tif (p->path[len] != '/')\n\t\t\tcontinue;\n\t\tretval = -1;\n\t\tif (!ok_to_replace)\n\t\t\tbreak;\n\n\t\tif (index_remove_entry(index, --pos) < 0)\n\t\t\tbreak;\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "index_entry_dup_nocache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1016-1026",
    "snippet": "static int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_cpy_nocache",
          "args": [
            "*out",
            "src"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_cpy_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1006-1014",
          "snippet": "static void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_create",
          "args": [
            "out",
            "INDEX_OWNER(index)",
            "src->path",
            "false"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "863-896",
          "snippet": "static int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup_nocache(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy_nocache(*out, src);\n\treturn 0;\n}"
  },
  {
    "function_name": "index_entry_cpy_nocache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "1006-1014",
    "snippet": "static void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&tgt->id",
            "&src->id"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}"
  },
  {
    "function_name": "index_entry_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "994-1004",
    "snippet": "static int index_entry_dup(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy(*out, src);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_cpy",
          "args": [
            "*out",
            "src"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_cpy_nocache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1006-1014",
          "snippet": "static void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_cpy_nocache(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tgit_oid_cpy(&tgt->id, &src->id);\n\ttgt->mode = src->mode;\n\ttgt->flags = src->flags;\n\ttgt->flags_extended = (src->flags_extended & GIT_IDXENTRY_EXTENDED_FLAGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_create",
          "args": [
            "out",
            "INDEX_OWNER(index)",
            "src->path",
            "false"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "863-896",
          "snippet": "static int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic int index_entry_dup(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst git_index_entry *src)\n{\n\tif (index_entry_create(out, INDEX_OWNER(index), src->path, false) < 0)\n\t\treturn -1;\n\n\tindex_entry_cpy(*out, src);\n\treturn 0;\n}"
  },
  {
    "function_name": "index_entry_cpy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "985-992",
    "snippet": "static void index_entry_cpy(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tconst char *tgt_path = tgt->path;\n\tmemcpy(tgt, src, sizeof(*tgt));\n\ttgt->path = tgt_path;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tgt",
            "src",
            "sizeof(*tgt)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_cpy(\n\tgit_index_entry *tgt,\n\tconst git_index_entry *src)\n{\n\tconst char *tgt_path = tgt->path;\n\tmemcpy(tgt, src, sizeof(*tgt));\n\ttgt->path = tgt_path;\n}"
  },
  {
    "function_name": "index_entry_reuc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "954-983",
    "snippet": "static int index_entry_reuc_init(git_index_reuc_entry **reuc_out,\n\tconst char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\n\tassert(reuc_out && path);\n\n\t*reuc_out = reuc = reuc_entry_alloc(path);\n\tGITERR_CHECK_ALLOC(reuc);\n\n\tif ((reuc->mode[0] = ancestor_mode) > 0) {\n\t\tassert(ancestor_oid);\n\t\tgit_oid_cpy(&reuc->oid[0], ancestor_oid);\n\t}\n\n\tif ((reuc->mode[1] = our_mode) > 0) {\n\t\tassert(our_oid);\n\t\tgit_oid_cpy(&reuc->oid[1], our_oid);\n\t}\n\n\tif ((reuc->mode[2] = their_mode) > 0) {\n\t\tassert(their_oid);\n\t\tgit_oid_cpy(&reuc->oid[2], their_oid);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&reuc->oid[2]",
            "their_oid"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "their_oid"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "our_oid"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ancestor_oid"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "reuc"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuc_entry_alloc",
          "args": [
            "path"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "reuc_entry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "932-952",
          "snippet": "static git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "reuc_out && path"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int index_entry_reuc_init(git_index_reuc_entry **reuc_out,\n\tconst char *path,\n\tint ancestor_mode, const git_oid *ancestor_oid,\n\tint our_mode, const git_oid *our_oid,\n\tint their_mode, const git_oid *their_oid)\n{\n\tgit_index_reuc_entry *reuc = NULL;\n\n\tassert(reuc_out && path);\n\n\t*reuc_out = reuc = reuc_entry_alloc(path);\n\tGITERR_CHECK_ALLOC(reuc);\n\n\tif ((reuc->mode[0] = ancestor_mode) > 0) {\n\t\tassert(ancestor_oid);\n\t\tgit_oid_cpy(&reuc->oid[0], ancestor_oid);\n\t}\n\n\tif ((reuc->mode[1] = our_mode) > 0) {\n\t\tassert(our_oid);\n\t\tgit_oid_cpy(&reuc->oid[1], our_oid);\n\t}\n\n\tif ((reuc->mode[2] = their_mode) > 0) {\n\t\tassert(their_oid);\n\t\tgit_oid_cpy(&reuc->oid[2], their_oid);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reuc_entry_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "932-952",
    "snippet": "static git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->path",
            "path",
            "pathlen"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloclen"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloclen",
            "alloclen",
            "1"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_ADD_SIZET_OVERFLOW",
          "args": [
            "&alloclen",
            "structlen",
            "pathlen"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic git_index_reuc_entry *reuc_entry_alloc(const char *path)\n{\n\tsize_t pathlen = strlen(path),\n\t\tstructlen = sizeof(struct reuc_entry_internal),\n\t\talloclen;\n\tstruct reuc_entry_internal *entry;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, structlen, pathlen) ||\n\t\tGIT_ADD_SIZET_OVERFLOW(&alloclen, alloclen, 1))\n\t\treturn NULL;\n\n\tentry = git__calloc(1, alloclen);\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\treturn (git_index_reuc_entry *)entry;\n}"
  },
  {
    "function_name": "index_entry_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "898-930",
    "snippet": "static int index_entry_init(\n\tgit_index_entry **entry_out,\n\tgit_index *index,\n\tconst char *rel_path)\n{\n\tint error = 0;\n\tgit_index_entry *entry = NULL;\n\tstruct stat st;\n\tgit_oid oid;\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), rel_path, true) < 0)\n\t\treturn -1;\n\n\t/* write the blob to disk and get the oid and stat info */\n\terror = git_blob__create_from_paths(\n\t\t&oid, &st, INDEX_OWNER(index), NULL, rel_path, 0, true);\n\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tentry->id = oid;\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\t*entry_out = (git_index_entry *)entry;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_entry__init_from_stat",
          "args": [
            "entry",
            "&st",
            "!index->distrust_filemode"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry__init_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "827-843",
          "snippet": "void git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entry"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob__create_from_paths",
          "args": [
            "&oid",
            "&st",
            "INDEX_OWNER(index)",
            "NULL",
            "rel_path",
            "0",
            "true"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob__create_from_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "155-244",
          "snippet": "int git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_blob__create_from_paths(\n\tgit_oid *id,\n\tstruct stat *out_st,\n\tgit_repository *repo,\n\tconst char *content_path,\n\tconst char *hint_path,\n\tmode_t hint_mode,\n\tbool try_load_filters)\n{\n\tint error;\n\tstruct stat st;\n\tgit_odb *odb = NULL;\n\tgit_off_t size;\n\tmode_t mode;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tassert(hint_path || !try_load_filters);\n\n\tif (!content_path) {\n\t\tif (git_repository__ensure_not_bare(repo, \"create blob from file\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\n\t\tif (git_buf_joinpath(\n\t\t\t\t&path, git_repository_workdir(repo), hint_path) < 0)\n\t\t\treturn -1;\n\n\t\tcontent_path = path.ptr;\n\t}\n\n\tif ((error = git_path_lstat(content_path, &st)) < 0 ||\n\t\t(error = git_repository_odb(&odb, repo)) < 0)\n\t\tgoto done;\n\n\tif (S_ISDIR(st.st_mode)) {\n\t\tgiterr_set(GITERR_ODB, \"cannot create blob from '%s'; it is a directory\", content_path);\n\t\terror = GIT_EDIRECTORY;\n\t\tgoto done;\n\t}\n\n\tif (out_st)\n\t\tmemcpy(out_st, &st, sizeof(st));\n\n\tsize = st.st_size;\n\tmode = hint_mode ? hint_mode : st.st_mode;\n\n\tif (S_ISLNK(mode)) {\n\t\terror = write_symlink(id, odb, content_path, (size_t)size);\n\t} else {\n\t\tgit_filter_list *fl = NULL;\n\n\t\tif (try_load_filters)\n\t\t\t/* Load the filters for writing this file to the ODB */\n\t\t\terror = git_filter_list_load(\n\t\t\t\t&fl, repo, NULL, hint_path,\n\t\t\t\tGIT_FILTER_TO_ODB, GIT_FILTER_DEFAULT);\n\n\t\tif (error < 0)\n\t\t\t/* well, that didn't work */;\n\t\telse if (fl == NULL)\n\t\t\t/* No filters need to be applied to the document: we can stream\n\t\t\t * directly from disk */\n\t\t\terror = write_file_stream(id, odb, content_path, size);\n\t\telse {\n\t\t\t/* We need to apply one or more filters */\n\t\t\terror = write_file_filtered(id, &size, odb, content_path, fl);\n\n\t\t\tgit_filter_list_free(fl);\n\t\t}\n\n\t\t/*\n\t\t * TODO: eventually support streaming filtered files, for files\n\t\t * which are bigger than a given threshold. This is not a priority\n\t\t * because applying a filter in streaming mode changes the final\n\t\t * size of the blob, and without knowing its final size, the blob\n\t\t * cannot be written in stream mode to the ODB.\n\t\t *\n\t\t * The plan is to do streaming writes to a tempfile on disk and then\n\t\t * opening streaming that file to the ODB, using\n\t\t * `write_file_stream`.\n\t\t *\n\t\t * CAREFULLY DESIGNED APIS YO\n\t\t */\n\t}\n\ndone:\n\tgit_odb_free(odb);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_entry_create",
          "args": [
            "&entry",
            "INDEX_OWNER(index)",
            "rel_path",
            "true"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "863-896",
          "snippet": "static int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\""
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_init(\n\tgit_index_entry **entry_out,\n\tgit_index *index,\n\tconst char *rel_path)\n{\n\tint error = 0;\n\tgit_index_entry *entry = NULL;\n\tstruct stat st;\n\tgit_oid oid;\n\n\tif (INDEX_OWNER(index) == NULL)\n\t\treturn create_index_error(-1,\n\t\t\t\"Could not initialize index entry. \"\n\t\t\t\"Index is not backed up by an existing repository.\");\n\n\tif (index_entry_create(&entry, INDEX_OWNER(index), rel_path, true) < 0)\n\t\treturn -1;\n\n\t/* write the blob to disk and get the oid and stat info */\n\terror = git_blob__create_from_paths(\n\t\t&oid, &st, INDEX_OWNER(index), NULL, rel_path, 0, true);\n\n\tif (error < 0) {\n\t\tindex_entry_free(entry);\n\t\treturn error;\n\t}\n\n\tentry->id = oid;\n\tgit_index_entry__init_from_stat(entry, &st, !index->distrust_filemode);\n\n\t*entry_out = (git_index_entry *)entry;\n\treturn 0;\n}"
  },
  {
    "function_name": "index_entry_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "863-896",
    "snippet": "static int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->path",
            "path",
            "pathlen"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloclen"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "1"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "sizeof(struct entry_internal)",
            "pathlen"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"invalid path: '%s'\"",
            "path"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isvalid",
          "args": [
            "repo",
            "path",
            "path_valid_flags"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1677-1701",
          "snippet": "bool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_create(\n\tgit_index_entry **out,\n\tgit_repository *repo,\n\tconst char *path,\n\tbool from_workdir)\n{\n\tsize_t pathlen = strlen(path), alloclen;\n\tstruct entry_internal *entry;\n\tunsigned int path_valid_flags = GIT_PATH_REJECT_INDEX_DEFAULTS;\n\n\t/* always reject placing `.git` in the index and directory traversal.\n\t * when requested, disallow platform-specific filenames and upgrade to\n\t * the platform-specific `.git` tests (eg, `git~1`, etc).\n\t */\n\tif (from_workdir)\n\t\tpath_valid_flags |= GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (!git_path_isvalid(repo, path, path_valid_flags)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid path: '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(struct entry_internal), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tentry = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(entry);\n\n\tentry->pathlen = pathlen;\n\tmemcpy(entry->path, path, pathlen);\n\tentry->entry.path = entry->path;\n\n\t*out = (git_index_entry *)entry;\n\treturn 0;\n}"
  },
  {
    "function_name": "index_entry_adjust_namemask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "845-855",
    "snippet": "static void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_adjust_namemask(\n\t\tgit_index_entry *entry,\n\t\tsize_t path_length)\n{\n\tentry->flags &= ~GIT_IDXENTRY_NAMEMASK;\n\n\tif (path_length < GIT_IDXENTRY_NAMEMASK)\n\t\tentry->flags |= path_length & GIT_IDXENTRY_NAMEMASK;\n\telse\n\t\tentry->flags |= GIT_IDXENTRY_NAMEMASK;\n}"
  },
  {
    "function_name": "git_index_entry__init_from_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "827-843",
    "snippet": "void git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index__create_mode",
          "args": [
            "st->st_mode"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__create_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "334-343",
          "snippet": "unsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "st->st_mode"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}"
  },
  {
    "function_name": "git_index_get_bypath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "807-825",
    "snippet": "const git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Index does not contain %s\"",
            "path"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_value_at",
          "args": [
            "index->entries_map",
            "pos"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_idxmap_valid_index",
          "args": [
            "index->entries_map",
            "pos"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOOKUP_IN_MAP",
          "args": [
            "pos",
            "index",
            "&key"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE_SET",
          "args": [
            "&key",
            "stage"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_index_get_byindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "799-805",
    "snippet": "const git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "n"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_byindex(\n\tgit_index *index, size_t n)\n{\n\tassert(index);\n\tgit_vector_sort(&index->entries);\n\treturn git_vector_get(&index->entries, n);\n}"
  },
  {
    "function_name": "git_index_entrycount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "793-797",
    "snippet": "size_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nsize_t git_index_entrycount(const git_index *index)\n{\n\tassert(index);\n\treturn index->entries.length;\n}"
  },
  {
    "function_name": "git_index_write_tree_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "786-791",
    "snippet": "int git_index_write_tree_to(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tassert(oid && index && repo);\n\treturn git_tree__write_index(oid, index, repo);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree__write_index",
          "args": [
            "oid",
            "index",
            "repo"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree__write_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "619-669",
          "snippet": "int git_tree__write_index(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tint ret;\n\tgit_tree *tree;\n\tbool old_ignore_case = false;\n\n\tassert(oid && index && repo);\n\n\tif (git_index_has_conflicts(index)) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"Cannot create a tree from a not fully merged index.\");\n\t\treturn GIT_EUNMERGED;\n\t}\n\n\tif (index->tree != NULL && index->tree->entry_count >= 0) {\n\t\tgit_oid_cpy(oid, &index->tree->oid);\n\t\treturn 0;\n\t}\n\n\t/* The tree cache didn't help us; we'll have to write\n\t * out a tree. If the index is ignore_case, we must\n\t * make it case-sensitive for the duration of the tree-write\n\t * operation. */\n\n\tif (index->ignore_case) {\n\t\told_ignore_case = true;\n\t\tgit_index__set_ignore_case(index, false);\n\t}\n\n\tret = write_tree(oid, repo, index, \"\", 0);\n\n\tif (old_ignore_case)\n\t\tgit_index__set_ignore_case(index, true);\n\n\tindex->tree = NULL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgit_pool_clear(&index->tree_pool);\n\n\tif ((ret = git_tree_lookup(&tree, repo, oid)) < 0)\n\t\treturn ret;\n\n\t/* Read the tree cache into the index */\n\tret = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\tgit_tree_free(tree);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree__write_index(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tint ret;\n\tgit_tree *tree;\n\tbool old_ignore_case = false;\n\n\tassert(oid && index && repo);\n\n\tif (git_index_has_conflicts(index)) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"Cannot create a tree from a not fully merged index.\");\n\t\treturn GIT_EUNMERGED;\n\t}\n\n\tif (index->tree != NULL && index->tree->entry_count >= 0) {\n\t\tgit_oid_cpy(oid, &index->tree->oid);\n\t\treturn 0;\n\t}\n\n\t/* The tree cache didn't help us; we'll have to write\n\t * out a tree. If the index is ignore_case, we must\n\t * make it case-sensitive for the duration of the tree-write\n\t * operation. */\n\n\tif (index->ignore_case) {\n\t\told_ignore_case = true;\n\t\tgit_index__set_ignore_case(index, false);\n\t}\n\n\tret = write_tree(oid, repo, index, \"\", 0);\n\n\tif (old_ignore_case)\n\t\tgit_index__set_ignore_case(index, true);\n\n\tindex->tree = NULL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgit_pool_clear(&index->tree_pool);\n\n\tif ((ret = git_tree_lookup(&tree, repo, oid)) < 0)\n\t\treturn ret;\n\n\t/* Read the tree cache into the index */\n\tret = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\tgit_tree_free(tree);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "oid && index && repo"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write_tree_to(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tassert(oid && index && repo);\n\treturn git_tree__write_index(oid, index, repo);\n}"
  },
  {
    "function_name": "git_index_write_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "771-784",
    "snippet": "int git_index_write_tree(git_oid *oid, git_index *index)\n{\n\tgit_repository *repo;\n\n\tassert(oid && index);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (repo == NULL)\n\t\treturn create_index_error(-1, \"Failed to write tree. \"\n\t\t  \"The index file is not backed up by an existing repository\");\n\n\treturn git_tree__write_index(oid, index, repo);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree__write_index",
          "args": [
            "oid",
            "index",
            "repo"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree__write_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "619-669",
          "snippet": "int git_tree__write_index(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tint ret;\n\tgit_tree *tree;\n\tbool old_ignore_case = false;\n\n\tassert(oid && index && repo);\n\n\tif (git_index_has_conflicts(index)) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"Cannot create a tree from a not fully merged index.\");\n\t\treturn GIT_EUNMERGED;\n\t}\n\n\tif (index->tree != NULL && index->tree->entry_count >= 0) {\n\t\tgit_oid_cpy(oid, &index->tree->oid);\n\t\treturn 0;\n\t}\n\n\t/* The tree cache didn't help us; we'll have to write\n\t * out a tree. If the index is ignore_case, we must\n\t * make it case-sensitive for the duration of the tree-write\n\t * operation. */\n\n\tif (index->ignore_case) {\n\t\told_ignore_case = true;\n\t\tgit_index__set_ignore_case(index, false);\n\t}\n\n\tret = write_tree(oid, repo, index, \"\", 0);\n\n\tif (old_ignore_case)\n\t\tgit_index__set_ignore_case(index, true);\n\n\tindex->tree = NULL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgit_pool_clear(&index->tree_pool);\n\n\tif ((ret = git_tree_lookup(&tree, repo, oid)) < 0)\n\t\treturn ret;\n\n\t/* Read the tree cache into the index */\n\tret = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\tgit_tree_free(tree);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree__write_index(\n\tgit_oid *oid, git_index *index, git_repository *repo)\n{\n\tint ret;\n\tgit_tree *tree;\n\tbool old_ignore_case = false;\n\n\tassert(oid && index && repo);\n\n\tif (git_index_has_conflicts(index)) {\n\t\tgiterr_set(GITERR_INDEX,\n\t\t\t\"Cannot create a tree from a not fully merged index.\");\n\t\treturn GIT_EUNMERGED;\n\t}\n\n\tif (index->tree != NULL && index->tree->entry_count >= 0) {\n\t\tgit_oid_cpy(oid, &index->tree->oid);\n\t\treturn 0;\n\t}\n\n\t/* The tree cache didn't help us; we'll have to write\n\t * out a tree. If the index is ignore_case, we must\n\t * make it case-sensitive for the duration of the tree-write\n\t * operation. */\n\n\tif (index->ignore_case) {\n\t\told_ignore_case = true;\n\t\tgit_index__set_ignore_case(index, false);\n\t}\n\n\tret = write_tree(oid, repo, index, \"\", 0);\n\n\tif (old_ignore_case)\n\t\tgit_index__set_ignore_case(index, true);\n\n\tindex->tree = NULL;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgit_pool_clear(&index->tree_pool);\n\n\tif ((ret = git_tree_lookup(&tree, repo, oid)) < 0)\n\t\treturn ret;\n\n\t/* Read the tree cache into the index */\n\tret = git_tree_cache_read_tree(&index->tree, tree, &index->tree_pool);\n\tgit_tree_free(tree);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"Failed to write tree. \"\n\t\t  \"The index file is not backed up by an existing repository\""
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "oid && index"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nint git_index_write_tree(git_oid *oid, git_index *index)\n{\n\tgit_repository *repo;\n\n\tassert(oid && index);\n\n\trepo = INDEX_OWNER(index);\n\n\tif (repo == NULL)\n\t\treturn create_index_error(-1, \"Failed to write tree. \"\n\t\t  \"The index file is not backed up by an existing repository\");\n\n\treturn git_tree__write_index(oid, index, repo);\n}"
  },
  {
    "function_name": "git_index_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "765-769",
    "snippet": "const char * git_index_path(const git_index *index)\n{\n\tassert(index);\n\treturn index->index_file_path;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst char * git_index_path(const git_index *index)\n{\n\tassert(index);\n\treturn index->index_file_path;\n}"
  },
  {
    "function_name": "git_index_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "750-763",
    "snippet": "int git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_indexwriter_cleanup",
          "args": [
            "&writer"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3433-3439",
          "snippet": "void git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nvoid git_indexwriter_cleanup(git_indexwriter *writer)\n{\n\tgit_filebuf_cleanup(&writer->file);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_commit",
          "args": [
            "&writer"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3399-3431",
          "snippet": "int git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_indexwriter_commit(git_indexwriter *writer)\n{\n\tint error;\n\tgit_oid checksum = {{ 0 }};\n\n\tif (!writer->should_write)\n\t\treturn 0;\n\n\tgit_vector_sort(&writer->index->entries);\n\tgit_vector_sort(&writer->index->reuc);\n\n\tif ((error = write_index(&checksum, writer->index, &writer->file)) < 0) {\n\t\tgit_indexwriter_cleanup(writer);\n\t\treturn error;\n\t}\n\n\tif ((error = git_filebuf_commit(&writer->file)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(\n\t\t&writer->index->stamp, writer->index->index_file_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not read index timestamp\");\n\t\treturn -1;\n\t}\n\n\twriter->index->on_disk = 1;\n\tgit_oid_cpy(&writer->index->checksum, &checksum);\n\n\tgit_index_free(writer->index);\n\twriter->index = NULL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_indexwriter_init",
          "args": [
            "&writer",
            "index"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "git_indexwriter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3353-3379",
          "snippet": "int git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"The index is locked. This might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nint git_indexwriter_init(\n\tgit_indexwriter *writer,\n\tgit_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\twriter->index = index;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to write index: The index is in-memory only\");\n\n\tif ((error = git_filebuf_open(\n\t\t&writer->file, index->index_file_path, GIT_FILEBUF_HASH_CONTENTS, GIT_INDEX_FILE_MODE)) < 0) {\n\n\t\tif (error == GIT_ELOCKED)\n\t\t\tgiterr_set(GITERR_INDEX, \"The index is locked. This might be due to a concurrent or crashed process\");\n\n\t\treturn error;\n\t}\n\n\twriter->should_write = 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_racily_clean",
          "args": [
            "index"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_racily_clean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "700-748",
          "snippet": "static int truncate_racily_clean(git_index *index)\n{\n\tsize_t i;\n\tint error;\n\tgit_index_entry *entry;\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = NULL;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tgit_diff_delta *delta;\n\n\t/* Nothing to do if there's no repo to talk about */\n\tif (!INDEX_OWNER(index))\n\t\treturn 0;\n\n\t/* If there's no workdir, we can't know where to even check */\n\tif (!git_repository_workdir(INDEX_OWNER(index)))\n\t\treturn 0;\n\n\tdiff_opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE | GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif ((entry->flags_extended & GIT_IDXENTRY_UPTODATE) == 0 &&\n\t\t\tis_racy_entry(index, entry))\n\t\t\tgit_vector_insert(&paths, (char *)entry->path);\n\t}\n\n\tif (paths.length == 0)\n\t\tgoto done;\n\n\tdiff_opts.pathspec.count = paths.length;\n\tdiff_opts.pathspec.strings = (char **)paths.contents;\n\n\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);\n\n\t\t/* Ensure that we have a stage 0 for this file (ie, it's not a\n\t\t * conflict), otherwise smudging it is quite pointless.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->file_size = 0;\n\t}\n\ndone:\n\tgit_diff_free(diff);\n\tgit_vector_free(&paths);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int truncate_racily_clean(git_index *index)\n{\n\tsize_t i;\n\tint error;\n\tgit_index_entry *entry;\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = NULL;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tgit_diff_delta *delta;\n\n\t/* Nothing to do if there's no repo to talk about */\n\tif (!INDEX_OWNER(index))\n\t\treturn 0;\n\n\t/* If there's no workdir, we can't know where to even check */\n\tif (!git_repository_workdir(INDEX_OWNER(index)))\n\t\treturn 0;\n\n\tdiff_opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE | GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif ((entry->flags_extended & GIT_IDXENTRY_UPTODATE) == 0 &&\n\t\t\tis_racy_entry(index, entry))\n\t\t\tgit_vector_insert(&paths, (char *)entry->path);\n\t}\n\n\tif (paths.length == 0)\n\t\tgoto done;\n\n\tdiff_opts.pathspec.count = paths.length;\n\tdiff_opts.pathspec.strings = (char **)paths.contents;\n\n\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);\n\n\t\t/* Ensure that we have a stage 0 for this file (ie, it's not a\n\t\t * conflict), otherwise smudging it is quite pointless.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->file_size = 0;\n\t}\n\ndone:\n\tgit_diff_free(diff);\n\tgit_vector_free(&paths);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "truncate_racily_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "700-748",
    "snippet": "static int truncate_racily_clean(git_index *index)\n{\n\tsize_t i;\n\tint error;\n\tgit_index_entry *entry;\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = NULL;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tgit_diff_delta *delta;\n\n\t/* Nothing to do if there's no repo to talk about */\n\tif (!INDEX_OWNER(index))\n\t\treturn 0;\n\n\t/* If there's no workdir, we can't know where to even check */\n\tif (!git_repository_workdir(INDEX_OWNER(index)))\n\t\treturn 0;\n\n\tdiff_opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE | GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif ((entry->flags_extended & GIT_IDXENTRY_UPTODATE) == 0 &&\n\t\t\tis_racy_entry(index, entry))\n\t\t\tgit_vector_insert(&paths, (char *)entry->path);\n\t}\n\n\tif (paths.length == 0)\n\t\tgoto done;\n\n\tdiff_opts.pathspec.count = paths.length;\n\tdiff_opts.pathspec.strings = (char **)paths.contents;\n\n\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);\n\n\t\t/* Ensure that we have a stage 0 for this file (ie, it's not a\n\t\t * conflict), otherwise smudging it is quite pointless.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->file_size = 0;\n\t}\n\ndone:\n\tgit_diff_free(diff);\n\tgit_vector_free(&paths);\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&paths"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_get_bypath",
          "args": [
            "index",
            "delta->old_file.path",
            "0"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_get_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "807-825",
          "snippet": "const git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_index_entry *git_index_get_bypath(\n\tgit_index *index, const char *path, int stage)\n{\n\tkhiter_t pos;\n\tgit_index_entry key = {{ 0 }};\n\n\tassert(index);\n\n\tkey.path = path;\n\tGIT_IDXENTRY_STAGE_SET(&key, stage);\n\n\tLOOKUP_IN_MAP(pos, index, &key);\n\n\tif (git_idxmap_valid_index(index->entries_map, pos))\n\t\treturn git_idxmap_value_at(index->entries_map, pos);\n\n\tgiterr_set(GITERR_INDEX, \"Index does not contain %s\", path);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "i",
            "delta"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&diff",
            "INDEX_OWNER(index)",
            "index",
            "&diff_opts"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&paths",
            "(char *)entry->path"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_racy_entry",
          "args": [
            "index",
            "entry"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "is_racy_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "687-694",
          "snippet": "static bool is_racy_entry(git_index *index, const git_index_entry *entry)\n{\n\t/* Git special-cases submodules in the check */\n\tif (S_ISGITLINK(entry->mode))\n\t\treturn false;\n\n\treturn git_index_entry_newer_than_index(entry, index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic bool is_racy_entry(git_index *index, const git_index_entry *entry)\n{\n\t/* Git special-cases submodules in the check */\n\tif (S_ISGITLINK(entry->mode))\n\t\treturn false;\n\n\treturn git_index_entry_newer_than_index(entry, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&index->entries",
            "i",
            "entry"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "INDEX_OWNER(index)"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int truncate_racily_clean(git_index *index)\n{\n\tsize_t i;\n\tint error;\n\tgit_index_entry *entry;\n\tgit_diff_options diff_opts = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = NULL;\n\tgit_vector paths = GIT_VECTOR_INIT;\n\tgit_diff_delta *delta;\n\n\t/* Nothing to do if there's no repo to talk about */\n\tif (!INDEX_OWNER(index))\n\t\treturn 0;\n\n\t/* If there's no workdir, we can't know where to even check */\n\tif (!git_repository_workdir(INDEX_OWNER(index)))\n\t\treturn 0;\n\n\tdiff_opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE | GIT_DIFF_IGNORE_SUBMODULES | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tgit_vector_foreach(&index->entries, i, entry) {\n\t\tif ((entry->flags_extended & GIT_IDXENTRY_UPTODATE) == 0 &&\n\t\t\tis_racy_entry(index, entry))\n\t\t\tgit_vector_insert(&paths, (char *)entry->path);\n\t}\n\n\tif (paths.length == 0)\n\t\tgoto done;\n\n\tdiff_opts.pathspec.count = paths.length;\n\tdiff_opts.pathspec.strings = (char **)paths.contents;\n\n\tif ((error = git_diff_index_to_workdir(&diff, INDEX_OWNER(index), index, &diff_opts)) < 0)\n\t\treturn error;\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tentry = (git_index_entry *)git_index_get_bypath(index, delta->old_file.path, 0);\n\n\t\t/* Ensure that we have a stage 0 for this file (ie, it's not a\n\t\t * conflict), otherwise smudging it is quite pointless.\n\t\t */\n\t\tif (entry)\n\t\t\tentry->file_size = 0;\n\t}\n\ndone:\n\tgit_diff_free(diff);\n\tgit_vector_free(&paths);\n\treturn 0;\n}"
  },
  {
    "function_name": "is_racy_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "687-694",
    "snippet": "static bool is_racy_entry(git_index *index, const git_index_entry *entry)\n{\n\t/* Git special-cases submodules in the check */\n\tif (S_ISGITLINK(entry->mode))\n\t\treturn false;\n\n\treturn git_index_entry_newer_than_index(entry, index);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_entry_newer_than_index",
          "args": [
            "entry",
            "index"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_newer_than_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.h",
          "lines": "86-104",
          "snippet": "GIT_INLINE(bool) git_index_entry_newer_than_index(\n\tconst git_index_entry *entry, git_index *index)\n{\n\t/* If we never read the index, we can't have this race either */\n\tif (!index || index->stamp.mtime.tv_sec == 0)\n\t\treturn false;\n\n\t/* If the timestamp is the same or newer than the index, it's racy */\n#if defined(GIT_USE_NSEC)\n\tif ((int32_t)index->stamp.mtime.tv_sec < entry->mtime.seconds)\n\t\treturn true;\n\telse if ((int32_t)index->stamp.mtime.tv_sec > entry->mtime.seconds)\n\t\treturn false;\n\telse\n\t\treturn (uint32_t)index->stamp.mtime.tv_nsec <= entry->mtime.nanoseconds;\n#else\n\treturn ((int32_t)index->stamp.mtime.tv_sec) <= entry->mtime.seconds;\n#endif\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/odb.h\"",
            "#include \"tree-cache.h\"",
            "#include \"idxmap.h\"",
            "#include \"vector.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/odb.h\"\n#include \"tree-cache.h\"\n#include \"idxmap.h\"\n#include \"vector.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n\nGIT_INLINE(bool) git_index_entry_newer_than_index(\n\tconst git_index_entry *entry, git_index *index)\n{\n\t/* If we never read the index, we can't have this race either */\n\tif (!index || index->stamp.mtime.tv_sec == 0)\n\t\treturn false;\n\n\t/* If the timestamp is the same or newer than the index, it's racy */\n#if defined(GIT_USE_NSEC)\n\tif ((int32_t)index->stamp.mtime.tv_sec < entry->mtime.seconds)\n\t\treturn true;\n\telse if ((int32_t)index->stamp.mtime.tv_sec > entry->mtime.seconds)\n\t\treturn false;\n\telse\n\t\treturn (uint32_t)index->stamp.mtime.tv_nsec <= entry->mtime.nanoseconds;\n#else\n\treturn ((int32_t)index->stamp.mtime.tv_sec) <= entry->mtime.seconds;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "entry->mode"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic bool is_racy_entry(git_index *index, const git_index_entry *entry)\n{\n\t/* Git special-cases submodules in the check */\n\tif (S_ISGITLINK(entry->mode))\n\t\treturn false;\n\n\treturn git_index_entry_newer_than_index(entry, index);\n}"
  },
  {
    "function_name": "git_index__changed_relative_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "677-685",
    "snippet": "int git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "&index->checksum",
            "checksum"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_read",
          "args": [
            "index",
            "false"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2928-3062",
          "snippet": "int git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}"
  },
  {
    "function_name": "git_index_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "629-675",
    "snippet": "int git_index_read(git_index *index, int force)\n{\n\tint error = 0, updated;\n\tgit_buf buffer = GIT_BUF_INIT;\n\tgit_futils_filestamp stamp = index->stamp;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to read index: The index is in-memory only\");\n\n\tindex->on_disk = git_path_exists(index->index_file_path);\n\n\tif (!index->on_disk) {\n\t\tif (force)\n\t\t\treturn git_index_clear(index);\n\t\treturn 0;\n\t}\n\n\tif ((updated = git_futils_filestamp_check(&stamp, index->index_file_path) < 0) ||\n\t    ((updated = compare_checksum(index)) < 0)) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX,\n\t\t\t\"Failed to read index: '%s' no longer exists\",\n\t\t\tindex->index_file_path);\n\t\treturn updated;\n\t}\n\tif (!updated && !force)\n\t\treturn 0;\n\n\terror = git_futils_readbuffer(&buffer, index->index_file_path);\n\tif (error < 0)\n\t\treturn error;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\terror = git_index_clear(index);\n\n\tif (!error)\n\t\terror = parse_index(index, buffer.ptr, buffer.size);\n\n\tif (!error)\n\t\tgit_futils_filestamp_set(&index->stamp, &stamp);\n\n\tgit_buf_free(&buffer);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int read_header(struct index_header *dest, const void *buffer);",
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buffer"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filestamp_set",
          "args": [
            "&index->stamp",
            "&stamp"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_set_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1075-1090",
          "snippet": "void git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_index",
          "args": [
            "index",
            "buffer.ptr",
            "buffer.size"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "parse_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2392-2501",
          "snippet": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tkh_resize(idx, index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;",
            "static const size_t INDEX_HEADER_SIZE = 12;",
            "static size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);",
            "static int read_header(struct index_header *dest, const void *buffer);",
            "static int parse_index(git_index *index, const char *buffer, size_t buffer_size);",
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic const size_t INDEX_FOOTER_SIZE = GIT_OID_RAWSZ;\nstatic const size_t INDEX_HEADER_SIZE = 12;\nstatic size_t read_extension(git_index *index, const char *buffer, size_t buffer_size);\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size);\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tkh_resize(idx, index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_clear",
          "args": [
            "index"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "526-546",
          "snippet": "int git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&index->tree_pool"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&buffer",
            "index->index_file_path"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "\"Failed to read index: '%s' no longer exists\"",
            "index->index_file_path"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compare_checksum",
          "args": [
            "index"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "compare_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "605-627",
          "snippet": "static int compare_checksum(git_index *index)\n{\n\tint fd;\n\tssize_t bytes_read;\n\tgit_oid checksum = {{ 0 }};\n\n\tif ((fd = p_open(index->index_file_path, O_RDONLY)) < 0)\n\t\treturn fd;\n\n\tif (p_lseek(fd, -20, SEEK_END) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"failed to seek to end of file\");\n\t\treturn -1;\n\t}\n\n\tbytes_read = p_read(fd, &checksum, GIT_OID_RAWSZ);\n\tp_close(fd);\n\n\tif (bytes_read < 0)\n\t\treturn -1;\n\n\treturn !!git_oid_cmp(&checksum, &index->checksum);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int compare_checksum(git_index *index)\n{\n\tint fd;\n\tssize_t bytes_read;\n\tgit_oid checksum = {{ 0 }};\n\n\tif ((fd = p_open(index->index_file_path, O_RDONLY)) < 0)\n\t\treturn fd;\n\n\tif (p_lseek(fd, -20, SEEK_END) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"failed to seek to end of file\");\n\t\treturn -1;\n\t}\n\n\tbytes_read = p_read(fd, &checksum, GIT_OID_RAWSZ);\n\tp_close(fd);\n\n\tif (bytes_read < 0)\n\t\treturn -1;\n\n\treturn !!git_oid_cmp(&checksum, &index->checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_filestamp_check",
          "args": [
            "&stamp",
            "index->index_file_path"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1033-1061",
          "snippet": "int git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_filestamp_check(\n\tgit_futils_filestamp *stamp, const char *path)\n{\n\tstruct stat st;\n\n\t/* if the stamp is NULL, then always reload */\n\tif (stamp == NULL)\n\t\treturn 1;\n\n\tif (p_stat(path, &st) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (stamp->mtime.tv_sec == st.st_mtime &&\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec == st.st_mtime_nsec &&\n#endif\n\t\tstamp->size  == (git_off_t)st.st_size   &&\n\t\tstamp->ino   == (unsigned int)st.st_ino)\n\t\treturn 0;\n\n\tstamp->mtime.tv_sec = st.st_mtime;\n#if defined(GIT_USE_NSEC)\n\tstamp->mtime.tv_nsec = st.st_mtime_nsec;\n#endif\n\tstamp->size  = (git_off_t)st.st_size;\n\tstamp->ino   = (unsigned int)st.st_ino;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "index->index_file_path"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"Failed to read index: The index is in-memory only\""
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int read_header(struct index_header *dest, const void *buffer);\nstatic bool is_index_extended(git_index *index);\n\nint git_index_read(git_index *index, int force)\n{\n\tint error = 0, updated;\n\tgit_buf buffer = GIT_BUF_INIT;\n\tgit_futils_filestamp stamp = index->stamp;\n\n\tif (!index->index_file_path)\n\t\treturn create_index_error(-1,\n\t\t\t\"Failed to read index: The index is in-memory only\");\n\n\tindex->on_disk = git_path_exists(index->index_file_path);\n\n\tif (!index->on_disk) {\n\t\tif (force)\n\t\t\treturn git_index_clear(index);\n\t\treturn 0;\n\t}\n\n\tif ((updated = git_futils_filestamp_check(&stamp, index->index_file_path) < 0) ||\n\t    ((updated = compare_checksum(index)) < 0)) {\n\t\tgiterr_set(\n\t\t\tGITERR_INDEX,\n\t\t\t\"Failed to read index: '%s' no longer exists\",\n\t\t\tindex->index_file_path);\n\t\treturn updated;\n\t}\n\tif (!updated && !force)\n\t\treturn 0;\n\n\terror = git_futils_readbuffer(&buffer, index->index_file_path);\n\tif (error < 0)\n\t\treturn error;\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\terror = git_index_clear(index);\n\n\tif (!error)\n\t\terror = parse_index(index, buffer.ptr, buffer.size);\n\n\tif (!error)\n\t\tgit_futils_filestamp_set(&index->stamp, &stamp);\n\n\tgit_buf_free(&buffer);\n\treturn error;\n}"
  },
  {
    "function_name": "compare_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "605-627",
    "snippet": "static int compare_checksum(git_index *index)\n{\n\tint fd;\n\tssize_t bytes_read;\n\tgit_oid checksum = {{ 0 }};\n\n\tif ((fd = p_open(index->index_file_path, O_RDONLY)) < 0)\n\t\treturn fd;\n\n\tif (p_lseek(fd, -20, SEEK_END) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"failed to seek to end of file\");\n\t\treturn -1;\n\t}\n\n\tbytes_read = p_read(fd, &checksum, GIT_OID_RAWSZ);\n\tp_close(fd);\n\n\tif (bytes_read < 0)\n\t\treturn -1;\n\n\treturn !!git_oid_cmp(&checksum, &index->checksum);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "&checksum",
            "&index->checksum"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_read",
          "args": [
            "fd",
            "&checksum",
            "GIT_OID_RAWSZ"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "p_readdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.h",
          "lines": "126-131",
          "snippet": "GIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <netdb.h>",
            "#include \"strnlen.h\"",
            "#\tinclude \"unix/posix.h\"",
            "#\tinclude \"win32/posix.h\"",
            "#include \"fnmatch.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <netdb.h>\n#include \"strnlen.h\"\n#\tinclude \"unix/posix.h\"\n#\tinclude \"win32/posix.h\"\n#include \"fnmatch.h\"\n#include <time.h>\n#include <fcntl.h>\n#include \"common.h\"\n\nGIT_INLINE(int) p_readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result)\n{\n\tGIT_UNUSED(entry);\n\t*result = readdir(dirp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to seek to end of file\""
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_lseek",
          "args": [
            "fd",
            "-20",
            "SEEK_END"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "index->index_file_path",
            "O_RDONLY"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\n\nstatic int compare_checksum(git_index *index)\n{\n\tint fd;\n\tssize_t bytes_read;\n\tgit_oid checksum = {{ 0 }};\n\n\tif ((fd = p_open(index->index_file_path, O_RDONLY)) < 0)\n\t\treturn fd;\n\n\tif (p_lseek(fd, -20, SEEK_END) < 0) {\n\t\tp_close(fd);\n\t\tgiterr_set(GITERR_OS, \"failed to seek to end of file\");\n\t\treturn -1;\n\t}\n\n\tbytes_read = p_read(fd, &checksum, GIT_OID_RAWSZ);\n\tp_close(fd);\n\n\tif (bytes_read < 0)\n\t\treturn -1;\n\n\treturn !!git_oid_cmp(&checksum, &index->checksum);\n}"
  },
  {
    "function_name": "git_index_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "597-600",
    "snippet": "const git_oid *git_index_checksum(git_index *index)\n{\n\treturn &index->checksum;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nconst git_oid *git_index_checksum(git_index *index)\n{\n\treturn &index->checksum;\n}"
  },
  {
    "function_name": "git_index_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "590-595",
    "snippet": "int git_index_caps(const git_index *index)\n{\n\treturn ((index->ignore_case ? GIT_INDEXCAP_IGNORE_CASE : 0) |\n\t\t\t(index->distrust_filemode ? GIT_INDEXCAP_NO_FILEMODE : 0) |\n\t\t\t(index->no_symlinks ? GIT_INDEXCAP_NO_SYMLINKS : 0));\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_caps(const git_index *index)\n{\n\treturn ((index->ignore_case ? GIT_INDEXCAP_IGNORE_CASE : 0) |\n\t\t\t(index->distrust_filemode ? GIT_INDEXCAP_NO_FILEMODE : 0) |\n\t\t\t(index->no_symlinks ? GIT_INDEXCAP_NO_SYMLINKS : 0));\n}"
  },
  {
    "function_name": "git_index_set_caps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "554-588",
    "snippet": "int git_index_set_caps(git_index *index, int caps)\n{\n\tunsigned int old_ignore_case;\n\n\tassert(index);\n\n\told_ignore_case = index->ignore_case;\n\n\tif (caps == GIT_INDEXCAP_FROM_OWNER) {\n\t\tgit_repository *repo = INDEX_OWNER(index);\n\t\tint val;\n\n\t\tif (!repo)\n\t\t\treturn create_index_error(\n\t\t\t\t-1, \"Cannot access repository to set index caps\");\n\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_IGNORECASE))\n\t\t\tindex->ignore_case = (val != 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_FILEMODE))\n\t\t\tindex->distrust_filemode = (val == 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_SYMLINKS))\n\t\t\tindex->no_symlinks = (val == 0);\n\t}\n\telse {\n\t\tindex->ignore_case = ((caps & GIT_INDEXCAP_IGNORE_CASE) != 0);\n\t\tindex->distrust_filemode = ((caps & GIT_INDEXCAP_NO_FILEMODE) != 0);\n\t\tindex->no_symlinks = ((caps & GIT_INDEXCAP_NO_SYMLINKS) != 0);\n\t}\n\n\tif (old_ignore_case != index->ignore_case) {\n\t\tgit_index__set_ignore_case(index, (bool)index->ignore_case);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index__set_ignore_case",
          "args": [
            "index",
            "(bool)index->ignore_case"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__set_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "380-402",
          "snippet": "void git_index__set_ignore_case(git_index *index, bool ignore_case)\n{\n\tindex->ignore_case = ignore_case;\n\n\tif (ignore_case) {\n\t\tindex->entries_cmp_path    = git__strcasecmp_cb;\n\t\tindex->entries_search      = git_index_entry_isrch;\n\t\tindex->entries_search_path = index_entry_isrch_path;\n\t\tindex->reuc_search         = reuc_isrch;\n\t} else {\n\t\tindex->entries_cmp_path    = git__strcmp_cb;\n\t\tindex->entries_search      = git_index_entry_srch;\n\t\tindex->entries_search_path = index_entry_srch_path;\n\t\tindex->reuc_search         = reuc_srch;\n\t}\n\n\tgit_vector_set_cmp(&index->entries,\n\t\tignore_case ? git_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&index->entries);\n\n\tgit_vector_set_cmp(&index->reuc, ignore_case ? reuc_icmp : reuc_cmp);\n\tgit_vector_sort(&index->reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nvoid git_index__set_ignore_case(git_index *index, bool ignore_case)\n{\n\tindex->ignore_case = ignore_case;\n\n\tif (ignore_case) {\n\t\tindex->entries_cmp_path    = git__strcasecmp_cb;\n\t\tindex->entries_search      = git_index_entry_isrch;\n\t\tindex->entries_search_path = index_entry_isrch_path;\n\t\tindex->reuc_search         = reuc_isrch;\n\t} else {\n\t\tindex->entries_cmp_path    = git__strcmp_cb;\n\t\tindex->entries_search      = git_index_entry_srch;\n\t\tindex->entries_search_path = index_entry_srch_path;\n\t\tindex->reuc_search         = reuc_srch;\n\t}\n\n\tgit_vector_set_cmp(&index->entries,\n\t\tignore_case ? git_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&index->entries);\n\n\tgit_vector_set_cmp(&index->reuc, ignore_case ? reuc_icmp : reuc_cmp);\n\tgit_vector_sort(&index->reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&val",
            "repo",
            "GIT_CVAR_SYMLINKS"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_index_error",
          "args": [
            "-1",
            "\"Cannot access repository to set index caps\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "create_index_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "548-552",
          "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INDEX_OWNER",
          "args": [
            "index"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_set_caps(git_index *index, int caps)\n{\n\tunsigned int old_ignore_case;\n\n\tassert(index);\n\n\told_ignore_case = index->ignore_case;\n\n\tif (caps == GIT_INDEXCAP_FROM_OWNER) {\n\t\tgit_repository *repo = INDEX_OWNER(index);\n\t\tint val;\n\n\t\tif (!repo)\n\t\t\treturn create_index_error(\n\t\t\t\t-1, \"Cannot access repository to set index caps\");\n\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_IGNORECASE))\n\t\t\tindex->ignore_case = (val != 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_FILEMODE))\n\t\t\tindex->distrust_filemode = (val == 0);\n\t\tif (!git_repository__cvar(&val, repo, GIT_CVAR_SYMLINKS))\n\t\t\tindex->no_symlinks = (val == 0);\n\t}\n\telse {\n\t\tindex->ignore_case = ((caps & GIT_INDEXCAP_IGNORE_CASE) != 0);\n\t\tindex->distrust_filemode = ((caps & GIT_INDEXCAP_NO_FILEMODE) != 0);\n\t\tindex->no_symlinks = ((caps & GIT_INDEXCAP_NO_SYMLINKS) != 0);\n\t}\n\n\tif (old_ignore_case != index->ignore_case) {\n\t\tgit_index__set_ignore_case(index, (bool)index->ignore_case);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "create_index_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "548-552",
    "snippet": "static int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INDEX",
            "msg"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int create_index_error(int error, const char *msg)\n{\n\tgiterr_set(GITERR_INDEX, msg);\n\treturn error;\n}"
  },
  {
    "function_name": "git_index_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "526-546",
    "snippet": "int git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_filestamp_set",
          "args": [
            "&index->stamp",
            "NULL"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_filestamp_set_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "1075-1090",
          "snippet": "void git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_futils_filestamp_set_from_stat(\n\tgit_futils_filestamp *stamp, struct stat *st)\n{\n\tif (st) {\n\t\tstamp->mtime.tv_sec = st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\t\tstamp->mtime.tv_nsec = st->st_mtime_nsec;\n#else\n\t\tstamp->mtime.tv_nsec = 0;\n#endif\n\t\tstamp->size  = (git_off_t)st->st_size;\n\t\tstamp->ino   = (unsigned int)st->st_ino;\n\t} else {\n\t\tmemset(stamp, 0, sizeof(*stamp));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_name_clear",
          "args": [
            "index"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_name_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2011-2022",
          "snippet": "void git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_name_clear(git_index *index)\n{\n\tsize_t i;\n\tgit_index_name_entry *conflict_name;\n\n\tassert(index);\n\n\tgit_vector_foreach(&index->names, i, conflict_name)\n\t\tindex_name_entry_free(conflict_name);\n\n\tgit_vector_clear(&index->names);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_reuc_clear",
          "args": [
            "index"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_reuc_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2115-2125",
          "snippet": "void git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nvoid git_index_reuc_clear(git_index *index)\n{\n\tsize_t i;\n\n\tassert(index);\n\n\tfor (i = 0; i < index->reuc.length; ++i)\n\t\tindex_entry_reuc_free(git__swap(index->reuc.contents[i], NULL));\n\n\tgit_vector_clear(&index->reuc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_free_deleted",
          "args": [
            "index"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "index_free_deleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "486-500",
          "snippet": "static void index_free_deleted(git_index *index)\n{\n\tint readers = (int)git_atomic_get(&index->readers);\n\tsize_t i;\n\n\tif (readers > 0 || !index->deleted.length)\n\t\treturn;\n\n\tfor (i = 0; i < index->deleted.length; ++i) {\n\t\tgit_index_entry *ie = git__swap(index->deleted.contents[i], NULL);\n\t\tindex_entry_free(ie);\n\t}\n\n\tgit_vector_clear(&index->deleted);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic void index_free_deleted(git_index *index)\n{\n\tint readers = (int)git_atomic_get(&index->readers);\n\tsize_t i;\n\n\tif (readers > 0 || !index->deleted.length)\n\t\treturn;\n\n\tfor (i = 0; i < index->deleted.length; ++i) {\n\t\tgit_index_entry *ie = git__swap(index->deleted.contents[i], NULL);\n\t\tindex_entry_free(ie);\n\t}\n\n\tgit_vector_clear(&index->deleted);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_remove_entry",
          "args": [
            "index",
            "index->entries.length - 1"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "index_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "503-524",
          "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_clear",
          "args": [
            "index->entries_map"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&index->tree_pool"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_remove_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "503-524",
    "snippet": "static int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "entry"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&index->deleted",
            "entry"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_atomic_get",
          "args": [
            "&index->readers"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "217-220",
          "snippet": "GIT_INLINE(int) git_atomic_get(git_atomic *a)\n{\n\treturn (int)a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_get(git_atomic *a)\n{\n\treturn (int)a->val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&index->entries",
            "pos"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELETE_IN_MAP",
          "args": [
            "index",
            "entry"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_cache_invalidate_path",
          "args": [
            "index->tree",
            "entry->path"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_cache_invalidate_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree-cache.c",
          "lines": "27-49",
          "snippet": "void git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}",
          "includes": [
            "#include \"tree.h\"",
            "#include \"pool.h\"",
            "#include \"tree-cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree.h\"\n#include \"pool.h\"\n#include \"tree-cache.h\"\n\nvoid git_tree_cache_invalidate_path(git_tree_cache *tree, const char *path)\n{\n\tconst char *ptr = path, *end;\n\n\tif (tree == NULL)\n\t\treturn;\n\n\ttree->entry_count = -1;\n\n\twhile (ptr != NULL) {\n\t\tend = strchr(ptr, '/');\n\n\t\tif (end == NULL) /* End of path */\n\t\t\tbreak;\n\n\t\ttree = find_child(tree, ptr, end);\n\t\tif (tree == NULL) /* We don't have that tree */\n\t\t\treturn;\n\n\t\ttree->entry_count = -1;\n\t\tptr = end + 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&index->entries",
            "pos"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_remove_entry(git_index *index, size_t pos)\n{\n\tint error = 0;\n\tgit_index_entry *entry = git_vector_get(&index->entries, pos);\n\n\tif (entry != NULL) {\n\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\t\tDELETE_IN_MAP(index, entry);\n\t}\n\n\terror = git_vector_remove(&index->entries, pos);\n\n\tif (!error) {\n\t\tif (git_atomic_get(&index->readers) > 0) {\n\t\t\terror = git_vector_insert(&index->deleted, entry);\n\t\t} else {\n\t\t\tindex_entry_free(entry);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "index_free_deleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "486-500",
    "snippet": "static void index_free_deleted(git_index *index)\n{\n\tint readers = (int)git_atomic_get(&index->readers);\n\tsize_t i;\n\n\tif (readers > 0 || !index->deleted.length)\n\t\treturn;\n\n\tfor (i = 0; i < index->deleted.length; ++i) {\n\t\tgit_index_entry *ie = git__swap(index->deleted.contents[i], NULL);\n\t\tindex_entry_free(ie);\n\t}\n\n\tgit_vector_clear(&index->deleted);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_clear",
          "args": [
            "&index->deleted"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "298-303",
          "snippet": "void git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_clear(git_vector *v)\n{\n\tassert(v);\n\tv->length = 0;\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_entry_free",
          "args": [
            "ie"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "index_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "325-332",
          "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__swap",
          "args": [
            "index->deleted.contents[i]",
            "NULL"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_atomic_get",
          "args": [
            "&index->readers"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "217-220",
          "snippet": "GIT_INLINE(int) git_atomic_get(git_atomic *a)\n{\n\treturn (int)a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_get(git_atomic *a)\n{\n\treturn (int)a->val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic void index_free_deleted(git_index *index)\n{\n\tint readers = (int)git_atomic_get(&index->readers);\n\tsize_t i;\n\n\tif (readers > 0 || !index->deleted.length)\n\t\treturn;\n\n\tfor (i = 0; i < index->deleted.length; ++i) {\n\t\tgit_index_entry *ie = git__swap(index->deleted.contents[i], NULL);\n\t\tindex_entry_free(ie);\n\t}\n\n\tgit_vector_clear(&index->deleted);\n}"
  },
  {
    "function_name": "git_index_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "477-483",
    "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "index",
            "index_free"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
  },
  {
    "function_name": "index_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "457-475",
    "snippet": "static void index_free(git_index *index)\n{\n\t/* index iterators increment the refcount of the index, so if we\n\t * get here then there should be no outstanding iterators.\n\t */\n\tassert(!git_atomic_get(&index->readers));\n\n\tgit_index_clear(index);\n\tgit_idxmap_free(index->entries_map);\n\tgit_vector_free(&index->entries);\n\tgit_vector_free(&index->names);\n\tgit_vector_free(&index->reuc);\n\tgit_vector_free(&index->deleted);\n\n\tgit__free(index->index_file_path);\n\n\tgit__memzero(index, sizeof(*index));\n\tgit__free(index);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "index"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__memzero",
          "args": [
            "index",
            "sizeof(*index)"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "git__memzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "521-531",
          "snippet": "GIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&index->deleted"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_free",
          "args": [
            "index->entries_map"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_clear",
          "args": [
            "index"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "526-546",
          "snippet": "int git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_clear(git_index *index)\n{\n\tint error = 0;\n\n\tassert(index);\n\n\tindex->tree = NULL;\n\tgit_pool_clear(&index->tree_pool);\n\n\tgit_idxmap_clear(index->entries_map);\n\twhile (!error && index->entries.length > 0)\n\t\terror = index_remove_entry(index, index->entries.length - 1);\n\tindex_free_deleted(index);\n\n\tgit_index_reuc_clear(index);\n\tgit_index_name_clear(index);\n\n\tgit_futils_filestamp_set(&index->stamp, NULL);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!git_atomic_get(&index->readers)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_atomic_get",
          "args": [
            "&index->readers"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "git_atomic_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/thread-utils.h",
          "lines": "217-220",
          "snippet": "GIT_INLINE(int) git_atomic_get(git_atomic *a)\n{\n\treturn (int)a->val;\n}",
          "includes": [
            "#   include \"unix/pthread.h\"",
            "#   include \"win32/thread.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include \"unix/pthread.h\"\n#   include \"win32/thread.h\"\n\nGIT_INLINE(int) git_atomic_get(git_atomic *a)\n{\n\treturn (int)a->val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_free(git_index *index)\n{\n\t/* index iterators increment the refcount of the index, so if we\n\t * get here then there should be no outstanding iterators.\n\t */\n\tassert(!git_atomic_get(&index->readers));\n\n\tgit_index_clear(index);\n\tgit_idxmap_free(index->entries_map);\n\tgit_vector_free(&index->entries);\n\tgit_vector_free(&index->names);\n\tgit_vector_free(&index->reuc);\n\tgit_vector_free(&index->deleted);\n\n\tgit__free(index->index_file_path);\n\n\tgit__memzero(index, sizeof(*index));\n\tgit__free(index);\n}"
  },
  {
    "function_name": "git_index_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "452-455",
    "snippet": "int git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_open",
          "args": [
            "out",
            "NULL"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "404-450",
          "snippet": "int git_index_open(git_index **index_out, const char *index_path)\n{\n\tgit_index *index;\n\tint error = -1;\n\n\tassert(index_out);\n\n\tindex = git__calloc(1, sizeof(git_index));\n\tGITERR_CHECK_ALLOC(index);\n\n\tgit_pool_init(&index->tree_pool, 1);\n\n\tif (index_path != NULL) {\n\t\tindex->index_file_path = git__strdup(index_path);\n\t\tif (!index->index_file_path)\n\t\t\tgoto fail;\n\n\t\t/* Check if index file is stored on disk already */\n\t\tif (git_path_exists(index->index_file_path) == true)\n\t\t\tindex->on_disk = 1;\n\t}\n\n\tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||\n\t\tgit_idxmap_alloc(&index->entries_map) < 0 ||\n\t\tgit_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||\n\t\tgit_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||\n\t\tgit_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)\n\t\tgoto fail;\n\n\tindex->entries_cmp_path = git__strcmp_cb;\n\tindex->entries_search = git_index_entry_srch;\n\tindex->entries_search_path = index_entry_srch_path;\n\tindex->reuc_search = reuc_srch;\n\n\tif (index_path != NULL && (error = git_index_read(index, true)) < 0)\n\t\tgoto fail;\n\n\t*index_out = index;\n\tGIT_REFCOUNT_INC(index);\n\n\treturn 0;\n\nfail:\n\tgit_pool_clear(&index->tree_pool);\n\tgit_index_free(index);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
            "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_open(git_index **index_out, const char *index_path)\n{\n\tgit_index *index;\n\tint error = -1;\n\n\tassert(index_out);\n\n\tindex = git__calloc(1, sizeof(git_index));\n\tGITERR_CHECK_ALLOC(index);\n\n\tgit_pool_init(&index->tree_pool, 1);\n\n\tif (index_path != NULL) {\n\t\tindex->index_file_path = git__strdup(index_path);\n\t\tif (!index->index_file_path)\n\t\t\tgoto fail;\n\n\t\t/* Check if index file is stored on disk already */\n\t\tif (git_path_exists(index->index_file_path) == true)\n\t\t\tindex->on_disk = 1;\n\t}\n\n\tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||\n\t\tgit_idxmap_alloc(&index->entries_map) < 0 ||\n\t\tgit_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||\n\t\tgit_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||\n\t\tgit_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)\n\t\tgoto fail;\n\n\tindex->entries_cmp_path = git__strcmp_cb;\n\tindex->entries_search = git_index_entry_srch;\n\tindex->entries_search_path = index_entry_srch_path;\n\tindex->reuc_search = reuc_srch;\n\n\tif (index_path != NULL && (error = git_index_read(index, true)) < 0)\n\t\tgoto fail;\n\n\t*index_out = index;\n\tGIT_REFCOUNT_INC(index);\n\n\treturn 0;\n\nfail:\n\tgit_pool_clear(&index->tree_pool);\n\tgit_index_free(index);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_new(git_index **out)\n{\n\treturn git_index_open(out, NULL);\n}"
  },
  {
    "function_name": "git_index_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "404-450",
    "snippet": "int git_index_open(git_index **index_out, const char *index_path)\n{\n\tgit_index *index;\n\tint error = -1;\n\n\tassert(index_out);\n\n\tindex = git__calloc(1, sizeof(git_index));\n\tGITERR_CHECK_ALLOC(index);\n\n\tgit_pool_init(&index->tree_pool, 1);\n\n\tif (index_path != NULL) {\n\t\tindex->index_file_path = git__strdup(index_path);\n\t\tif (!index->index_file_path)\n\t\t\tgoto fail;\n\n\t\t/* Check if index file is stored on disk already */\n\t\tif (git_path_exists(index->index_file_path) == true)\n\t\t\tindex->on_disk = 1;\n\t}\n\n\tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||\n\t\tgit_idxmap_alloc(&index->entries_map) < 0 ||\n\t\tgit_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||\n\t\tgit_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||\n\t\tgit_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)\n\t\tgoto fail;\n\n\tindex->entries_cmp_path = git__strcmp_cb;\n\tindex->entries_search = git_index_entry_srch;\n\tindex->entries_search_path = index_entry_srch_path;\n\tindex->reuc_search = reuc_srch;\n\n\tif (index_path != NULL && (error = git_index_read(index, true)) < 0)\n\t\tgoto fail;\n\n\t*index_out = index;\n\tGIT_REFCOUNT_INC(index);\n\n\treturn 0;\n\nfail:\n\tgit_pool_clear(&index->tree_pool);\n\tgit_index_free(index);\n\treturn error;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static int write_index(git_oid *checksum, git_index *index, git_filebuf *file);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&index->tree_pool"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "index"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_read",
          "args": [
            "index",
            "true"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2928-3062",
          "snippet": "int git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&index->deleted",
            "8",
            "git_index_entry_cmp"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_idxmap_alloc",
          "args": [
            "&index->entries_map"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "index->index_file_path"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "index_path"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&index->tree_pool",
            "1"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "index"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_index)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index_out"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic int write_index(git_oid *checksum, git_index *index, git_filebuf *file);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nint git_index_open(git_index **index_out, const char *index_path)\n{\n\tgit_index *index;\n\tint error = -1;\n\n\tassert(index_out);\n\n\tindex = git__calloc(1, sizeof(git_index));\n\tGITERR_CHECK_ALLOC(index);\n\n\tgit_pool_init(&index->tree_pool, 1);\n\n\tif (index_path != NULL) {\n\t\tindex->index_file_path = git__strdup(index_path);\n\t\tif (!index->index_file_path)\n\t\t\tgoto fail;\n\n\t\t/* Check if index file is stored on disk already */\n\t\tif (git_path_exists(index->index_file_path) == true)\n\t\t\tindex->on_disk = 1;\n\t}\n\n\tif (git_vector_init(&index->entries, 32, git_index_entry_cmp) < 0 ||\n\t\tgit_idxmap_alloc(&index->entries_map) < 0 ||\n\t\tgit_vector_init(&index->names, 8, conflict_name_cmp) < 0 ||\n\t\tgit_vector_init(&index->reuc, 8, reuc_cmp) < 0 ||\n\t\tgit_vector_init(&index->deleted, 8, git_index_entry_cmp) < 0)\n\t\tgoto fail;\n\n\tindex->entries_cmp_path = git__strcmp_cb;\n\tindex->entries_search = git_index_entry_srch;\n\tindex->entries_search_path = index_entry_srch_path;\n\tindex->reuc_search = reuc_srch;\n\n\tif (index_path != NULL && (error = git_index_read(index, true)) < 0)\n\t\tgoto fail;\n\n\t*index_out = index;\n\tGIT_REFCOUNT_INC(index);\n\n\treturn 0;\n\nfail:\n\tgit_pool_clear(&index->tree_pool);\n\tgit_index_free(index);\n\treturn error;\n}"
  },
  {
    "function_name": "git_index__set_ignore_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "380-402",
    "snippet": "void git_index__set_ignore_case(git_index *index, bool ignore_case)\n{\n\tindex->ignore_case = ignore_case;\n\n\tif (ignore_case) {\n\t\tindex->entries_cmp_path    = git__strcasecmp_cb;\n\t\tindex->entries_search      = git_index_entry_isrch;\n\t\tindex->entries_search_path = index_entry_isrch_path;\n\t\tindex->reuc_search         = reuc_isrch;\n\t} else {\n\t\tindex->entries_cmp_path    = git__strcmp_cb;\n\t\tindex->entries_search      = git_index_entry_srch;\n\t\tindex->entries_search_path = index_entry_srch_path;\n\t\tindex->reuc_search         = reuc_srch;\n\t}\n\n\tgit_vector_set_cmp(&index->entries,\n\t\tignore_case ? git_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&index->entries);\n\n\tgit_vector_set_cmp(&index->reuc, ignore_case ? reuc_icmp : reuc_cmp);\n\tgit_vector_sort(&index->reuc);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);",
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->reuc"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&index->reuc",
            "ignore_case ? reuc_icmp : reuc_cmp"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nvoid git_index__set_ignore_case(git_index *index, bool ignore_case)\n{\n\tindex->ignore_case = ignore_case;\n\n\tif (ignore_case) {\n\t\tindex->entries_cmp_path    = git__strcasecmp_cb;\n\t\tindex->entries_search      = git_index_entry_isrch;\n\t\tindex->entries_search_path = index_entry_isrch_path;\n\t\tindex->reuc_search         = reuc_isrch;\n\t} else {\n\t\tindex->entries_cmp_path    = git__strcmp_cb;\n\t\tindex->entries_search      = git_index_entry_srch;\n\t\tindex->entries_search_path = index_entry_srch_path;\n\t\tindex->reuc_search         = reuc_srch;\n\t}\n\n\tgit_vector_set_cmp(&index->entries,\n\t\tignore_case ? git_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&index->entries);\n\n\tgit_vector_set_cmp(&index->reuc, ignore_case ? reuc_icmp : reuc_cmp);\n\tgit_vector_sort(&index->reuc);\n}"
  },
  {
    "function_name": "index_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "370-378",
    "snippet": "GIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_find_in_entries",
          "args": [
            "out",
            "&index->entries",
            "index->entries_search",
            "path",
            "path_len",
            "stage"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "index_find_in_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "359-368",
          "snippet": "GIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nGIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&index->entries"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nGIT_INLINE(int) index_find(\n\tsize_t *out, git_index *index,\n\tconst char *path, size_t path_len, int stage)\n{\n\tgit_vector_sort(&index->entries);\n\n\treturn index_find_in_entries(\n\t\tout, &index->entries, index->entries_search, path, path_len, stage);\n}"
  },
  {
    "function_name": "index_find_in_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "359-368",
    "snippet": "GIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "out",
            "entries",
            "entry_srch",
            "&srch_key"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nGIT_INLINE(int) index_find_in_entries(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\tstruct entry_srch_key srch_key;\n\tsrch_key.path = path;\n\tsrch_key.pathlen = !path_len ? strlen(path) : path_len;\n\tsrch_key.stage = stage;\n\treturn git_vector_bsearch2(out, entries, entry_srch, &srch_key);\n}"
  },
  {
    "function_name": "index_merge_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "345-357",
    "snippet": "static unsigned int index_merge_mode(\n\tgit_index *index, git_index_entry *existing, unsigned int mode)\n{\n\tif (index->no_symlinks && S_ISREG(mode) &&\n\t\texisting && S_ISLNK(existing->mode))\n\t\treturn existing->mode;\n\n\tif (index->distrust_filemode && S_ISREG(mode))\n\t\treturn (existing && S_ISREG(existing->mode)) ?\n\t\t\texisting->mode : git_index__create_mode(0666);\n\n\treturn git_index__create_mode(mode);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool is_index_extended(git_index *index);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index__create_mode",
          "args": [
            "mode"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "git_index__create_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "334-343",
          "snippet": "unsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "existing->mode"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "existing->mode"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nstatic unsigned int index_merge_mode(\n\tgit_index *index, git_index_entry *existing, unsigned int mode)\n{\n\tif (index->no_symlinks && S_ISREG(mode) &&\n\t\texisting && S_ISLNK(existing->mode))\n\t\treturn existing->mode;\n\n\tif (index->distrust_filemode && S_ISREG(mode))\n\t\treturn (existing && S_ISREG(existing->mode)) ?\n\t\t\texisting->mode : git_index__create_mode(0666);\n\n\treturn git_index__create_mode(mode);\n}"
  },
  {
    "function_name": "git_index__create_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "334-343",
    "snippet": "unsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_PERMS_CANONICAL",
          "args": [
            "mode"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nunsigned int git_index__create_mode(unsigned int mode)\n{\n\tif (S_ISLNK(mode))\n\t\treturn S_IFLNK;\n\n\tif (S_ISDIR(mode) || (mode & S_IFMT) == (S_IFLNK | S_IFDIR))\n\t\treturn (S_IFLNK | S_IFDIR);\n\n\treturn S_IFREG | GIT_PERMS_CANONICAL(mode);\n}"
  },
  {
    "function_name": "index_entry_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "325-332",
    "snippet": "static void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "entry"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry->id",
            "0",
            "sizeof(entry->id)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic void index_entry_free(git_index_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tmemset(&entry->id, 0, sizeof(entry->id));\n\tgit__free(entry);\n}"
  },
  {
    "function_name": "index_entry_reuc_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "320-323",
    "snippet": "static void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "reuc"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc)\n{\n\tgit__free(reuc);\n}"
  },
  {
    "function_name": "reuc_icmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "312-318",
    "snippet": "static int reuc_icmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcasecmp(info_a->path, info_b->path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "info_a->path",
            "info_b->path"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int reuc_icmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcasecmp(info_a->path, info_b->path);\n}"
  },
  {
    "function_name": "reuc_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "304-310",
    "snippet": "static int reuc_cmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcmp(info_a->path, info_b->path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "info_a->path",
            "info_b->path"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int reuc_cmp(const void *a, const void *b)\n{\n\tconst git_index_reuc_entry *info_a = a;\n\tconst git_index_reuc_entry *info_b = b;\n\n\treturn strcmp(info_a->path, info_b->path);\n}"
  },
  {
    "function_name": "reuc_isrch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "297-302",
    "snippet": "static int reuc_isrch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcasecmp(key, reuc->path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "key",
            "reuc->path"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int reuc_isrch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcasecmp(key, reuc->path);\n}"
  },
  {
    "function_name": "reuc_srch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "290-295",
    "snippet": "static int reuc_srch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcmp(key, reuc->path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_reuc_free(git_index_reuc_entry *reuc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key",
            "reuc->path"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_reuc_free(git_index_reuc_entry *reuc);\n\nstatic int reuc_srch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcmp(key, reuc->path);\n}"
  },
  {
    "function_name": "conflict_name_icmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "269-287",
    "snippet": "static int conflict_name_icmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcasecmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcasecmp(name_a->ours, name_b->ours);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "name_a->ours",
            "name_b->ours"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int conflict_name_icmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcasecmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcasecmp(name_a->ours, name_b->ours);\n}"
  },
  {
    "function_name": "conflict_name_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "245-263",
    "snippet": "static int conflict_name_cmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcmp(name_a->ours, name_b->ours);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name_a->ours",
            "name_b->ours"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic int conflict_name_cmp(const void *a, const void *b)\n{\n\tconst git_index_name_entry *name_a = a;\n\tconst git_index_name_entry *name_b = b;\n\n\tif (name_a->ancestor && !name_b->ancestor)\n\t\treturn 1;\n\n\tif (!name_a->ancestor && name_b->ancestor)\n\t\treturn -1;\n\n\tif (name_a->ancestor)\n\t\treturn strcmp(name_a->ancestor, name_b->ancestor);\n\n\tif (!name_a->ours || !name_b->ours)\n\t\treturn 0;\n\n\treturn strcmp(name_a->ours, name_b->ours);\n}"
  },
  {
    "function_name": "git_index_entry_icmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "231-243",
    "snippet": "int git_index_entry_icmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcasecmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry_b"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry_a"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "entry_a->path",
            "entry_b->path"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_entry_icmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcasecmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}"
  },
  {
    "function_name": "git_index_entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "217-229",
    "snippet": "int git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry_b"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "entry_a"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry_a->path",
            "entry_b->path"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}"
  },
  {
    "function_name": "index_entry_isrch_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "210-215",
    "snippet": "static int index_entry_isrch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcasecmp((const char *)path, entry->path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "(const char *)path",
            "entry->path"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_isrch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcasecmp((const char *)path, entry->path);\n}"
  },
  {
    "function_name": "index_entry_srch_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "203-208",
    "snippet": "static int index_entry_srch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcmp((const char *)path, entry->path);\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "(const char *)path",
            "entry->path"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nstatic int index_entry_srch_path(const void *path, const void *array_member)\n{\n\tconst git_index_entry *entry = array_member;\n\n\treturn strcmp((const char *)path, entry->path);\n}"
  },
  {
    "function_name": "git_index_entry_isrch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "177-201",
    "snippet": "int git_index_entry_isrch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = strncasecmp(srch_key->path, entry->path, len);\n\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "&entry->entry"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "srch_key->path",
            "entry->path",
            "len"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_isrch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = strncasecmp(srch_key->path, entry->path, len);\n\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_index_entry_srch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
    "lines": "152-175",
    "snippet": "int git_index_entry_srch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = memcmp(srch_key->path, entry->path, len);\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2/sys/index.h\"",
      "#include \"git2/config.h\"",
      "#include \"git2/blob.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/odb.h\"",
      "#include \"diff.h\"",
      "#include \"idxmap.h\"",
      "#include \"blob.h\"",
      "#include \"ignore.h\"",
      "#include \"pathspec.h\"",
      "#include \"iterator.h\"",
      "#include \"hash.h\"",
      "#include \"tree-cache.h\"",
      "#include \"tree.h\"",
      "#include \"index.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include <stddef.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void index_entry_free(git_index_entry *entry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_IDXENTRY_STAGE",
          "args": [
            "&entry->entry"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "srch_key->path",
            "entry->path",
            "len"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_srch(const void *key, const void *array_member)\n{\n\tconst struct entry_srch_key *srch_key = key;\n\tconst struct entry_internal *entry = array_member;\n\tint cmp;\n\tsize_t len1, len2, len;\n\n\tlen1 = srch_key->pathlen;\n\tlen2 = entry->pathlen;\n\tlen = len1 < len2 ? len1 : len2;\n\n\tcmp = memcmp(srch_key->path, entry->path, len);\n\tif (cmp)\n\t\treturn cmp;\n\tif (len1 < len2)\n\t\treturn -1;\n\tif (len1 > len2)\n\t\treturn 1;\n\n\tif (srch_key->stage != GIT_INDEX_STAGE_ANY)\n\t\treturn srch_key->stage - GIT_IDXENTRY_STAGE(&entry->entry);\n\n\treturn 0;\n}"
  }
]