[
  {
    "function_name": "git_transport_ssh_global_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "896-909",
    "snippet": "int git_transport_ssh_global_init(void)\n{\n#ifdef GIT_SSH\n\n\tlibssh2_init(0);\n\treturn 0;\n\n#else\n\n\t/* Nothing to initialize */\n\treturn 0;\n\n#endif\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libssh2_init",
          "args": [
            "0"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nint git_transport_ssh_global_init(void)\n{\n#ifdef GIT_SSH\n\n\tlibssh2_init(0);\n\treturn 0;\n\n#else\n\n\t/* Nothing to initialize */\n\treturn 0;\n\n#endif\n}"
  },
  {
    "function_name": "git_transport_ssh_with_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "852-894",
    "snippet": "int git_transport_ssh_with_paths(git_transport **out, git_remote *owner, void *payload)\n{\n#ifdef GIT_SSH\n\tgit_strarray *paths = (git_strarray *) payload;\n\tgit_transport *transport;\n\ttransport_smart *smart;\n\tssh_subtransport *t;\n\tint error;\n\tgit_smart_subtransport_definition ssh_definition = {\n\t\tgit_smart_subtransport_ssh,\n\t\t0, /* no RPC */\n\t\tNULL,\n\t};\n\n\tif (paths->count != 2) {\n\t\tgiterr_set(GITERR_SSH, \"invalid ssh paths, must be two strings\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = git_transport_smart(&transport, owner, &ssh_definition)) < 0)\n\t\treturn error;\n\n\tsmart = (transport_smart *) transport;\n\tt = (ssh_subtransport *) smart->wrapped;\n\n\tt->cmd_uploadpack = git__strdup(paths->strings[0]);\n\tGITERR_CHECK_ALLOC(t->cmd_uploadpack);\n\tt->cmd_receivepack = git__strdup(paths->strings[1]);\n\tGITERR_CHECK_ALLOC(t->cmd_receivepack);\n\n\t*out = transport;\n\treturn 0;\n#else\n\tGIT_UNUSED(owner);\n\tGIT_UNUSED(payload);\n\n\tassert(out);\n\t*out = NULL;\n\n\tgiterr_set(GITERR_INVALID, \"Cannot create SSH transport. Library was built without SSH support\");\n\treturn -1;\n#endif\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Cannot create SSH transport. Library was built without SSH support\""
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "payload"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "owner"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t->cmd_receivepack"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "paths->strings[1]"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t->cmd_uploadpack"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_transport_smart",
          "args": [
            "&transport",
            "owner",
            "&ssh_definition"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "git_transport_smart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/smart.c",
          "lines": "469-514",
          "snippet": "int git_transport_smart(git_transport **out, git_remote *owner, void *param)\n{\n\ttransport_smart *t;\n\tgit_smart_subtransport_definition *definition = (git_smart_subtransport_definition *)param;\n\n\tif (!param)\n\t\treturn -1;\n\n\tt = git__calloc(1, sizeof(transport_smart));\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->parent.version = GIT_TRANSPORT_VERSION;\n\tt->parent.set_callbacks = git_smart__set_callbacks;\n\tt->parent.set_custom_headers = git_smart__set_custom_headers;\n\tt->parent.connect = git_smart__connect;\n\tt->parent.close = git_smart__close;\n\tt->parent.free = git_smart__free;\n\tt->parent.negotiate_fetch = git_smart__negotiate_fetch;\n\tt->parent.download_pack = git_smart__download_pack;\n\tt->parent.push = git_smart__push;\n\tt->parent.ls = git_smart__ls;\n\tt->parent.is_connected = git_smart__is_connected;\n\tt->parent.read_flags = git_smart__read_flags;\n\tt->parent.cancel = git_smart__cancel;\n\n\tt->owner = owner;\n\tt->rpc = definition->rpc;\n\n\tif (git_vector_init(&t->refs, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&t->heads, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\t*out = (git_transport *) t;\n\treturn 0;\n}",
          "includes": [
            "#include \"refspec.h\"",
            "#include \"refs.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"refspec.h\"\n#include \"refs.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nint git_transport_smart(git_transport **out, git_remote *owner, void *param)\n{\n\ttransport_smart *t;\n\tgit_smart_subtransport_definition *definition = (git_smart_subtransport_definition *)param;\n\n\tif (!param)\n\t\treturn -1;\n\n\tt = git__calloc(1, sizeof(transport_smart));\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->parent.version = GIT_TRANSPORT_VERSION;\n\tt->parent.set_callbacks = git_smart__set_callbacks;\n\tt->parent.set_custom_headers = git_smart__set_custom_headers;\n\tt->parent.connect = git_smart__connect;\n\tt->parent.close = git_smart__close;\n\tt->parent.free = git_smart__free;\n\tt->parent.negotiate_fetch = git_smart__negotiate_fetch;\n\tt->parent.download_pack = git_smart__download_pack;\n\tt->parent.push = git_smart__push;\n\tt->parent.ls = git_smart__ls;\n\tt->parent.is_connected = git_smart__is_connected;\n\tt->parent.read_flags = git_smart__read_flags;\n\tt->parent.cancel = git_smart__cancel;\n\n\tt->owner = owner;\n\tt->rpc = definition->rpc;\n\n\tif (git_vector_init(&t->refs, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (git_vector_init(&t->heads, 16, ref_name_cmp) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\tif (definition->callback(&t->wrapped, &t->parent, definition->param) < 0) {\n\t\tgit__free(t);\n\t\treturn -1;\n\t}\n\n\t*out = (git_transport *) t;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nint git_transport_ssh_with_paths(git_transport **out, git_remote *owner, void *payload)\n{\n#ifdef GIT_SSH\n\tgit_strarray *paths = (git_strarray *) payload;\n\tgit_transport *transport;\n\ttransport_smart *smart;\n\tssh_subtransport *t;\n\tint error;\n\tgit_smart_subtransport_definition ssh_definition = {\n\t\tgit_smart_subtransport_ssh,\n\t\t0, /* no RPC */\n\t\tNULL,\n\t};\n\n\tif (paths->count != 2) {\n\t\tgiterr_set(GITERR_SSH, \"invalid ssh paths, must be two strings\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = git_transport_smart(&transport, owner, &ssh_definition)) < 0)\n\t\treturn error;\n\n\tsmart = (transport_smart *) transport;\n\tt = (ssh_subtransport *) smart->wrapped;\n\n\tt->cmd_uploadpack = git__strdup(paths->strings[0]);\n\tGITERR_CHECK_ALLOC(t->cmd_uploadpack);\n\tt->cmd_receivepack = git__strdup(paths->strings[1]);\n\tGITERR_CHECK_ALLOC(t->cmd_receivepack);\n\n\t*out = transport;\n\treturn 0;\n#else\n\tGIT_UNUSED(owner);\n\tGIT_UNUSED(payload);\n\n\tassert(out);\n\t*out = NULL;\n\n\tgiterr_set(GITERR_INVALID, \"Cannot create SSH transport. Library was built without SSH support\");\n\treturn -1;\n#endif\n}"
  },
  {
    "function_name": "git_smart_subtransport_ssh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "820-850",
    "snippet": "int git_smart_subtransport_ssh(\n\tgit_smart_subtransport **out, git_transport *owner, void *param)\n{\n#ifdef GIT_SSH\n\tssh_subtransport *t;\n\n\tassert(out);\n\n\tGIT_UNUSED(param);\n\n\tt = git__calloc(sizeof(ssh_subtransport), 1);\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = _ssh_action;\n\tt->parent.close = _ssh_close;\n\tt->parent.free = _ssh_free;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n#else\n\tGIT_UNUSED(owner);\n\tGIT_UNUSED(param);\n\n\tassert(out);\n\t*out = NULL;\n\n\tgiterr_set(GITERR_INVALID, \"Cannot create SSH transport. Library was built without SSH support\");\n\treturn -1;\n#endif\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Cannot create SSH transport. Library was built without SSH support\""
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "param"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "owner"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "t"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "sizeof(ssh_subtransport)",
            "1"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "param"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nint git_smart_subtransport_ssh(\n\tgit_smart_subtransport **out, git_transport *owner, void *param)\n{\n#ifdef GIT_SSH\n\tssh_subtransport *t;\n\n\tassert(out);\n\n\tGIT_UNUSED(param);\n\n\tt = git__calloc(sizeof(ssh_subtransport), 1);\n\tGITERR_CHECK_ALLOC(t);\n\n\tt->owner = (transport_smart *)owner;\n\tt->parent.action = _ssh_action;\n\tt->parent.close = _ssh_close;\n\tt->parent.free = _ssh_free;\n\n\t*out = (git_smart_subtransport *) t;\n\treturn 0;\n#else\n\tGIT_UNUSED(owner);\n\tGIT_UNUSED(param);\n\n\tassert(out);\n\t*out = NULL;\n\n\tgiterr_set(GITERR_INVALID, \"Cannot create SSH transport. Library was built without SSH support\");\n\treturn -1;\n#endif\n}"
  },
  {
    "function_name": "list_auth_methods",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "771-817",
    "snippet": "static int list_auth_methods(int *out, LIBSSH2_SESSION *session, const char *username)\n{\n\tconst char *list, *ptr;\n\n\t*out = 0;\n\n\tlist = libssh2_userauth_list(session, username, strlen(username));\n\n\t/* either error, or the remote accepts NONE auth, which is bizarre, let's punt */\n\tif (list == NULL && !libssh2_userauth_authenticated(session)) {\n\t\tssh_error(session, \"Failed to retrieve list of SSH authentication methods\");\n\t\treturn -1;\n\t}\n\n\tptr = list;\n\twhile (ptr) {\n\t\tif (*ptr == ',')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PUBLICKEY)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_KEY;\n\t\t\t*out |= GIT_CREDTYPE_SSH_CUSTOM;\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\t\t*out |= GIT_CREDTYPE_SSH_MEMORY;\n#endif\n\t\t\tptr += strlen(SSH_AUTH_PUBLICKEY);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PASSWORD)) {\n\t\t\t*out |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t\tptr += strlen(SSH_AUTH_PASSWORD);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_KEYBOARD_INTERACTIVE)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_INTERACTIVE;\n\t\t\tptr += strlen(SSH_AUTH_KEYBOARD_INTERACTIVE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Skipt it if we don't know it */\n\t\tptr = strchr(ptr, ',');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [
      "#define SSH_AUTH_KEYBOARD_INTERACTIVE \"keyboard-interactive\"",
      "#define SSH_AUTH_PASSWORD \"password\"",
      "#define SSH_AUTH_PUBLICKEY \"publickey\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ptr",
            "','"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "SSH_AUTH_KEYBOARD_INTERACTIVE"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ptr",
            "SSH_AUTH_KEYBOARD_INTERACTIVE"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "SSH_AUTH_PASSWORD"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "SSH_AUTH_PUBLICKEY"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "session",
            "\"Failed to retrieve list of SSH authentication methods\""
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_authenticated",
          "args": [
            "session"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_list",
          "args": [
            "session",
            "username",
            "strlen(username)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "username"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\n#define SSH_AUTH_KEYBOARD_INTERACTIVE \"keyboard-interactive\"\n#define SSH_AUTH_PASSWORD \"password\"\n#define SSH_AUTH_PUBLICKEY \"publickey\"\n\nstatic int list_auth_methods(int *out, LIBSSH2_SESSION *session, const char *username)\n{\n\tconst char *list, *ptr;\n\n\t*out = 0;\n\n\tlist = libssh2_userauth_list(session, username, strlen(username));\n\n\t/* either error, or the remote accepts NONE auth, which is bizarre, let's punt */\n\tif (list == NULL && !libssh2_userauth_authenticated(session)) {\n\t\tssh_error(session, \"Failed to retrieve list of SSH authentication methods\");\n\t\treturn -1;\n\t}\n\n\tptr = list;\n\twhile (ptr) {\n\t\tif (*ptr == ',')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PUBLICKEY)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_KEY;\n\t\t\t*out |= GIT_CREDTYPE_SSH_CUSTOM;\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\t\t*out |= GIT_CREDTYPE_SSH_MEMORY;\n#endif\n\t\t\tptr += strlen(SSH_AUTH_PUBLICKEY);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PASSWORD)) {\n\t\t\t*out |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t\tptr += strlen(SSH_AUTH_PASSWORD);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_KEYBOARD_INTERACTIVE)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_INTERACTIVE;\n\t\t\tptr += strlen(SSH_AUTH_KEYBOARD_INTERACTIVE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Skipt it if we don't know it */\n\t\tptr = strchr(ptr, ',');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "_ssh_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "756-765",
    "snippet": "static void _ssh_free(git_smart_subtransport *subtransport)\n{\n\tssh_subtransport *t = (ssh_subtransport *) subtransport;\n\n\tassert(!t->current_stream);\n\n\tgit__free(t->cmd_uploadpack);\n\tgit__free(t->cmd_receivepack);\n\tgit__free(t);\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "t"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!t->current_stream"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void _ssh_free(git_smart_subtransport *subtransport)\n{\n\tssh_subtransport *t = (ssh_subtransport *) subtransport;\n\n\tassert(!t->current_stream);\n\n\tgit__free(t->cmd_uploadpack);\n\tgit__free(t->cmd_receivepack);\n\tgit__free(t);\n}"
  },
  {
    "function_name": "_ssh_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "745-754",
    "snippet": "static int _ssh_close(git_smart_subtransport *subtransport)\n{\n\tssh_subtransport *t = (ssh_subtransport *) subtransport;\n\n\tassert(!t->current_stream);\n\n\tGIT_UNUSED(t);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "t"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!t->current_stream"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _ssh_close(git_smart_subtransport *subtransport)\n{\n\tssh_subtransport *t = (ssh_subtransport *) subtransport;\n\n\tassert(!t->current_stream);\n\n\tGIT_UNUSED(t);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "_ssh_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "719-743",
    "snippet": "static int _ssh_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\tssh_subtransport *t = (ssh_subtransport *) subtransport;\n\n\tswitch (action) {\n\t\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\t\treturn ssh_uploadpack_ls(t, url, stream);\n\n\t\tcase GIT_SERVICE_UPLOADPACK:\n\t\t\treturn ssh_uploadpack(t, url, stream);\n\n\t\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\t\treturn ssh_receivepack_ls(t, url, stream);\n\n\t\tcase GIT_SERVICE_RECEIVEPACK:\n\t\t\treturn ssh_receivepack(t, url, stream);\n\t}\n\n\t*stream = NULL;\n\treturn -1;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_receivepack",
          "args": [
            "t",
            "url",
            "stream"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_receivepack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "703-717",
          "snippet": "static int ssh_receivepack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call RECEIVEPACK_LS before RECEIVEPACK\");\n\treturn -1;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_receivepack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call RECEIVEPACK_LS before RECEIVEPACK\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_receivepack_ls",
          "args": [
            "t",
            "url",
            "stream"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_receivepack_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "692-701",
          "snippet": "static int ssh_receivepack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_receivepack ? t->cmd_receivepack : cmd_receivepack;\n\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_receivepack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_receivepack ? t->cmd_receivepack : cmd_receivepack;\n\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_uploadpack",
          "args": [
            "t",
            "url",
            "stream"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_uploadpack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "676-690",
          "snippet": "static int ssh_uploadpack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call UPLOADPACK_LS before UPLOADPACK\");\n\treturn -1;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_uploadpack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call UPLOADPACK_LS before UPLOADPACK\");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_uploadpack_ls",
          "args": [
            "t",
            "url",
            "stream"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_uploadpack_ls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "666-674",
          "snippet": "static int ssh_uploadpack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_uploadpack ? t->cmd_uploadpack : cmd_uploadpack;\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_uploadpack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_uploadpack ? t->cmd_uploadpack : cmd_uploadpack;\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _ssh_action(\n\tgit_smart_subtransport_stream **stream,\n\tgit_smart_subtransport *subtransport,\n\tconst char *url,\n\tgit_smart_service_t action)\n{\n\tssh_subtransport *t = (ssh_subtransport *) subtransport;\n\n\tswitch (action) {\n\t\tcase GIT_SERVICE_UPLOADPACK_LS:\n\t\t\treturn ssh_uploadpack_ls(t, url, stream);\n\n\t\tcase GIT_SERVICE_UPLOADPACK:\n\t\t\treturn ssh_uploadpack(t, url, stream);\n\n\t\tcase GIT_SERVICE_RECEIVEPACK_LS:\n\t\t\treturn ssh_receivepack_ls(t, url, stream);\n\n\t\tcase GIT_SERVICE_RECEIVEPACK:\n\t\t\treturn ssh_receivepack(t, url, stream);\n\t}\n\n\t*stream = NULL;\n\treturn -1;\n}"
  },
  {
    "function_name": "ssh_receivepack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "703-717",
    "snippet": "static int ssh_receivepack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call RECEIVEPACK_LS before RECEIVEPACK\");\n\treturn -1;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Must call RECEIVEPACK_LS before RECEIVEPACK\""
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "url"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_receivepack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call RECEIVEPACK_LS before RECEIVEPACK\");\n\treturn -1;\n}"
  },
  {
    "function_name": "ssh_receivepack_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "692-701",
    "snippet": "static int ssh_receivepack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_receivepack ? t->cmd_receivepack : cmd_receivepack;\n\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_git_ssh_setup_conn",
          "args": [
            "t",
            "url",
            "cmd",
            "stream"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "_git_ssh_setup_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "502-664",
          "snippet": "static int _git_ssh_setup_conn(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tchar *host=NULL, *port=NULL, *path=NULL, *user=NULL, *pass=NULL;\n\tconst char *default_port=\"22\";\n\tint auth_methods, error = 0;\n\tsize_t i;\n\tssh_stream *s;\n\tgit_cred *cred = NULL;\n\tLIBSSH2_SESSION* session=NULL;\n\tLIBSSH2_CHANNEL* channel=NULL;\n\n\tt->current_stream = NULL;\n\n\t*stream = NULL;\n\tif (ssh_stream_alloc(t, url, cmd, stream) < 0)\n\t\treturn -1;\n\n\ts = (ssh_stream *)*stream;\n\ts->session = NULL;\n\ts->channel = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\tif ((error = gitno_extract_url_parts(&host, &port, &path, &user, &pass, url, default_port)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgoto post_extract;\n\t\t}\n\t}\n\tif ((error = git_ssh_extract_url_parts(&host, &user, url)) < 0)\n\t\tgoto done;\n\tport = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(port);\n\npost_extract:\n\tif ((error = git_socket_stream_new(&s->io, host, port)) < 0 ||\n\t    (error = git_stream_connect(s->io)) < 0)\n\t\tgoto done;\n\n\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\t\tgoto done;\n\n\tif (t->owner->certificate_check_cb != NULL) {\n\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n\t\tconst char *key;\n\n\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n\t\t}\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n\t\t\tmemcpy(&cert.hash_md5, key, 16);\n\t\t}\n\n\t\tif (cert.type == 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"unable to get the host key\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We don't currently trust any hostkeys */\n\t\tgiterr_clear();\n\n\t\tcert_ptr = &cert;\n\n\t\terror = t->owner->certificate_check_cb((git_cert *) cert_ptr, 0, host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled hostkey check\");\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* we need the username to ask for auth methods */\n\tif (!user) {\n\t\tif ((error = request_creds(&cred, t, NULL, GIT_CREDTYPE_USERNAME)) < 0)\n\t\t\tgoto done;\n\n\t\tuser = git__strdup(((git_cred_username *) cred)->username);\n\t\tcred->free(cred);\n\t\tcred = NULL;\n\t\tif (!user)\n\t\t\tgoto done;\n\t} else if (user && pass) {\n\t\tif ((error = git_cred_userpass_plaintext_new(&cred, user, pass)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif ((error = list_auth_methods(&auth_methods, session, user)) < 0)\n\t\tgoto done;\n\n\terror = GIT_EAUTH;\n\t/* if we already have something to try */\n\tif (cred && auth_methods & cred->credtype)\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\n\twhile (error == GIT_EAUTH) {\n\t\tif (cred) {\n\t\t\tcred->free(cred);\n\t\t\tcred = NULL;\n\t\t}\n\n\t\tif ((error = request_creds(&cred, t, user, auth_methods)) < 0)\n\t\t\tgoto done;\n\n\t\tif (strcmp(user, git_cred__username(cred))) {\n\t\t\tgiterr_set(GITERR_SSH, \"username does not match previous request\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tchannel = libssh2_channel_open_session(session);\n\tif (!channel) {\n\t\terror = -1;\n\t\tssh_error(session, \"Failed to open SSH channel\");\n\t\tgoto done;\n\t}\n\n\tlibssh2_channel_set_blocking(channel, 1);\n\n\ts->session = session;\n\ts->channel = channel;\n\n\tt->current_stream = s;\n\ndone:\n\tif (error < 0) {\n\t\tssh_stream_free(*stream);\n\n\t\tif (session)\n\t\t\tlibssh2_session_free(session);\n\t}\n\n\tif (cred)\n\t\tcred->free(cred);\n\n\tgit__free(host);\n\tgit__free(port);\n\tgit__free(path);\n\tgit__free(user);\n\tgit__free(pass);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_setup_conn(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tchar *host=NULL, *port=NULL, *path=NULL, *user=NULL, *pass=NULL;\n\tconst char *default_port=\"22\";\n\tint auth_methods, error = 0;\n\tsize_t i;\n\tssh_stream *s;\n\tgit_cred *cred = NULL;\n\tLIBSSH2_SESSION* session=NULL;\n\tLIBSSH2_CHANNEL* channel=NULL;\n\n\tt->current_stream = NULL;\n\n\t*stream = NULL;\n\tif (ssh_stream_alloc(t, url, cmd, stream) < 0)\n\t\treturn -1;\n\n\ts = (ssh_stream *)*stream;\n\ts->session = NULL;\n\ts->channel = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\tif ((error = gitno_extract_url_parts(&host, &port, &path, &user, &pass, url, default_port)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgoto post_extract;\n\t\t}\n\t}\n\tif ((error = git_ssh_extract_url_parts(&host, &user, url)) < 0)\n\t\tgoto done;\n\tport = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(port);\n\npost_extract:\n\tif ((error = git_socket_stream_new(&s->io, host, port)) < 0 ||\n\t    (error = git_stream_connect(s->io)) < 0)\n\t\tgoto done;\n\n\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\t\tgoto done;\n\n\tif (t->owner->certificate_check_cb != NULL) {\n\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n\t\tconst char *key;\n\n\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n\t\t}\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n\t\t\tmemcpy(&cert.hash_md5, key, 16);\n\t\t}\n\n\t\tif (cert.type == 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"unable to get the host key\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We don't currently trust any hostkeys */\n\t\tgiterr_clear();\n\n\t\tcert_ptr = &cert;\n\n\t\terror = t->owner->certificate_check_cb((git_cert *) cert_ptr, 0, host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled hostkey check\");\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* we need the username to ask for auth methods */\n\tif (!user) {\n\t\tif ((error = request_creds(&cred, t, NULL, GIT_CREDTYPE_USERNAME)) < 0)\n\t\t\tgoto done;\n\n\t\tuser = git__strdup(((git_cred_username *) cred)->username);\n\t\tcred->free(cred);\n\t\tcred = NULL;\n\t\tif (!user)\n\t\t\tgoto done;\n\t} else if (user && pass) {\n\t\tif ((error = git_cred_userpass_plaintext_new(&cred, user, pass)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif ((error = list_auth_methods(&auth_methods, session, user)) < 0)\n\t\tgoto done;\n\n\terror = GIT_EAUTH;\n\t/* if we already have something to try */\n\tif (cred && auth_methods & cred->credtype)\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\n\twhile (error == GIT_EAUTH) {\n\t\tif (cred) {\n\t\t\tcred->free(cred);\n\t\t\tcred = NULL;\n\t\t}\n\n\t\tif ((error = request_creds(&cred, t, user, auth_methods)) < 0)\n\t\t\tgoto done;\n\n\t\tif (strcmp(user, git_cred__username(cred))) {\n\t\t\tgiterr_set(GITERR_SSH, \"username does not match previous request\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tchannel = libssh2_channel_open_session(session);\n\tif (!channel) {\n\t\terror = -1;\n\t\tssh_error(session, \"Failed to open SSH channel\");\n\t\tgoto done;\n\t}\n\n\tlibssh2_channel_set_blocking(channel, 1);\n\n\ts->session = session;\n\ts->channel = channel;\n\n\tt->current_stream = s;\n\ndone:\n\tif (error < 0) {\n\t\tssh_stream_free(*stream);\n\n\t\tif (session)\n\t\t\tlibssh2_session_free(session);\n\t}\n\n\tif (cred)\n\t\tcred->free(cred);\n\n\tgit__free(host);\n\tgit__free(port);\n\tgit__free(path);\n\tgit__free(user);\n\tgit__free(pass);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_receivepack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_receivepack ? t->cmd_receivepack : cmd_receivepack;\n\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}"
  },
  {
    "function_name": "ssh_uploadpack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "676-690",
    "snippet": "static int ssh_uploadpack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call UPLOADPACK_LS before UPLOADPACK\");\n\treturn -1;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Must call UPLOADPACK_LS before UPLOADPACK\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "url"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_uploadpack(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tGIT_UNUSED(url);\n\n\tif (t->current_stream) {\n\t\t*stream = &t->current_stream->parent;\n\t\treturn 0;\n\t}\n\n\tgiterr_set(GITERR_NET, \"Must call UPLOADPACK_LS before UPLOADPACK\");\n\treturn -1;\n}"
  },
  {
    "function_name": "ssh_uploadpack_ls",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "666-674",
    "snippet": "static int ssh_uploadpack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_uploadpack ? t->cmd_uploadpack : cmd_uploadpack;\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_git_ssh_setup_conn",
          "args": [
            "t",
            "url",
            "cmd",
            "stream"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "_git_ssh_setup_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "502-664",
          "snippet": "static int _git_ssh_setup_conn(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tchar *host=NULL, *port=NULL, *path=NULL, *user=NULL, *pass=NULL;\n\tconst char *default_port=\"22\";\n\tint auth_methods, error = 0;\n\tsize_t i;\n\tssh_stream *s;\n\tgit_cred *cred = NULL;\n\tLIBSSH2_SESSION* session=NULL;\n\tLIBSSH2_CHANNEL* channel=NULL;\n\n\tt->current_stream = NULL;\n\n\t*stream = NULL;\n\tif (ssh_stream_alloc(t, url, cmd, stream) < 0)\n\t\treturn -1;\n\n\ts = (ssh_stream *)*stream;\n\ts->session = NULL;\n\ts->channel = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\tif ((error = gitno_extract_url_parts(&host, &port, &path, &user, &pass, url, default_port)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgoto post_extract;\n\t\t}\n\t}\n\tif ((error = git_ssh_extract_url_parts(&host, &user, url)) < 0)\n\t\tgoto done;\n\tport = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(port);\n\npost_extract:\n\tif ((error = git_socket_stream_new(&s->io, host, port)) < 0 ||\n\t    (error = git_stream_connect(s->io)) < 0)\n\t\tgoto done;\n\n\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\t\tgoto done;\n\n\tif (t->owner->certificate_check_cb != NULL) {\n\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n\t\tconst char *key;\n\n\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n\t\t}\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n\t\t\tmemcpy(&cert.hash_md5, key, 16);\n\t\t}\n\n\t\tif (cert.type == 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"unable to get the host key\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We don't currently trust any hostkeys */\n\t\tgiterr_clear();\n\n\t\tcert_ptr = &cert;\n\n\t\terror = t->owner->certificate_check_cb((git_cert *) cert_ptr, 0, host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled hostkey check\");\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* we need the username to ask for auth methods */\n\tif (!user) {\n\t\tif ((error = request_creds(&cred, t, NULL, GIT_CREDTYPE_USERNAME)) < 0)\n\t\t\tgoto done;\n\n\t\tuser = git__strdup(((git_cred_username *) cred)->username);\n\t\tcred->free(cred);\n\t\tcred = NULL;\n\t\tif (!user)\n\t\t\tgoto done;\n\t} else if (user && pass) {\n\t\tif ((error = git_cred_userpass_plaintext_new(&cred, user, pass)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif ((error = list_auth_methods(&auth_methods, session, user)) < 0)\n\t\tgoto done;\n\n\terror = GIT_EAUTH;\n\t/* if we already have something to try */\n\tif (cred && auth_methods & cred->credtype)\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\n\twhile (error == GIT_EAUTH) {\n\t\tif (cred) {\n\t\t\tcred->free(cred);\n\t\t\tcred = NULL;\n\t\t}\n\n\t\tif ((error = request_creds(&cred, t, user, auth_methods)) < 0)\n\t\t\tgoto done;\n\n\t\tif (strcmp(user, git_cred__username(cred))) {\n\t\t\tgiterr_set(GITERR_SSH, \"username does not match previous request\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tchannel = libssh2_channel_open_session(session);\n\tif (!channel) {\n\t\terror = -1;\n\t\tssh_error(session, \"Failed to open SSH channel\");\n\t\tgoto done;\n\t}\n\n\tlibssh2_channel_set_blocking(channel, 1);\n\n\ts->session = session;\n\ts->channel = channel;\n\n\tt->current_stream = s;\n\ndone:\n\tif (error < 0) {\n\t\tssh_stream_free(*stream);\n\n\t\tif (session)\n\t\t\tlibssh2_session_free(session);\n\t}\n\n\tif (cred)\n\t\tcred->free(cred);\n\n\tgit__free(host);\n\tgit__free(port);\n\tgit__free(path);\n\tgit__free(user);\n\tgit__free(pass);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_setup_conn(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tchar *host=NULL, *port=NULL, *path=NULL, *user=NULL, *pass=NULL;\n\tconst char *default_port=\"22\";\n\tint auth_methods, error = 0;\n\tsize_t i;\n\tssh_stream *s;\n\tgit_cred *cred = NULL;\n\tLIBSSH2_SESSION* session=NULL;\n\tLIBSSH2_CHANNEL* channel=NULL;\n\n\tt->current_stream = NULL;\n\n\t*stream = NULL;\n\tif (ssh_stream_alloc(t, url, cmd, stream) < 0)\n\t\treturn -1;\n\n\ts = (ssh_stream *)*stream;\n\ts->session = NULL;\n\ts->channel = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\tif ((error = gitno_extract_url_parts(&host, &port, &path, &user, &pass, url, default_port)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgoto post_extract;\n\t\t}\n\t}\n\tif ((error = git_ssh_extract_url_parts(&host, &user, url)) < 0)\n\t\tgoto done;\n\tport = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(port);\n\npost_extract:\n\tif ((error = git_socket_stream_new(&s->io, host, port)) < 0 ||\n\t    (error = git_stream_connect(s->io)) < 0)\n\t\tgoto done;\n\n\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\t\tgoto done;\n\n\tif (t->owner->certificate_check_cb != NULL) {\n\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n\t\tconst char *key;\n\n\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n\t\t}\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n\t\t\tmemcpy(&cert.hash_md5, key, 16);\n\t\t}\n\n\t\tif (cert.type == 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"unable to get the host key\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We don't currently trust any hostkeys */\n\t\tgiterr_clear();\n\n\t\tcert_ptr = &cert;\n\n\t\terror = t->owner->certificate_check_cb((git_cert *) cert_ptr, 0, host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled hostkey check\");\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* we need the username to ask for auth methods */\n\tif (!user) {\n\t\tif ((error = request_creds(&cred, t, NULL, GIT_CREDTYPE_USERNAME)) < 0)\n\t\t\tgoto done;\n\n\t\tuser = git__strdup(((git_cred_username *) cred)->username);\n\t\tcred->free(cred);\n\t\tcred = NULL;\n\t\tif (!user)\n\t\t\tgoto done;\n\t} else if (user && pass) {\n\t\tif ((error = git_cred_userpass_plaintext_new(&cred, user, pass)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif ((error = list_auth_methods(&auth_methods, session, user)) < 0)\n\t\tgoto done;\n\n\terror = GIT_EAUTH;\n\t/* if we already have something to try */\n\tif (cred && auth_methods & cred->credtype)\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\n\twhile (error == GIT_EAUTH) {\n\t\tif (cred) {\n\t\t\tcred->free(cred);\n\t\t\tcred = NULL;\n\t\t}\n\n\t\tif ((error = request_creds(&cred, t, user, auth_methods)) < 0)\n\t\t\tgoto done;\n\n\t\tif (strcmp(user, git_cred__username(cred))) {\n\t\t\tgiterr_set(GITERR_SSH, \"username does not match previous request\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tchannel = libssh2_channel_open_session(session);\n\tif (!channel) {\n\t\terror = -1;\n\t\tssh_error(session, \"Failed to open SSH channel\");\n\t\tgoto done;\n\t}\n\n\tlibssh2_channel_set_blocking(channel, 1);\n\n\ts->session = session;\n\ts->channel = channel;\n\n\tt->current_stream = s;\n\ndone:\n\tif (error < 0) {\n\t\tssh_stream_free(*stream);\n\n\t\tif (session)\n\t\t\tlibssh2_session_free(session);\n\t}\n\n\tif (cred)\n\t\tcred->free(cred);\n\n\tgit__free(host);\n\tgit__free(port);\n\tgit__free(path);\n\tgit__free(user);\n\tgit__free(pass);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_uploadpack_ls(\n\tssh_subtransport *t,\n\tconst char *url,\n\tgit_smart_subtransport_stream **stream)\n{\n\tconst char *cmd = t->cmd_uploadpack ? t->cmd_uploadpack : cmd_uploadpack;\n\n\treturn _git_ssh_setup_conn(t, url, cmd, stream);\n}"
  },
  {
    "function_name": "_git_ssh_setup_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "502-664",
    "snippet": "static int _git_ssh_setup_conn(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tchar *host=NULL, *port=NULL, *path=NULL, *user=NULL, *pass=NULL;\n\tconst char *default_port=\"22\";\n\tint auth_methods, error = 0;\n\tsize_t i;\n\tssh_stream *s;\n\tgit_cred *cred = NULL;\n\tLIBSSH2_SESSION* session=NULL;\n\tLIBSSH2_CHANNEL* channel=NULL;\n\n\tt->current_stream = NULL;\n\n\t*stream = NULL;\n\tif (ssh_stream_alloc(t, url, cmd, stream) < 0)\n\t\treturn -1;\n\n\ts = (ssh_stream *)*stream;\n\ts->session = NULL;\n\ts->channel = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\tif ((error = gitno_extract_url_parts(&host, &port, &path, &user, &pass, url, default_port)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgoto post_extract;\n\t\t}\n\t}\n\tif ((error = git_ssh_extract_url_parts(&host, &user, url)) < 0)\n\t\tgoto done;\n\tport = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(port);\n\npost_extract:\n\tif ((error = git_socket_stream_new(&s->io, host, port)) < 0 ||\n\t    (error = git_stream_connect(s->io)) < 0)\n\t\tgoto done;\n\n\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\t\tgoto done;\n\n\tif (t->owner->certificate_check_cb != NULL) {\n\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n\t\tconst char *key;\n\n\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n\t\t}\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n\t\t\tmemcpy(&cert.hash_md5, key, 16);\n\t\t}\n\n\t\tif (cert.type == 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"unable to get the host key\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We don't currently trust any hostkeys */\n\t\tgiterr_clear();\n\n\t\tcert_ptr = &cert;\n\n\t\terror = t->owner->certificate_check_cb((git_cert *) cert_ptr, 0, host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled hostkey check\");\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* we need the username to ask for auth methods */\n\tif (!user) {\n\t\tif ((error = request_creds(&cred, t, NULL, GIT_CREDTYPE_USERNAME)) < 0)\n\t\t\tgoto done;\n\n\t\tuser = git__strdup(((git_cred_username *) cred)->username);\n\t\tcred->free(cred);\n\t\tcred = NULL;\n\t\tif (!user)\n\t\t\tgoto done;\n\t} else if (user && pass) {\n\t\tif ((error = git_cred_userpass_plaintext_new(&cred, user, pass)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif ((error = list_auth_methods(&auth_methods, session, user)) < 0)\n\t\tgoto done;\n\n\terror = GIT_EAUTH;\n\t/* if we already have something to try */\n\tif (cred && auth_methods & cred->credtype)\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\n\twhile (error == GIT_EAUTH) {\n\t\tif (cred) {\n\t\t\tcred->free(cred);\n\t\t\tcred = NULL;\n\t\t}\n\n\t\tif ((error = request_creds(&cred, t, user, auth_methods)) < 0)\n\t\t\tgoto done;\n\n\t\tif (strcmp(user, git_cred__username(cred))) {\n\t\t\tgiterr_set(GITERR_SSH, \"username does not match previous request\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tchannel = libssh2_channel_open_session(session);\n\tif (!channel) {\n\t\terror = -1;\n\t\tssh_error(session, \"Failed to open SSH channel\");\n\t\tgoto done;\n\t}\n\n\tlibssh2_channel_set_blocking(channel, 1);\n\n\ts->session = session;\n\ts->channel = channel;\n\n\tt->current_stream = s;\n\ndone:\n\tif (error < 0) {\n\t\tssh_stream_free(*stream);\n\n\t\tif (session)\n\t\t\tlibssh2_session_free(session);\n\t}\n\n\tif (cred)\n\t\tcred->free(cred);\n\n\tgit__free(host);\n\tgit__free(port);\n\tgit__free(path);\n\tgit__free(user);\n\tgit__free(pass);\n\n\treturn error;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "pass"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred->free",
          "args": [
            "cred"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_session_free",
          "args": [
            "session"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_stream_free",
          "args": [
            "*stream"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "193-223",
          "snippet": "static void ssh_stream_free(git_smart_subtransport_stream *stream)\n{\n\tssh_stream *s = (ssh_stream *)stream;\n\tssh_subtransport *t;\n\n\tif (!stream)\n\t\treturn;\n\n\tt = OWNING_SUBTRANSPORT(s);\n\tt->current_stream = NULL;\n\n\tif (s->channel) {\n\t\tlibssh2_channel_close(s->channel);\n\t\tlibssh2_channel_free(s->channel);\n\t\ts->channel = NULL;\n\t}\n\n\tif (s->session) {\n\t\tlibssh2_session_free(s->session);\n\t\ts->session = NULL;\n\t}\n\n\tif (s->io) {\n\t\tgit_stream_close(s->io);\n\t\tgit_stream_free(s->io);\n\t\ts->io = NULL;\n\t}\n\n\tgit__free(s->url);\n\tgit__free(s);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_stream_free(git_smart_subtransport_stream *stream)\n{\n\tssh_stream *s = (ssh_stream *)stream;\n\tssh_subtransport *t;\n\n\tif (!stream)\n\t\treturn;\n\n\tt = OWNING_SUBTRANSPORT(s);\n\tt->current_stream = NULL;\n\n\tif (s->channel) {\n\t\tlibssh2_channel_close(s->channel);\n\t\tlibssh2_channel_free(s->channel);\n\t\ts->channel = NULL;\n\t}\n\n\tif (s->session) {\n\t\tlibssh2_session_free(s->session);\n\t\ts->session = NULL;\n\t}\n\n\tif (s->io) {\n\t\tgit_stream_close(s->io);\n\t\tgit_stream_free(s->io);\n\t\ts->io = NULL;\n\t}\n\n\tgit__free(s->url);\n\tgit__free(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_channel_set_blocking",
          "args": [
            "channel",
            "1"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "session",
            "\"Failed to open SSH channel\""
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_channel_open_session",
          "args": [
            "session"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_git_ssh_authenticate_session",
          "args": [
            "session",
            "cred"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "_git_ssh_authenticate_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "341-430",
          "snippet": "static int _git_ssh_authenticate_session(\n\tLIBSSH2_SESSION* session,\n\tgit_cred* cred)\n{\n\tint rc;\n\n\tdo {\n\t\tgiterr_clear();\n\t\tswitch (cred->credtype) {\n\t\tcase GIT_CREDTYPE_USERPASS_PLAINTEXT: {\n\t\t\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\t\t\trc = libssh2_userauth_password(session, c->username, c->password);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_KEY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tif (c->privatekey)\n\t\t\t\trc = libssh2_userauth_publickey_fromfile(\n\t\t\t\t\tsession, c->username, c->publickey,\n\t\t\t\t\tc->privatekey, c->passphrase);\n\t\t\telse\n\t\t\t\trc = ssh_agent_auth(session, c);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_CUSTOM: {\n\t\t\tgit_cred_ssh_custom *c = (git_cred_ssh_custom *)cred;\n\n\t\t\trc = libssh2_userauth_publickey(\n\t\t\t\tsession, c->username, (const unsigned char *)c->publickey,\n\t\t\t\tc->publickey_len, c->sign_callback, &c->payload);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_INTERACTIVE: {\n\t\t\tvoid **abstract = libssh2_session_abstract(session);\n\t\t\tgit_cred_ssh_interactive *c = (git_cred_ssh_interactive *)cred;\n\n\t\t\t/* ideally, we should be able to set this by calling\n\t\t\t * libssh2_session_init_ex() instead of libssh2_session_init().\n\t\t\t * libssh2's API is inconsistent here i.e. libssh2_userauth_publickey()\n\t\t\t * allows you to pass the `abstract` as part of the call, whereas\n\t\t\t * libssh2_userauth_keyboard_interactive() does not!\n\t\t\t *\n\t\t\t * The only way to set the `abstract` pointer is by calling\n\t\t\t * libssh2_session_abstract(), which will replace the existing\n\t\t\t * pointer as is done below. This is safe for now (at time of writing),\n\t\t\t * but may not be valid in future.\n\t\t\t */\n\t\t\t*abstract = c->payload;\n\n\t\t\trc = libssh2_userauth_keyboard_interactive(\n\t\t\t\tsession, c->username, c->prompt_callback);\n\t\t\tbreak;\n\t\t}\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\tcase GIT_CREDTYPE_SSH_MEMORY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tassert(c->username);\n\t\t\tassert(c->privatekey);\n\n\t\t\trc = libssh2_userauth_publickey_frommemory(\n\t\t\t\tsession,\n\t\t\t\tc->username,\n\t\t\t\tstrlen(c->username),\n\t\t\t\tc->publickey,\n\t\t\t\tc->publickey ? strlen(c->publickey) : 0,\n\t\t\t\tc->privatekey,\n\t\t\t\tstrlen(c->privatekey),\n\t\t\t\tc->passphrase);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t}\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n        if (rc == LIBSSH2_ERROR_PASSWORD_EXPIRED || rc == LIBSSH2_ERROR_AUTHENTICATION_FAILED)\n                return GIT_EAUTH;\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tif (!giterr_last())\n\t\t\tssh_error(session, \"Failed to authenticate SSH session\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_authenticate_session(\n\tLIBSSH2_SESSION* session,\n\tgit_cred* cred)\n{\n\tint rc;\n\n\tdo {\n\t\tgiterr_clear();\n\t\tswitch (cred->credtype) {\n\t\tcase GIT_CREDTYPE_USERPASS_PLAINTEXT: {\n\t\t\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\t\t\trc = libssh2_userauth_password(session, c->username, c->password);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_KEY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tif (c->privatekey)\n\t\t\t\trc = libssh2_userauth_publickey_fromfile(\n\t\t\t\t\tsession, c->username, c->publickey,\n\t\t\t\t\tc->privatekey, c->passphrase);\n\t\t\telse\n\t\t\t\trc = ssh_agent_auth(session, c);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_CUSTOM: {\n\t\t\tgit_cred_ssh_custom *c = (git_cred_ssh_custom *)cred;\n\n\t\t\trc = libssh2_userauth_publickey(\n\t\t\t\tsession, c->username, (const unsigned char *)c->publickey,\n\t\t\t\tc->publickey_len, c->sign_callback, &c->payload);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_INTERACTIVE: {\n\t\t\tvoid **abstract = libssh2_session_abstract(session);\n\t\t\tgit_cred_ssh_interactive *c = (git_cred_ssh_interactive *)cred;\n\n\t\t\t/* ideally, we should be able to set this by calling\n\t\t\t * libssh2_session_init_ex() instead of libssh2_session_init().\n\t\t\t * libssh2's API is inconsistent here i.e. libssh2_userauth_publickey()\n\t\t\t * allows you to pass the `abstract` as part of the call, whereas\n\t\t\t * libssh2_userauth_keyboard_interactive() does not!\n\t\t\t *\n\t\t\t * The only way to set the `abstract` pointer is by calling\n\t\t\t * libssh2_session_abstract(), which will replace the existing\n\t\t\t * pointer as is done below. This is safe for now (at time of writing),\n\t\t\t * but may not be valid in future.\n\t\t\t */\n\t\t\t*abstract = c->payload;\n\n\t\t\trc = libssh2_userauth_keyboard_interactive(\n\t\t\t\tsession, c->username, c->prompt_callback);\n\t\t\tbreak;\n\t\t}\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\tcase GIT_CREDTYPE_SSH_MEMORY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tassert(c->username);\n\t\t\tassert(c->privatekey);\n\n\t\t\trc = libssh2_userauth_publickey_frommemory(\n\t\t\t\tsession,\n\t\t\t\tc->username,\n\t\t\t\tstrlen(c->username),\n\t\t\t\tc->publickey,\n\t\t\t\tc->publickey ? strlen(c->publickey) : 0,\n\t\t\t\tc->privatekey,\n\t\t\t\tstrlen(c->privatekey),\n\t\t\t\tc->passphrase);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t}\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n        if (rc == LIBSSH2_ERROR_PASSWORD_EXPIRED || rc == LIBSSH2_ERROR_AUTHENTICATION_FAILED)\n                return GIT_EAUTH;\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tif (!giterr_last())\n\t\t\tssh_error(session, \"Failed to authenticate SSH session\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SSH",
            "\"username does not match previous request\""
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "user",
            "git_cred__username(cred)"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_cred__username",
          "args": [
            "cred"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "git_cred__username",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/cred.c",
          "lines": "28-61",
          "snippet": "const char *git_cred__username(git_cred *cred)\n{\n\tswitch (cred->credtype) {\n\tcase GIT_CREDTYPE_USERNAME:\n\t{\n\t\tgit_cred_username *c = (git_cred_username *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_USERPASS_PLAINTEXT:\n\t{\n\t\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_SSH_KEY:\n\tcase GIT_CREDTYPE_SSH_MEMORY:\n\t{\n\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_SSH_CUSTOM:\n\t{\n\t\tgit_cred_ssh_custom *c = (git_cred_ssh_custom *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_SSH_INTERACTIVE:\n\t{\n\t\tgit_cred_ssh_interactive *c = (git_cred_ssh_interactive *) cred;\n\t\treturn c->username;\n\t}\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"git2/cred_helpers.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/cred_helpers.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);\n\nconst char *git_cred__username(git_cred *cred)\n{\n\tswitch (cred->credtype) {\n\tcase GIT_CREDTYPE_USERNAME:\n\t{\n\t\tgit_cred_username *c = (git_cred_username *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_USERPASS_PLAINTEXT:\n\t{\n\t\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_SSH_KEY:\n\tcase GIT_CREDTYPE_SSH_MEMORY:\n\t{\n\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_SSH_CUSTOM:\n\t{\n\t\tgit_cred_ssh_custom *c = (git_cred_ssh_custom *) cred;\n\t\treturn c->username;\n\t}\n\tcase GIT_CREDTYPE_SSH_INTERACTIVE:\n\t{\n\t\tgit_cred_ssh_interactive *c = (git_cred_ssh_interactive *) cred;\n\t\treturn c->username;\n\t}\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_creds",
          "args": [
            "&cred",
            "t",
            "user",
            "auth_methods"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "request_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "432-467",
          "snippet": "static int request_creds(git_cred **out, ssh_subtransport *t, const char *user, int auth_methods)\n{\n\tint error, no_callback = 0;\n\tgit_cred *cred = NULL;\n\n\tif (!t->owner->cred_acquire_cb) {\n\t\tno_callback = 1;\n\t} else {\n\t\terror = t->owner->cred_acquire_cb(&cred, t->owner->url, user, auth_methods,\n\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\tno_callback = 1;\n\t\telse if (error < 0)\n\t\t\treturn error;\n\t\telse if (!cred) {\n\t\t\tgiterr_set(GITERR_SSH, \"Callback failed to initialize SSH credentials\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (no_callback) {\n\t\tgiterr_set(GITERR_SSH, \"authentication required but no callback set\");\n\t\treturn -1;\n\t}\n\n\tif (!(cred->credtype & auth_methods)) {\n\t\tcred->free(cred);\n\t\tgiterr_set(GITERR_SSH, \"callback returned unsupported credentials type\");\n\t\treturn -1;\n\t}\n\n\t*out = cred;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int request_creds(git_cred **out, ssh_subtransport *t, const char *user, int auth_methods)\n{\n\tint error, no_callback = 0;\n\tgit_cred *cred = NULL;\n\n\tif (!t->owner->cred_acquire_cb) {\n\t\tno_callback = 1;\n\t} else {\n\t\terror = t->owner->cred_acquire_cb(&cred, t->owner->url, user, auth_methods,\n\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\tno_callback = 1;\n\t\telse if (error < 0)\n\t\t\treturn error;\n\t\telse if (!cred) {\n\t\t\tgiterr_set(GITERR_SSH, \"Callback failed to initialize SSH credentials\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (no_callback) {\n\t\tgiterr_set(GITERR_SSH, \"authentication required but no callback set\");\n\t\treturn -1;\n\t}\n\n\tif (!(cred->credtype & auth_methods)) {\n\t\tcred->free(cred);\n\t\tgiterr_set(GITERR_SSH, \"callback returned unsupported credentials type\");\n\t\treturn -1;\n\t}\n\n\t*out = cred;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred->free",
          "args": [
            "cred"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_auth_methods",
          "args": [
            "&auth_methods",
            "session",
            "user"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "list_auth_methods",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "771-817",
          "snippet": "static int list_auth_methods(int *out, LIBSSH2_SESSION *session, const char *username)\n{\n\tconst char *list, *ptr;\n\n\t*out = 0;\n\n\tlist = libssh2_userauth_list(session, username, strlen(username));\n\n\t/* either error, or the remote accepts NONE auth, which is bizarre, let's punt */\n\tif (list == NULL && !libssh2_userauth_authenticated(session)) {\n\t\tssh_error(session, \"Failed to retrieve list of SSH authentication methods\");\n\t\treturn -1;\n\t}\n\n\tptr = list;\n\twhile (ptr) {\n\t\tif (*ptr == ',')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PUBLICKEY)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_KEY;\n\t\t\t*out |= GIT_CREDTYPE_SSH_CUSTOM;\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\t\t*out |= GIT_CREDTYPE_SSH_MEMORY;\n#endif\n\t\t\tptr += strlen(SSH_AUTH_PUBLICKEY);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PASSWORD)) {\n\t\t\t*out |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t\tptr += strlen(SSH_AUTH_PASSWORD);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_KEYBOARD_INTERACTIVE)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_INTERACTIVE;\n\t\t\tptr += strlen(SSH_AUTH_KEYBOARD_INTERACTIVE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Skipt it if we don't know it */\n\t\tptr = strchr(ptr, ',');\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [
            "#define SSH_AUTH_KEYBOARD_INTERACTIVE \"keyboard-interactive\"",
            "#define SSH_AUTH_PASSWORD \"password\"",
            "#define SSH_AUTH_PUBLICKEY \"publickey\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\n#define SSH_AUTH_KEYBOARD_INTERACTIVE \"keyboard-interactive\"\n#define SSH_AUTH_PASSWORD \"password\"\n#define SSH_AUTH_PUBLICKEY \"publickey\"\n\nstatic int list_auth_methods(int *out, LIBSSH2_SESSION *session, const char *username)\n{\n\tconst char *list, *ptr;\n\n\t*out = 0;\n\n\tlist = libssh2_userauth_list(session, username, strlen(username));\n\n\t/* either error, or the remote accepts NONE auth, which is bizarre, let's punt */\n\tif (list == NULL && !libssh2_userauth_authenticated(session)) {\n\t\tssh_error(session, \"Failed to retrieve list of SSH authentication methods\");\n\t\treturn -1;\n\t}\n\n\tptr = list;\n\twhile (ptr) {\n\t\tif (*ptr == ',')\n\t\t\tptr++;\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PUBLICKEY)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_KEY;\n\t\t\t*out |= GIT_CREDTYPE_SSH_CUSTOM;\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\t\t*out |= GIT_CREDTYPE_SSH_MEMORY;\n#endif\n\t\t\tptr += strlen(SSH_AUTH_PUBLICKEY);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_PASSWORD)) {\n\t\t\t*out |= GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\t\t\tptr += strlen(SSH_AUTH_PASSWORD);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!git__prefixcmp(ptr, SSH_AUTH_KEYBOARD_INTERACTIVE)) {\n\t\t\t*out |= GIT_CREDTYPE_SSH_INTERACTIVE;\n\t\t\tptr += strlen(SSH_AUTH_KEYBOARD_INTERACTIVE);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Skipt it if we don't know it */\n\t\tptr = strchr(ptr, ',');\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_cred_userpass_plaintext_new",
          "args": [
            "&cred",
            "user",
            "pass"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "git_cred_userpass_plaintext_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/cred.c",
          "lines": "79-110",
          "snippet": "int git_cred_userpass_plaintext_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *password)\n{\n\tgit_cred_userpass_plaintext *c;\n\n\tassert(cred && username && password);\n\n\tc = git__malloc(sizeof(git_cred_userpass_plaintext));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->parent.credtype = GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\tc->parent.free = plaintext_free;\n\tc->username = git__strdup(username);\n\n\tif (!c->username) {\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\tc->password = git__strdup(password);\n\n\tif (!c->password) {\n\t\tgit__free(c->username);\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\t*cred = &c->parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/cred_helpers.h\"",
            "#include \"smart.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/cred_helpers.h\"\n#include \"smart.h\"\n#include \"git2.h\"\n\nstatic int git_cred_ssh_key_type_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *publickey,\n\tconst char *privatekey,\n\tconst char *passphrase,\n\tgit_credtype_t credtype);\n\nint git_cred_userpass_plaintext_new(\n\tgit_cred **cred,\n\tconst char *username,\n\tconst char *password)\n{\n\tgit_cred_userpass_plaintext *c;\n\n\tassert(cred && username && password);\n\n\tc = git__malloc(sizeof(git_cred_userpass_plaintext));\n\tGITERR_CHECK_ALLOC(c);\n\n\tc->parent.credtype = GIT_CREDTYPE_USERPASS_PLAINTEXT;\n\tc->parent.free = plaintext_free;\n\tc->username = git__strdup(username);\n\n\tif (!c->username) {\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\tc->password = git__strdup(password);\n\n\tif (!c->password) {\n\t\tgit__free(c->username);\n\t\tgit__free(c);\n\t\treturn -1;\n\t}\n\n\t*cred = &c->parent;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred->free",
          "args": [
            "cred"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "((git_cred_username *) cred)->username"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->owner->certificate_check_cb",
          "args": [
            "(git_cert *) cert_ptr",
            "0",
            "host",
            "t->owner->message_cb_payload"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cert.hash_md5",
            "key",
            "16"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_hostkey_hash",
          "args": [
            "session",
            "LIBSSH2_HOSTKEY_HASH_MD5"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cert.hash_sha1",
            "key",
            "20"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_hostkey_hash",
          "args": [
            "session",
            "LIBSSH2_HOSTKEY_HASH_SHA1"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_git_ssh_session_create",
          "args": [
            "&session",
            "s->io"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "_git_ssh_session_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "469-500",
          "snippet": "static int _git_ssh_session_create(\n\tLIBSSH2_SESSION** session,\n\tgit_stream *io)\n{\n\tint rc = 0;\n\tLIBSSH2_SESSION* s;\n\tgit_socket_stream *socket = (git_socket_stream *) io;\n\n\tassert(session);\n\n\ts = libssh2_session_init();\n\tif (!s) {\n\t\tgiterr_set(GITERR_NET, \"Failed to initialize SSH session\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\trc = libssh2_session_startup(s, socket->s);\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s, \"Failed to start SSH session\");\n\t\tlibssh2_session_free(s);\n\t\treturn -1;\n\t}\n\n\tlibssh2_session_set_blocking(s, 1);\n\n\t*session = s;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_session_create(\n\tLIBSSH2_SESSION** session,\n\tgit_stream *io)\n{\n\tint rc = 0;\n\tLIBSSH2_SESSION* s;\n\tgit_socket_stream *socket = (git_socket_stream *) io;\n\n\tassert(session);\n\n\ts = libssh2_session_init();\n\tif (!s) {\n\t\tgiterr_set(GITERR_NET, \"Failed to initialize SSH session\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\trc = libssh2_session_startup(s, socket->s);\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s, \"Failed to start SSH session\");\n\t\tlibssh2_session_free(s);\n\t\treturn -1;\n\t}\n\n\tlibssh2_session_set_blocking(s, 1);\n\n\t*session = s;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_connect",
          "args": [
            "s->io"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "13-16",
          "snippet": "GIT_INLINE(int) git_stream_connect(git_stream *st)\n{\n\treturn st->connect(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_connect(git_stream *st)\n{\n\treturn st->connect(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_socket_stream_new",
          "args": [
            "&s->io",
            "host",
            "port"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "git_socket_stream_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/socket_stream.c",
          "lines": "185-212",
          "snippet": "int git_socket_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tgit_socket_stream *st;\n\n\tassert(out && host);\n\n\tst = git__calloc(1, sizeof(git_socket_stream));\n\tGITERR_CHECK_ALLOC(st);\n\n\tst->host = git__strdup(host);\n\tGITERR_CHECK_ALLOC(st->host);\n\n\tif (port) {\n\t\tst->port = git__strdup(port);\n\t\tGITERR_CHECK_ALLOC(st->port);\n\t}\n\n\tst->parent.version = GIT_STREAM_VERSION;\n\tst->parent.connect = socket_connect;\n\tst->parent.write = socket_write;\n\tst->parent.read = socket_read;\n\tst->parent.close = socket_close;\n\tst->parent.free = socket_free;\n\tst->s = INVALID_SOCKET;\n\n\t*out = (git_stream *) st;\n\treturn 0;\n}",
          "includes": [
            "#\tinclude <ws2tcpip.h>",
            "#\tinclude <winsock2.h>",
            "#       include <arpa/inet.h>",
            "#\tinclude <netinet/in.h>",
            "#\tinclude <netdb.h>",
            "#\tinclude <sys/time.h>",
            "#\tinclude <sys/select.h>",
            "#\tinclude <sys/socket.h>",
            "#\tinclude <sys/types.h>",
            "#include \"socket_stream.h\"",
            "#include \"stream.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#\tinclude <ws2tcpip.h>\n#\tinclude <winsock2.h>\n#       include <arpa/inet.h>\n#\tinclude <netinet/in.h>\n#\tinclude <netdb.h>\n#\tinclude <sys/time.h>\n#\tinclude <sys/select.h>\n#\tinclude <sys/socket.h>\n#\tinclude <sys/types.h>\n#include \"socket_stream.h\"\n#include \"stream.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint git_socket_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tgit_socket_stream *st;\n\n\tassert(out && host);\n\n\tst = git__calloc(1, sizeof(git_socket_stream));\n\tGITERR_CHECK_ALLOC(st);\n\n\tst->host = git__strdup(host);\n\tGITERR_CHECK_ALLOC(st->host);\n\n\tif (port) {\n\t\tst->port = git__strdup(port);\n\t\tGITERR_CHECK_ALLOC(st->port);\n\t}\n\n\tst->parent.version = GIT_STREAM_VERSION;\n\tst->parent.connect = socket_connect;\n\tst->parent.write = socket_write;\n\tst->parent.read = socket_read;\n\tst->parent.close = socket_close;\n\tst->parent.free = socket_free;\n\tst->s = INVALID_SOCKET;\n\n\t*out = (git_stream *) st;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "port"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_ssh_extract_url_parts",
          "args": [
            "&host",
            "&user",
            "url"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "git_ssh_extract_url_parts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "255-285",
          "snippet": "static int git_ssh_extract_url_parts(\n\tchar **host,\n\tchar **username,\n\tconst char *url)\n{\n\tchar *colon, *at;\n\tconst char *start;\n\n\tcolon = strchr(url, ':');\n\n\n\tat = strchr(url, '@');\n\tif (at) {\n\t\tstart = at + 1;\n\t\t*username = git__substrdup(url, at - url);\n\t\tGITERR_CHECK_ALLOC(*username);\n\t} else {\n\t\tstart = url;\n\t\t*username = NULL;\n\t}\n\n\tif (colon == NULL || (colon < start)) {\n\t\tgiterr_set(GITERR_NET, \"Malformed URL\");\n\t\treturn -1;\n\t}\n\n\t*host = git__substrdup(start, colon - start);\n\tGITERR_CHECK_ALLOC(*host);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int git_ssh_extract_url_parts(\n\tchar **host,\n\tchar **username,\n\tconst char *url)\n{\n\tchar *colon, *at;\n\tconst char *start;\n\n\tcolon = strchr(url, ':');\n\n\n\tat = strchr(url, '@');\n\tif (at) {\n\t\tstart = at + 1;\n\t\t*username = git__substrdup(url, at - url);\n\t\tGITERR_CHECK_ALLOC(*username);\n\t} else {\n\t\tstart = url;\n\t\t*username = NULL;\n\t}\n\n\tif (colon == NULL || (colon < start)) {\n\t\tgiterr_set(GITERR_NET, \"Malformed URL\");\n\t\treturn -1;\n\t}\n\n\t*host = git__substrdup(start, colon - start);\n\tGITERR_CHECK_ALLOC(*host);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gitno_extract_url_parts",
          "args": [
            "&host",
            "&port",
            "&path",
            "&user",
            "&pass",
            "url",
            "default_port"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "gitno_extract_url_parts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/netops.c",
          "lines": "227-286",
          "snippet": "int gitno_extract_url_parts(\n\t\tchar **host,\n\t\tchar **port,\n\t\tchar **path,\n\t\tchar **username,\n\t\tchar **password,\n\t\tconst char *url,\n\t\tconst char *default_port)\n{\n\tstruct http_parser_url u = {0};\n\tconst char *_host, *_port, *_path, *_userinfo;\n\n\tif (http_parser_parse_url(url, strlen(url), false, &u)) {\n\t\tgiterr_set(GITERR_NET, \"Malformed URL '%s'\", url);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t_host = url+u.field_data[UF_HOST].off;\n\t_port = url+u.field_data[UF_PORT].off;\n\t_path = url+u.field_data[UF_PATH].off;\n\t_userinfo = url+u.field_data[UF_USERINFO].off;\n\n\tif (u.field_set & (1 << UF_HOST)) {\n\t\t*host = git__substrdup(_host, u.field_data[UF_HOST].len);\n\t\tGITERR_CHECK_ALLOC(*host);\n\t}\n\n\tif (u.field_set & (1 << UF_PORT))\n\t\t*port = git__substrdup(_port, u.field_data[UF_PORT].len);\n\telse\n\t\t*port = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(*port);\n\n\tif (u.field_set & (1 << UF_PATH)) {\n\t\t*path = git__substrdup(_path, u.field_data[UF_PATH].len);\n\t\tGITERR_CHECK_ALLOC(*path);\n\t} else {\n\t\tgit__free(*port);\n\t\t*port = NULL;\n\t\tgit__free(*host);\n\t\t*host = NULL;\n\t\tgiterr_set(GITERR_NET, \"invalid url, missing path\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (u.field_set & (1 << UF_USERINFO)) {\n\t\tconst char *colon = memchr(_userinfo, ':', u.field_data[UF_USERINFO].len);\n\t\tif (colon) {\n\t\t\t*username = unescape(git__substrdup(_userinfo, colon - _userinfo));\n\t\t\t*password = unescape(git__substrdup(colon+1, u.field_data[UF_USERINFO].len - (colon+1-_userinfo)));\n\t\t\tGITERR_CHECK_ALLOC(*password);\n\t\t} else {\n\t\t\t*username = git__substrdup(_userinfo, u.field_data[UF_USERINFO].len);\n\t\t}\n\t\tGITERR_CHECK_ALLOC(*username);\n\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"global.h\"",
            "#include \"http_parser.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"netops.h\"",
            "#include \"common.h\"",
            "#include \"git2/errors.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"global.h\"\n#include \"http_parser.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"netops.h\"\n#include \"common.h\"\n#include \"git2/errors.h\"\n#include <ctype.h>\n\nint gitno_extract_url_parts(\n\t\tchar **host,\n\t\tchar **port,\n\t\tchar **path,\n\t\tchar **username,\n\t\tchar **password,\n\t\tconst char *url,\n\t\tconst char *default_port)\n{\n\tstruct http_parser_url u = {0};\n\tconst char *_host, *_port, *_path, *_userinfo;\n\n\tif (http_parser_parse_url(url, strlen(url), false, &u)) {\n\t\tgiterr_set(GITERR_NET, \"Malformed URL '%s'\", url);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t_host = url+u.field_data[UF_HOST].off;\n\t_port = url+u.field_data[UF_PORT].off;\n\t_path = url+u.field_data[UF_PATH].off;\n\t_userinfo = url+u.field_data[UF_USERINFO].off;\n\n\tif (u.field_set & (1 << UF_HOST)) {\n\t\t*host = git__substrdup(_host, u.field_data[UF_HOST].len);\n\t\tGITERR_CHECK_ALLOC(*host);\n\t}\n\n\tif (u.field_set & (1 << UF_PORT))\n\t\t*port = git__substrdup(_port, u.field_data[UF_PORT].len);\n\telse\n\t\t*port = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(*port);\n\n\tif (u.field_set & (1 << UF_PATH)) {\n\t\t*path = git__substrdup(_path, u.field_data[UF_PATH].len);\n\t\tGITERR_CHECK_ALLOC(*path);\n\t} else {\n\t\tgit__free(*port);\n\t\t*port = NULL;\n\t\tgit__free(*host);\n\t\t*host = NULL;\n\t\tgiterr_set(GITERR_NET, \"invalid url, missing path\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (u.field_set & (1 << UF_USERINFO)) {\n\t\tconst char *colon = memchr(_userinfo, ':', u.field_data[UF_USERINFO].len);\n\t\tif (colon) {\n\t\t\t*username = unescape(git__substrdup(_userinfo, colon - _userinfo));\n\t\t\t*password = unescape(git__substrdup(colon+1, u.field_data[UF_USERINFO].len - (colon+1-_userinfo)));\n\t\t\tGITERR_CHECK_ALLOC(*password);\n\t\t} else {\n\t\t\t*username = git__substrdup(_userinfo, u.field_data[UF_USERINFO].len);\n\t\t}\n\t\tGITERR_CHECK_ALLOC(*username);\n\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "url",
            "p"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ssh_prefixes"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_stream_alloc",
          "args": [
            "t",
            "url",
            "cmd",
            "stream"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_stream_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "225-253",
          "snippet": "static int ssh_stream_alloc(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tssh_stream *s;\n\n\tassert(stream);\n\n\ts = git__calloc(sizeof(ssh_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = ssh_stream_read;\n\ts->parent.write = ssh_stream_write;\n\ts->parent.free = ssh_stream_free;\n\n\ts->cmd = cmd;\n\n\ts->url = git__strdup(url);\n\tif (!s->url) {\n\t\tgit__free(s);\n\t\treturn -1;\n\t}\n\n\t*stream = &s->parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_stream_alloc(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tssh_stream *s;\n\n\tassert(stream);\n\n\ts = git__calloc(sizeof(ssh_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = ssh_stream_read;\n\ts->parent.write = ssh_stream_write;\n\ts->parent.free = ssh_stream_free;\n\n\ts->cmd = cmd;\n\n\ts->url = git__strdup(url);\n\tif (!s->url) {\n\t\tgit__free(s);\n\t\treturn -1;\n\t}\n\n\t*stream = &s->parent;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_setup_conn(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tchar *host=NULL, *port=NULL, *path=NULL, *user=NULL, *pass=NULL;\n\tconst char *default_port=\"22\";\n\tint auth_methods, error = 0;\n\tsize_t i;\n\tssh_stream *s;\n\tgit_cred *cred = NULL;\n\tLIBSSH2_SESSION* session=NULL;\n\tLIBSSH2_CHANNEL* channel=NULL;\n\n\tt->current_stream = NULL;\n\n\t*stream = NULL;\n\tif (ssh_stream_alloc(t, url, cmd, stream) < 0)\n\t\treturn -1;\n\n\ts = (ssh_stream *)*stream;\n\ts->session = NULL;\n\ts->channel = NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\tif ((error = gitno_extract_url_parts(&host, &port, &path, &user, &pass, url, default_port)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgoto post_extract;\n\t\t}\n\t}\n\tif ((error = git_ssh_extract_url_parts(&host, &user, url)) < 0)\n\t\tgoto done;\n\tport = git__strdup(default_port);\n\tGITERR_CHECK_ALLOC(port);\n\npost_extract:\n\tif ((error = git_socket_stream_new(&s->io, host, port)) < 0 ||\n\t    (error = git_stream_connect(s->io)) < 0)\n\t\tgoto done;\n\n\tif ((error = _git_ssh_session_create(&session, s->io)) < 0)\n\t\tgoto done;\n\n\tif (t->owner->certificate_check_cb != NULL) {\n\t\tgit_cert_hostkey cert = {{ 0 }}, *cert_ptr;\n\t\tconst char *key;\n\n\t\tcert.parent.cert_type = GIT_CERT_HOSTKEY_LIBSSH2;\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_SHA1);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_SHA1;\n\t\t\tmemcpy(&cert.hash_sha1, key, 20);\n\t\t}\n\n\t\tkey = libssh2_hostkey_hash(session, LIBSSH2_HOSTKEY_HASH_MD5);\n\t\tif (key != NULL) {\n\t\t\tcert.type |= GIT_CERT_SSH_MD5;\n\t\t\tmemcpy(&cert.hash_md5, key, 16);\n\t\t}\n\n\t\tif (cert.type == 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"unable to get the host key\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* We don't currently trust any hostkeys */\n\t\tgiterr_clear();\n\n\t\tcert_ptr = &cert;\n\n\t\terror = t->owner->certificate_check_cb((git_cert *) cert_ptr, 0, host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled hostkey check\");\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* we need the username to ask for auth methods */\n\tif (!user) {\n\t\tif ((error = request_creds(&cred, t, NULL, GIT_CREDTYPE_USERNAME)) < 0)\n\t\t\tgoto done;\n\n\t\tuser = git__strdup(((git_cred_username *) cred)->username);\n\t\tcred->free(cred);\n\t\tcred = NULL;\n\t\tif (!user)\n\t\t\tgoto done;\n\t} else if (user && pass) {\n\t\tif ((error = git_cred_userpass_plaintext_new(&cred, user, pass)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif ((error = list_auth_methods(&auth_methods, session, user)) < 0)\n\t\tgoto done;\n\n\terror = GIT_EAUTH;\n\t/* if we already have something to try */\n\tif (cred && auth_methods & cred->credtype)\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\n\twhile (error == GIT_EAUTH) {\n\t\tif (cred) {\n\t\t\tcred->free(cred);\n\t\t\tcred = NULL;\n\t\t}\n\n\t\tif ((error = request_creds(&cred, t, user, auth_methods)) < 0)\n\t\t\tgoto done;\n\n\t\tif (strcmp(user, git_cred__username(cred))) {\n\t\t\tgiterr_set(GITERR_SSH, \"username does not match previous request\");\n\t\t\terror = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\terror = _git_ssh_authenticate_session(session, cred);\n\t}\n\n\tif (error < 0)\n\t\tgoto done;\n\n\tchannel = libssh2_channel_open_session(session);\n\tif (!channel) {\n\t\terror = -1;\n\t\tssh_error(session, \"Failed to open SSH channel\");\n\t\tgoto done;\n\t}\n\n\tlibssh2_channel_set_blocking(channel, 1);\n\n\ts->session = session;\n\ts->channel = channel;\n\n\tt->current_stream = s;\n\ndone:\n\tif (error < 0) {\n\t\tssh_stream_free(*stream);\n\n\t\tif (session)\n\t\t\tlibssh2_session_free(session);\n\t}\n\n\tif (cred)\n\t\tcred->free(cred);\n\n\tgit__free(host);\n\tgit__free(port);\n\tgit__free(path);\n\tgit__free(user);\n\tgit__free(pass);\n\n\treturn error;\n}"
  },
  {
    "function_name": "_git_ssh_session_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "469-500",
    "snippet": "static int _git_ssh_session_create(\n\tLIBSSH2_SESSION** session,\n\tgit_stream *io)\n{\n\tint rc = 0;\n\tLIBSSH2_SESSION* s;\n\tgit_socket_stream *socket = (git_socket_stream *) io;\n\n\tassert(session);\n\n\ts = libssh2_session_init();\n\tif (!s) {\n\t\tgiterr_set(GITERR_NET, \"Failed to initialize SSH session\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\trc = libssh2_session_startup(s, socket->s);\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s, \"Failed to start SSH session\");\n\t\tlibssh2_session_free(s);\n\t\treturn -1;\n\t}\n\n\tlibssh2_session_set_blocking(s, 1);\n\n\t*session = s;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libssh2_session_set_blocking",
          "args": [
            "s",
            "1"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_session_free",
          "args": [
            "s"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "s",
            "\"Failed to start SSH session\""
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_session_startup",
          "args": [
            "s",
            "socket->s"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Failed to initialize SSH session\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_session_init",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "session"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_session_create(\n\tLIBSSH2_SESSION** session,\n\tgit_stream *io)\n{\n\tint rc = 0;\n\tLIBSSH2_SESSION* s;\n\tgit_socket_stream *socket = (git_socket_stream *) io;\n\n\tassert(session);\n\n\ts = libssh2_session_init();\n\tif (!s) {\n\t\tgiterr_set(GITERR_NET, \"Failed to initialize SSH session\");\n\t\treturn -1;\n\t}\n\n\tdo {\n\t\trc = libssh2_session_startup(s, socket->s);\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s, \"Failed to start SSH session\");\n\t\tlibssh2_session_free(s);\n\t\treturn -1;\n\t}\n\n\tlibssh2_session_set_blocking(s, 1);\n\n\t*session = s;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "request_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "432-467",
    "snippet": "static int request_creds(git_cred **out, ssh_subtransport *t, const char *user, int auth_methods)\n{\n\tint error, no_callback = 0;\n\tgit_cred *cred = NULL;\n\n\tif (!t->owner->cred_acquire_cb) {\n\t\tno_callback = 1;\n\t} else {\n\t\terror = t->owner->cred_acquire_cb(&cred, t->owner->url, user, auth_methods,\n\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\tno_callback = 1;\n\t\telse if (error < 0)\n\t\t\treturn error;\n\t\telse if (!cred) {\n\t\t\tgiterr_set(GITERR_SSH, \"Callback failed to initialize SSH credentials\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (no_callback) {\n\t\tgiterr_set(GITERR_SSH, \"authentication required but no callback set\");\n\t\treturn -1;\n\t}\n\n\tif (!(cred->credtype & auth_methods)) {\n\t\tcred->free(cred);\n\t\tgiterr_set(GITERR_SSH, \"callback returned unsupported credentials type\");\n\t\treturn -1;\n\t}\n\n\t*out = cred;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SSH",
            "\"callback returned unsupported credentials type\""
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cred->free",
          "args": [
            "cred"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t->owner->cred_acquire_cb",
          "args": [
            "&cred",
            "t->owner->url",
            "user",
            "auth_methods",
            "t->owner->cred_acquire_payload"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int request_creds(git_cred **out, ssh_subtransport *t, const char *user, int auth_methods)\n{\n\tint error, no_callback = 0;\n\tgit_cred *cred = NULL;\n\n\tif (!t->owner->cred_acquire_cb) {\n\t\tno_callback = 1;\n\t} else {\n\t\terror = t->owner->cred_acquire_cb(&cred, t->owner->url, user, auth_methods,\n\t\t\t\t\t\t  t->owner->cred_acquire_payload);\n\n\t\tif (error == GIT_PASSTHROUGH)\n\t\t\tno_callback = 1;\n\t\telse if (error < 0)\n\t\t\treturn error;\n\t\telse if (!cred) {\n\t\t\tgiterr_set(GITERR_SSH, \"Callback failed to initialize SSH credentials\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (no_callback) {\n\t\tgiterr_set(GITERR_SSH, \"authentication required but no callback set\");\n\t\treturn -1;\n\t}\n\n\tif (!(cred->credtype & auth_methods)) {\n\t\tcred->free(cred);\n\t\tgiterr_set(GITERR_SSH, \"callback returned unsupported credentials type\");\n\t\treturn -1;\n\t}\n\n\t*out = cred;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "_git_ssh_authenticate_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "341-430",
    "snippet": "static int _git_ssh_authenticate_session(\n\tLIBSSH2_SESSION* session,\n\tgit_cred* cred)\n{\n\tint rc;\n\n\tdo {\n\t\tgiterr_clear();\n\t\tswitch (cred->credtype) {\n\t\tcase GIT_CREDTYPE_USERPASS_PLAINTEXT: {\n\t\t\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\t\t\trc = libssh2_userauth_password(session, c->username, c->password);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_KEY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tif (c->privatekey)\n\t\t\t\trc = libssh2_userauth_publickey_fromfile(\n\t\t\t\t\tsession, c->username, c->publickey,\n\t\t\t\t\tc->privatekey, c->passphrase);\n\t\t\telse\n\t\t\t\trc = ssh_agent_auth(session, c);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_CUSTOM: {\n\t\t\tgit_cred_ssh_custom *c = (git_cred_ssh_custom *)cred;\n\n\t\t\trc = libssh2_userauth_publickey(\n\t\t\t\tsession, c->username, (const unsigned char *)c->publickey,\n\t\t\t\tc->publickey_len, c->sign_callback, &c->payload);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_INTERACTIVE: {\n\t\t\tvoid **abstract = libssh2_session_abstract(session);\n\t\t\tgit_cred_ssh_interactive *c = (git_cred_ssh_interactive *)cred;\n\n\t\t\t/* ideally, we should be able to set this by calling\n\t\t\t * libssh2_session_init_ex() instead of libssh2_session_init().\n\t\t\t * libssh2's API is inconsistent here i.e. libssh2_userauth_publickey()\n\t\t\t * allows you to pass the `abstract` as part of the call, whereas\n\t\t\t * libssh2_userauth_keyboard_interactive() does not!\n\t\t\t *\n\t\t\t * The only way to set the `abstract` pointer is by calling\n\t\t\t * libssh2_session_abstract(), which will replace the existing\n\t\t\t * pointer as is done below. This is safe for now (at time of writing),\n\t\t\t * but may not be valid in future.\n\t\t\t */\n\t\t\t*abstract = c->payload;\n\n\t\t\trc = libssh2_userauth_keyboard_interactive(\n\t\t\t\tsession, c->username, c->prompt_callback);\n\t\t\tbreak;\n\t\t}\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\tcase GIT_CREDTYPE_SSH_MEMORY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tassert(c->username);\n\t\t\tassert(c->privatekey);\n\n\t\t\trc = libssh2_userauth_publickey_frommemory(\n\t\t\t\tsession,\n\t\t\t\tc->username,\n\t\t\t\tstrlen(c->username),\n\t\t\t\tc->publickey,\n\t\t\t\tc->publickey ? strlen(c->publickey) : 0,\n\t\t\t\tc->privatekey,\n\t\t\t\tstrlen(c->privatekey),\n\t\t\t\tc->passphrase);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t}\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n        if (rc == LIBSSH2_ERROR_PASSWORD_EXPIRED || rc == LIBSSH2_ERROR_AUTHENTICATION_FAILED)\n                return GIT_EAUTH;\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tif (!giterr_last())\n\t\t\tssh_error(session, \"Failed to authenticate SSH session\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "session",
            "\"Failed to authenticate SSH session\""
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_publickey_frommemory",
          "args": [
            "session",
            "c->username",
            "strlen(c->username)",
            "c->publickey",
            "c->publickey ? strlen(c->publickey) : 0",
            "c->privatekey",
            "strlen(c->privatekey)",
            "c->passphrase"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->privatekey"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->publickey"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c->username"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "c->privatekey"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "c->username"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_keyboard_interactive",
          "args": [
            "session",
            "c->username",
            "c->prompt_callback"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_session_abstract",
          "args": [
            "session"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_publickey",
          "args": [
            "session",
            "c->username",
            "(const unsigned char *)c->publickey",
            "c->publickey_len",
            "c->sign_callback",
            "&c->payload"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_agent_auth",
          "args": [
            "session",
            "c"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_agent_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "287-339",
          "snippet": "static int ssh_agent_auth(LIBSSH2_SESSION *session, git_cred_ssh_key *c) {\n\tint rc = LIBSSH2_ERROR_NONE;\n\n\tstruct libssh2_agent_publickey *curr, *prev = NULL;\n\n\tLIBSSH2_AGENT *agent = libssh2_agent_init(session);\n\n\tif (agent == NULL)\n\t\treturn -1;\n\n\trc = libssh2_agent_connect(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\trc = libssh2_agent_list_identities(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\twhile (1) {\n\t\trc = libssh2_agent_get_identity(agent, &curr, prev);\n\n\t\tif (rc < 0)\n\t\t\tgoto shutdown;\n\n\t\t/* rc is set to 1 whenever the ssh agent ran out of keys to check.\n\t\t * Set the error code to authentication failure rather than erroring\n\t\t * out with an untranslatable error code.\n\t\t */\n\t\tif (rc == 1) {\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t\tgoto shutdown;\n\t\t}\n\n\t\trc = libssh2_agent_userauth(agent, c->username, curr);\n\n\t\tif (rc == 0)\n\t\t\tbreak;\n\n\t\tprev = curr;\n\t}\n\nshutdown:\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tssh_error(session, \"error authenticating\");\n\n\tlibssh2_agent_disconnect(agent);\n\tlibssh2_agent_free(agent);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_agent_auth(LIBSSH2_SESSION *session, git_cred_ssh_key *c) {\n\tint rc = LIBSSH2_ERROR_NONE;\n\n\tstruct libssh2_agent_publickey *curr, *prev = NULL;\n\n\tLIBSSH2_AGENT *agent = libssh2_agent_init(session);\n\n\tif (agent == NULL)\n\t\treturn -1;\n\n\trc = libssh2_agent_connect(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\trc = libssh2_agent_list_identities(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\twhile (1) {\n\t\trc = libssh2_agent_get_identity(agent, &curr, prev);\n\n\t\tif (rc < 0)\n\t\t\tgoto shutdown;\n\n\t\t/* rc is set to 1 whenever the ssh agent ran out of keys to check.\n\t\t * Set the error code to authentication failure rather than erroring\n\t\t * out with an untranslatable error code.\n\t\t */\n\t\tif (rc == 1) {\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t\tgoto shutdown;\n\t\t}\n\n\t\trc = libssh2_agent_userauth(agent, c->username, curr);\n\n\t\tif (rc == 0)\n\t\t\tbreak;\n\n\t\tprev = curr;\n\t}\n\nshutdown:\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tssh_error(session, \"error authenticating\");\n\n\tlibssh2_agent_disconnect(agent);\n\tlibssh2_agent_free(agent);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_publickey_fromfile",
          "args": [
            "session",
            "c->username",
            "c->publickey",
            "c->privatekey",
            "c->passphrase"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_userauth_password",
          "args": [
            "session",
            "c->username",
            "c->password"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int _git_ssh_authenticate_session(\n\tLIBSSH2_SESSION* session,\n\tgit_cred* cred)\n{\n\tint rc;\n\n\tdo {\n\t\tgiterr_clear();\n\t\tswitch (cred->credtype) {\n\t\tcase GIT_CREDTYPE_USERPASS_PLAINTEXT: {\n\t\t\tgit_cred_userpass_plaintext *c = (git_cred_userpass_plaintext *)cred;\n\t\t\trc = libssh2_userauth_password(session, c->username, c->password);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_KEY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tif (c->privatekey)\n\t\t\t\trc = libssh2_userauth_publickey_fromfile(\n\t\t\t\t\tsession, c->username, c->publickey,\n\t\t\t\t\tc->privatekey, c->passphrase);\n\t\t\telse\n\t\t\t\trc = ssh_agent_auth(session, c);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_CUSTOM: {\n\t\t\tgit_cred_ssh_custom *c = (git_cred_ssh_custom *)cred;\n\n\t\t\trc = libssh2_userauth_publickey(\n\t\t\t\tsession, c->username, (const unsigned char *)c->publickey,\n\t\t\t\tc->publickey_len, c->sign_callback, &c->payload);\n\t\t\tbreak;\n\t\t}\n\t\tcase GIT_CREDTYPE_SSH_INTERACTIVE: {\n\t\t\tvoid **abstract = libssh2_session_abstract(session);\n\t\t\tgit_cred_ssh_interactive *c = (git_cred_ssh_interactive *)cred;\n\n\t\t\t/* ideally, we should be able to set this by calling\n\t\t\t * libssh2_session_init_ex() instead of libssh2_session_init().\n\t\t\t * libssh2's API is inconsistent here i.e. libssh2_userauth_publickey()\n\t\t\t * allows you to pass the `abstract` as part of the call, whereas\n\t\t\t * libssh2_userauth_keyboard_interactive() does not!\n\t\t\t *\n\t\t\t * The only way to set the `abstract` pointer is by calling\n\t\t\t * libssh2_session_abstract(), which will replace the existing\n\t\t\t * pointer as is done below. This is safe for now (at time of writing),\n\t\t\t * but may not be valid in future.\n\t\t\t */\n\t\t\t*abstract = c->payload;\n\n\t\t\trc = libssh2_userauth_keyboard_interactive(\n\t\t\t\tsession, c->username, c->prompt_callback);\n\t\t\tbreak;\n\t\t}\n#ifdef GIT_SSH_MEMORY_CREDENTIALS\n\t\tcase GIT_CREDTYPE_SSH_MEMORY: {\n\t\t\tgit_cred_ssh_key *c = (git_cred_ssh_key *)cred;\n\n\t\t\tassert(c->username);\n\t\t\tassert(c->privatekey);\n\n\t\t\trc = libssh2_userauth_publickey_frommemory(\n\t\t\t\tsession,\n\t\t\t\tc->username,\n\t\t\t\tstrlen(c->username),\n\t\t\t\tc->publickey,\n\t\t\t\tc->publickey ? strlen(c->publickey) : 0,\n\t\t\t\tc->privatekey,\n\t\t\t\tstrlen(c->privatekey),\n\t\t\t\tc->passphrase);\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t}\n\t} while (LIBSSH2_ERROR_EAGAIN == rc || LIBSSH2_ERROR_TIMEOUT == rc);\n\n        if (rc == LIBSSH2_ERROR_PASSWORD_EXPIRED || rc == LIBSSH2_ERROR_AUTHENTICATION_FAILED)\n                return GIT_EAUTH;\n\n\tif (rc != LIBSSH2_ERROR_NONE) {\n\t\tif (!giterr_last())\n\t\t\tssh_error(session, \"Failed to authenticate SSH session\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_agent_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "287-339",
    "snippet": "static int ssh_agent_auth(LIBSSH2_SESSION *session, git_cred_ssh_key *c) {\n\tint rc = LIBSSH2_ERROR_NONE;\n\n\tstruct libssh2_agent_publickey *curr, *prev = NULL;\n\n\tLIBSSH2_AGENT *agent = libssh2_agent_init(session);\n\n\tif (agent == NULL)\n\t\treturn -1;\n\n\trc = libssh2_agent_connect(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\trc = libssh2_agent_list_identities(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\twhile (1) {\n\t\trc = libssh2_agent_get_identity(agent, &curr, prev);\n\n\t\tif (rc < 0)\n\t\t\tgoto shutdown;\n\n\t\t/* rc is set to 1 whenever the ssh agent ran out of keys to check.\n\t\t * Set the error code to authentication failure rather than erroring\n\t\t * out with an untranslatable error code.\n\t\t */\n\t\tif (rc == 1) {\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t\tgoto shutdown;\n\t\t}\n\n\t\trc = libssh2_agent_userauth(agent, c->username, curr);\n\n\t\tif (rc == 0)\n\t\t\tbreak;\n\n\t\tprev = curr;\n\t}\n\nshutdown:\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tssh_error(session, \"error authenticating\");\n\n\tlibssh2_agent_disconnect(agent);\n\tlibssh2_agent_free(agent);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libssh2_agent_free",
          "args": [
            "agent"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_agent_disconnect",
          "args": [
            "agent"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "session",
            "\"error authenticating\""
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_agent_userauth",
          "args": [
            "agent",
            "c->username",
            "curr"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_agent_get_identity",
          "args": [
            "agent",
            "&curr",
            "prev"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_agent_list_identities",
          "args": [
            "agent"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_agent_connect",
          "args": [
            "agent"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_agent_init",
          "args": [
            "session"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_agent_auth(LIBSSH2_SESSION *session, git_cred_ssh_key *c) {\n\tint rc = LIBSSH2_ERROR_NONE;\n\n\tstruct libssh2_agent_publickey *curr, *prev = NULL;\n\n\tLIBSSH2_AGENT *agent = libssh2_agent_init(session);\n\n\tif (agent == NULL)\n\t\treturn -1;\n\n\trc = libssh2_agent_connect(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\trc = libssh2_agent_list_identities(agent);\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tgoto shutdown;\n\n\twhile (1) {\n\t\trc = libssh2_agent_get_identity(agent, &curr, prev);\n\n\t\tif (rc < 0)\n\t\t\tgoto shutdown;\n\n\t\t/* rc is set to 1 whenever the ssh agent ran out of keys to check.\n\t\t * Set the error code to authentication failure rather than erroring\n\t\t * out with an untranslatable error code.\n\t\t */\n\t\tif (rc == 1) {\n\t\t\trc = LIBSSH2_ERROR_AUTHENTICATION_FAILED;\n\t\t\tgoto shutdown;\n\t\t}\n\n\t\trc = libssh2_agent_userauth(agent, c->username, curr);\n\n\t\tif (rc == 0)\n\t\t\tbreak;\n\n\t\tprev = curr;\n\t}\n\nshutdown:\n\n\tif (rc != LIBSSH2_ERROR_NONE)\n\t\tssh_error(session, \"error authenticating\");\n\n\tlibssh2_agent_disconnect(agent);\n\tlibssh2_agent_free(agent);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "git_ssh_extract_url_parts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "255-285",
    "snippet": "static int git_ssh_extract_url_parts(\n\tchar **host,\n\tchar **username,\n\tconst char *url)\n{\n\tchar *colon, *at;\n\tconst char *start;\n\n\tcolon = strchr(url, ':');\n\n\n\tat = strchr(url, '@');\n\tif (at) {\n\t\tstart = at + 1;\n\t\t*username = git__substrdup(url, at - url);\n\t\tGITERR_CHECK_ALLOC(*username);\n\t} else {\n\t\tstart = url;\n\t\t*username = NULL;\n\t}\n\n\tif (colon == NULL || (colon < start)) {\n\t\tgiterr_set(GITERR_NET, \"Malformed URL\");\n\t\treturn -1;\n\t}\n\n\t*host = git__substrdup(start, colon - start);\n\tGITERR_CHECK_ALLOC(*host);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "*host"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__substrdup",
          "args": [
            "start",
            "colon - start"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "git__substrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "201-213",
          "snippet": "GIT_INLINE(char *) git__substrdup(const char *start, size_t n)\n{\n\tchar *ptr;\n\tsize_t alloclen;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, n, 1) ||\n\t\t!(ptr = git__malloc(alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(ptr, start, n);\n\tptr[n] = '\\0';\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__substrdup(const char *start, size_t n)\n{\n\tchar *ptr;\n\tsize_t alloclen;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, n, 1) ||\n\t\t!(ptr = git__malloc(alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(ptr, start, n);\n\tptr[n] = '\\0';\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Malformed URL\""
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "*username"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "url",
            "'@'"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "url",
            "':'"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int git_ssh_extract_url_parts(\n\tchar **host,\n\tchar **username,\n\tconst char *url)\n{\n\tchar *colon, *at;\n\tconst char *start;\n\n\tcolon = strchr(url, ':');\n\n\n\tat = strchr(url, '@');\n\tif (at) {\n\t\tstart = at + 1;\n\t\t*username = git__substrdup(url, at - url);\n\t\tGITERR_CHECK_ALLOC(*username);\n\t} else {\n\t\tstart = url;\n\t\t*username = NULL;\n\t}\n\n\tif (colon == NULL || (colon < start)) {\n\t\tgiterr_set(GITERR_NET, \"Malformed URL\");\n\t\treturn -1;\n\t}\n\n\t*host = git__substrdup(start, colon - start);\n\tGITERR_CHECK_ALLOC(*host);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_stream_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "225-253",
    "snippet": "static int ssh_stream_alloc(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tssh_stream *s;\n\n\tassert(stream);\n\n\ts = git__calloc(sizeof(ssh_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = ssh_stream_read;\n\ts->parent.write = ssh_stream_write;\n\ts->parent.free = ssh_stream_free;\n\n\ts->cmd = cmd;\n\n\ts->url = git__strdup(url);\n\tif (!s->url) {\n\t\tgit__free(s);\n\t\treturn -1;\n\t}\n\n\t*stream = &s->parent;\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "s"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "url"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "s"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "sizeof(ssh_stream)",
            "1"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "stream"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_stream_alloc(\n\tssh_subtransport *t,\n\tconst char *url,\n\tconst char *cmd,\n\tgit_smart_subtransport_stream **stream)\n{\n\tssh_stream *s;\n\n\tassert(stream);\n\n\ts = git__calloc(sizeof(ssh_stream), 1);\n\tGITERR_CHECK_ALLOC(s);\n\n\ts->parent.subtransport = &t->parent;\n\ts->parent.read = ssh_stream_read;\n\ts->parent.write = ssh_stream_write;\n\ts->parent.free = ssh_stream_free;\n\n\ts->cmd = cmd;\n\n\ts->url = git__strdup(url);\n\tif (!s->url) {\n\t\tgit__free(s);\n\t\treturn -1;\n\t}\n\n\t*stream = &s->parent;\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_stream_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "193-223",
    "snippet": "static void ssh_stream_free(git_smart_subtransport_stream *stream)\n{\n\tssh_stream *s = (ssh_stream *)stream;\n\tssh_subtransport *t;\n\n\tif (!stream)\n\t\treturn;\n\n\tt = OWNING_SUBTRANSPORT(s);\n\tt->current_stream = NULL;\n\n\tif (s->channel) {\n\t\tlibssh2_channel_close(s->channel);\n\t\tlibssh2_channel_free(s->channel);\n\t\ts->channel = NULL;\n\t}\n\n\tif (s->session) {\n\t\tlibssh2_session_free(s->session);\n\t\ts->session = NULL;\n\t}\n\n\tif (s->io) {\n\t\tgit_stream_close(s->io);\n\t\tgit_stream_free(s->io);\n\t\ts->io = NULL;\n\t}\n\n\tgit__free(s->url);\n\tgit__free(s);\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "s"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_free",
          "args": [
            "s->io"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "63-69",
          "snippet": "GIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_stream_close",
          "args": [
            "s->io"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git_stream_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stream.h",
          "lines": "58-61",
          "snippet": "GIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}",
          "includes": [
            "#include \"git2/sys/stream.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/stream.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_session_free",
          "args": [
            "s->session"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_channel_free",
          "args": [
            "s->channel"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_channel_close",
          "args": [
            "s->channel"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OWNING_SUBTRANSPORT",
          "args": [
            "s"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_stream_free(git_smart_subtransport_stream *stream)\n{\n\tssh_stream *s = (ssh_stream *)stream;\n\tssh_subtransport *t;\n\n\tif (!stream)\n\t\treturn;\n\n\tt = OWNING_SUBTRANSPORT(s);\n\tt->current_stream = NULL;\n\n\tif (s->channel) {\n\t\tlibssh2_channel_close(s->channel);\n\t\tlibssh2_channel_free(s->channel);\n\t\ts->channel = NULL;\n\t}\n\n\tif (s->session) {\n\t\tlibssh2_session_free(s->session);\n\t\ts->session = NULL;\n\t}\n\n\tif (s->io) {\n\t\tgit_stream_close(s->io);\n\t\tgit_stream_free(s->io);\n\t\ts->io = NULL;\n\t}\n\n\tgit__free(s->url);\n\tgit__free(s);\n}"
  },
  {
    "function_name": "ssh_stream_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "164-191",
    "snippet": "static int ssh_stream_write(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\tssh_stream *s = (ssh_stream *)stream;\n\tsize_t off = 0;\n\tssize_t ret = 0;\n\n\tif (!s->sent_command && send_command(s) < 0)\n\t\treturn -1;\n\n\tdo {\n\t\tret = libssh2_channel_write(s->channel, buffer + off, len - off);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\toff += ret;\n\n\t} while (off < len);\n\n\tif (ret < 0) {\n\t\tssh_error(s->session, \"SSH could not write data\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "s->session",
            "\"SSH could not write data\""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_channel_write",
          "args": [
            "s->channel",
            "buffer + off",
            "len - off"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_command",
          "args": [
            "s"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "send_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "102-122",
          "snippet": "static int send_command(ssh_stream *s)\n{\n\tint error;\n\tgit_buf request = GIT_BUF_INIT;\n\n\terror = gen_proto(&request, s->cmd, s->url);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = libssh2_channel_exec(s->channel, request.ptr);\n\tif (error < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not execute request\");\n\t\tgoto cleanup;\n\t}\n\n\ts->sent_command = 1;\n\ncleanup:\n\tgit_buf_free(&request);\n\treturn error;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int send_command(ssh_stream *s)\n{\n\tint error;\n\tgit_buf request = GIT_BUF_INIT;\n\n\terror = gen_proto(&request, s->cmd, s->url);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = libssh2_channel_exec(s->channel, request.ptr);\n\tif (error < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not execute request\");\n\t\tgoto cleanup;\n\t}\n\n\ts->sent_command = 1;\n\ncleanup:\n\tgit_buf_free(&request);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_stream_write(\n\tgit_smart_subtransport_stream *stream,\n\tconst char *buffer,\n\tsize_t len)\n{\n\tssh_stream *s = (ssh_stream *)stream;\n\tsize_t off = 0;\n\tssize_t ret = 0;\n\n\tif (!s->sent_command && send_command(s) < 0)\n\t\treturn -1;\n\n\tdo {\n\t\tret = libssh2_channel_write(s->channel, buffer + off, len - off);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\toff += ret;\n\n\t} while (off < len);\n\n\tif (ret < 0) {\n\t\tssh_error(s->session, \"SSH could not write data\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_stream_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "124-162",
    "snippet": "static int ssh_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\tint rc;\n\tssh_stream *s = (ssh_stream *)stream;\n\n\t*bytes_read = 0;\n\n\tif (!s->sent_command && send_command(s) < 0)\n\t\treturn -1;\n\n\tif ((rc = libssh2_channel_read(s->channel, buffer, buf_size)) < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not read data\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we can't get anything out of stdout, it's typically a\n\t * not-found error, so read from stderr and signal EOF on\n\t * stderr.\n\t */\n\tif (rc == 0) {\n\t\tif ((rc = libssh2_channel_read_stderr(s->channel, buffer, buf_size)) > 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"%*s\", rc, buffer);\n\t\t\treturn GIT_EEOF;\n\t\t} else if (rc < LIBSSH2_ERROR_NONE) {\n\t\t\tssh_error(s->session, \"SSH could not read stderr\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\t*bytes_read = rc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "s->session",
            "\"SSH could not read stderr\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SSH",
            "\"%*s\"",
            "rc",
            "buffer"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_channel_read_stderr",
          "args": [
            "s->channel",
            "buffer",
            "buf_size"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libssh2_channel_read",
          "args": [
            "s->channel",
            "buffer",
            "buf_size"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_command",
          "args": [
            "s"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "send_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "102-122",
          "snippet": "static int send_command(ssh_stream *s)\n{\n\tint error;\n\tgit_buf request = GIT_BUF_INIT;\n\n\terror = gen_proto(&request, s->cmd, s->url);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = libssh2_channel_exec(s->channel, request.ptr);\n\tif (error < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not execute request\");\n\t\tgoto cleanup;\n\t}\n\n\ts->sent_command = 1;\n\ncleanup:\n\tgit_buf_free(&request);\n\treturn error;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int send_command(ssh_stream *s)\n{\n\tint error;\n\tgit_buf request = GIT_BUF_INIT;\n\n\terror = gen_proto(&request, s->cmd, s->url);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = libssh2_channel_exec(s->channel, request.ptr);\n\tif (error < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not execute request\");\n\t\tgoto cleanup;\n\t}\n\n\ts->sent_command = 1;\n\ncleanup:\n\tgit_buf_free(&request);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int ssh_stream_read(\n\tgit_smart_subtransport_stream *stream,\n\tchar *buffer,\n\tsize_t buf_size,\n\tsize_t *bytes_read)\n{\n\tint rc;\n\tssh_stream *s = (ssh_stream *)stream;\n\n\t*bytes_read = 0;\n\n\tif (!s->sent_command && send_command(s) < 0)\n\t\treturn -1;\n\n\tif ((rc = libssh2_channel_read(s->channel, buffer, buf_size)) < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not read data\");\n\t\treturn -1;\n\t}\n\n\t/*\n\t * If we can't get anything out of stdout, it's typically a\n\t * not-found error, so read from stderr and signal EOF on\n\t * stderr.\n\t */\n\tif (rc == 0) {\n\t\tif ((rc = libssh2_channel_read_stderr(s->channel, buffer, buf_size)) > 0) {\n\t\t\tgiterr_set(GITERR_SSH, \"%*s\", rc, buffer);\n\t\t\treturn GIT_EEOF;\n\t\t} else if (rc < LIBSSH2_ERROR_NONE) {\n\t\t\tssh_error(s->session, \"SSH could not read stderr\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\n\t*bytes_read = rc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "send_command",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "102-122",
    "snippet": "static int send_command(ssh_stream *s)\n{\n\tint error;\n\tgit_buf request = GIT_BUF_INIT;\n\n\terror = gen_proto(&request, s->cmd, s->url);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = libssh2_channel_exec(s->channel, request.ptr);\n\tif (error < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not execute request\");\n\t\tgoto cleanup;\n\t}\n\n\ts->sent_command = 1;\n\ncleanup:\n\tgit_buf_free(&request);\n\treturn error;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&request"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssh_error",
          "args": [
            "s->session",
            "\"SSH could not execute request\""
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ssh_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "50-56",
          "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_channel_exec",
          "args": [
            "s->channel",
            "request.ptr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_proto",
          "args": [
            "&request",
            "s->cmd",
            "s->url"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "gen_proto",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
          "lines": "63-100",
          "snippet": "static int gen_proto(git_buf *request, const char *cmd, const char *url)\n{\n\tchar *repo;\n\tint len;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\turl = url + strlen(p);\n\t\t\trepo = strchr(url, '/');\n\t\t\tif (repo && repo[1] == '~')\n\t\t\t\t++repo;\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\trepo = strchr(url, ':');\n\tif (repo) repo++;\n\ndone:\n\tif (!repo) {\n\t\tgiterr_set(GITERR_NET, \"Malformed git protocol URL\");\n\t\treturn -1;\n\t}\n\n\tlen = strlen(cmd) + 1 /* Space */ + 1 /* Quote */ + strlen(repo) + 1 /* Quote */ + 1;\n\n\tgit_buf_grow(request, len);\n\tgit_buf_printf(request, \"%s '%s'\", cmd, repo);\n\tgit_buf_putc(request, '\\0');\n\n\tif (git_buf_oom(request))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ssh.h\"",
            "#include \"socket_stream.h\"",
            "#include \"cred.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"buffer.h\"",
            "#include \"git2.h\"",
            "#include <libssh2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int gen_proto(git_buf *request, const char *cmd, const char *url)\n{\n\tchar *repo;\n\tint len;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\turl = url + strlen(p);\n\t\t\trepo = strchr(url, '/');\n\t\t\tif (repo && repo[1] == '~')\n\t\t\t\t++repo;\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\trepo = strchr(url, ':');\n\tif (repo) repo++;\n\ndone:\n\tif (!repo) {\n\t\tgiterr_set(GITERR_NET, \"Malformed git protocol URL\");\n\t\treturn -1;\n\t}\n\n\tlen = strlen(cmd) + 1 /* Space */ + 1 /* Quote */ + strlen(repo) + 1 /* Quote */ + 1;\n\n\tgit_buf_grow(request, len);\n\tgit_buf_printf(request, \"%s '%s'\", cmd, repo);\n\tgit_buf_putc(request, '\\0');\n\n\tif (git_buf_oom(request))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int send_command(ssh_stream *s)\n{\n\tint error;\n\tgit_buf request = GIT_BUF_INIT;\n\n\terror = gen_proto(&request, s->cmd, s->url);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\terror = libssh2_channel_exec(s->channel, request.ptr);\n\tif (error < LIBSSH2_ERROR_NONE) {\n\t\tssh_error(s->session, \"SSH could not execute request\");\n\t\tgoto cleanup;\n\t}\n\n\ts->sent_command = 1;\n\ncleanup:\n\tgit_buf_free(&request);\n\treturn error;\n}"
  },
  {
    "function_name": "gen_proto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "63-100",
    "snippet": "static int gen_proto(git_buf *request, const char *cmd, const char *url)\n{\n\tchar *repo;\n\tint len;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\turl = url + strlen(p);\n\t\t\trepo = strchr(url, '/');\n\t\t\tif (repo && repo[1] == '~')\n\t\t\t\t++repo;\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\trepo = strchr(url, ':');\n\tif (repo) repo++;\n\ndone:\n\tif (!repo) {\n\t\tgiterr_set(GITERR_NET, \"Malformed git protocol URL\");\n\t\treturn -1;\n\t}\n\n\tlen = strlen(cmd) + 1 /* Space */ + 1 /* Quote */ + strlen(repo) + 1 /* Quote */ + 1;\n\n\tgit_buf_grow(request, len);\n\tgit_buf_printf(request, \"%s '%s'\", cmd, repo);\n\tgit_buf_putc(request, '\\0');\n\n\tif (git_buf_oom(request))\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "request"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "request",
            "'\\0'"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "request",
            "\"%s '%s'\"",
            "cmd",
            "repo"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "request",
            "len"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "repo"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Malformed git protocol URL\""
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "url",
            "':'"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "url",
            "'/'"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "url",
            "p"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ssh_prefixes"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic int gen_proto(git_buf *request, const char *cmd, const char *url)\n{\n\tchar *repo;\n\tint len;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ssh_prefixes); ++i) {\n\t\tconst char *p = ssh_prefixes[i];\n\n\t\tif (!git__prefixcmp(url, p)) {\n\t\t\turl = url + strlen(p);\n\t\t\trepo = strchr(url, '/');\n\t\t\tif (repo && repo[1] == '~')\n\t\t\t\t++repo;\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\trepo = strchr(url, ':');\n\tif (repo) repo++;\n\ndone:\n\tif (!repo) {\n\t\tgiterr_set(GITERR_NET, \"Malformed git protocol URL\");\n\t\treturn -1;\n\t}\n\n\tlen = strlen(cmd) + 1 /* Space */ + 1 /* Quote */ + strlen(repo) + 1 /* Quote */ + 1;\n\n\tgit_buf_grow(request, len);\n\tgit_buf_printf(request, \"%s '%s'\", cmd, repo);\n\tgit_buf_putc(request, '\\0');\n\n\tif (git_buf_oom(request))\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ssh_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/ssh.c",
    "lines": "50-56",
    "snippet": "static void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}",
    "includes": [
      "#include \"ssh.h\"",
      "#include \"socket_stream.h\"",
      "#include \"cred.h\"",
      "#include \"smart.h\"",
      "#include \"netops.h\"",
      "#include \"buffer.h\"",
      "#include \"git2.h\"",
      "#include <libssh2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_SSH",
            "\"%s: %s\"",
            "errmsg",
            "ssherr"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libssh2_session_last_error",
          "args": [
            "session",
            "&ssherr",
            "NULL",
            "0"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ssh.h\"\n#include \"socket_stream.h\"\n#include \"cred.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"git2.h\"\n#include <libssh2.h>\n\nstatic void ssh_error(LIBSSH2_SESSION *session, const char *errmsg)\n{\n\tchar *ssherr;\n\tlibssh2_session_last_error(session, &ssherr, NULL, 0);\n\n\tgiterr_set(GITERR_SSH, \"%s: %s\", errmsg, ssherr);\n}"
  }
]