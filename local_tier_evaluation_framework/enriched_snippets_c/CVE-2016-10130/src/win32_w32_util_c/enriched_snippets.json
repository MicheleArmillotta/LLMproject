[
  {
    "function_name": "git_win32__canonicalize_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
    "lines": "130-163",
    "snippet": "size_t git_win32__canonicalize_path(wchar_t *str, size_t len)\n{\n\tstatic const wchar_t dosdevices_prefix[] = L\"\\\\\\?\\?\\\\\";\n\tstatic const wchar_t nt_prefix[] = L\"\\\\\\\\?\\\\\";\n\tstatic const wchar_t unc_prefix[] = L\"UNC\\\\\";\n\tsize_t to_advance = 0;\n\n\t/* \"\\??\\\" -- DOS Devices prefix */\n\tif (len >= CONST_STRLEN(dosdevices_prefix) &&\n\t\t!wcsncmp(str, dosdevices_prefix, CONST_STRLEN(dosdevices_prefix))) {\n\t\tto_advance += CONST_STRLEN(dosdevices_prefix);\n\t\tlen -= CONST_STRLEN(dosdevices_prefix);\n\t}\n\t/* \"\\\\?\\\" -- NT namespace prefix */\n\telse if (len >= CONST_STRLEN(nt_prefix) &&\n\t\t!wcsncmp(str, nt_prefix, CONST_STRLEN(nt_prefix))) {\n\t\tto_advance += CONST_STRLEN(nt_prefix);\n\t\tlen -= CONST_STRLEN(nt_prefix);\n\t}\n\n\t/* \"\\??\\UNC\\\", \"\\\\?\\UNC\\\" -- UNC prefix */\n\tif (to_advance && len >= CONST_STRLEN(unc_prefix) &&\n\t\t!wcsncmp(str + to_advance, unc_prefix, CONST_STRLEN(unc_prefix))) {\n\t\tto_advance += CONST_STRLEN(unc_prefix);\n\t\tlen -= CONST_STRLEN(unc_prefix);\n\t}\n\n\tif (to_advance) {\n\t\tmemmove(str, str + to_advance, len * sizeof(wchar_t));\n\t\tstr[len] = L'\\0';\n\t}\n\n\treturn git_win32__path_trim_end(str, len);\n}",
    "includes": [
      "#include \"w32_util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__path_trim_end",
          "args": [
            "str",
            "len"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__path_trim_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "104-121",
          "snippet": "size_t git_win32__path_trim_end(wchar_t *str, size_t len)\n{\n\twhile (1) {\n\t\tif (!len || str[len - 1] != L'\\\\')\n\t\t\tbreak;\n\n\t\t/* Don't trim backslashes from drive letter paths, which\n\t\t * are 3 characters long and of the form C:\\, D:\\, etc. */\n\t\tif (len == 3 && git_win32__isalpha(str[0]) && str[1] == ':')\n\t\t\tbreak;\n\n\t\tlen--;\n\t}\n\n\tstr[len] = L'\\0';\n\n\treturn len;\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nsize_t git_win32__path_trim_end(wchar_t *str, size_t len)\n{\n\twhile (1) {\n\t\tif (!len || str[len - 1] != L'\\\\')\n\t\t\tbreak;\n\n\t\t/* Don't trim backslashes from drive letter paths, which\n\t\t * are 3 characters long and of the form C:\\, D:\\, etc. */\n\t\tif (len == 3 && git_win32__isalpha(str[0]) && str[1] == ':')\n\t\t\tbreak;\n\n\t\tlen--;\n\t}\n\n\tstr[len] = L'\\0';\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "str",
            "str + to_advance",
            "len * sizeof(wchar_t)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "unc_prefix"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "unc_prefix"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "str + to_advance",
            "unc_prefix",
            "CONST_STRLEN(unc_prefix)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "unc_prefix"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "unc_prefix"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "nt_prefix"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "nt_prefix"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "str",
            "nt_prefix",
            "CONST_STRLEN(nt_prefix)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "nt_prefix"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "nt_prefix"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "dosdevices_prefix"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "dosdevices_prefix"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcsncmp",
          "args": [
            "str",
            "dosdevices_prefix",
            "CONST_STRLEN(dosdevices_prefix)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "dosdevices_prefix"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "dosdevices_prefix"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"w32_util.h\"\n\nsize_t git_win32__canonicalize_path(wchar_t *str, size_t len)\n{\n\tstatic const wchar_t dosdevices_prefix[] = L\"\\\\\\?\\?\\\\\";\n\tstatic const wchar_t nt_prefix[] = L\"\\\\\\\\?\\\\\";\n\tstatic const wchar_t unc_prefix[] = L\"UNC\\\\\";\n\tsize_t to_advance = 0;\n\n\t/* \"\\??\\\" -- DOS Devices prefix */\n\tif (len >= CONST_STRLEN(dosdevices_prefix) &&\n\t\t!wcsncmp(str, dosdevices_prefix, CONST_STRLEN(dosdevices_prefix))) {\n\t\tto_advance += CONST_STRLEN(dosdevices_prefix);\n\t\tlen -= CONST_STRLEN(dosdevices_prefix);\n\t}\n\t/* \"\\\\?\\\" -- NT namespace prefix */\n\telse if (len >= CONST_STRLEN(nt_prefix) &&\n\t\t!wcsncmp(str, nt_prefix, CONST_STRLEN(nt_prefix))) {\n\t\tto_advance += CONST_STRLEN(nt_prefix);\n\t\tlen -= CONST_STRLEN(nt_prefix);\n\t}\n\n\t/* \"\\??\\UNC\\\", \"\\\\?\\UNC\\\" -- UNC prefix */\n\tif (to_advance && len >= CONST_STRLEN(unc_prefix) &&\n\t\t!wcsncmp(str + to_advance, unc_prefix, CONST_STRLEN(unc_prefix))) {\n\t\tto_advance += CONST_STRLEN(unc_prefix);\n\t\tlen -= CONST_STRLEN(unc_prefix);\n\t}\n\n\tif (to_advance) {\n\t\tmemmove(str, str + to_advance, len * sizeof(wchar_t));\n\t\tstr[len] = L'\\0';\n\t}\n\n\treturn git_win32__path_trim_end(str, len);\n}"
  },
  {
    "function_name": "git_win32__path_trim_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
    "lines": "104-121",
    "snippet": "size_t git_win32__path_trim_end(wchar_t *str, size_t len)\n{\n\twhile (1) {\n\t\tif (!len || str[len - 1] != L'\\\\')\n\t\t\tbreak;\n\n\t\t/* Don't trim backslashes from drive letter paths, which\n\t\t * are 3 characters long and of the form C:\\, D:\\, etc. */\n\t\tif (len == 3 && git_win32__isalpha(str[0]) && str[1] == ':')\n\t\t\tbreak;\n\n\t\tlen--;\n\t}\n\n\tstr[len] = L'\\0';\n\n\treturn len;\n}",
    "includes": [
      "#include \"w32_util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__isalpha",
          "args": [
            "str[0]"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__isalpha",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.h",
          "lines": "27-30",
          "snippet": "GIT_INLINE(bool) git_win32__isalpha(wchar_t c)\n{\n\treturn ((c >= L'A' && c <= L'Z') || (c >= L'a' && c <= L'z'));\n}",
          "includes": [
            "#include \"path_w32.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"path_w32.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n\nGIT_INLINE(bool) git_win32__isalpha(wchar_t c)\n{\n\treturn ((c >= L'A' && c <= L'Z') || (c >= L'a' && c <= L'z'));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_util.h\"\n\nsize_t git_win32__path_trim_end(wchar_t *str, size_t len)\n{\n\twhile (1) {\n\t\tif (!len || str[len - 1] != L'\\\\')\n\t\t\tbreak;\n\n\t\t/* Don't trim backslashes from drive letter paths, which\n\t\t * are 3 characters long and of the form C:\\, D:\\, etc. */\n\t\tif (len == 3 && git_win32__isalpha(str[0]) && str[1] == ':')\n\t\t\tbreak;\n\n\t\tlen--;\n\t}\n\n\tstr[len] = L'\\0';\n\n\treturn len;\n}"
  },
  {
    "function_name": "git_win32__hidden",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
    "lines": "79-95",
    "snippet": "int git_win32__hidden(bool *out, const char *path)\n{\n\tgit_win32_path buf;\n\tDWORD attrs;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tattrs = GetFileAttributesW(buf);\n\n\t/* Ensure the path exists */\n\tif (attrs == INVALID_FILE_ATTRIBUTES)\n\t\treturn -1;\n\n\t*out = (attrs & FILE_ATTRIBUTE_HIDDEN) ? true : false;\n\treturn 0;\n}",
    "includes": [
      "#include \"w32_util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetFileAttributesW",
          "args": [
            "buf"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_util.h\"\n\nint git_win32__hidden(bool *out, const char *path)\n{\n\tgit_win32_path buf;\n\tDWORD attrs;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tattrs = GetFileAttributesW(buf);\n\n\t/* Ensure the path exists */\n\tif (attrs == INVALID_FILE_ATTRIBUTES)\n\t\treturn -1;\n\n\t*out = (attrs & FILE_ATTRIBUTE_HIDDEN) ? true : false;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_win32__set_hidden",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
    "lines": "51-77",
    "snippet": "int git_win32__set_hidden(const char *path, bool hidden)\n{\n\tgit_win32_path buf;\n\tDWORD attrs, newattrs;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tattrs = GetFileAttributesW(buf);\n\n\t/* Ensure the path exists */\n\tif (attrs == INVALID_FILE_ATTRIBUTES)\n\t\treturn -1;\n\n\tif (hidden)\n\t\tnewattrs = attrs | FILE_ATTRIBUTE_HIDDEN;\n\telse\n\t\tnewattrs = attrs & ~FILE_ATTRIBUTE_HIDDEN;\n\n\tif (attrs != newattrs && !SetFileAttributesW(buf, newattrs)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to %s hidden bit for '%s'\",\n\t\t\thidden ? \"set\" : \"unset\", path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"w32_util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to %s hidden bit for '%s'\"",
            "hidden ? \"set\" : \"unset\"",
            "path"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetFileAttributesW",
          "args": [
            "buf",
            "newattrs"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFileAttributesW",
          "args": [
            "buf"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_util.h\"\n\nint git_win32__set_hidden(const char *path, bool hidden)\n{\n\tgit_win32_path buf;\n\tDWORD attrs, newattrs;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tattrs = GetFileAttributesW(buf);\n\n\t/* Ensure the path exists */\n\tif (attrs == INVALID_FILE_ATTRIBUTES)\n\t\treturn -1;\n\n\tif (hidden)\n\t\tnewattrs = attrs | FILE_ATTRIBUTE_HIDDEN;\n\telse\n\t\tnewattrs = attrs & ~FILE_ATTRIBUTE_HIDDEN;\n\n\tif (attrs != newattrs && !SetFileAttributesW(buf, newattrs)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to %s hidden bit for '%s'\",\n\t\t\thidden ? \"set\" : \"unset\", path);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_win32__findfirstfile_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
    "lines": "18-43",
    "snippet": "bool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}",
    "includes": [
      "#include \"w32_util.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wcscat",
          "args": [
            "dest",
            "suffix"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CONST_STRLEN",
          "args": [
            "suffix"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "dest",
            "src"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"w32_util.h\"\n\nbool git_win32__findfirstfile_filter(git_win32_path dest, const char *src)\n{\n\tstatic const wchar_t suffix[] = L\"\\\\*\";\n\tint len = git_win32_path_from_utf8(dest, src);\n\n\t/* Ensure the path was converted */\n\tif (len < 0)\n\t\treturn false;\n\n\t/* Ensure that the path does not end with a trailing slash,\n\t * because we're about to add one. Don't rely our trim_end\n\t * helper, because we want to remove the backslash even for\n\t * drive letter paths, in this case. */\n\tif (len > 0 &&\n\t\t(dest[len - 1] == L'/' || dest[len - 1] == L'\\\\')) {\n\t\tdest[len - 1] = L'\\0';\n\t\tlen--;\n\t}\n\n\t/* Ensure we have enough room to add the suffix */\n\tif ((size_t)len >= GIT_WIN_PATH_UTF16 - CONST_STRLEN(suffix))\n\t\treturn false;\n\n\twcscat(dest, suffix);\n\treturn true;\n}"
  }
]