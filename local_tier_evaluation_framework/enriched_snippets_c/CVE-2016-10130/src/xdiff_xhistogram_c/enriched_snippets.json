[
  {
    "function_name": "xdl_do_histogram_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "364-373",
    "snippet": "int xdl_do_histogram_diff(mmfile_t *file1, mmfile_t *file2,\n\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\treturn histogram_diff(xpp, env,\n\t\tenv->xdf1.dstart + 1, env->xdf1.dend - env->xdf1.dstart + 1,\n\t\tenv->xdf2.dstart + 1, env->xdf2.dend - env->xdf2.dstart + 1);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "histogram_diff",
          "args": [
            "xpp",
            "env",
            "env->xdf1.dstart + 1",
            "env->xdf1.dend - env->xdf1.dstart + 1",
            "env->xdf2.dstart + 1",
            "env->xdf2.dend - env->xdf2.dstart + 1"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "histogram_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "268-362",
          "snippet": "static int histogram_diff(\n\txpparam_t const *xpp, xdfenv_t *env,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tstruct histindex index;\n\tstruct region lcs;\n\tsize_t sz;\n\tint result = -1;\n\n\tif (count1 <= 0 && count2 <= 0)\n\t\treturn 0;\n\n\tif (LINE_END(1) >= MAX_PTR)\n\t\treturn -1;\n\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&index, 0, sizeof(index));\n\n\tindex.env = env;\n\tindex.xpp = xpp;\n\n\tindex.records = NULL;\n\tindex.line_map = NULL;\n\t/* in case of early xdl_cha_free() */\n\tindex.rcha.head = NULL;\n\n\tindex.table_bits = xdl_hashbits(count1);\n\tsz = index.records_size = 1 << index.table_bits;\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sz, sz, sizeof(struct record *));\n\n\tif (!(index.records = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.records, 0, sz);\n\n\tsz = index.line_map_size = count1;\n\tsz *= sizeof(struct record *);\n\tif (!(index.line_map = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.line_map, 0, sz);\n\n\tsz = index.line_map_size;\n\tsz *= sizeof(unsigned int);\n\tif (!(index.next_ptrs = (unsigned int *) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.next_ptrs, 0, sz);\n\n\t/* lines / 4 + 1 comes from xprepare.c:xdl_prepare_ctx() */\n\tif (xdl_cha_init(&index.rcha, sizeof(struct record), count1 / 4 + 1) < 0)\n\t\tgoto cleanup;\n\n\tindex.ptr_shift = line1;\n\tindex.max_chain_length = 64;\n\n\tmemset(&lcs, 0, sizeof(lcs));\n\tif (find_lcs(&index, &lcs, line1, count1, line2, count2))\n\t\tresult = fall_back_to_classic_diff(&index, line1, count1, line2, count2);\n\telse {\n\t\tif (lcs.begin1 == 0 && lcs.begin2 == 0) {\n\t\t\twhile (count1--)\n\t\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\t\twhile (count2--)\n\t\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\t\tresult = 0;\n\t\t} else {\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tline1, lcs.begin1 - line1,\n\t\t\t\t\t\tline2, lcs.begin2 - line2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tlcs.end1 + 1, LINE_END(1) - lcs.end1,\n\t\t\t\t\t\tlcs.end2 + 1, LINE_END(2) - lcs.end2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\txdl_free(index.records);\n\txdl_free(index.line_map);\n\txdl_free(index.next_ptrs);\n\txdl_cha_free(&index.rcha);\n\n\treturn result;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define MAX_PTR\tUINT_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define MAX_PTR\tUINT_MAX\n\nstatic int histogram_diff(\n\txpparam_t const *xpp, xdfenv_t *env,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tstruct histindex index;\n\tstruct region lcs;\n\tsize_t sz;\n\tint result = -1;\n\n\tif (count1 <= 0 && count2 <= 0)\n\t\treturn 0;\n\n\tif (LINE_END(1) >= MAX_PTR)\n\t\treturn -1;\n\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&index, 0, sizeof(index));\n\n\tindex.env = env;\n\tindex.xpp = xpp;\n\n\tindex.records = NULL;\n\tindex.line_map = NULL;\n\t/* in case of early xdl_cha_free() */\n\tindex.rcha.head = NULL;\n\n\tindex.table_bits = xdl_hashbits(count1);\n\tsz = index.records_size = 1 << index.table_bits;\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sz, sz, sizeof(struct record *));\n\n\tif (!(index.records = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.records, 0, sz);\n\n\tsz = index.line_map_size = count1;\n\tsz *= sizeof(struct record *);\n\tif (!(index.line_map = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.line_map, 0, sz);\n\n\tsz = index.line_map_size;\n\tsz *= sizeof(unsigned int);\n\tif (!(index.next_ptrs = (unsigned int *) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.next_ptrs, 0, sz);\n\n\t/* lines / 4 + 1 comes from xprepare.c:xdl_prepare_ctx() */\n\tif (xdl_cha_init(&index.rcha, sizeof(struct record), count1 / 4 + 1) < 0)\n\t\tgoto cleanup;\n\n\tindex.ptr_shift = line1;\n\tindex.max_chain_length = 64;\n\n\tmemset(&lcs, 0, sizeof(lcs));\n\tif (find_lcs(&index, &lcs, line1, count1, line2, count2))\n\t\tresult = fall_back_to_classic_diff(&index, line1, count1, line2, count2);\n\telse {\n\t\tif (lcs.begin1 == 0 && lcs.begin2 == 0) {\n\t\t\twhile (count1--)\n\t\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\t\twhile (count2--)\n\t\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\t\tresult = 0;\n\t\t} else {\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tline1, lcs.begin1 - line1,\n\t\t\t\t\t\tline2, lcs.begin2 - line2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tlcs.end1 + 1, LINE_END(1) - lcs.end1,\n\t\t\t\t\t\tlcs.end2 + 1, LINE_END(2) - lcs.end2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\txdl_free(index.records);\n\txdl_free(index.line_map);\n\txdl_free(index.next_ptrs);\n\txdl_cha_free(&index.rcha);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_prepare_env",
          "args": [
            "file1",
            "file2",
            "xpp",
            "env"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_prepare_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "262-312",
          "snippet": "int xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define XDL_GUESS_NLINES2 20",
            "#define XDL_GUESS_NLINES1 256"
          ],
          "globals_used": [
            "static int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);",
            "static void xdl_free_classifier(xdlclassifier_t *cf);",
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\n#define XDL_GUESS_NLINES2 20\n#define XDL_GUESS_NLINES1 256\n\nstatic int xdl_init_classifier(xdlclassifier_t *cf, long size, long flags);\nstatic void xdl_free_classifier(xdlclassifier_t *cf);\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nint xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t\t    xdfenv_t *xe) {\n\tlong enl1, enl2, sample;\n\txdlclassifier_t cf;\n\n\tmemset(&cf, 0, sizeof(cf));\n\n\t/*\n\t * For histogram diff, we can afford a smaller sample size and\n\t * thus a poorer estimate of the number of lines, as the hash\n\t * table (rhash) won't be filled up/grown. The number of lines\n\t * (nrecs) will be updated correctly anyway by\n\t * xdl_prepare_ctx().\n\t */\n\tsample = (XDF_DIFF_ALG(xpp->flags) == XDF_HISTOGRAM_DIFF\n\t\t  ? XDL_GUESS_NLINES2 : XDL_GUESS_NLINES1);\n\n\tenl1 = xdl_guess_lines(mf1, sample) + 1;\n\tenl2 = xdl_guess_lines(mf2, sample) + 1;\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF &&\n\t    xdl_init_classifier(&cf, enl1 + enl2 + 1, xpp->flags) < 0)\n\t\treturn -1;\n\n\tif (xdl_prepare_ctx(1, mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {\n\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\tif (xdl_prepare_ctx(2, mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif ((XDF_DIFF_ALG(xpp->flags) != XDF_PATIENCE_DIFF) &&\n\t    (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF) &&\n\t    xdl_optimize_ctxs(&cf, &xe->xdf1, &xe->xdf2) < 0) {\n\n\t\txdl_free_ctx(&xe->xdf2);\n\t\txdl_free_ctx(&xe->xdf1);\n\t\txdl_free_classifier(&cf);\n\t\treturn -1;\n\t}\n\n\tif (XDF_DIFF_ALG(xpp->flags) != XDF_HISTOGRAM_DIFF)\n\t\txdl_free_classifier(&cf);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nint xdl_do_histogram_diff(mmfile_t *file1, mmfile_t *file2,\n\txpparam_t const *xpp, xdfenv_t *env)\n{\n\tif (xdl_prepare_env(file1, file2, xpp, env) < 0)\n\t\treturn -1;\n\n\treturn histogram_diff(xpp, env,\n\t\tenv->xdf1.dstart + 1, env->xdf1.dend - env->xdf1.dstart + 1,\n\t\tenv->xdf2.dstart + 1, env->xdf2.dend - env->xdf2.dstart + 1);\n}"
  },
  {
    "function_name": "histogram_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "268-362",
    "snippet": "static int histogram_diff(\n\txpparam_t const *xpp, xdfenv_t *env,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tstruct histindex index;\n\tstruct region lcs;\n\tsize_t sz;\n\tint result = -1;\n\n\tif (count1 <= 0 && count2 <= 0)\n\t\treturn 0;\n\n\tif (LINE_END(1) >= MAX_PTR)\n\t\treturn -1;\n\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&index, 0, sizeof(index));\n\n\tindex.env = env;\n\tindex.xpp = xpp;\n\n\tindex.records = NULL;\n\tindex.line_map = NULL;\n\t/* in case of early xdl_cha_free() */\n\tindex.rcha.head = NULL;\n\n\tindex.table_bits = xdl_hashbits(count1);\n\tsz = index.records_size = 1 << index.table_bits;\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sz, sz, sizeof(struct record *));\n\n\tif (!(index.records = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.records, 0, sz);\n\n\tsz = index.line_map_size = count1;\n\tsz *= sizeof(struct record *);\n\tif (!(index.line_map = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.line_map, 0, sz);\n\n\tsz = index.line_map_size;\n\tsz *= sizeof(unsigned int);\n\tif (!(index.next_ptrs = (unsigned int *) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.next_ptrs, 0, sz);\n\n\t/* lines / 4 + 1 comes from xprepare.c:xdl_prepare_ctx() */\n\tif (xdl_cha_init(&index.rcha, sizeof(struct record), count1 / 4 + 1) < 0)\n\t\tgoto cleanup;\n\n\tindex.ptr_shift = line1;\n\tindex.max_chain_length = 64;\n\n\tmemset(&lcs, 0, sizeof(lcs));\n\tif (find_lcs(&index, &lcs, line1, count1, line2, count2))\n\t\tresult = fall_back_to_classic_diff(&index, line1, count1, line2, count2);\n\telse {\n\t\tif (lcs.begin1 == 0 && lcs.begin2 == 0) {\n\t\t\twhile (count1--)\n\t\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\t\twhile (count2--)\n\t\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\t\tresult = 0;\n\t\t} else {\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tline1, lcs.begin1 - line1,\n\t\t\t\t\t\tline2, lcs.begin2 - line2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tlcs.end1 + 1, LINE_END(1) - lcs.end1,\n\t\t\t\t\t\tlcs.end2 + 1, LINE_END(2) - lcs.end2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\txdl_free(index.records);\n\txdl_free(index.line_map);\n\txdl_free(index.next_ptrs);\n\txdl_cha_free(&index.rcha);\n\n\treturn result;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define MAX_PTR\tUINT_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_cha_free",
          "args": [
            "&index.rcha"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "88-95",
          "snippet": "void xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid xdl_cha_free(chastore_t *cha) {\n\tchanode_t *cur, *tmp;\n\n\tfor (cur = cha->head; (tmp = cur) != NULL;) {\n\t\tcur = cur->next;\n\t\txdl_free(tmp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdl_free",
          "args": [
            "index.next_ptrs"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_free_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xprepare.c",
          "lines": "315-319",
          "snippet": "void xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);",
            "static int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nstatic int xdl_cleanup_records(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);\nstatic int xdl_optimize_ctxs(xdlclassifier_t *cf, xdfile_t *xdf1, xdfile_t *xdf2);\n\nvoid xdl_free_env(xdfenv_t *xe) {\n\n\txdl_free_ctx(&xe->xdf2);\n\txdl_free_ctx(&xe->xdf1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "histogram_diff",
          "args": [
            "xpp",
            "env",
            "lcs.end1 + 1",
            "LINE_END(1) - lcs.end1",
            "lcs.end2 + 1",
            "LINE_END(2) - lcs.end2"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "histogram_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "268-362",
          "snippet": "static int histogram_diff(\n\txpparam_t const *xpp, xdfenv_t *env,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tstruct histindex index;\n\tstruct region lcs;\n\tsize_t sz;\n\tint result = -1;\n\n\tif (count1 <= 0 && count2 <= 0)\n\t\treturn 0;\n\n\tif (LINE_END(1) >= MAX_PTR)\n\t\treturn -1;\n\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&index, 0, sizeof(index));\n\n\tindex.env = env;\n\tindex.xpp = xpp;\n\n\tindex.records = NULL;\n\tindex.line_map = NULL;\n\t/* in case of early xdl_cha_free() */\n\tindex.rcha.head = NULL;\n\n\tindex.table_bits = xdl_hashbits(count1);\n\tsz = index.records_size = 1 << index.table_bits;\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sz, sz, sizeof(struct record *));\n\n\tif (!(index.records = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.records, 0, sz);\n\n\tsz = index.line_map_size = count1;\n\tsz *= sizeof(struct record *);\n\tif (!(index.line_map = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.line_map, 0, sz);\n\n\tsz = index.line_map_size;\n\tsz *= sizeof(unsigned int);\n\tif (!(index.next_ptrs = (unsigned int *) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.next_ptrs, 0, sz);\n\n\t/* lines / 4 + 1 comes from xprepare.c:xdl_prepare_ctx() */\n\tif (xdl_cha_init(&index.rcha, sizeof(struct record), count1 / 4 + 1) < 0)\n\t\tgoto cleanup;\n\n\tindex.ptr_shift = line1;\n\tindex.max_chain_length = 64;\n\n\tmemset(&lcs, 0, sizeof(lcs));\n\tif (find_lcs(&index, &lcs, line1, count1, line2, count2))\n\t\tresult = fall_back_to_classic_diff(&index, line1, count1, line2, count2);\n\telse {\n\t\tif (lcs.begin1 == 0 && lcs.begin2 == 0) {\n\t\t\twhile (count1--)\n\t\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\t\twhile (count2--)\n\t\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\t\tresult = 0;\n\t\t} else {\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tline1, lcs.begin1 - line1,\n\t\t\t\t\t\tline2, lcs.begin2 - line2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tlcs.end1 + 1, LINE_END(1) - lcs.end1,\n\t\t\t\t\t\tlcs.end2 + 1, LINE_END(2) - lcs.end2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\txdl_free(index.records);\n\txdl_free(index.line_map);\n\txdl_free(index.next_ptrs);\n\txdl_cha_free(&index.rcha);\n\n\treturn result;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "2"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "1"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fall_back_to_classic_diff",
          "args": [
            "&index",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "fall_back_to_classic_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "258-266",
          "snippet": "static int fall_back_to_classic_diff(struct histindex *index,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = index->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(index->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int fall_back_to_classic_diff(struct histindex *index,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = index->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(index->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lcs",
          "args": [
            "&index",
            "&lcs",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "find_lcs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "240-256",
          "snippet": "static int find_lcs(\n\tstruct histindex *index, struct region *lcs,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_ptr;\n\n\tif (scanA(index, line1, count1))\n\t\treturn -1;\n\n\tindex->cnt = index->max_chain_length + 1;\n\n\tfor (b_ptr = line2; b_ptr <= LINE_END(2); )\n\t\tb_ptr = try_lcs(index, lcs, b_ptr, line1, count1, line2, count2);\n\n\treturn index->has_common && index->max_chain_length < index->cnt;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int find_lcs(\n\tstruct histindex *index, struct region *lcs,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_ptr;\n\n\tif (scanA(index, line1, count1))\n\t\treturn -1;\n\n\tindex->cnt = index->max_chain_length + 1;\n\n\tfor (b_ptr = line2; b_ptr <= LINE_END(2); )\n\t\tb_ptr = try_lcs(index, lcs, b_ptr, line1, count1, line2, count2);\n\n\treturn index->has_common && index->max_chain_length < index->cnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lcs",
            "0",
            "sizeof(lcs)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_cha_init",
          "args": [
            "&index.rcha",
            "sizeof(struct record)",
            "count1 / 4 + 1"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "76-85",
          "snippet": "int xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_cha_init(chastore_t *cha, long isize, long icount) {\n\n\tcha->head = cha->tail = NULL;\n\tcha->isize = isize;\n\tcha->nsize = icount * isize;\n\tcha->ancur = cha->sncur = NULL;\n\tcha->scurr = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "index.next_ptrs",
            "0",
            "sz"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sz"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "index.line_map",
            "0",
            "sz"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sz"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "index.records",
            "0",
            "sz"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_malloc",
          "args": [
            "sz"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&sz",
            "sz",
            "sizeof(struct record *)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_hashbits",
          "args": [
            "count1"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_hashbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "281-286",
          "snippet": "unsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nunsigned int xdl_hashbits(unsigned int size) {\n\tunsigned int val = 1, bits = 0;\n\n\tfor (; val < size && bits < CHAR_BIT * sizeof(unsigned int); val <<= 1, bits++);\n\treturn bits ? bits: 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&index",
            "0",
            "sizeof(index)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define MAX_PTR\tUINT_MAX\n\nstatic int histogram_diff(\n\txpparam_t const *xpp, xdfenv_t *env,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tstruct histindex index;\n\tstruct region lcs;\n\tsize_t sz;\n\tint result = -1;\n\n\tif (count1 <= 0 && count2 <= 0)\n\t\treturn 0;\n\n\tif (LINE_END(1) >= MAX_PTR)\n\t\treturn -1;\n\n\tif (!count1) {\n\t\twhile(count2--)\n\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\treturn 0;\n\t} else if (!count2) {\n\t\twhile(count1--)\n\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\treturn 0;\n\t}\n\n\tmemset(&index, 0, sizeof(index));\n\n\tindex.env = env;\n\tindex.xpp = xpp;\n\n\tindex.records = NULL;\n\tindex.line_map = NULL;\n\t/* in case of early xdl_cha_free() */\n\tindex.rcha.head = NULL;\n\n\tindex.table_bits = xdl_hashbits(count1);\n\tsz = index.records_size = 1 << index.table_bits;\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sz, sz, sizeof(struct record *));\n\n\tif (!(index.records = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.records, 0, sz);\n\n\tsz = index.line_map_size = count1;\n\tsz *= sizeof(struct record *);\n\tif (!(index.line_map = (struct record **) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.line_map, 0, sz);\n\n\tsz = index.line_map_size;\n\tsz *= sizeof(unsigned int);\n\tif (!(index.next_ptrs = (unsigned int *) xdl_malloc(sz)))\n\t\tgoto cleanup;\n\tmemset(index.next_ptrs, 0, sz);\n\n\t/* lines / 4 + 1 comes from xprepare.c:xdl_prepare_ctx() */\n\tif (xdl_cha_init(&index.rcha, sizeof(struct record), count1 / 4 + 1) < 0)\n\t\tgoto cleanup;\n\n\tindex.ptr_shift = line1;\n\tindex.max_chain_length = 64;\n\n\tmemset(&lcs, 0, sizeof(lcs));\n\tif (find_lcs(&index, &lcs, line1, count1, line2, count2))\n\t\tresult = fall_back_to_classic_diff(&index, line1, count1, line2, count2);\n\telse {\n\t\tif (lcs.begin1 == 0 && lcs.begin2 == 0) {\n\t\t\twhile (count1--)\n\t\t\t\tenv->xdf1.rchg[line1++ - 1] = 1;\n\t\t\twhile (count2--)\n\t\t\t\tenv->xdf2.rchg[line2++ - 1] = 1;\n\t\t\tresult = 0;\n\t\t} else {\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tline1, lcs.begin1 - line1,\n\t\t\t\t\t\tline2, lcs.begin2 - line2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t\tresult = histogram_diff(xpp, env,\n\t\t\t\t\t\tlcs.end1 + 1, LINE_END(1) - lcs.end1,\n\t\t\t\t\t\tlcs.end2 + 1, LINE_END(2) - lcs.end2);\n\t\t\tif (result)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\ncleanup:\n\txdl_free(index.records);\n\txdl_free(index.line_map);\n\txdl_free(index.next_ptrs);\n\txdl_cha_free(&index.rcha);\n\n\treturn result;\n}"
  },
  {
    "function_name": "fall_back_to_classic_diff",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "258-266",
    "snippet": "static int fall_back_to_classic_diff(struct histindex *index,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = index->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(index->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_fall_back_diff",
          "args": [
            "index->env",
            "&xpp",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_fall_back_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "374-403",
          "snippet": "int xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_fall_back_diff(xdfenv_t *diff_env, xpparam_t const *xpp,\n\t\tint line1, int count1, int line2, int count2)\n{\n\t/*\n\t * This probably does not work outside Git, since\n\t * we have a very simple mmfile structure.\n\t *\n\t * Note: ideally, we would reuse the prepared environment, but\n\t * the libxdiff interface does not (yet) allow for diffing only\n\t * ranges of lines instead of the whole files.\n\t */\n\tmmfile_t subfile1, subfile2;\n\txdfenv_t env;\n\n\tsubfile1.ptr = (char *)diff_env->xdf1.recs[line1 - 1]->ptr;\n\tsubfile1.size = diff_env->xdf1.recs[line1 + count1 - 2]->ptr +\n\t\tdiff_env->xdf1.recs[line1 + count1 - 2]->size - subfile1.ptr;\n\tsubfile2.ptr = (char *)diff_env->xdf2.recs[line2 - 1]->ptr;\n\tsubfile2.size = diff_env->xdf2.recs[line2 + count2 - 2]->ptr +\n\t\tdiff_env->xdf2.recs[line2 + count2 - 2]->size - subfile2.ptr;\n\tif (xdl_do_diff(&subfile1, &subfile2, xpp, &env) < 0)\n\t\treturn -1;\n\n\tmemcpy(diff_env->xdf1.rchg + line1 - 1, env.xdf1.rchg, count1);\n\tmemcpy(diff_env->xdf2.rchg + line2 - 1, env.xdf2.rchg, count2);\n\n\txdl_free_env(&env);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int fall_back_to_classic_diff(struct histindex *index,\n\t\tint line1, int count1, int line2, int count2)\n{\n\txpparam_t xpp;\n\txpp.flags = index->xpp->flags & ~XDF_DIFF_ALGORITHM_MASK;\n\n\treturn xdl_fall_back_diff(index->env, &xpp,\n\t\t\t\t  line1, count1, line2, count2);\n}"
  },
  {
    "function_name": "find_lcs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "240-256",
    "snippet": "static int find_lcs(\n\tstruct histindex *index, struct region *lcs,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_ptr;\n\n\tif (scanA(index, line1, count1))\n\t\treturn -1;\n\n\tindex->cnt = index->max_chain_length + 1;\n\n\tfor (b_ptr = line2; b_ptr <= LINE_END(2); )\n\t\tb_ptr = try_lcs(index, lcs, b_ptr, line1, count1, line2, count2);\n\n\treturn index->has_common && index->max_chain_length < index->cnt;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_lcs",
          "args": [
            "index",
            "lcs",
            "b_ptr",
            "line1",
            "count1",
            "line2",
            "count2"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "try_lcs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "165-238",
          "snippet": "static int try_lcs(\n\tstruct histindex *index, struct region *lcs, unsigned int b_ptr,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_next = b_ptr + 1;\n\tstruct record *rec = index->records[TABLE_HASH(index, 2, b_ptr)];\n\tunsigned int as, ae, bs, be, np, rc;\n\tint should_break;\n\n\tfor (; rec; rec = rec->next) {\n\t\tif (rec->cnt > index->cnt) {\n\t\t\tif (!index->has_common)\n\t\t\t\tindex->has_common = CMP(index, 1, rec->ptr, 2, b_ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tas = rec->ptr;\n\t\tif (!CMP(index, 1, as, 2, b_ptr))\n\t\t\tcontinue;\n\n\t\tindex->has_common = 1;\n\t\tfor (;;) {\n\t\t\tshould_break = 0;\n\t\t\tnp = NEXT_PTR(index, as);\n\t\t\tbs = b_ptr;\n\t\t\tae = as;\n\t\t\tbe = bs;\n\t\t\trc = rec->cnt;\n\n\t\t\twhile (line1 < as && line2 < bs\n\t\t\t\t&& CMP(index, 1, as - 1, 2, bs - 1)) {\n\t\t\t\tas--;\n\t\t\t\tbs--;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, as));\n\t\t\t}\n\t\t\twhile (ae < LINE_END(1) && be < LINE_END(2)\n\t\t\t\t&& CMP(index, 1, ae + 1, 2, be + 1)) {\n\t\t\t\tae++;\n\t\t\t\tbe++;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, ae));\n\t\t\t}\n\n\t\t\tif (b_next <= be)\n\t\t\t\tb_next = be + 1;\n\t\t\tif (lcs->end1 - lcs->begin1 < ae - as || rc < index->cnt) {\n\t\t\t\tlcs->begin1 = as;\n\t\t\t\tlcs->begin2 = bs;\n\t\t\t\tlcs->end1 = ae;\n\t\t\t\tlcs->end2 = be;\n\t\t\t\tindex->cnt = rc;\n\t\t\t}\n\n\t\t\tif (np == 0)\n\t\t\t\tbreak;\n\n\t\t\twhile (np <= ae) {\n\t\t\t\tnp = NEXT_PTR(index, np);\n\t\t\t\tif (np == 0) {\n\t\t\t\t\tshould_break = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_break)\n\t\t\t\tbreak;\n\n\t\t\tas = np;\n\t\t}\n\t}\n\treturn b_next;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int try_lcs(\n\tstruct histindex *index, struct region *lcs, unsigned int b_ptr,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_next = b_ptr + 1;\n\tstruct record *rec = index->records[TABLE_HASH(index, 2, b_ptr)];\n\tunsigned int as, ae, bs, be, np, rc;\n\tint should_break;\n\n\tfor (; rec; rec = rec->next) {\n\t\tif (rec->cnt > index->cnt) {\n\t\t\tif (!index->has_common)\n\t\t\t\tindex->has_common = CMP(index, 1, rec->ptr, 2, b_ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tas = rec->ptr;\n\t\tif (!CMP(index, 1, as, 2, b_ptr))\n\t\t\tcontinue;\n\n\t\tindex->has_common = 1;\n\t\tfor (;;) {\n\t\t\tshould_break = 0;\n\t\t\tnp = NEXT_PTR(index, as);\n\t\t\tbs = b_ptr;\n\t\t\tae = as;\n\t\t\tbe = bs;\n\t\t\trc = rec->cnt;\n\n\t\t\twhile (line1 < as && line2 < bs\n\t\t\t\t&& CMP(index, 1, as - 1, 2, bs - 1)) {\n\t\t\t\tas--;\n\t\t\t\tbs--;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, as));\n\t\t\t}\n\t\t\twhile (ae < LINE_END(1) && be < LINE_END(2)\n\t\t\t\t&& CMP(index, 1, ae + 1, 2, be + 1)) {\n\t\t\t\tae++;\n\t\t\t\tbe++;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, ae));\n\t\t\t}\n\n\t\t\tif (b_next <= be)\n\t\t\t\tb_next = be + 1;\n\t\t\tif (lcs->end1 - lcs->begin1 < ae - as || rc < index->cnt) {\n\t\t\t\tlcs->begin1 = as;\n\t\t\t\tlcs->begin2 = bs;\n\t\t\t\tlcs->end1 = ae;\n\t\t\t\tlcs->end2 = be;\n\t\t\t\tindex->cnt = rc;\n\t\t\t}\n\n\t\t\tif (np == 0)\n\t\t\t\tbreak;\n\n\t\t\twhile (np <= ae) {\n\t\t\t\tnp = NEXT_PTR(index, np);\n\t\t\t\tif (np == 0) {\n\t\t\t\t\tshould_break = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_break)\n\t\t\t\tbreak;\n\n\t\t\tas = np;\n\t\t}\n\t}\n\treturn b_next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "2"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scanA",
          "args": [
            "index",
            "line1",
            "count1"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "scanA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
          "lines": "111-163",
          "snippet": "static int scanA(struct histindex *index, unsigned int line1, unsigned int count1)\n{\n\tunsigned int ptr;\n\tunsigned int tbl_idx;\n\tunsigned int chain_len;\n\tstruct record **rec_chain, *rec;\n\n\tfor (ptr = LINE_END(1); line1 <= ptr; ptr--) {\n\t\ttbl_idx = TABLE_HASH(index, 1, ptr);\n\t\trec_chain = index->records + tbl_idx;\n\t\trec = *rec_chain;\n\n\t\tchain_len = 0;\n\t\twhile (rec) {\n\t\t\tif (CMP(index, 1, rec->ptr, 1, ptr)) {\n\t\t\t\t/*\n\t\t\t\t * ptr is identical to another element. Insert\n\t\t\t\t * it onto the front of the existing element\n\t\t\t\t * chain.\n\t\t\t\t */\n\t\t\t\tNEXT_PTR(index, ptr) = rec->ptr;\n\t\t\t\trec->ptr = ptr;\n\t\t\t\t/* cap rec->cnt at MAX_CNT */\n\t\t\t\trec->cnt = XDL_MIN(MAX_CNT, rec->cnt + 1);\n\t\t\t\tLINE_MAP(index, ptr) = rec;\n\t\t\t\tgoto continue_scan;\n\t\t\t}\n\n\t\t\trec = rec->next;\n\t\t\tchain_len++;\n\t\t}\n\n\t\tif (chain_len == index->max_chain_length)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * This is the first time we have ever seen this particular\n\t\t * element in the sequence. Construct a new chain for it.\n\t\t */\n\t\tif (!(rec = xdl_cha_alloc(&index->rcha)))\n\t\t\treturn -1;\n\t\trec->ptr = ptr;\n\t\trec->cnt = 1;\n\t\trec->next = *rec_chain;\n\t\t*rec_chain = rec;\n\t\tLINE_MAP(index, ptr) = rec;\n\ncontinue_scan:\n\t\t; /* no op */\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include \"xdiff.h\"",
            "#include \"xtypes.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [
            "#define MAX_CNT\tUINT_MAX"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define MAX_CNT\tUINT_MAX\n\nstatic int scanA(struct histindex *index, unsigned int line1, unsigned int count1)\n{\n\tunsigned int ptr;\n\tunsigned int tbl_idx;\n\tunsigned int chain_len;\n\tstruct record **rec_chain, *rec;\n\n\tfor (ptr = LINE_END(1); line1 <= ptr; ptr--) {\n\t\ttbl_idx = TABLE_HASH(index, 1, ptr);\n\t\trec_chain = index->records + tbl_idx;\n\t\trec = *rec_chain;\n\n\t\tchain_len = 0;\n\t\twhile (rec) {\n\t\t\tif (CMP(index, 1, rec->ptr, 1, ptr)) {\n\t\t\t\t/*\n\t\t\t\t * ptr is identical to another element. Insert\n\t\t\t\t * it onto the front of the existing element\n\t\t\t\t * chain.\n\t\t\t\t */\n\t\t\t\tNEXT_PTR(index, ptr) = rec->ptr;\n\t\t\t\trec->ptr = ptr;\n\t\t\t\t/* cap rec->cnt at MAX_CNT */\n\t\t\t\trec->cnt = XDL_MIN(MAX_CNT, rec->cnt + 1);\n\t\t\t\tLINE_MAP(index, ptr) = rec;\n\t\t\t\tgoto continue_scan;\n\t\t\t}\n\n\t\t\trec = rec->next;\n\t\t\tchain_len++;\n\t\t}\n\n\t\tif (chain_len == index->max_chain_length)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * This is the first time we have ever seen this particular\n\t\t * element in the sequence. Construct a new chain for it.\n\t\t */\n\t\tif (!(rec = xdl_cha_alloc(&index->rcha)))\n\t\t\treturn -1;\n\t\trec->ptr = ptr;\n\t\trec->cnt = 1;\n\t\trec->next = *rec_chain;\n\t\t*rec_chain = rec;\n\t\tLINE_MAP(index, ptr) = rec;\n\ncontinue_scan:\n\t\t; /* no op */\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int find_lcs(\n\tstruct histindex *index, struct region *lcs,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_ptr;\n\n\tif (scanA(index, line1, count1))\n\t\treturn -1;\n\n\tindex->cnt = index->max_chain_length + 1;\n\n\tfor (b_ptr = line2; b_ptr <= LINE_END(2); )\n\t\tb_ptr = try_lcs(index, lcs, b_ptr, line1, count1, line2, count2);\n\n\treturn index->has_common && index->max_chain_length < index->cnt;\n}"
  },
  {
    "function_name": "try_lcs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "165-238",
    "snippet": "static int try_lcs(\n\tstruct histindex *index, struct region *lcs, unsigned int b_ptr,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_next = b_ptr + 1;\n\tstruct record *rec = index->records[TABLE_HASH(index, 2, b_ptr)];\n\tunsigned int as, ae, bs, be, np, rc;\n\tint should_break;\n\n\tfor (; rec; rec = rec->next) {\n\t\tif (rec->cnt > index->cnt) {\n\t\t\tif (!index->has_common)\n\t\t\t\tindex->has_common = CMP(index, 1, rec->ptr, 2, b_ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tas = rec->ptr;\n\t\tif (!CMP(index, 1, as, 2, b_ptr))\n\t\t\tcontinue;\n\n\t\tindex->has_common = 1;\n\t\tfor (;;) {\n\t\t\tshould_break = 0;\n\t\t\tnp = NEXT_PTR(index, as);\n\t\t\tbs = b_ptr;\n\t\t\tae = as;\n\t\t\tbe = bs;\n\t\t\trc = rec->cnt;\n\n\t\t\twhile (line1 < as && line2 < bs\n\t\t\t\t&& CMP(index, 1, as - 1, 2, bs - 1)) {\n\t\t\t\tas--;\n\t\t\t\tbs--;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, as));\n\t\t\t}\n\t\t\twhile (ae < LINE_END(1) && be < LINE_END(2)\n\t\t\t\t&& CMP(index, 1, ae + 1, 2, be + 1)) {\n\t\t\t\tae++;\n\t\t\t\tbe++;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, ae));\n\t\t\t}\n\n\t\t\tif (b_next <= be)\n\t\t\t\tb_next = be + 1;\n\t\t\tif (lcs->end1 - lcs->begin1 < ae - as || rc < index->cnt) {\n\t\t\t\tlcs->begin1 = as;\n\t\t\t\tlcs->begin2 = bs;\n\t\t\t\tlcs->end1 = ae;\n\t\t\t\tlcs->end2 = be;\n\t\t\t\tindex->cnt = rc;\n\t\t\t}\n\n\t\t\tif (np == 0)\n\t\t\t\tbreak;\n\n\t\t\twhile (np <= ae) {\n\t\t\t\tnp = NEXT_PTR(index, np);\n\t\t\t\tif (np == 0) {\n\t\t\t\t\tshould_break = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_break)\n\t\t\t\tbreak;\n\n\t\t\tas = np;\n\t\t}\n\t}\n\treturn b_next;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NEXT_PTR",
          "args": [
            "index",
            "np"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_MIN",
          "args": [
            "rc",
            "CNT(index, ae)"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNT",
          "args": [
            "index",
            "ae"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMP",
          "args": [
            "index",
            "1",
            "ae + 1",
            "2",
            "be + 1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "2"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "1"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_MIN",
          "args": [
            "rc",
            "CNT(index, as)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNT",
          "args": [
            "index",
            "as"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMP",
          "args": [
            "index",
            "1",
            "as - 1",
            "2",
            "bs - 1"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_PTR",
          "args": [
            "index",
            "as"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMP",
          "args": [
            "index",
            "1",
            "as",
            "2",
            "b_ptr"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMP",
          "args": [
            "index",
            "1",
            "rec->ptr",
            "2",
            "b_ptr"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TABLE_HASH",
          "args": [
            "index",
            "2",
            "b_ptr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int try_lcs(\n\tstruct histindex *index, struct region *lcs, unsigned int b_ptr,\n\tunsigned int line1, unsigned int count1,\n\tunsigned int line2, unsigned int count2)\n{\n\tunsigned int b_next = b_ptr + 1;\n\tstruct record *rec = index->records[TABLE_HASH(index, 2, b_ptr)];\n\tunsigned int as, ae, bs, be, np, rc;\n\tint should_break;\n\n\tfor (; rec; rec = rec->next) {\n\t\tif (rec->cnt > index->cnt) {\n\t\t\tif (!index->has_common)\n\t\t\t\tindex->has_common = CMP(index, 1, rec->ptr, 2, b_ptr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tas = rec->ptr;\n\t\tif (!CMP(index, 1, as, 2, b_ptr))\n\t\t\tcontinue;\n\n\t\tindex->has_common = 1;\n\t\tfor (;;) {\n\t\t\tshould_break = 0;\n\t\t\tnp = NEXT_PTR(index, as);\n\t\t\tbs = b_ptr;\n\t\t\tae = as;\n\t\t\tbe = bs;\n\t\t\trc = rec->cnt;\n\n\t\t\twhile (line1 < as && line2 < bs\n\t\t\t\t&& CMP(index, 1, as - 1, 2, bs - 1)) {\n\t\t\t\tas--;\n\t\t\t\tbs--;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, as));\n\t\t\t}\n\t\t\twhile (ae < LINE_END(1) && be < LINE_END(2)\n\t\t\t\t&& CMP(index, 1, ae + 1, 2, be + 1)) {\n\t\t\t\tae++;\n\t\t\t\tbe++;\n\t\t\t\tif (1 < rc)\n\t\t\t\t\trc = XDL_MIN(rc, CNT(index, ae));\n\t\t\t}\n\n\t\t\tif (b_next <= be)\n\t\t\t\tb_next = be + 1;\n\t\t\tif (lcs->end1 - lcs->begin1 < ae - as || rc < index->cnt) {\n\t\t\t\tlcs->begin1 = as;\n\t\t\t\tlcs->begin2 = bs;\n\t\t\t\tlcs->end1 = ae;\n\t\t\t\tlcs->end2 = be;\n\t\t\t\tindex->cnt = rc;\n\t\t\t}\n\n\t\t\tif (np == 0)\n\t\t\t\tbreak;\n\n\t\t\twhile (np <= ae) {\n\t\t\t\tnp = NEXT_PTR(index, np);\n\t\t\t\tif (np == 0) {\n\t\t\t\t\tshould_break = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_break)\n\t\t\t\tbreak;\n\n\t\t\tas = np;\n\t\t}\n\t}\n\treturn b_next;\n}"
  },
  {
    "function_name": "scanA",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "111-163",
    "snippet": "static int scanA(struct histindex *index, unsigned int line1, unsigned int count1)\n{\n\tunsigned int ptr;\n\tunsigned int tbl_idx;\n\tunsigned int chain_len;\n\tstruct record **rec_chain, *rec;\n\n\tfor (ptr = LINE_END(1); line1 <= ptr; ptr--) {\n\t\ttbl_idx = TABLE_HASH(index, 1, ptr);\n\t\trec_chain = index->records + tbl_idx;\n\t\trec = *rec_chain;\n\n\t\tchain_len = 0;\n\t\twhile (rec) {\n\t\t\tif (CMP(index, 1, rec->ptr, 1, ptr)) {\n\t\t\t\t/*\n\t\t\t\t * ptr is identical to another element. Insert\n\t\t\t\t * it onto the front of the existing element\n\t\t\t\t * chain.\n\t\t\t\t */\n\t\t\t\tNEXT_PTR(index, ptr) = rec->ptr;\n\t\t\t\trec->ptr = ptr;\n\t\t\t\t/* cap rec->cnt at MAX_CNT */\n\t\t\t\trec->cnt = XDL_MIN(MAX_CNT, rec->cnt + 1);\n\t\t\t\tLINE_MAP(index, ptr) = rec;\n\t\t\t\tgoto continue_scan;\n\t\t\t}\n\n\t\t\trec = rec->next;\n\t\t\tchain_len++;\n\t\t}\n\n\t\tif (chain_len == index->max_chain_length)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * This is the first time we have ever seen this particular\n\t\t * element in the sequence. Construct a new chain for it.\n\t\t */\n\t\tif (!(rec = xdl_cha_alloc(&index->rcha)))\n\t\t\treturn -1;\n\t\trec->ptr = ptr;\n\t\trec->cnt = 1;\n\t\trec->next = *rec_chain;\n\t\t*rec_chain = rec;\n\t\tLINE_MAP(index, ptr) = rec;\n\ncontinue_scan:\n\t\t; /* no op */\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [
      "#define MAX_CNT\tUINT_MAX"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LINE_MAP",
          "args": [
            "index",
            "ptr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdl_cha_alloc",
          "args": [
            "&index->rcha"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_cha_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "98-121",
          "snippet": "void *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nvoid *xdl_cha_alloc(chastore_t *cha) {\n\tchanode_t *ancur;\n\tvoid *data;\n\n\tif (!(ancur = cha->ancur) || ancur->icurr == cha->nsize) {\n\t\tif (!(ancur = (chanode_t *) xdl_malloc(sizeof(chanode_t) + cha->nsize))) {\n\n\t\t\treturn NULL;\n\t\t}\n\t\tancur->icurr = 0;\n\t\tancur->next = NULL;\n\t\tif (cha->tail)\n\t\t\tcha->tail->next = ancur;\n\t\tif (!cha->head)\n\t\t\tcha->head = ancur;\n\t\tcha->tail = ancur;\n\t\tcha->ancur = ancur;\n\t}\n\n\tdata = (char *) ancur + sizeof(chanode_t) + ancur->icurr;\n\tancur->icurr += cha->isize;\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LINE_MAP",
          "args": [
            "index",
            "ptr"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDL_MIN",
          "args": [
            "MAX_CNT",
            "rec->cnt + 1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NEXT_PTR",
          "args": [
            "index",
            "ptr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CMP",
          "args": [
            "index",
            "1",
            "rec->ptr",
            "1",
            "ptr"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TABLE_HASH",
          "args": [
            "index",
            "1",
            "ptr"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LINE_END",
          "args": [
            "1"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\n#define MAX_CNT\tUINT_MAX\n\nstatic int scanA(struct histindex *index, unsigned int line1, unsigned int count1)\n{\n\tunsigned int ptr;\n\tunsigned int tbl_idx;\n\tunsigned int chain_len;\n\tstruct record **rec_chain, *rec;\n\n\tfor (ptr = LINE_END(1); line1 <= ptr; ptr--) {\n\t\ttbl_idx = TABLE_HASH(index, 1, ptr);\n\t\trec_chain = index->records + tbl_idx;\n\t\trec = *rec_chain;\n\n\t\tchain_len = 0;\n\t\twhile (rec) {\n\t\t\tif (CMP(index, 1, rec->ptr, 1, ptr)) {\n\t\t\t\t/*\n\t\t\t\t * ptr is identical to another element. Insert\n\t\t\t\t * it onto the front of the existing element\n\t\t\t\t * chain.\n\t\t\t\t */\n\t\t\t\tNEXT_PTR(index, ptr) = rec->ptr;\n\t\t\t\trec->ptr = ptr;\n\t\t\t\t/* cap rec->cnt at MAX_CNT */\n\t\t\t\trec->cnt = XDL_MIN(MAX_CNT, rec->cnt + 1);\n\t\t\t\tLINE_MAP(index, ptr) = rec;\n\t\t\t\tgoto continue_scan;\n\t\t\t}\n\n\t\t\trec = rec->next;\n\t\t\tchain_len++;\n\t\t}\n\n\t\tif (chain_len == index->max_chain_length)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * This is the first time we have ever seen this particular\n\t\t * element in the sequence. Construct a new chain for it.\n\t\t */\n\t\tif (!(rec = xdl_cha_alloc(&index->rcha)))\n\t\t\treturn -1;\n\t\trec->ptr = ptr;\n\t\trec->cnt = 1;\n\t\trec->next = *rec_chain;\n\t\t*rec_chain = rec;\n\t\tLINE_MAP(index, ptr) = rec;\n\ncontinue_scan:\n\t\t; /* no op */\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cmp_recs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xhistogram.c",
    "lines": "94-100",
    "snippet": "static int cmp_recs(xpparam_t const *xpp,\n\txrecord_t *r1, xrecord_t *r2)\n{\n\treturn r1->ha == r2->ha &&\n\t\txdl_recmatch(r1->ptr, r1->size, r2->ptr, r2->size,\n\t\t\t    xpp->flags);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include \"xdiff.h\"",
      "#include \"xtypes.h\"",
      "#include \"xinclude.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_recmatch",
          "args": [
            "r1->ptr",
            "r1->size",
            "r2->ptr",
            "r2->size",
            "xpp->flags"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_recmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xutils.c",
          "lines": "157-223",
          "snippet": "int xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xinclude.h\"\n\nint xdl_recmatch(const char *l1, long s1, const char *l2, long s2, long flags)\n{\n\tint i1, i2;\n\n\tif (s1 == s2 && !memcmp(l1, l2, s1))\n\t\treturn 1;\n\tif (!(flags & XDF_WHITESPACE_FLAGS))\n\t\treturn 0;\n\n\ti1 = 0;\n\ti2 = 0;\n\n\t/*\n\t * -w matches everything that matches with -b, and -b in turn\n\t * matches everything that matches with --ignore-space-at-eol.\n\t *\n\t * Each flavor of ignoring needs different logic to skip whitespaces\n\t * while we have both sides to compare.\n\t */\n\tif (flags & XDF_IGNORE_WHITESPACE) {\n\t\tgoto skip_ws;\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\tskip_ws:\n\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\ti1++;\n\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\ti2++;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_CHANGE) {\n\t\twhile (i1 < s1 && i2 < s2) {\n\t\t\tif (XDL_ISSPACE(l1[i1]) && XDL_ISSPACE(l2[i2])) {\n\t\t\t\t/* Skip matching spaces and try again */\n\t\t\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\t\t\ti1++;\n\t\t\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\t\t\ti2++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (l1[i1++] != l2[i2++])\n\t\t\t\treturn 0;\n\t\t}\n\t} else if (flags & XDF_IGNORE_WHITESPACE_AT_EOL) {\n\t\twhile (i1 < s1 && i2 < s2 && l1[i1++] == l2[i2++])\n\t\t\t; /* keep going */\n\t}\n\n\t/*\n\t * After running out of one side, the remaining side must have\n\t * nothing but whitespace for the lines to match.  Note that\n\t * ignore-whitespace-at-eol case may break out of the loop\n\t * while there still are characters remaining on both lines.\n\t */\n\tif (i1 < s1) {\n\t\twhile (i1 < s1 && XDL_ISSPACE(l1[i1]))\n\t\t\ti1++;\n\t\tif (s1 != i1)\n\t\t\treturn 0;\n\t}\n\tif (i2 < s2) {\n\t\twhile (i2 < s2 && XDL_ISSPACE(l2[i2]))\n\t\t\ti2++;\n\t\treturn (s2 == i2);\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include \"xdiff.h\"\n#include \"xtypes.h\"\n#include \"xinclude.h\"\n\nstatic int cmp_recs(xpparam_t const *xpp,\n\txrecord_t *r1, xrecord_t *r2)\n{\n\treturn r1->ha == r2->ha &&\n\t\txdl_recmatch(r1->ptr, r1->size, r2->ptr, r2->size,\n\t\t\t    xpp->flags);\n}"
  }
]