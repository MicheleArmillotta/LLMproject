[
  {
    "function_name": "git_blame__free_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "655-660",
    "snippet": "void git_blame__free_entry(git_blame__entry *ent)\n{\n\tif (!ent) return;\n\torigin_decref(ent->suspect);\n\tgit__free(ent);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ent"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "ent->suspect"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nvoid git_blame__free_entry(git_blame__entry *ent)\n{\n\tif (!ent) return;\n\torigin_decref(ent->suspect);\n\tgit__free(ent);\n}"
  },
  {
    "function_name": "git_blame__like_git",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "619-653",
    "snippet": "int git_blame__like_git(git_blame *blame, uint32_t opt)\n{\n\twhile (true) {\n\t\tgit_blame__entry *ent;\n\t\tgit_blame__origin *suspect = NULL;\n\n\t\t/* Find a suspect to break down */\n\t\tfor (ent = blame->ent; !suspect && ent; ent = ent->next)\n\t\t\tif (!ent->guilty)\n\t\t\t\tsuspect = ent->suspect;\n\t\tif (!suspect)\n\t\t\treturn 0; /* all done */\n\n\t\t/* We'll use this suspect later in the loop, so hold on to it for now. */\n\t\torigin_incref(suspect);\n\n\t\tif (pass_blame(blame, suspect, opt) < 0)\n\t\t\treturn -1;\n\n\t\t/* Take responsibility for the remaining entries */\n\t\tfor (ent = blame->ent; ent; ent = ent->next) {\n\t\t\tif (same_suspect(ent->suspect, suspect)) {\n\t\t\t\tent->guilty = true;\n\t\t\t\tent->is_boundary = !git_oid_cmp(\n\t\t\t\t\t\tgit_commit_id(suspect->commit),\n\t\t\t\t\t\t&blame->options.oldest_commit);\n\t\t\t}\n\t\t}\n\t\torigin_decref(suspect);\n\t}\n\n\tcoalesce(blame);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "coalesce",
          "args": [
            "blame"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "coalesce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "598-617",
          "snippet": "static void coalesce(git_blame *blame)\n{\n\tgit_blame__entry *ent, *next;\n\n\tfor (ent=blame->ent; ent && (next = ent->next); ent = next) {\n\t\tif (same_suspect(ent->suspect, next->suspect) &&\n\t\t    ent->guilty == next->guilty &&\n\t\t    ent->s_lno + ent->num_lines == next->s_lno)\n\t\t{\n\t\t\tent->num_lines += next->num_lines;\n\t\t\tent->next = next->next;\n\t\t\tif (ent->next)\n\t\t\t\tent->next->prev = ent;\n\t\t\torigin_decref(next->suspect);\n\t\t\tgit__free(next);\n\t\t\tent->score = 0;\n\t\t\tnext = ent; /* again */\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void coalesce(git_blame *blame)\n{\n\tgit_blame__entry *ent, *next;\n\n\tfor (ent=blame->ent; ent && (next = ent->next); ent = next) {\n\t\tif (same_suspect(ent->suspect, next->suspect) &&\n\t\t    ent->guilty == next->guilty &&\n\t\t    ent->s_lno + ent->num_lines == next->s_lno)\n\t\t{\n\t\t\tent->num_lines += next->num_lines;\n\t\t\tent->next = next->next;\n\t\t\tif (ent->next)\n\t\t\t\tent->next->prev = ent;\n\t\t\torigin_decref(next->suspect);\n\t\t\tgit__free(next);\n\t\t\tent->score = 0;\n\t\t\tnext = ent; /* again */\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "suspect"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "git_commit_id(suspect->commit)",
            "&blame->options.oldest_commit"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "suspect->commit"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_suspect",
          "args": [
            "ent->suspect",
            "suspect"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "same_suspect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "88-95",
          "snippet": "static bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pass_blame",
          "args": [
            "blame",
            "suspect",
            "opt"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "pass_blame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "498-591",
          "snippet": "static int pass_blame(git_blame *blame, git_blame__origin *origin, uint32_t opt)\n{\n\tgit_commit *commit = origin->commit;\n\tint i, num_parents;\n\tgit_blame__origin *sg_buf[16];\n\tgit_blame__origin *porigin, **sg_origin = sg_buf;\n\tint ret, error = 0;\n\n\tnum_parents = git_commit_parentcount(commit);\n\tif (!git_oid_cmp(git_commit_id(commit), &blame->options.oldest_commit))\n\t\t/* Stop at oldest specified commit */\n\t\tnum_parents = 0;\n\telse if (opt & GIT_BLAME_FIRST_PARENT && num_parents > 1)\n\t\t/* Limit search to the first parent */\n\t\tnum_parents = 1;\n\n\tif (!num_parents) {\n\t\tgit_oid_cpy(&blame->options.oldest_commit, git_commit_id(commit));\n\t\tgoto finish;\n\t}\n\telse if (num_parents < (int)ARRAY_SIZE(sg_buf))\n\t\tmemset(sg_buf, 0, sizeof(sg_buf));\n\telse\n\t\tsg_origin = git__calloc(num_parents, sizeof(*sg_origin));\n\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_commit *p;\n\t\tint j, same;\n\n\t\tif (sg_origin[i])\n\t\t\tcontinue;\n\n\t\tif ((error = git_commit_parent(&p, origin->commit, i)) < 0)\n\t\t\tgoto finish;\n\t\tporigin = find_origin(blame, p, origin);\n\n\t\tif (!porigin) {\n\t\t\t/*\n\t\t\t * We only have to decrement the parent's\n\t\t\t * reference count when no porigin has\n\t\t\t * been created, as otherwise the commit\n\t\t\t * is assigned to the created object.\n\t\t\t */\n\t\t\tgit_commit_free(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif (porigin->blob && origin->blob &&\n\t\t    !git_oid_cmp(git_blob_id(porigin->blob), git_blob_id(origin->blob))) {\n\t\t\tpass_whole_blame(blame, origin, porigin);\n\t\t\torigin_decref(porigin);\n\t\t\tgoto finish;\n\t\t}\n\t\tfor (j = same = 0; j<i; j++)\n\t\t\tif (sg_origin[j] &&\n\t\t\t\t !git_oid_cmp(git_blob_id(sg_origin[j]->blob), git_blob_id(porigin->blob))) {\n\t\t\t\tsame = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!same)\n\t\t\tsg_origin[i] = porigin;\n\t\telse\n\t\t\torigin_decref(porigin);\n\t}\n\n\t/* Standard blame */\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_blame__origin *porigin = sg_origin[i];\n\t\tif (!porigin)\n\t\t\tcontinue;\n\t\tif (!origin->previous) {\n\t\t\torigin_incref(porigin);\n\t\t\torigin->previous = porigin;\n\t\t}\n\n\t\tif ((ret = pass_blame_to_parent(blame, origin, porigin)) != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\terror = -1;\n\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/* TODO: optionally find moves in parents' files */\n\n\t/* TODO: optionally find copies in parents' files */\n\nfinish:\n\tfor (i=0; i<num_parents; i++)\n\t\tif (sg_origin[i])\n\t\t\torigin_decref(sg_origin[i]);\n\tif (sg_origin != sg_buf)\n\t\tgit__free(sg_origin);\n\treturn error;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int pass_blame(git_blame *blame, git_blame__origin *origin, uint32_t opt)\n{\n\tgit_commit *commit = origin->commit;\n\tint i, num_parents;\n\tgit_blame__origin *sg_buf[16];\n\tgit_blame__origin *porigin, **sg_origin = sg_buf;\n\tint ret, error = 0;\n\n\tnum_parents = git_commit_parentcount(commit);\n\tif (!git_oid_cmp(git_commit_id(commit), &blame->options.oldest_commit))\n\t\t/* Stop at oldest specified commit */\n\t\tnum_parents = 0;\n\telse if (opt & GIT_BLAME_FIRST_PARENT && num_parents > 1)\n\t\t/* Limit search to the first parent */\n\t\tnum_parents = 1;\n\n\tif (!num_parents) {\n\t\tgit_oid_cpy(&blame->options.oldest_commit, git_commit_id(commit));\n\t\tgoto finish;\n\t}\n\telse if (num_parents < (int)ARRAY_SIZE(sg_buf))\n\t\tmemset(sg_buf, 0, sizeof(sg_buf));\n\telse\n\t\tsg_origin = git__calloc(num_parents, sizeof(*sg_origin));\n\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_commit *p;\n\t\tint j, same;\n\n\t\tif (sg_origin[i])\n\t\t\tcontinue;\n\n\t\tif ((error = git_commit_parent(&p, origin->commit, i)) < 0)\n\t\t\tgoto finish;\n\t\tporigin = find_origin(blame, p, origin);\n\n\t\tif (!porigin) {\n\t\t\t/*\n\t\t\t * We only have to decrement the parent's\n\t\t\t * reference count when no porigin has\n\t\t\t * been created, as otherwise the commit\n\t\t\t * is assigned to the created object.\n\t\t\t */\n\t\t\tgit_commit_free(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif (porigin->blob && origin->blob &&\n\t\t    !git_oid_cmp(git_blob_id(porigin->blob), git_blob_id(origin->blob))) {\n\t\t\tpass_whole_blame(blame, origin, porigin);\n\t\t\torigin_decref(porigin);\n\t\t\tgoto finish;\n\t\t}\n\t\tfor (j = same = 0; j<i; j++)\n\t\t\tif (sg_origin[j] &&\n\t\t\t\t !git_oid_cmp(git_blob_id(sg_origin[j]->blob), git_blob_id(porigin->blob))) {\n\t\t\t\tsame = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!same)\n\t\t\tsg_origin[i] = porigin;\n\t\telse\n\t\t\torigin_decref(porigin);\n\t}\n\n\t/* Standard blame */\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_blame__origin *porigin = sg_origin[i];\n\t\tif (!porigin)\n\t\t\tcontinue;\n\t\tif (!origin->previous) {\n\t\t\torigin_incref(porigin);\n\t\t\torigin->previous = porigin;\n\t\t}\n\n\t\tif ((ret = pass_blame_to_parent(blame, origin, porigin)) != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\terror = -1;\n\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/* TODO: optionally find moves in parents' files */\n\n\t/* TODO: optionally find copies in parents' files */\n\nfinish:\n\tfor (i=0; i<num_parents; i++)\n\t\tif (sg_origin[i])\n\t\t\torigin_decref(sg_origin[i]);\n\tif (sg_origin != sg_buf)\n\t\tgit__free(sg_origin);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "suspect"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nint git_blame__like_git(git_blame *blame, uint32_t opt)\n{\n\twhile (true) {\n\t\tgit_blame__entry *ent;\n\t\tgit_blame__origin *suspect = NULL;\n\n\t\t/* Find a suspect to break down */\n\t\tfor (ent = blame->ent; !suspect && ent; ent = ent->next)\n\t\t\tif (!ent->guilty)\n\t\t\t\tsuspect = ent->suspect;\n\t\tif (!suspect)\n\t\t\treturn 0; /* all done */\n\n\t\t/* We'll use this suspect later in the loop, so hold on to it for now. */\n\t\torigin_incref(suspect);\n\n\t\tif (pass_blame(blame, suspect, opt) < 0)\n\t\t\treturn -1;\n\n\t\t/* Take responsibility for the remaining entries */\n\t\tfor (ent = blame->ent; ent; ent = ent->next) {\n\t\t\tif (same_suspect(ent->suspect, suspect)) {\n\t\t\t\tent->guilty = true;\n\t\t\t\tent->is_boundary = !git_oid_cmp(\n\t\t\t\t\t\tgit_commit_id(suspect->commit),\n\t\t\t\t\t\t&blame->options.oldest_commit);\n\t\t\t}\n\t\t}\n\t\torigin_decref(suspect);\n\t}\n\n\tcoalesce(blame);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "coalesce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "598-617",
    "snippet": "static void coalesce(git_blame *blame)\n{\n\tgit_blame__entry *ent, *next;\n\n\tfor (ent=blame->ent; ent && (next = ent->next); ent = next) {\n\t\tif (same_suspect(ent->suspect, next->suspect) &&\n\t\t    ent->guilty == next->guilty &&\n\t\t    ent->s_lno + ent->num_lines == next->s_lno)\n\t\t{\n\t\t\tent->num_lines += next->num_lines;\n\t\t\tent->next = next->next;\n\t\t\tif (ent->next)\n\t\t\t\tent->next->prev = ent;\n\t\t\torigin_decref(next->suspect);\n\t\t\tgit__free(next);\n\t\t\tent->score = 0;\n\t\t\tnext = ent; /* again */\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "next"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "next->suspect"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_suspect",
          "args": [
            "ent->suspect",
            "next->suspect"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "same_suspect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "88-95",
          "snippet": "static bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void coalesce(git_blame *blame)\n{\n\tgit_blame__entry *ent, *next;\n\n\tfor (ent=blame->ent; ent && (next = ent->next); ent = next) {\n\t\tif (same_suspect(ent->suspect, next->suspect) &&\n\t\t    ent->guilty == next->guilty &&\n\t\t    ent->s_lno + ent->num_lines == next->s_lno)\n\t\t{\n\t\t\tent->num_lines += next->num_lines;\n\t\t\tent->next = next->next;\n\t\t\tif (ent->next)\n\t\t\t\tent->next->prev = ent;\n\t\t\torigin_decref(next->suspect);\n\t\t\tgit__free(next);\n\t\t\tent->score = 0;\n\t\t\tnext = ent; /* again */\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pass_blame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "498-591",
    "snippet": "static int pass_blame(git_blame *blame, git_blame__origin *origin, uint32_t opt)\n{\n\tgit_commit *commit = origin->commit;\n\tint i, num_parents;\n\tgit_blame__origin *sg_buf[16];\n\tgit_blame__origin *porigin, **sg_origin = sg_buf;\n\tint ret, error = 0;\n\n\tnum_parents = git_commit_parentcount(commit);\n\tif (!git_oid_cmp(git_commit_id(commit), &blame->options.oldest_commit))\n\t\t/* Stop at oldest specified commit */\n\t\tnum_parents = 0;\n\telse if (opt & GIT_BLAME_FIRST_PARENT && num_parents > 1)\n\t\t/* Limit search to the first parent */\n\t\tnum_parents = 1;\n\n\tif (!num_parents) {\n\t\tgit_oid_cpy(&blame->options.oldest_commit, git_commit_id(commit));\n\t\tgoto finish;\n\t}\n\telse if (num_parents < (int)ARRAY_SIZE(sg_buf))\n\t\tmemset(sg_buf, 0, sizeof(sg_buf));\n\telse\n\t\tsg_origin = git__calloc(num_parents, sizeof(*sg_origin));\n\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_commit *p;\n\t\tint j, same;\n\n\t\tif (sg_origin[i])\n\t\t\tcontinue;\n\n\t\tif ((error = git_commit_parent(&p, origin->commit, i)) < 0)\n\t\t\tgoto finish;\n\t\tporigin = find_origin(blame, p, origin);\n\n\t\tif (!porigin) {\n\t\t\t/*\n\t\t\t * We only have to decrement the parent's\n\t\t\t * reference count when no porigin has\n\t\t\t * been created, as otherwise the commit\n\t\t\t * is assigned to the created object.\n\t\t\t */\n\t\t\tgit_commit_free(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif (porigin->blob && origin->blob &&\n\t\t    !git_oid_cmp(git_blob_id(porigin->blob), git_blob_id(origin->blob))) {\n\t\t\tpass_whole_blame(blame, origin, porigin);\n\t\t\torigin_decref(porigin);\n\t\t\tgoto finish;\n\t\t}\n\t\tfor (j = same = 0; j<i; j++)\n\t\t\tif (sg_origin[j] &&\n\t\t\t\t !git_oid_cmp(git_blob_id(sg_origin[j]->blob), git_blob_id(porigin->blob))) {\n\t\t\t\tsame = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!same)\n\t\t\tsg_origin[i] = porigin;\n\t\telse\n\t\t\torigin_decref(porigin);\n\t}\n\n\t/* Standard blame */\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_blame__origin *porigin = sg_origin[i];\n\t\tif (!porigin)\n\t\t\tcontinue;\n\t\tif (!origin->previous) {\n\t\t\torigin_incref(porigin);\n\t\t\torigin->previous = porigin;\n\t\t}\n\n\t\tif ((ret = pass_blame_to_parent(blame, origin, porigin)) != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\terror = -1;\n\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/* TODO: optionally find moves in parents' files */\n\n\t/* TODO: optionally find copies in parents' files */\n\nfinish:\n\tfor (i=0; i<num_parents; i++)\n\t\tif (sg_origin[i])\n\t\t\torigin_decref(sg_origin[i]);\n\tif (sg_origin != sg_buf)\n\t\tgit__free(sg_origin);\n\treturn error;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sg_origin"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "sg_origin[i]"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pass_blame_to_parent",
          "args": [
            "blame",
            "origin",
            "porigin"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "pass_blame_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "383-405",
          "snippet": "static int pass_blame_to_parent(\n\t\tgit_blame *blame,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tsize_t last_in_target;\n\tmmfile_t file_p, file_o;\n\tblame_chunk_cb_data d = { blame, target, parent, 0, 0 };\n\n\tif (!find_last_in_target(&last_in_target, blame, target))\n\t\treturn 1; /* nothing remains for this target */\n\n\tfill_origin_blob(parent, &file_p);\n\tfill_origin_blob(target, &file_o);\n\n\tif (diff_hunks(file_p, file_o, &d) < 0)\n\t\treturn -1;\n\n\t/* The reset (i.e. anything after tlno) are the same as the parent */\n\tblame_chunk(blame, d.tlno, d.plno, last_in_target, target, parent);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int pass_blame_to_parent(\n\t\tgit_blame *blame,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tsize_t last_in_target;\n\tmmfile_t file_p, file_o;\n\tblame_chunk_cb_data d = { blame, target, parent, 0, 0 };\n\n\tif (!find_last_in_target(&last_in_target, blame, target))\n\t\treturn 1; /* nothing remains for this target */\n\n\tfill_origin_blob(parent, &file_p);\n\tfill_origin_blob(target, &file_o);\n\n\tif (diff_hunks(file_p, file_o, &d) < 0)\n\t\treturn -1;\n\n\t/* The reset (i.e. anything after tlno) are the same as the parent */\n\tblame_chunk(blame, d.tlno, d.plno, last_in_target, target, parent);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "porigin"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "git_blob_id(sg_origin[j]->blob)",
            "git_blob_id(porigin->blob)"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_id",
          "args": [
            "porigin->blob"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "121-124",
          "snippet": "const git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pass_whole_blame",
          "args": [
            "blame",
            "origin",
            "porigin"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "pass_whole_blame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "481-496",
          "snippet": "static void pass_whole_blame(git_blame *blame,\n\t\tgit_blame__origin *origin, git_blame__origin *porigin)\n{\n\tgit_blame__entry *e;\n\n\tif (!porigin->blob)\n\t\tgit_object_lookup((git_object**)&porigin->blob, blame->repository,\n\t\t\t\tgit_blob_id(origin->blob), GIT_OBJ_BLOB);\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (!same_suspect(e->suspect, origin))\n\t\t\tcontinue;\n\t\torigin_incref(porigin);\n\t\torigin_decref(e->suspect);\n\t\te->suspect = porigin;\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void pass_whole_blame(git_blame *blame,\n\t\tgit_blame__origin *origin, git_blame__origin *porigin)\n{\n\tgit_blame__entry *e;\n\n\tif (!porigin->blob)\n\t\tgit_object_lookup((git_object**)&porigin->blob, blame->repository,\n\t\t\t\tgit_blob_id(origin->blob), GIT_OBJ_BLOB);\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (!same_suspect(e->suspect, origin))\n\t\t\tcontinue;\n\t\torigin_incref(porigin);\n\t\torigin_decref(e->suspect);\n\t\te->suspect = porigin;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "p"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_origin",
          "args": [
            "blame",
            "p",
            "origin"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "find_origin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "414-475",
          "snippet": "static git_blame__origin* find_origin(\n\t\tgit_blame *blame,\n\t\tgit_commit *parent,\n\t\tgit_blame__origin *origin)\n{\n\tgit_blame__origin *porigin = NULL;\n\tgit_diff *difflist = NULL;\n\tgit_diff_options diffopts = GIT_DIFF_OPTIONS_INIT;\n\tgit_tree *otree=NULL, *ptree=NULL;\n\n\t/* Get the trees from this commit and its parent */\n\tif (0 != git_commit_tree(&otree, origin->commit) ||\n\t    0 != git_commit_tree(&ptree, parent))\n\t\tgoto cleanup;\n\n\t/* Configure the diff */\n\tdiffopts.context_lines = 0;\n\tdiffopts.flags = GIT_DIFF_SKIP_BINARY_CHECK;\n\n\t/* Check to see if files we're interested have changed */\n\tdiffopts.pathspec.count = blame->paths.length;\n\tdiffopts.pathspec.strings = (char**)blame->paths.contents;\n\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\tif (!git_diff_num_deltas(difflist)) {\n\t\t/* No changes; copy data */\n\t\tgit_blame__get_origin(&porigin, blame, parent, origin->path);\n\t} else {\n\t\tgit_diff_find_options findopts = GIT_DIFF_FIND_OPTIONS_INIT;\n\t\tint i;\n\n\t\t/* Generate a full diff between the two trees */\n\t\tgit_diff_free(difflist);\n\t\tdiffopts.pathspec.count = 0;\n\t\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Let diff find renames */\n\t\tfindopts.flags = GIT_DIFF_FIND_RENAMES;\n\t\tif (0 != git_diff_find_similar(difflist, &findopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Find one that matches */\n\t\tfor (i=0; i<(int)git_diff_num_deltas(difflist); i++) {\n\t\t\tconst git_diff_delta *delta = git_diff_get_delta(difflist, i);\n\n\t\t\tif (!git_vector_bsearch(NULL, &blame->paths, delta->new_file.path))\n\t\t\t{\n\t\t\t\tgit_vector_insert_sorted(&blame->paths, (void*)git__strdup(delta->old_file.path),\n\t\t\t\t\t\tpaths_on_dup);\n\t\t\t\tmake_origin(&porigin, parent, delta->old_file.path);\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tgit_diff_free(difflist);\n\tgit_tree_free(otree);\n\tgit_tree_free(ptree);\n\treturn porigin;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin* find_origin(\n\t\tgit_blame *blame,\n\t\tgit_commit *parent,\n\t\tgit_blame__origin *origin)\n{\n\tgit_blame__origin *porigin = NULL;\n\tgit_diff *difflist = NULL;\n\tgit_diff_options diffopts = GIT_DIFF_OPTIONS_INIT;\n\tgit_tree *otree=NULL, *ptree=NULL;\n\n\t/* Get the trees from this commit and its parent */\n\tif (0 != git_commit_tree(&otree, origin->commit) ||\n\t    0 != git_commit_tree(&ptree, parent))\n\t\tgoto cleanup;\n\n\t/* Configure the diff */\n\tdiffopts.context_lines = 0;\n\tdiffopts.flags = GIT_DIFF_SKIP_BINARY_CHECK;\n\n\t/* Check to see if files we're interested have changed */\n\tdiffopts.pathspec.count = blame->paths.length;\n\tdiffopts.pathspec.strings = (char**)blame->paths.contents;\n\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\tif (!git_diff_num_deltas(difflist)) {\n\t\t/* No changes; copy data */\n\t\tgit_blame__get_origin(&porigin, blame, parent, origin->path);\n\t} else {\n\t\tgit_diff_find_options findopts = GIT_DIFF_FIND_OPTIONS_INIT;\n\t\tint i;\n\n\t\t/* Generate a full diff between the two trees */\n\t\tgit_diff_free(difflist);\n\t\tdiffopts.pathspec.count = 0;\n\t\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Let diff find renames */\n\t\tfindopts.flags = GIT_DIFF_FIND_RENAMES;\n\t\tif (0 != git_diff_find_similar(difflist, &findopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Find one that matches */\n\t\tfor (i=0; i<(int)git_diff_num_deltas(difflist); i++) {\n\t\t\tconst git_diff_delta *delta = git_diff_get_delta(difflist, i);\n\n\t\t\tif (!git_vector_bsearch(NULL, &blame->paths, delta->new_file.path))\n\t\t\t{\n\t\t\t\tgit_vector_insert_sorted(&blame->paths, (void*)git__strdup(delta->old_file.path),\n\t\t\t\t\t\tpaths_on_dup);\n\t\t\t\tmake_origin(&porigin, parent, delta->old_file.path);\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tgit_diff_free(difflist);\n\tgit_tree_free(otree);\n\tgit_tree_free(ptree);\n\treturn porigin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "&p",
            "origin->commit",
            "i"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "num_parents",
            "sizeof(*sg_origin)"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sg_buf",
            "0",
            "sizeof(sg_buf)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sg_buf"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&blame->options.oldest_commit",
            "git_commit_id(commit)"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "commit"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int pass_blame(git_blame *blame, git_blame__origin *origin, uint32_t opt)\n{\n\tgit_commit *commit = origin->commit;\n\tint i, num_parents;\n\tgit_blame__origin *sg_buf[16];\n\tgit_blame__origin *porigin, **sg_origin = sg_buf;\n\tint ret, error = 0;\n\n\tnum_parents = git_commit_parentcount(commit);\n\tif (!git_oid_cmp(git_commit_id(commit), &blame->options.oldest_commit))\n\t\t/* Stop at oldest specified commit */\n\t\tnum_parents = 0;\n\telse if (opt & GIT_BLAME_FIRST_PARENT && num_parents > 1)\n\t\t/* Limit search to the first parent */\n\t\tnum_parents = 1;\n\n\tif (!num_parents) {\n\t\tgit_oid_cpy(&blame->options.oldest_commit, git_commit_id(commit));\n\t\tgoto finish;\n\t}\n\telse if (num_parents < (int)ARRAY_SIZE(sg_buf))\n\t\tmemset(sg_buf, 0, sizeof(sg_buf));\n\telse\n\t\tsg_origin = git__calloc(num_parents, sizeof(*sg_origin));\n\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_commit *p;\n\t\tint j, same;\n\n\t\tif (sg_origin[i])\n\t\t\tcontinue;\n\n\t\tif ((error = git_commit_parent(&p, origin->commit, i)) < 0)\n\t\t\tgoto finish;\n\t\tporigin = find_origin(blame, p, origin);\n\n\t\tif (!porigin) {\n\t\t\t/*\n\t\t\t * We only have to decrement the parent's\n\t\t\t * reference count when no porigin has\n\t\t\t * been created, as otherwise the commit\n\t\t\t * is assigned to the created object.\n\t\t\t */\n\t\t\tgit_commit_free(p);\n\t\t\tcontinue;\n\t\t}\n\t\tif (porigin->blob && origin->blob &&\n\t\t    !git_oid_cmp(git_blob_id(porigin->blob), git_blob_id(origin->blob))) {\n\t\t\tpass_whole_blame(blame, origin, porigin);\n\t\t\torigin_decref(porigin);\n\t\t\tgoto finish;\n\t\t}\n\t\tfor (j = same = 0; j<i; j++)\n\t\t\tif (sg_origin[j] &&\n\t\t\t\t !git_oid_cmp(git_blob_id(sg_origin[j]->blob), git_blob_id(porigin->blob))) {\n\t\t\t\tsame = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!same)\n\t\t\tsg_origin[i] = porigin;\n\t\telse\n\t\t\torigin_decref(porigin);\n\t}\n\n\t/* Standard blame */\n\tfor (i=0; i<num_parents; i++) {\n\t\tgit_blame__origin *porigin = sg_origin[i];\n\t\tif (!porigin)\n\t\t\tcontinue;\n\t\tif (!origin->previous) {\n\t\t\torigin_incref(porigin);\n\t\t\torigin->previous = porigin;\n\t\t}\n\n\t\tif ((ret = pass_blame_to_parent(blame, origin, porigin)) != 0) {\n\t\t\tif (ret < 0)\n\t\t\t\terror = -1;\n\n\t\t\tgoto finish;\n\t\t}\n\t}\n\n\t/* TODO: optionally find moves in parents' files */\n\n\t/* TODO: optionally find copies in parents' files */\n\nfinish:\n\tfor (i=0; i<num_parents; i++)\n\t\tif (sg_origin[i])\n\t\t\torigin_decref(sg_origin[i]);\n\tif (sg_origin != sg_buf)\n\t\tgit__free(sg_origin);\n\treturn error;\n}"
  },
  {
    "function_name": "pass_whole_blame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "481-496",
    "snippet": "static void pass_whole_blame(git_blame *blame,\n\t\tgit_blame__origin *origin, git_blame__origin *porigin)\n{\n\tgit_blame__entry *e;\n\n\tif (!porigin->blob)\n\t\tgit_object_lookup((git_object**)&porigin->blob, blame->repository,\n\t\t\t\tgit_blob_id(origin->blob), GIT_OBJ_BLOB);\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (!same_suspect(e->suspect, origin))\n\t\t\tcontinue;\n\t\torigin_incref(porigin);\n\t\torigin_decref(e->suspect);\n\t\te->suspect = porigin;\n\t}\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "e->suspect"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "porigin"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_suspect",
          "args": [
            "e->suspect",
            "origin"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "same_suspect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "88-95",
          "snippet": "static bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "(git_object**)&porigin->blob",
            "blame->repository",
            "git_blob_id(origin->blob)",
            "GIT_OBJ_BLOB"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_id",
          "args": [
            "origin->blob"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "121-124",
          "snippet": "const git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_blob_id(const git_blob *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void pass_whole_blame(git_blame *blame,\n\t\tgit_blame__origin *origin, git_blame__origin *porigin)\n{\n\tgit_blame__entry *e;\n\n\tif (!porigin->blob)\n\t\tgit_object_lookup((git_object**)&porigin->blob, blame->repository,\n\t\t\t\tgit_blob_id(origin->blob), GIT_OBJ_BLOB);\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (!same_suspect(e->suspect, origin))\n\t\t\tcontinue;\n\t\torigin_incref(porigin);\n\t\torigin_decref(e->suspect);\n\t\te->suspect = porigin;\n\t}\n}"
  },
  {
    "function_name": "find_origin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "414-475",
    "snippet": "static git_blame__origin* find_origin(\n\t\tgit_blame *blame,\n\t\tgit_commit *parent,\n\t\tgit_blame__origin *origin)\n{\n\tgit_blame__origin *porigin = NULL;\n\tgit_diff *difflist = NULL;\n\tgit_diff_options diffopts = GIT_DIFF_OPTIONS_INIT;\n\tgit_tree *otree=NULL, *ptree=NULL;\n\n\t/* Get the trees from this commit and its parent */\n\tif (0 != git_commit_tree(&otree, origin->commit) ||\n\t    0 != git_commit_tree(&ptree, parent))\n\t\tgoto cleanup;\n\n\t/* Configure the diff */\n\tdiffopts.context_lines = 0;\n\tdiffopts.flags = GIT_DIFF_SKIP_BINARY_CHECK;\n\n\t/* Check to see if files we're interested have changed */\n\tdiffopts.pathspec.count = blame->paths.length;\n\tdiffopts.pathspec.strings = (char**)blame->paths.contents;\n\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\tif (!git_diff_num_deltas(difflist)) {\n\t\t/* No changes; copy data */\n\t\tgit_blame__get_origin(&porigin, blame, parent, origin->path);\n\t} else {\n\t\tgit_diff_find_options findopts = GIT_DIFF_FIND_OPTIONS_INIT;\n\t\tint i;\n\n\t\t/* Generate a full diff between the two trees */\n\t\tgit_diff_free(difflist);\n\t\tdiffopts.pathspec.count = 0;\n\t\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Let diff find renames */\n\t\tfindopts.flags = GIT_DIFF_FIND_RENAMES;\n\t\tif (0 != git_diff_find_similar(difflist, &findopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Find one that matches */\n\t\tfor (i=0; i<(int)git_diff_num_deltas(difflist); i++) {\n\t\t\tconst git_diff_delta *delta = git_diff_get_delta(difflist, i);\n\n\t\t\tif (!git_vector_bsearch(NULL, &blame->paths, delta->new_file.path))\n\t\t\t{\n\t\t\t\tgit_vector_insert_sorted(&blame->paths, (void*)git__strdup(delta->old_file.path),\n\t\t\t\t\t\tpaths_on_dup);\n\t\t\t\tmake_origin(&porigin, parent, delta->old_file.path);\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tgit_diff_free(difflist);\n\tgit_tree_free(otree);\n\tgit_tree_free(ptree);\n\treturn porigin;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "ptree"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "difflist"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_origin",
          "args": [
            "&porigin",
            "parent",
            "delta->old_file.path"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "make_origin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "37-61",
          "snippet": "static int make_origin(git_blame__origin **out, git_commit *commit, const char *path)\n{\n\tgit_blame__origin *o;\n\tgit_object *blob;\n\tsize_t path_len = strlen(path), alloc_len;\n\tint error = 0;\n\n\tif ((error = git_object_lookup_bypath(&blob, (git_object*)commit,\n\t\t\tpath, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*o), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\to = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(o);\n\n\to->commit = commit;\n\to->blob = (git_blob *) blob;\n\to->refcnt = 1;\n\tstrcpy(o->path, path);\n\n\t*out = o;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int make_origin(git_blame__origin **out, git_commit *commit, const char *path)\n{\n\tgit_blame__origin *o;\n\tgit_object *blob;\n\tsize_t path_len = strlen(path), alloc_len;\n\tint error = 0;\n\n\tif ((error = git_object_lookup_bypath(&blob, (git_object*)commit,\n\t\t\tpath, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*o), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\to = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(o);\n\n\to->commit = commit;\n\to->blob = (git_blob *) blob;\n\to->refcnt = 1;\n\tstrcpy(o->path, path);\n\n\t*out = o;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert_sorted",
          "args": [
            "&blame->paths",
            "(void*)git__strdup(delta->old_file.path)",
            "paths_on_dup"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert_sorted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "141-173",
          "snippet": "int git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert_sorted(\n\tgit_vector *v, void *element, int (*on_dup)(void **old, void *new))\n{\n\tint result;\n\tsize_t pos;\n\n\tassert(v && v->_cmp);\n\n\tif (!git_vector_is_sorted(v))\n\t\tgit_vector_sort(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\t/* If we find the element and have a duplicate handler callback,\n\t * invoke it.  If it returns non-zero, then cancel insert, otherwise\n\t * proceed with normal insert.\n\t */\n\tif (!git__bsearch(v->contents, v->length, element, v->_cmp, &pos) &&\n\t\ton_dup && (result = on_dup(&v->contents[pos], element)) < 0)\n\t\treturn result;\n\n\t/* shift elements to the right */\n\tif (pos < v->length)\n\t\tmemmove(v->contents + pos + 1, v->contents + pos,\n\t\t        (v->length - pos) * sizeof(void *));\n\n\tv->contents[pos] = element;\n\tv->length++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "delta->old_file.path"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch",
          "args": [
            "NULL",
            "&blame->paths",
            "delta->new_file.path"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "55-58",
          "snippet": "GIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(int) git_vector_bsearch(size_t *at_pos, git_vector *v, const void *key)\n{\n\treturn git_vector_bsearch2(at_pos, v, v->_cmp, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_get_delta",
          "args": [
            "difflist",
            "i"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_get_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1506-1510",
          "snippet": "const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas",
          "args": [
            "difflist"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1486-1490",
          "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_find_similar",
          "args": [
            "difflist",
            "&findopts"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_find_similar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "795-1112",
          "snippet": "int git_diff_find_similar(\n\tgit_diff *diff,\n\tconst git_diff_find_options *given_opts)\n{\n\tsize_t s, t;\n\tint error = 0, result;\n\tuint16_t similarity;\n\tgit_diff_delta *src, *tgt;\n\tgit_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT;\n\tsize_t num_deltas, num_srcs = 0, num_tgts = 0;\n\tsize_t tried_srcs = 0, tried_tgts = 0;\n\tsize_t num_rewrites = 0, num_updates = 0, num_bumped = 0;\n\tsize_t sigcache_size;\n\tvoid **sigcache = NULL; /* cache of similarity metric file signatures */\n\tdiff_find_match *tgt2src = NULL;\n\tdiff_find_match *src2tgt = NULL;\n\tdiff_find_match *tgt2src_copy = NULL;\n\tdiff_find_match *best_match;\n\tgit_diff_file swap;\n\n\tif ((error = normalize_find_opts(diff, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tnum_deltas = diff->deltas.length;\n\n\t/* TODO: maybe abort if deltas.length > rename_limit ??? */\n\tif (!git__is_uint32(num_deltas))\n\t\tgoto cleanup;\n\n\t/* No flags set; nothing to do */\n\tif ((opts.flags & GIT_DIFF_FIND_ALL) == 0)\n\t\tgoto cleanup;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sigcache_size, num_deltas, 2);\n\tsigcache = git__calloc(sigcache_size, sizeof(void *));\n\tGITERR_CHECK_ALLOC(sigcache);\n\n\t/* Label rename sources and targets\n\t *\n\t * This will also set self-similarity scores for MODIFIED files and\n\t * mark them for splitting if break-rewrites is enabled\n\t */\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\tif (is_rename_source(diff, &opts, t, sigcache))\n\t\t\t++num_srcs;\n\n\t\tif (is_rename_target(diff, &opts, t, sigcache))\n\t\t\t++num_tgts;\n\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0)\n\t\t\tnum_rewrites++;\n\t}\n\n\t/* if there are no candidate srcs or tgts, we're done */\n\tif (!num_srcs || !num_tgts)\n\t\tgoto cleanup;\n\n\tsrc2tgt = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(src2tgt);\n\ttgt2src = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(tgt2src);\n\n\tif (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\ttgt2src_copy = git__calloc(num_deltas, sizeof(diff_find_match));\n\t\tGITERR_CHECK_ALLOC(tgt2src_copy);\n\t}\n\n\t/*\n\t * Find best-fit matches for rename / copy candidates\n\t */\n\nfind_best_matches:\n\ttried_tgts = num_bumped = 0;\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\ttried_srcs = 0;\n\n\t\tgit_vector_foreach(&diff->deltas, s, src) {\n\t\t\t/* skip things that are not rename sources */\n\t\t\tif ((src->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* calculate similarity for this pair and find best match */\n\t\t\tif (s == t)\n\t\t\t\tresult = -1; /* don't measure self-similarity here */\n\t\t\telse if ((error = similarity_measure(\n\t\t\t\t&result, diff, &opts, sigcache, 2 * s, 2 * t + 1)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (result < 0)\n\t\t\t\tcontinue;\n\t\t\tsimilarity = (uint16_t)result;\n\n\t\t\t/* is this a better rename? */\n\t\t\tif (tgt2src[t].similarity < similarity &&\n\t\t\t\tsrc2tgt[s].similarity < similarity)\n\t\t\t{\n\t\t\t\t/* eject old mapping */\n\t\t\t\tif (src2tgt[s].similarity > 0) {\n\t\t\t\t\ttgt2src[src2tgt[s].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\t\t\t\tif (tgt2src[t].similarity > 0) {\n\t\t\t\t\tsrc2tgt[tgt2src[t].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\n\t\t\t\t/* write new mapping */\n\t\t\t\ttgt2src[t].idx = s;\n\t\t\t\ttgt2src[t].similarity = similarity;\n\t\t\t\tsrc2tgt[s].idx = t;\n\t\t\t\tsrc2tgt[s].similarity = similarity;\n\t\t\t}\n\n\t\t\t/* keep best absolute match for copies */\n\t\t\tif (tgt2src_copy != NULL &&\n\t\t\t\ttgt2src_copy[t].similarity < similarity)\n\t\t\t{\n\t\t\t\ttgt2src_copy[t].idx = s;\n\t\t\t\ttgt2src_copy[t].similarity = similarity;\n\t\t\t}\n\n\t\t\tif (++tried_srcs >= num_srcs)\n\t\t\t\tbreak;\n\n\t\t\t/* cap on maximum targets we'll examine (per \"tgt\" file) */\n\t\t\tif (tried_srcs > opts.rename_limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tried_tgts >= num_tgts)\n\t\t\tbreak;\n\t}\n\n\tif (num_bumped > 0) /* try again if we bumped some items */\n\t\tgoto find_best_matches;\n\n\t/*\n\t * Rewrite the diffs with renames / copies\n\t */\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\t/* check if this delta was the target of a similarity */\n\t\tif (tgt2src[t].similarity)\n\t\t\tbest_match = &tgt2src[t];\n\t\telse if (tgt2src_copy && tgt2src_copy[t].similarity)\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\telse\n\t\t\tcontinue;\n\n\t\ts = best_match->idx;\n\t\tsrc = GIT_VECTOR_GET(&diff->deltas, s);\n\n\t\t/* possible scenarios:\n\t\t * 1. from DELETE to ADD/UNTRACK/IGNORE = RENAME\n\t\t * 2. from DELETE to SPLIT/TYPECHANGE = RENAME + DELETE\n\t\t * 3. from SPLIT/TYPECHANGE to ADD/UNTRACK/IGNORE = ADD + RENAME\n\t\t * 4. from SPLIT/TYPECHANGE to SPLIT/TYPECHANGE = RENAME + SPLIT\n\t\t * 5. from OTHER to ADD/UNTRACK/IGNORE = OTHER + COPY\n\t\t */\n\n\t\tif (src->status == GIT_DELTA_DELETED) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\t\t\tnum_rewrites++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(tgt));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tassert(src->status == GIT_DELTA_DELETED);\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\t\t\t\tmemset(&src->new_file, 0, sizeof(src->new_file));\n\t\t\t\tsrc->new_file.path = src->old_file.path;\n\t\t\t\tsrc->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tnum_updates++;\n\n\t\t\t\tif (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (delta_is_split(src)) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->status = (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ?\n\t\t\t\t\tGIT_DELTA_UNTRACKED : GIT_DELTA_ADDED;\n\t\t\t\tsrc->nfiles = 1;\n\t\t\t\tmemset(&src->old_file, 0, sizeof(src->old_file));\n\t\t\t\tsrc->old_file.path = src->new_file.path;\n\t\t\t\tsrc->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tnum_updates++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(src));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\t\t\t\tnum_updates++;\n\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\n\t\t\t\t/* if we've just swapped the new element into the correct\n\t\t\t\t * place, clear the SPLIT flag\n\t\t\t\t */\n\t\t\t\tif (tgt2src[s].idx == t &&\n\t\t\t\t\ttgt2src[s].similarity >\n\t\t\t\t\topts.rename_from_rewrite_threshold) {\n\t\t\t\t\tsrc->status     = GIT_DELTA_RENAMED;\n\t\t\t\t\tsrc->similarity = tgt2src[s].similarity;\n\t\t\t\t\ttgt2src[s].similarity = 0;\n\t\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\t\tnum_rewrites--;\n\t\t\t\t}\n\t\t\t\t/* otherwise, if we just overwrote a source, update mapping */\n\t\t\t\telse if (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\n\t\t\t\tnum_updates++;\n\t\t\t}\n\t\t}\n\n\t\telse if (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\t\tif (tgt2src_copy[t].similarity < opts.copy_threshold)\n\t\t\t\tcontinue;\n\n\t\t\t/* always use best possible source for copy */\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\t\tsrc = GIT_VECTOR_GET(&diff->deltas, best_match->idx);\n\n\t\t\tif (delta_is_split(tgt)) {\n\t\t\t\terror = insert_delete_side_of_split(diff, &diff->deltas, tgt);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tnum_rewrites--;\n\t\t\t}\n\n\t\t\tif (!delta_is_split(tgt) && !delta_is_new_only(tgt))\n\t\t\t\tcontinue;\n\n\t\t\ttgt->status     = GIT_DELTA_COPIED;\n\t\t\ttgt->similarity = best_match->similarity;\n\t\t\ttgt->nfiles     = 2;\n\t\t\tmemcpy(&tgt->old_file, &src->old_file, sizeof(tgt->old_file));\n\t\t\ttgt->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\n\t\t\tnum_updates++;\n\t\t}\n\t}\n\n\t/*\n\t * Actually split and delete entries as needed\n\t */\n\n\tif (num_rewrites > 0 || num_updates > 0)\n\t\terror = apply_splits_and_deletes(\n\t\t\tdiff, diff->deltas.length - num_rewrites,\n\t\t\tFLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY));\n\ncleanup:\n\tgit__free(tgt2src);\n\tgit__free(src2tgt);\n\tgit__free(tgt2src_copy);\n\n\tif (sigcache) {\n\t\tfor (t = 0; t < num_deltas * 2; ++t) {\n\t\t\tif (sigcache[t] != NULL)\n\t\t\t\topts.metric->free_signature(sigcache[t], opts.metric->payload);\n\t\t}\n\t\tgit__free(sigcache);\n\t}\n\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_find_similar(\n\tgit_diff *diff,\n\tconst git_diff_find_options *given_opts)\n{\n\tsize_t s, t;\n\tint error = 0, result;\n\tuint16_t similarity;\n\tgit_diff_delta *src, *tgt;\n\tgit_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT;\n\tsize_t num_deltas, num_srcs = 0, num_tgts = 0;\n\tsize_t tried_srcs = 0, tried_tgts = 0;\n\tsize_t num_rewrites = 0, num_updates = 0, num_bumped = 0;\n\tsize_t sigcache_size;\n\tvoid **sigcache = NULL; /* cache of similarity metric file signatures */\n\tdiff_find_match *tgt2src = NULL;\n\tdiff_find_match *src2tgt = NULL;\n\tdiff_find_match *tgt2src_copy = NULL;\n\tdiff_find_match *best_match;\n\tgit_diff_file swap;\n\n\tif ((error = normalize_find_opts(diff, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tnum_deltas = diff->deltas.length;\n\n\t/* TODO: maybe abort if deltas.length > rename_limit ??? */\n\tif (!git__is_uint32(num_deltas))\n\t\tgoto cleanup;\n\n\t/* No flags set; nothing to do */\n\tif ((opts.flags & GIT_DIFF_FIND_ALL) == 0)\n\t\tgoto cleanup;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sigcache_size, num_deltas, 2);\n\tsigcache = git__calloc(sigcache_size, sizeof(void *));\n\tGITERR_CHECK_ALLOC(sigcache);\n\n\t/* Label rename sources and targets\n\t *\n\t * This will also set self-similarity scores for MODIFIED files and\n\t * mark them for splitting if break-rewrites is enabled\n\t */\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\tif (is_rename_source(diff, &opts, t, sigcache))\n\t\t\t++num_srcs;\n\n\t\tif (is_rename_target(diff, &opts, t, sigcache))\n\t\t\t++num_tgts;\n\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0)\n\t\t\tnum_rewrites++;\n\t}\n\n\t/* if there are no candidate srcs or tgts, we're done */\n\tif (!num_srcs || !num_tgts)\n\t\tgoto cleanup;\n\n\tsrc2tgt = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(src2tgt);\n\ttgt2src = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(tgt2src);\n\n\tif (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\ttgt2src_copy = git__calloc(num_deltas, sizeof(diff_find_match));\n\t\tGITERR_CHECK_ALLOC(tgt2src_copy);\n\t}\n\n\t/*\n\t * Find best-fit matches for rename / copy candidates\n\t */\n\nfind_best_matches:\n\ttried_tgts = num_bumped = 0;\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\ttried_srcs = 0;\n\n\t\tgit_vector_foreach(&diff->deltas, s, src) {\n\t\t\t/* skip things that are not rename sources */\n\t\t\tif ((src->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* calculate similarity for this pair and find best match */\n\t\t\tif (s == t)\n\t\t\t\tresult = -1; /* don't measure self-similarity here */\n\t\t\telse if ((error = similarity_measure(\n\t\t\t\t&result, diff, &opts, sigcache, 2 * s, 2 * t + 1)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (result < 0)\n\t\t\t\tcontinue;\n\t\t\tsimilarity = (uint16_t)result;\n\n\t\t\t/* is this a better rename? */\n\t\t\tif (tgt2src[t].similarity < similarity &&\n\t\t\t\tsrc2tgt[s].similarity < similarity)\n\t\t\t{\n\t\t\t\t/* eject old mapping */\n\t\t\t\tif (src2tgt[s].similarity > 0) {\n\t\t\t\t\ttgt2src[src2tgt[s].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\t\t\t\tif (tgt2src[t].similarity > 0) {\n\t\t\t\t\tsrc2tgt[tgt2src[t].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\n\t\t\t\t/* write new mapping */\n\t\t\t\ttgt2src[t].idx = s;\n\t\t\t\ttgt2src[t].similarity = similarity;\n\t\t\t\tsrc2tgt[s].idx = t;\n\t\t\t\tsrc2tgt[s].similarity = similarity;\n\t\t\t}\n\n\t\t\t/* keep best absolute match for copies */\n\t\t\tif (tgt2src_copy != NULL &&\n\t\t\t\ttgt2src_copy[t].similarity < similarity)\n\t\t\t{\n\t\t\t\ttgt2src_copy[t].idx = s;\n\t\t\t\ttgt2src_copy[t].similarity = similarity;\n\t\t\t}\n\n\t\t\tif (++tried_srcs >= num_srcs)\n\t\t\t\tbreak;\n\n\t\t\t/* cap on maximum targets we'll examine (per \"tgt\" file) */\n\t\t\tif (tried_srcs > opts.rename_limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tried_tgts >= num_tgts)\n\t\t\tbreak;\n\t}\n\n\tif (num_bumped > 0) /* try again if we bumped some items */\n\t\tgoto find_best_matches;\n\n\t/*\n\t * Rewrite the diffs with renames / copies\n\t */\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\t/* check if this delta was the target of a similarity */\n\t\tif (tgt2src[t].similarity)\n\t\t\tbest_match = &tgt2src[t];\n\t\telse if (tgt2src_copy && tgt2src_copy[t].similarity)\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\telse\n\t\t\tcontinue;\n\n\t\ts = best_match->idx;\n\t\tsrc = GIT_VECTOR_GET(&diff->deltas, s);\n\n\t\t/* possible scenarios:\n\t\t * 1. from DELETE to ADD/UNTRACK/IGNORE = RENAME\n\t\t * 2. from DELETE to SPLIT/TYPECHANGE = RENAME + DELETE\n\t\t * 3. from SPLIT/TYPECHANGE to ADD/UNTRACK/IGNORE = ADD + RENAME\n\t\t * 4. from SPLIT/TYPECHANGE to SPLIT/TYPECHANGE = RENAME + SPLIT\n\t\t * 5. from OTHER to ADD/UNTRACK/IGNORE = OTHER + COPY\n\t\t */\n\n\t\tif (src->status == GIT_DELTA_DELETED) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\t\t\tnum_rewrites++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(tgt));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tassert(src->status == GIT_DELTA_DELETED);\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\t\t\t\tmemset(&src->new_file, 0, sizeof(src->new_file));\n\t\t\t\tsrc->new_file.path = src->old_file.path;\n\t\t\t\tsrc->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tnum_updates++;\n\n\t\t\t\tif (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (delta_is_split(src)) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->status = (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ?\n\t\t\t\t\tGIT_DELTA_UNTRACKED : GIT_DELTA_ADDED;\n\t\t\t\tsrc->nfiles = 1;\n\t\t\t\tmemset(&src->old_file, 0, sizeof(src->old_file));\n\t\t\t\tsrc->old_file.path = src->new_file.path;\n\t\t\t\tsrc->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tnum_updates++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(src));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\t\t\t\tnum_updates++;\n\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\n\t\t\t\t/* if we've just swapped the new element into the correct\n\t\t\t\t * place, clear the SPLIT flag\n\t\t\t\t */\n\t\t\t\tif (tgt2src[s].idx == t &&\n\t\t\t\t\ttgt2src[s].similarity >\n\t\t\t\t\topts.rename_from_rewrite_threshold) {\n\t\t\t\t\tsrc->status     = GIT_DELTA_RENAMED;\n\t\t\t\t\tsrc->similarity = tgt2src[s].similarity;\n\t\t\t\t\ttgt2src[s].similarity = 0;\n\t\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\t\tnum_rewrites--;\n\t\t\t\t}\n\t\t\t\t/* otherwise, if we just overwrote a source, update mapping */\n\t\t\t\telse if (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\n\t\t\t\tnum_updates++;\n\t\t\t}\n\t\t}\n\n\t\telse if (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\t\tif (tgt2src_copy[t].similarity < opts.copy_threshold)\n\t\t\t\tcontinue;\n\n\t\t\t/* always use best possible source for copy */\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\t\tsrc = GIT_VECTOR_GET(&diff->deltas, best_match->idx);\n\n\t\t\tif (delta_is_split(tgt)) {\n\t\t\t\terror = insert_delete_side_of_split(diff, &diff->deltas, tgt);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tnum_rewrites--;\n\t\t\t}\n\n\t\t\tif (!delta_is_split(tgt) && !delta_is_new_only(tgt))\n\t\t\t\tcontinue;\n\n\t\t\ttgt->status     = GIT_DELTA_COPIED;\n\t\t\ttgt->similarity = best_match->similarity;\n\t\t\ttgt->nfiles     = 2;\n\t\t\tmemcpy(&tgt->old_file, &src->old_file, sizeof(tgt->old_file));\n\t\t\ttgt->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\n\t\t\tnum_updates++;\n\t\t}\n\t}\n\n\t/*\n\t * Actually split and delete entries as needed\n\t */\n\n\tif (num_rewrites > 0 || num_updates > 0)\n\t\terror = apply_splits_and_deletes(\n\t\t\tdiff, diff->deltas.length - num_rewrites,\n\t\t\tFLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY));\n\ncleanup:\n\tgit__free(tgt2src);\n\tgit__free(src2tgt);\n\tgit__free(tgt2src_copy);\n\n\tif (sigcache) {\n\t\tfor (t = 0; t < num_deltas * 2; ++t) {\n\t\t\tif (sigcache[t] != NULL)\n\t\t\t\topts.metric->free_signature(sigcache[t], opts.metric->payload);\n\t\t}\n\t\tgit__free(sigcache);\n\t}\n\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_tree",
          "args": [
            "&difflist",
            "blame->repository",
            "ptree",
            "otree",
            "&diffopts"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1315-1340",
          "snippet": "int git_diff_tree_to_tree(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_tree *new_tree,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\t/* for tree to tree diff, be case sensitive even if the index is\n\t * currently case insensitive, unless the user explicitly asked\n\t * for case insensitivity\n\t */\n\tif (opts && (opts->flags & GIT_DIFF_IGNORE_CASE) != 0)\n\t\tiflag = GIT_ITERATOR_IGNORE_CASE;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_tree(&b, new_tree, &b_opts), iflag\n\t);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_tree(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_tree *new_tree,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\t/* for tree to tree diff, be case sensitive even if the index is\n\t * currently case insensitive, unless the user explicitly asked\n\t * for case insensitivity\n\t */\n\tif (opts && (opts->flags & GIT_DIFF_IGNORE_CASE) != 0)\n\t\tiflag = GIT_ITERATOR_IGNORE_CASE;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_tree(&b, new_tree, &b_opts), iflag\n\t);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blame__get_origin",
          "args": [
            "&porigin",
            "blame",
            "parent",
            "origin->path"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "git_blame__get_origin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "64-78",
          "snippet": "int git_blame__get_origin(\n\t\tgit_blame__origin **out,\n\t\tgit_blame *blame,\n\t\tgit_commit *commit,\n\t\tconst char *path)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->suspect->commit == commit && !strcmp(e->suspect->path, path)) {\n\t\t\t*out = origin_incref(e->suspect);\n\t\t}\n\t}\n\treturn make_origin(out, commit, path);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nint git_blame__get_origin(\n\t\tgit_blame__origin **out,\n\t\tgit_blame *blame,\n\t\tgit_commit *commit,\n\t\tconst char *path)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->suspect->commit == commit && !strcmp(e->suspect->path, path)) {\n\t\t\t*out = origin_incref(e->suspect);\n\t\t}\n\t}\n\treturn make_origin(out, commit, path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&ptree",
            "parent"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin* find_origin(\n\t\tgit_blame *blame,\n\t\tgit_commit *parent,\n\t\tgit_blame__origin *origin)\n{\n\tgit_blame__origin *porigin = NULL;\n\tgit_diff *difflist = NULL;\n\tgit_diff_options diffopts = GIT_DIFF_OPTIONS_INIT;\n\tgit_tree *otree=NULL, *ptree=NULL;\n\n\t/* Get the trees from this commit and its parent */\n\tif (0 != git_commit_tree(&otree, origin->commit) ||\n\t    0 != git_commit_tree(&ptree, parent))\n\t\tgoto cleanup;\n\n\t/* Configure the diff */\n\tdiffopts.context_lines = 0;\n\tdiffopts.flags = GIT_DIFF_SKIP_BINARY_CHECK;\n\n\t/* Check to see if files we're interested have changed */\n\tdiffopts.pathspec.count = blame->paths.length;\n\tdiffopts.pathspec.strings = (char**)blame->paths.contents;\n\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\tif (!git_diff_num_deltas(difflist)) {\n\t\t/* No changes; copy data */\n\t\tgit_blame__get_origin(&porigin, blame, parent, origin->path);\n\t} else {\n\t\tgit_diff_find_options findopts = GIT_DIFF_FIND_OPTIONS_INIT;\n\t\tint i;\n\n\t\t/* Generate a full diff between the two trees */\n\t\tgit_diff_free(difflist);\n\t\tdiffopts.pathspec.count = 0;\n\t\tif (0 != git_diff_tree_to_tree(&difflist, blame->repository, ptree, otree, &diffopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Let diff find renames */\n\t\tfindopts.flags = GIT_DIFF_FIND_RENAMES;\n\t\tif (0 != git_diff_find_similar(difflist, &findopts))\n\t\t\tgoto cleanup;\n\n\t\t/* Find one that matches */\n\t\tfor (i=0; i<(int)git_diff_num_deltas(difflist); i++) {\n\t\t\tconst git_diff_delta *delta = git_diff_get_delta(difflist, i);\n\n\t\t\tif (!git_vector_bsearch(NULL, &blame->paths, delta->new_file.path))\n\t\t\t{\n\t\t\t\tgit_vector_insert_sorted(&blame->paths, (void*)git__strdup(delta->old_file.path),\n\t\t\t\t\t\tpaths_on_dup);\n\t\t\t\tmake_origin(&porigin, parent, delta->old_file.path);\n\t\t\t}\n\t\t}\n\t}\n\ncleanup:\n\tgit_diff_free(difflist);\n\tgit_tree_free(otree);\n\tgit_tree_free(ptree);\n\treturn porigin;\n}"
  },
  {
    "function_name": "paths_on_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "407-412",
    "snippet": "static int paths_on_dup(void **old, void *new)\n{\n\tGIT_UNUSED(old);\n\tgit__free(new);\n\treturn -1;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "new"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "old"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int paths_on_dup(void **old, void *new)\n{\n\tGIT_UNUSED(old);\n\tgit__free(new);\n\treturn -1;\n}"
  },
  {
    "function_name": "pass_blame_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "383-405",
    "snippet": "static int pass_blame_to_parent(\n\t\tgit_blame *blame,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tsize_t last_in_target;\n\tmmfile_t file_p, file_o;\n\tblame_chunk_cb_data d = { blame, target, parent, 0, 0 };\n\n\tif (!find_last_in_target(&last_in_target, blame, target))\n\t\treturn 1; /* nothing remains for this target */\n\n\tfill_origin_blob(parent, &file_p);\n\tfill_origin_blob(target, &file_o);\n\n\tif (diff_hunks(file_p, file_o, &d) < 0)\n\t\treturn -1;\n\n\t/* The reset (i.e. anything after tlno) are the same as the parent */\n\tblame_chunk(blame, d.tlno, d.plno, last_in_target, target, parent);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blame_chunk",
          "args": [
            "blame",
            "d.tlno",
            "d.plno",
            "last_in_target",
            "target",
            "parent"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "blame_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "295-314",
          "snippet": "static void blame_chunk(\n\t\tgit_blame *blame,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (same <= e->s_lno)\n\t\t\tcontinue;\n\t\tif (tlno < e->s_lno + e->num_lines) {\n\t\t\tblame_overlap(blame, e, tlno, plno, same, parent);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void blame_chunk(\n\t\tgit_blame *blame,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (same <= e->s_lno)\n\t\t\tcontinue;\n\t\tif (tlno < e->s_lno + e->num_lines) {\n\t\t\tblame_overlap(blame, e, tlno, plno, same, parent);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_hunks",
          "args": [
            "file_p",
            "file_o",
            "&d"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "diff_hunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "354-372",
          "snippet": "static int diff_hunks(mmfile_t file_a, mmfile_t file_b, void *cb_data)\n{\n\txpparam_t xpp = {0};\n\txdemitconf_t xecfg = {0};\n\txdemitcb_t ecb = {0};\n\n\txecfg.hunk_func = my_emit;\n\tecb.priv = cb_data;\n\n\ttrim_common_tail(&file_a, &file_b, 0);\n\n\tif (file_a.size > GIT_XDIFF_MAX_SIZE ||\n\t\tfile_b.size > GIT_XDIFF_MAX_SIZE) {\n\t\tgiterr_set(GITERR_INVALID, \"file too large to blame\");\n\t\treturn -1;\n\t}\n\n\treturn xdl_diff(&file_a, &file_b, &xpp, &xecfg, &ecb);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int diff_hunks(mmfile_t file_a, mmfile_t file_b, void *cb_data)\n{\n\txpparam_t xpp = {0};\n\txdemitconf_t xecfg = {0};\n\txdemitcb_t ecb = {0};\n\n\txecfg.hunk_func = my_emit;\n\tecb.priv = cb_data;\n\n\ttrim_common_tail(&file_a, &file_b, 0);\n\n\tif (file_a.size > GIT_XDIFF_MAX_SIZE ||\n\t\tfile_b.size > GIT_XDIFF_MAX_SIZE) {\n\t\tgiterr_set(GITERR_INVALID, \"file too large to blame\");\n\t\treturn -1;\n\t}\n\n\treturn xdl_diff(&file_a, &file_b, &xpp, &xecfg, &ecb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_origin_blob",
          "args": [
            "target",
            "&file_o"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "fill_origin_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "374-381",
          "snippet": "static void fill_origin_blob(git_blame__origin *o, mmfile_t *file)\n{\n\tmemset(file, 0, sizeof(*file));\n\tif (o->blob) {\n\t\tfile->ptr = (char*)git_blob_rawcontent(o->blob);\n\t\tfile->size = (size_t)git_blob_rawsize(o->blob);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void fill_origin_blob(git_blame__origin *o, mmfile_t *file)\n{\n\tmemset(file, 0, sizeof(*file));\n\tif (o->blob) {\n\t\tfile->ptr = (char*)git_blob_rawcontent(o->blob);\n\t\tfile->size = (size_t)git_blob_rawsize(o->blob);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_last_in_target",
          "args": [
            "&last_in_target",
            "blame",
            "target"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "find_last_in_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "98-117",
          "snippet": "static bool find_last_in_target(size_t *out, git_blame *blame, git_blame__origin *target)\n{\n\tgit_blame__entry *e;\n\tsize_t last_in_target = 0;\n\tbool found = false;\n\n\t*out = 0;\n\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (last_in_target < e->s_lno + e->num_lines) {\n\t\t\tfound = true;\n\t\t\tlast_in_target = e->s_lno + e->num_lines;\n\t\t}\n\t}\n\n\t*out = last_in_target;\n\treturn found;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool find_last_in_target(size_t *out, git_blame *blame, git_blame__origin *target)\n{\n\tgit_blame__entry *e;\n\tsize_t last_in_target = 0;\n\tbool found = false;\n\n\t*out = 0;\n\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (last_in_target < e->s_lno + e->num_lines) {\n\t\t\tfound = true;\n\t\t\tlast_in_target = e->s_lno + e->num_lines;\n\t\t}\n\t}\n\n\t*out = last_in_target;\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int pass_blame_to_parent(\n\t\tgit_blame *blame,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tsize_t last_in_target;\n\tmmfile_t file_p, file_o;\n\tblame_chunk_cb_data d = { blame, target, parent, 0, 0 };\n\n\tif (!find_last_in_target(&last_in_target, blame, target))\n\t\treturn 1; /* nothing remains for this target */\n\n\tfill_origin_blob(parent, &file_p);\n\tfill_origin_blob(target, &file_o);\n\n\tif (diff_hunks(file_p, file_o, &d) < 0)\n\t\treturn -1;\n\n\t/* The reset (i.e. anything after tlno) are the same as the parent */\n\tblame_chunk(blame, d.tlno, d.plno, last_in_target, target, parent);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_origin_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "374-381",
    "snippet": "static void fill_origin_blob(git_blame__origin *o, mmfile_t *file)\n{\n\tmemset(file, 0, sizeof(*file));\n\tif (o->blob) {\n\t\tfile->ptr = (char*)git_blob_rawcontent(o->blob);\n\t\tfile->size = (size_t)git_blob_rawsize(o->blob);\n\t}\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_blob_rawsize",
          "args": [
            "o->blob"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "25-29",
          "snippet": "git_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\ngit_off_t git_blob_rawsize(const git_blob *blob)\n{\n\tassert(blob);\n\treturn (git_off_t)git_odb_object_size(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_rawcontent",
          "args": [
            "o->blob"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_rawcontent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blob.c",
          "lines": "19-23",
          "snippet": "const void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}",
          "includes": [
            "#include \"buf_text.h\"",
            "#include \"filter.h\"",
            "#include \"blob.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n#include \"filter.h\"\n#include \"blob.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n#include \"git2/odb_backend.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst void *git_blob_rawcontent(const git_blob *blob)\n{\n\tassert(blob);\n\treturn git_odb_object_data(blob->odb_object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "file",
            "0",
            "sizeof(*file)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void fill_origin_blob(git_blame__origin *o, mmfile_t *file)\n{\n\tmemset(file, 0, sizeof(*file));\n\tif (o->blob) {\n\t\tfile->ptr = (char*)git_blob_rawcontent(o->blob);\n\t\tfile->size = (size_t)git_blob_rawsize(o->blob);\n\t}\n}"
  },
  {
    "function_name": "diff_hunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "354-372",
    "snippet": "static int diff_hunks(mmfile_t file_a, mmfile_t file_b, void *cb_data)\n{\n\txpparam_t xpp = {0};\n\txdemitconf_t xecfg = {0};\n\txdemitcb_t ecb = {0};\n\n\txecfg.hunk_func = my_emit;\n\tecb.priv = cb_data;\n\n\ttrim_common_tail(&file_a, &file_b, 0);\n\n\tif (file_a.size > GIT_XDIFF_MAX_SIZE ||\n\t\tfile_b.size > GIT_XDIFF_MAX_SIZE) {\n\t\tgiterr_set(GITERR_INVALID, \"file too large to blame\");\n\t\treturn -1;\n\t}\n\n\treturn xdl_diff(&file_a, &file_b, &xpp, &xecfg, &ecb);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdl_diff",
          "args": [
            "&file_a",
            "&file_b",
            "&xpp",
            "&xecfg",
            "&ecb"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "xdl_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/xdiff/xdiffi.c",
          "lines": "586-618",
          "snippet": "int xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\temit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xpp->flags & XDF_IGNORE_BLANK_LINES)\n\t\t\txdl_mark_ignorable(xscr, &xe, xpp->flags);\n\n\t\tif (ef(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"integer.h\"",
            "#include \"common.h\"",
            "#include \"xinclude.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integer.h\"\n#include \"common.h\"\n#include \"xinclude.h\"\n\nint xdl_diff(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,\n\t     xdemitconf_t const *xecfg, xdemitcb_t *ecb) {\n\txdchange_t *xscr;\n\txdfenv_t xe;\n\temit_func_t ef = xecfg->hunk_func ? xdl_call_hunk_func : xdl_emit_diff;\n\n\tif (xdl_do_diff(mf1, mf2, xpp, &xe) < 0) {\n\n\t\treturn -1;\n\t}\n\tif (xdl_change_compact(&xe.xdf1, &xe.xdf2, xpp->flags) < 0 ||\n\t    xdl_change_compact(&xe.xdf2, &xe.xdf1, xpp->flags) < 0 ||\n\t    xdl_build_script(&xe, &xscr) < 0) {\n\n\t\txdl_free_env(&xe);\n\t\treturn -1;\n\t}\n\tif (xscr) {\n\t\tif (xpp->flags & XDF_IGNORE_BLANK_LINES)\n\t\t\txdl_mark_ignorable(xscr, &xe, xpp->flags);\n\n\t\tif (ef(&xe, xscr, ecb, xecfg) < 0) {\n\n\t\t\txdl_free_script(xscr);\n\t\t\txdl_free_env(&xe);\n\t\t\treturn -1;\n\t\t}\n\t\txdl_free_script(xscr);\n\t}\n\txdl_free_env(&xe);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"file too large to blame\""
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trim_common_tail",
          "args": [
            "&file_a",
            "&file_b",
            "0"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "trim_common_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "330-352",
          "snippet": "static void trim_common_tail(mmfile_t *a, mmfile_t *b, long ctx)\n{\n\tconst int blk = 1024;\n\tlong trimmed = 0, recovered = 0;\n\tchar *ap = a->ptr + a->size;\n\tchar *bp = b->ptr + b->size;\n\tlong smaller = (long)((a->size < b->size) ? a->size : b->size);\n\n\tif (ctx)\n\t\treturn;\n\n\twhile (blk + trimmed <= smaller && !memcmp(ap - blk, bp - blk, blk)) {\n\t\ttrimmed += blk;\n\t\tap -= blk;\n\t\tbp -= blk;\n\t}\n\n\twhile (recovered < trimmed)\n\t\tif (ap[recovered++] == '\\n')\n\t\t\tbreak;\n\ta->size -= trimmed - recovered;\n\tb->size -= trimmed - recovered;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void trim_common_tail(mmfile_t *a, mmfile_t *b, long ctx)\n{\n\tconst int blk = 1024;\n\tlong trimmed = 0, recovered = 0;\n\tchar *ap = a->ptr + a->size;\n\tchar *bp = b->ptr + b->size;\n\tlong smaller = (long)((a->size < b->size) ? a->size : b->size);\n\n\tif (ctx)\n\t\treturn;\n\n\twhile (blk + trimmed <= smaller && !memcmp(ap - blk, bp - blk, blk)) {\n\t\ttrimmed += blk;\n\t\tap -= blk;\n\t\tbp -= blk;\n\t}\n\n\twhile (recovered < trimmed)\n\t\tif (ap[recovered++] == '\\n')\n\t\t\tbreak;\n\ta->size -= trimmed - recovered;\n\tb->size -= trimmed - recovered;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int diff_hunks(mmfile_t file_a, mmfile_t file_b, void *cb_data)\n{\n\txpparam_t xpp = {0};\n\txdemitconf_t xecfg = {0};\n\txdemitcb_t ecb = {0};\n\n\txecfg.hunk_func = my_emit;\n\tecb.priv = cb_data;\n\n\ttrim_common_tail(&file_a, &file_b, 0);\n\n\tif (file_a.size > GIT_XDIFF_MAX_SIZE ||\n\t\tfile_b.size > GIT_XDIFF_MAX_SIZE) {\n\t\tgiterr_set(GITERR_INVALID, \"file too large to blame\");\n\t\treturn -1;\n\t}\n\n\treturn xdl_diff(&file_a, &file_b, &xpp, &xecfg, &ecb);\n}"
  },
  {
    "function_name": "trim_common_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "330-352",
    "snippet": "static void trim_common_tail(mmfile_t *a, mmfile_t *b, long ctx)\n{\n\tconst int blk = 1024;\n\tlong trimmed = 0, recovered = 0;\n\tchar *ap = a->ptr + a->size;\n\tchar *bp = b->ptr + b->size;\n\tlong smaller = (long)((a->size < b->size) ? a->size : b->size);\n\n\tif (ctx)\n\t\treturn;\n\n\twhile (blk + trimmed <= smaller && !memcmp(ap - blk, bp - blk, blk)) {\n\t\ttrimmed += blk;\n\t\tap -= blk;\n\t\tbp -= blk;\n\t}\n\n\twhile (recovered < trimmed)\n\t\tif (ap[recovered++] == '\\n')\n\t\t\tbreak;\n\ta->size -= trimmed - recovered;\n\tb->size -= trimmed - recovered;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ap - blk",
            "bp - blk",
            "blk"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void trim_common_tail(mmfile_t *a, mmfile_t *b, long ctx)\n{\n\tconst int blk = 1024;\n\tlong trimmed = 0, recovered = 0;\n\tchar *ap = a->ptr + a->size;\n\tchar *bp = b->ptr + b->size;\n\tlong smaller = (long)((a->size < b->size) ? a->size : b->size);\n\n\tif (ctx)\n\t\treturn;\n\n\twhile (blk + trimmed <= smaller && !memcmp(ap - blk, bp - blk, blk)) {\n\t\ttrimmed += blk;\n\t\tap -= blk;\n\t\tbp -= blk;\n\t}\n\n\twhile (recovered < trimmed)\n\t\tif (ap[recovered++] == '\\n')\n\t\t\tbreak;\n\ta->size -= trimmed - recovered;\n\tb->size -= trimmed - recovered;\n}"
  },
  {
    "function_name": "my_emit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "316-328",
    "snippet": "static int my_emit(\n\tlong start_a, long count_a,\n\tlong start_b, long count_b,\n\tvoid *cb_data)\n{\n\tblame_chunk_cb_data *d = (blame_chunk_cb_data *)cb_data;\n\n\tblame_chunk(d->blame, d->tlno, d->plno, start_b, d->target, d->parent);\n\td->plno = start_a + count_a;\n\td->tlno = start_b + count_b;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blame_chunk",
          "args": [
            "d->blame",
            "d->tlno",
            "d->plno",
            "start_b",
            "d->target",
            "d->parent"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "blame_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "295-314",
          "snippet": "static void blame_chunk(\n\t\tgit_blame *blame,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (same <= e->s_lno)\n\t\t\tcontinue;\n\t\tif (tlno < e->s_lno + e->num_lines) {\n\t\t\tblame_overlap(blame, e, tlno, plno, same, parent);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void blame_chunk(\n\t\tgit_blame *blame,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (same <= e->s_lno)\n\t\t\tcontinue;\n\t\tif (tlno < e->s_lno + e->num_lines) {\n\t\t\tblame_overlap(blame, e, tlno, plno, same, parent);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int my_emit(\n\tlong start_a, long count_a,\n\tlong start_b, long count_b,\n\tvoid *cb_data)\n{\n\tblame_chunk_cb_data *d = (blame_chunk_cb_data *)cb_data;\n\n\tblame_chunk(d->blame, d->tlno, d->plno, start_b, d->target, d->parent);\n\td->plno = start_a + count_a;\n\td->tlno = start_b + count_b;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "blame_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "295-314",
    "snippet": "static void blame_chunk(\n\t\tgit_blame *blame,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (same <= e->s_lno)\n\t\t\tcontinue;\n\t\tif (tlno < e->s_lno + e->num_lines) {\n\t\t\tblame_overlap(blame, e, tlno, plno, same, parent);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blame_overlap",
          "args": [
            "blame",
            "e",
            "tlno",
            "plno",
            "same",
            "parent"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "blame_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "274-288",
          "snippet": "static void blame_overlap(\n\t\tgit_blame *blame,\n\t\tgit_blame__entry *e,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry split[3] = {{0}};\n\n\tsplit_overlap(split, e, tlno, plno, same, parent);\n\tif (split[1].suspect)\n\t\tsplit_blame(blame, split, e);\n\tdecref_split(split);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void blame_overlap(\n\t\tgit_blame *blame,\n\t\tgit_blame__entry *e,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry split[3] = {{0}};\n\n\tsplit_overlap(split, e, tlno, plno, same, parent);\n\tif (split[1].suspect)\n\t\tsplit_blame(blame, split, e);\n\tdecref_split(split);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_suspect",
          "args": [
            "e->suspect",
            "target"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "same_suspect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "88-95",
          "snippet": "static bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void blame_chunk(\n\t\tgit_blame *blame,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *target,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (same <= e->s_lno)\n\t\t\tcontinue;\n\t\tif (tlno < e->s_lno + e->num_lines) {\n\t\t\tblame_overlap(blame, e, tlno, plno, same, parent);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "blame_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "274-288",
    "snippet": "static void blame_overlap(\n\t\tgit_blame *blame,\n\t\tgit_blame__entry *e,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry split[3] = {{0}};\n\n\tsplit_overlap(split, e, tlno, plno, same, parent);\n\tif (split[1].suspect)\n\t\tsplit_blame(blame, split, e);\n\tdecref_split(split);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decref_split",
          "args": [
            "split"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "decref_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "263-268",
          "snippet": "static void decref_split(git_blame__entry *split)\n{\n\tint i;\n\tfor (i=0; i<3; i++)\n\t\torigin_decref(split[i].suspect);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void decref_split(git_blame__entry *split)\n{\n\tint i;\n\tfor (i=0; i<3; i++)\n\t\torigin_decref(split[i].suspect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_blame",
          "args": [
            "blame",
            "split",
            "e"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "split_blame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "221-257",
          "snippet": "static void split_blame(git_blame *blame, git_blame__entry *split, git_blame__entry *e)\n{\n\tgit_blame__entry *new_entry;\n\n\tif (split[0].suspect && split[2].suspect) {\n\t\t/* The first part (reuse storage for the existing entry e */\n\t\tdup_entry(e, &split[0]);\n\n\t\t/* The last part -- me */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\n\t\t/* ... and the middle part -- parent */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else if (!split[0].suspect && !split[2].suspect) {\n\t\t/*\n\t\t * The parent covers the entire area; reuse storage for e and replace it\n\t\t * with the parent\n\t\t */\n\t\tdup_entry(e, &split[1]);\n\t} else if (split[0].suspect) {\n\t\t/* me and then parent */\n\t\tdup_entry(e, &split[0]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else {\n\t\t/* parent and then me */\n\t\tdup_entry(e, &split[1]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void split_blame(git_blame *blame, git_blame__entry *split, git_blame__entry *e)\n{\n\tgit_blame__entry *new_entry;\n\n\tif (split[0].suspect && split[2].suspect) {\n\t\t/* The first part (reuse storage for the existing entry e */\n\t\tdup_entry(e, &split[0]);\n\n\t\t/* The last part -- me */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\n\t\t/* ... and the middle part -- parent */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else if (!split[0].suspect && !split[2].suspect) {\n\t\t/*\n\t\t * The parent covers the entire area; reuse storage for e and replace it\n\t\t * with the parent\n\t\t */\n\t\tdup_entry(e, &split[1]);\n\t} else if (split[0].suspect) {\n\t\t/* me and then parent */\n\t\tdup_entry(e, &split[0]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else {\n\t\t/* parent and then me */\n\t\tdup_entry(e, &split[1]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_overlap",
          "args": [
            "split",
            "e",
            "tlno",
            "plno",
            "same",
            "parent"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "split_overlap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "133-170",
          "snippet": "static void split_overlap(git_blame__entry *split, git_blame__entry *e,\n\t\tsize_t tlno, size_t plno, size_t same, git_blame__origin *parent)\n{\n\tsize_t chunk_end_lno;\n\n\tif (e->s_lno < tlno) {\n\t\t/* there is a pre-chunk part not blamed on the parent */\n\t\tsplit[0].suspect = origin_incref(e->suspect);\n\t\tsplit[0].lno = e->lno;\n\t\tsplit[0].s_lno = e->s_lno;\n\t\tsplit[0].num_lines = tlno - e->s_lno;\n\t\tsplit[1].lno = e->lno + tlno - e->s_lno;\n\t\tsplit[1].s_lno = plno;\n\t} else {\n\t\tsplit[1].lno = e->lno;\n\t\tsplit[1].s_lno = plno + (e->s_lno - tlno);\n\t}\n\n\tif (same < e->s_lno + e->num_lines) {\n\t\t/* there is a post-chunk part not blamed on parent */\n\t\tsplit[2].suspect = origin_incref(e->suspect);\n\t\tsplit[2].lno = e->lno + (same - e->s_lno);\n\t\tsplit[2].s_lno = e->s_lno + (same - e->s_lno);\n\t\tsplit[2].num_lines = e->s_lno + e->num_lines - same;\n\t\tchunk_end_lno = split[2].lno;\n\t} else {\n\t\tchunk_end_lno = e->lno + e->num_lines;\n\t}\n\tsplit[1].num_lines = chunk_end_lno - split[1].lno;\n\n\t/*\n\t * if it turns out there is nothing to blame the parent for, forget about\n\t * the splitting. !split[1].suspect signals this.\n\t */\n\tif (split[1].num_lines < 1)\n\t\treturn;\n\tsplit[1].suspect = origin_incref(parent);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void split_overlap(git_blame__entry *split, git_blame__entry *e,\n\t\tsize_t tlno, size_t plno, size_t same, git_blame__origin *parent)\n{\n\tsize_t chunk_end_lno;\n\n\tif (e->s_lno < tlno) {\n\t\t/* there is a pre-chunk part not blamed on the parent */\n\t\tsplit[0].suspect = origin_incref(e->suspect);\n\t\tsplit[0].lno = e->lno;\n\t\tsplit[0].s_lno = e->s_lno;\n\t\tsplit[0].num_lines = tlno - e->s_lno;\n\t\tsplit[1].lno = e->lno + tlno - e->s_lno;\n\t\tsplit[1].s_lno = plno;\n\t} else {\n\t\tsplit[1].lno = e->lno;\n\t\tsplit[1].s_lno = plno + (e->s_lno - tlno);\n\t}\n\n\tif (same < e->s_lno + e->num_lines) {\n\t\t/* there is a post-chunk part not blamed on parent */\n\t\tsplit[2].suspect = origin_incref(e->suspect);\n\t\tsplit[2].lno = e->lno + (same - e->s_lno);\n\t\tsplit[2].s_lno = e->s_lno + (same - e->s_lno);\n\t\tsplit[2].num_lines = e->s_lno + e->num_lines - same;\n\t\tchunk_end_lno = split[2].lno;\n\t} else {\n\t\tchunk_end_lno = e->lno + e->num_lines;\n\t}\n\tsplit[1].num_lines = chunk_end_lno - split[1].lno;\n\n\t/*\n\t * if it turns out there is nothing to blame the parent for, forget about\n\t * the splitting. !split[1].suspect signals this.\n\t */\n\tif (split[1].num_lines < 1)\n\t\treturn;\n\tsplit[1].suspect = origin_incref(parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void blame_overlap(\n\t\tgit_blame *blame,\n\t\tgit_blame__entry *e,\n\t\tsize_t tlno,\n\t\tsize_t plno,\n\t\tsize_t same,\n\t\tgit_blame__origin *parent)\n{\n\tgit_blame__entry split[3] = {{0}};\n\n\tsplit_overlap(split, e, tlno, plno, same, parent);\n\tif (split[1].suspect)\n\t\tsplit_blame(blame, split, e);\n\tdecref_split(split);\n}"
  },
  {
    "function_name": "decref_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "263-268",
    "snippet": "static void decref_split(git_blame__entry *split)\n{\n\tint i;\n\tfor (i=0; i<3; i++)\n\t\torigin_decref(split[i].suspect);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "split[i].suspect"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void decref_split(git_blame__entry *split)\n{\n\tint i;\n\tfor (i=0; i<3; i++)\n\t\torigin_decref(split[i].suspect);\n}"
  },
  {
    "function_name": "split_blame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "221-257",
    "snippet": "static void split_blame(git_blame *blame, git_blame__entry *split, git_blame__entry *e)\n{\n\tgit_blame__entry *new_entry;\n\n\tif (split[0].suspect && split[2].suspect) {\n\t\t/* The first part (reuse storage for the existing entry e */\n\t\tdup_entry(e, &split[0]);\n\n\t\t/* The last part -- me */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\n\t\t/* ... and the middle part -- parent */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else if (!split[0].suspect && !split[2].suspect) {\n\t\t/*\n\t\t * The parent covers the entire area; reuse storage for e and replace it\n\t\t * with the parent\n\t\t */\n\t\tdup_entry(e, &split[1]);\n\t} else if (split[0].suspect) {\n\t\t/* me and then parent */\n\t\tdup_entry(e, &split[0]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else {\n\t\t/* parent and then me */\n\t\tdup_entry(e, &split[1]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t}\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_blame_entry",
          "args": [
            "blame",
            "new_entry"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "add_blame_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "176-196",
          "snippet": "static void add_blame_entry(git_blame *blame, git_blame__entry *e)\n{\n\tgit_blame__entry *ent, *prev = NULL;\n\n\torigin_incref(e->suspect);\n\n\tfor (ent = blame->ent; ent && ent->lno < e->lno; ent = ent->next)\n\t\tprev = ent;\n\n\t/* prev, if not NULL, is the last one that is below e */\n\te->prev = prev;\n\tif (prev) {\n\t\te->next = prev->next;\n\t\tprev->next = e;\n\t} else {\n\t\te->next = blame->ent;\n\t\tblame->ent = e;\n\t}\n\tif (e->next)\n\t\te->next->prev = e;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void add_blame_entry(git_blame *blame, git_blame__entry *e)\n{\n\tgit_blame__entry *ent, *prev = NULL;\n\n\torigin_incref(e->suspect);\n\n\tfor (ent = blame->ent; ent && ent->lno < e->lno; ent = ent->next)\n\t\tprev = ent;\n\n\t/* prev, if not NULL, is the last one that is below e */\n\te->prev = prev;\n\tif (prev) {\n\t\te->next = prev->next;\n\t\tprev->next = e;\n\t} else {\n\t\te->next = blame->ent;\n\t\tblame->ent = e;\n\t}\n\tif (e->next)\n\t\te->next->prev = e;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_entry",
            "&(split[2])",
            "sizeof(git_blame__entry)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(*new_entry)"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup_entry",
          "args": [
            "e",
            "&split[1]"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dup_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "203-215",
          "snippet": "static void dup_entry(git_blame__entry *dst, git_blame__entry *src)\n{\n\tgit_blame__entry *p, *n;\n\n\tp = dst->prev;\n\tn = dst->next;\n\torigin_incref(src->suspect);\n\torigin_decref(dst->suspect);\n\tmemcpy(dst, src, sizeof(*src));\n\tdst->prev = p;\n\tdst->next = n;\n\tdst->score = 0;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void dup_entry(git_blame__entry *dst, git_blame__entry *src)\n{\n\tgit_blame__entry *p, *n;\n\n\tp = dst->prev;\n\tn = dst->next;\n\torigin_incref(src->suspect);\n\torigin_decref(dst->suspect);\n\tmemcpy(dst, src, sizeof(*src));\n\tdst->prev = p;\n\tdst->next = n;\n\tdst->score = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_entry",
            "&(split[1])",
            "sizeof(git_blame__entry)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_entry",
            "&(split[1])",
            "sizeof(git_blame__entry)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_entry",
            "&(split[2])",
            "sizeof(git_blame__entry)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void split_blame(git_blame *blame, git_blame__entry *split, git_blame__entry *e)\n{\n\tgit_blame__entry *new_entry;\n\n\tif (split[0].suspect && split[2].suspect) {\n\t\t/* The first part (reuse storage for the existing entry e */\n\t\tdup_entry(e, &split[0]);\n\n\t\t/* The last part -- me */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\n\t\t/* ... and the middle part -- parent */\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else if (!split[0].suspect && !split[2].suspect) {\n\t\t/*\n\t\t * The parent covers the entire area; reuse storage for e and replace it\n\t\t * with the parent\n\t\t */\n\t\tdup_entry(e, &split[1]);\n\t} else if (split[0].suspect) {\n\t\t/* me and then parent */\n\t\tdup_entry(e, &split[0]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[1]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t} else {\n\t\t/* parent and then me */\n\t\tdup_entry(e, &split[1]);\n\t\tnew_entry = git__malloc(sizeof(*new_entry));\n\t\tmemcpy(new_entry, &(split[2]), sizeof(git_blame__entry));\n\t\tadd_blame_entry(blame, new_entry);\n\t}\n}"
  },
  {
    "function_name": "dup_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "203-215",
    "snippet": "static void dup_entry(git_blame__entry *dst, git_blame__entry *src)\n{\n\tgit_blame__entry *p, *n;\n\n\tp = dst->prev;\n\tn = dst->next;\n\torigin_incref(src->suspect);\n\torigin_decref(dst->suspect);\n\tmemcpy(dst, src, sizeof(*src));\n\tdst->prev = p;\n\tdst->next = n;\n\tdst->score = 0;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "sizeof(*src)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "dst->suspect"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "src->suspect"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void dup_entry(git_blame__entry *dst, git_blame__entry *src)\n{\n\tgit_blame__entry *p, *n;\n\n\tp = dst->prev;\n\tn = dst->next;\n\torigin_incref(src->suspect);\n\torigin_decref(dst->suspect);\n\tmemcpy(dst, src, sizeof(*src));\n\tdst->prev = p;\n\tdst->next = n;\n\tdst->score = 0;\n}"
  },
  {
    "function_name": "add_blame_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "176-196",
    "snippet": "static void add_blame_entry(git_blame *blame, git_blame__entry *e)\n{\n\tgit_blame__entry *ent, *prev = NULL;\n\n\torigin_incref(e->suspect);\n\n\tfor (ent = blame->ent; ent && ent->lno < e->lno; ent = ent->next)\n\t\tprev = ent;\n\n\t/* prev, if not NULL, is the last one that is below e */\n\te->prev = prev;\n\tif (prev) {\n\t\te->next = prev->next;\n\t\tprev->next = e;\n\t} else {\n\t\te->next = blame->ent;\n\t\tblame->ent = e;\n\t}\n\tif (e->next)\n\t\te->next->prev = e;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "e->suspect"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void add_blame_entry(git_blame *blame, git_blame__entry *e)\n{\n\tgit_blame__entry *ent, *prev = NULL;\n\n\torigin_incref(e->suspect);\n\n\tfor (ent = blame->ent; ent && ent->lno < e->lno; ent = ent->next)\n\t\tprev = ent;\n\n\t/* prev, if not NULL, is the last one that is below e */\n\te->prev = prev;\n\tif (prev) {\n\t\te->next = prev->next;\n\t\tprev->next = e;\n\t} else {\n\t\te->next = blame->ent;\n\t\tblame->ent = e;\n\t}\n\tif (e->next)\n\t\te->next->prev = e;\n}"
  },
  {
    "function_name": "split_overlap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "133-170",
    "snippet": "static void split_overlap(git_blame__entry *split, git_blame__entry *e,\n\t\tsize_t tlno, size_t plno, size_t same, git_blame__origin *parent)\n{\n\tsize_t chunk_end_lno;\n\n\tif (e->s_lno < tlno) {\n\t\t/* there is a pre-chunk part not blamed on the parent */\n\t\tsplit[0].suspect = origin_incref(e->suspect);\n\t\tsplit[0].lno = e->lno;\n\t\tsplit[0].s_lno = e->s_lno;\n\t\tsplit[0].num_lines = tlno - e->s_lno;\n\t\tsplit[1].lno = e->lno + tlno - e->s_lno;\n\t\tsplit[1].s_lno = plno;\n\t} else {\n\t\tsplit[1].lno = e->lno;\n\t\tsplit[1].s_lno = plno + (e->s_lno - tlno);\n\t}\n\n\tif (same < e->s_lno + e->num_lines) {\n\t\t/* there is a post-chunk part not blamed on parent */\n\t\tsplit[2].suspect = origin_incref(e->suspect);\n\t\tsplit[2].lno = e->lno + (same - e->s_lno);\n\t\tsplit[2].s_lno = e->s_lno + (same - e->s_lno);\n\t\tsplit[2].num_lines = e->s_lno + e->num_lines - same;\n\t\tchunk_end_lno = split[2].lno;\n\t} else {\n\t\tchunk_end_lno = e->lno + e->num_lines;\n\t}\n\tsplit[1].num_lines = chunk_end_lno - split[1].lno;\n\n\t/*\n\t * if it turns out there is nothing to blame the parent for, forget about\n\t * the splitting. !split[1].suspect signals this.\n\t */\n\tif (split[1].num_lines < 1)\n\t\treturn;\n\tsplit[1].suspect = origin_incref(parent);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "parent"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void split_overlap(git_blame__entry *split, git_blame__entry *e,\n\t\tsize_t tlno, size_t plno, size_t same, git_blame__origin *parent)\n{\n\tsize_t chunk_end_lno;\n\n\tif (e->s_lno < tlno) {\n\t\t/* there is a pre-chunk part not blamed on the parent */\n\t\tsplit[0].suspect = origin_incref(e->suspect);\n\t\tsplit[0].lno = e->lno;\n\t\tsplit[0].s_lno = e->s_lno;\n\t\tsplit[0].num_lines = tlno - e->s_lno;\n\t\tsplit[1].lno = e->lno + tlno - e->s_lno;\n\t\tsplit[1].s_lno = plno;\n\t} else {\n\t\tsplit[1].lno = e->lno;\n\t\tsplit[1].s_lno = plno + (e->s_lno - tlno);\n\t}\n\n\tif (same < e->s_lno + e->num_lines) {\n\t\t/* there is a post-chunk part not blamed on parent */\n\t\tsplit[2].suspect = origin_incref(e->suspect);\n\t\tsplit[2].lno = e->lno + (same - e->s_lno);\n\t\tsplit[2].s_lno = e->s_lno + (same - e->s_lno);\n\t\tsplit[2].num_lines = e->s_lno + e->num_lines - same;\n\t\tchunk_end_lno = split[2].lno;\n\t} else {\n\t\tchunk_end_lno = e->lno + e->num_lines;\n\t}\n\tsplit[1].num_lines = chunk_end_lno - split[1].lno;\n\n\t/*\n\t * if it turns out there is nothing to blame the parent for, forget about\n\t * the splitting. !split[1].suspect signals this.\n\t */\n\tif (split[1].num_lines < 1)\n\t\treturn;\n\tsplit[1].suspect = origin_incref(parent);\n}"
  },
  {
    "function_name": "find_last_in_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "98-117",
    "snippet": "static bool find_last_in_target(size_t *out, git_blame *blame, git_blame__origin *target)\n{\n\tgit_blame__entry *e;\n\tsize_t last_in_target = 0;\n\tbool found = false;\n\n\t*out = 0;\n\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (last_in_target < e->s_lno + e->num_lines) {\n\t\t\tfound = true;\n\t\t\tlast_in_target = e->s_lno + e->num_lines;\n\t\t}\n\t}\n\n\t*out = last_in_target;\n\treturn found;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_suspect",
          "args": [
            "e->suspect",
            "target"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "same_suspect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "88-95",
          "snippet": "static bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool find_last_in_target(size_t *out, git_blame *blame, git_blame__origin *target)\n{\n\tgit_blame__entry *e;\n\tsize_t last_in_target = 0;\n\tbool found = false;\n\n\t*out = 0;\n\n\tfor (e=blame->ent; e; e=e->next) {\n\t\tif (e->guilty || !same_suspect(e->suspect, target))\n\t\t\tcontinue;\n\t\tif (last_in_target < e->s_lno + e->num_lines) {\n\t\t\tfound = true;\n\t\t\tlast_in_target = e->s_lno + e->num_lines;\n\t\t}\n\t}\n\n\t*out = last_in_target;\n\treturn found;\n}"
  },
  {
    "function_name": "same_suspect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "88-95",
    "snippet": "static bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->path",
            "b->path"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "git_commit_id(a->commit)",
            "git_commit_id(b->commit)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "b->commit"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic bool same_suspect(git_blame__origin *a, git_blame__origin *b)\n{\n\tif (a == b)\n\t\treturn true;\n\tif (git_oid_cmp(git_commit_id(a->commit), git_commit_id(b->commit)))\n\t\treturn false;\n\treturn 0 == strcmp(a->path, b->path);\n}"
  },
  {
    "function_name": "git_blame__get_origin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "64-78",
    "snippet": "int git_blame__get_origin(\n\t\tgit_blame__origin **out,\n\t\tgit_blame *blame,\n\t\tgit_commit *commit,\n\t\tconst char *path)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->suspect->commit == commit && !strcmp(e->suspect->path, path)) {\n\t\t\t*out = origin_incref(e->suspect);\n\t\t}\n\t}\n\treturn make_origin(out, commit, path);\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_origin",
          "args": [
            "out",
            "commit",
            "path"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "make_origin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "37-61",
          "snippet": "static int make_origin(git_blame__origin **out, git_commit *commit, const char *path)\n{\n\tgit_blame__origin *o;\n\tgit_object *blob;\n\tsize_t path_len = strlen(path), alloc_len;\n\tint error = 0;\n\n\tif ((error = git_object_lookup_bypath(&blob, (git_object*)commit,\n\t\t\tpath, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*o), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\to = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(o);\n\n\to->commit = commit;\n\to->blob = (git_blob *) blob;\n\to->refcnt = 1;\n\tstrcpy(o->path, path);\n\n\t*out = o;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int make_origin(git_blame__origin **out, git_commit *commit, const char *path)\n{\n\tgit_blame__origin *o;\n\tgit_object *blob;\n\tsize_t path_len = strlen(path), alloc_len;\n\tint error = 0;\n\n\tif ((error = git_object_lookup_bypath(&blob, (git_object*)commit,\n\t\t\tpath, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*o), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\to = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(o);\n\n\to->commit = commit;\n\to->blob = (git_blob *) blob;\n\to->refcnt = 1;\n\tstrcpy(o->path, path);\n\n\t*out = o;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_incref",
          "args": [
            "e->suspect"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "origin_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "18-23",
          "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
          "includes": [
            "#include \"diff_xdiff.h\"",
            "#include \"xdiff/xinclude.h\"",
            "#include \"blob.h\"",
            "#include \"commit.h\"",
            "#include \"blame_git.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "e->suspect->path",
            "path"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nint git_blame__get_origin(\n\t\tgit_blame__origin **out,\n\t\tgit_blame *blame,\n\t\tgit_commit *commit,\n\t\tconst char *path)\n{\n\tgit_blame__entry *e;\n\n\tfor (e = blame->ent; e; e = e->next) {\n\t\tif (e->suspect->commit == commit && !strcmp(e->suspect->path, path)) {\n\t\t\t*out = origin_incref(e->suspect);\n\t\t}\n\t}\n\treturn make_origin(out, commit, path);\n}"
  },
  {
    "function_name": "make_origin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "37-61",
    "snippet": "static int make_origin(git_blame__origin **out, git_commit *commit, const char *path)\n{\n\tgit_blame__origin *o;\n\tgit_object *blob;\n\tsize_t path_len = strlen(path), alloc_len;\n\tint error = 0;\n\n\tif ((error = git_object_lookup_bypath(&blob, (git_object*)commit,\n\t\t\tpath, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*o), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\to = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(o);\n\n\to->commit = commit;\n\to->blob = (git_blob *) blob;\n\to->refcnt = 1;\n\tstrcpy(o->path, path);\n\n\t*out = o;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "o->path",
            "path"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "o"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloc_len"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "alloc_len",
            "1"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloc_len",
            "sizeof(*o)",
            "path_len"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_object_lookup_bypath",
          "args": [
            "&blob",
            "(git_object*)commit",
            "path",
            "GIT_OBJ_BLOB"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic int make_origin(git_blame__origin **out, git_commit *commit, const char *path)\n{\n\tgit_blame__origin *o;\n\tgit_object *blob;\n\tsize_t path_len = strlen(path), alloc_len;\n\tint error = 0;\n\n\tif ((error = git_object_lookup_bypath(&blob, (git_object*)commit,\n\t\t\tpath, GIT_OBJ_BLOB)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(*o), path_len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\to = git__calloc(1, alloc_len);\n\tGITERR_CHECK_ALLOC(o);\n\n\to->commit = commit;\n\to->blob = (git_blob *) blob;\n\to->refcnt = 1;\n\tstrcpy(o->path, path);\n\n\t*out = o;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "origin_decref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "25-34",
    "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "o"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "o->commit"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_blob_free",
          "args": [
            "o->blob"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "git_blob_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "116-119",
          "snippet": "void git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_blob_free(git_blob *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "origin_decref",
          "args": [
            "o->previous"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "origin_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
          "lines": "25-34",
          "snippet": "static void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic void origin_decref(git_blame__origin *o)\n{\n\tif (o && --o->refcnt <= 0) {\n\t\tif (o->previous)\n\t\t\torigin_decref(o->previous);\n\t\tgit_blob_free(o->blob);\n\t\tgit_commit_free(o->commit);\n\t\tgit__free(o);\n\t}\n}"
  },
  {
    "function_name": "origin_incref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/blame_git.c",
    "lines": "18-23",
    "snippet": "static git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}",
    "includes": [
      "#include \"diff_xdiff.h\"",
      "#include \"xdiff/xinclude.h\"",
      "#include \"blob.h\"",
      "#include \"commit.h\"",
      "#include \"blame_git.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"diff_xdiff.h\"\n#include \"xdiff/xinclude.h\"\n#include \"blob.h\"\n#include \"commit.h\"\n#include \"blame_git.h\"\n\nstatic git_blame__origin *origin_incref(git_blame__origin *o)\n{\n\tif (o)\n\t\to->refcnt++;\n\treturn o;\n}"
  }
]