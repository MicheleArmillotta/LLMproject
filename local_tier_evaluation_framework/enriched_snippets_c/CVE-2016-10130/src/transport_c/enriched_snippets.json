[
  {
    "function_name": "git_transport_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
    "lines": "217-222",
    "snippet": "int git_transport_init(git_transport *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_transport, GIT_TRANSPORT_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"path.h\"",
      "#include \"git2/sys/transport.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/types.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_transport",
            "GIT_TRANSPORT_INIT"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nint git_transport_init(git_transport *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_transport, GIT_TRANSPORT_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_transport_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
    "lines": "182-215",
    "snippet": "int git_transport_unregister(const char *scheme)\n{\n\tgit_buf prefix = GIT_BUF_INIT;\n\ttransport_definition *d;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(scheme);\n\n\tif ((error = git_buf_printf(&prefix, \"%s://\", scheme)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strcasecmp(d->prefix, prefix.ptr) == 0) {\n\t\t\tif ((error = git_vector_remove(&custom_transports, i)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgit__free(d->prefix);\n\t\t\tgit__free(d);\n\n\t\t\tif (!custom_transports.length)\n\t\t\t\tgit_vector_free(&custom_transports);\n\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ndone:\n\tgit_buf_free(&prefix);\n\treturn error;\n}",
    "includes": [
      "#include \"path.h\"",
      "#include \"git2/sys/transport.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/types.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_vector custom_transports = GIT_VECTOR_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&prefix"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&custom_transports"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "d"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_remove",
          "args": [
            "&custom_transports",
            "i"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "233-250",
          "snippet": "int git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_remove(git_vector *v, size_t idx)\n{\n\tsize_t shift_count;\n\n\tassert(v);\n\n\tif (idx >= v->length)\n\t\treturn GIT_ENOTFOUND;\n\n\tshift_count = v->length - idx - 1;\n\n\tif (shift_count)\n\t\tmemmove(&v->contents[idx], &v->contents[idx + 1],\n\t\t\tshift_count * sizeof(void *));\n\n\tv->length--;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "d->prefix",
            "prefix.ptr"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&custom_transports",
            "i",
            "d"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&prefix",
            "\"%s://\"",
            "scheme"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "scheme"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic git_vector custom_transports = GIT_VECTOR_INIT;\n\nint git_transport_unregister(const char *scheme)\n{\n\tgit_buf prefix = GIT_BUF_INIT;\n\ttransport_definition *d;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(scheme);\n\n\tif ((error = git_buf_printf(&prefix, \"%s://\", scheme)) < 0)\n\t\tgoto done;\n\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strcasecmp(d->prefix, prefix.ptr) == 0) {\n\t\t\tif ((error = git_vector_remove(&custom_transports, i)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tgit__free(d->prefix);\n\t\t\tgit__free(d);\n\n\t\t\tif (!custom_transports.length)\n\t\t\t\tgit_vector_free(&custom_transports);\n\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ndone:\n\tgit_buf_free(&prefix);\n\treturn error;\n}"
  },
  {
    "function_name": "git_transport_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
    "lines": "141-180",
    "snippet": "int git_transport_register(\n\tconst char *scheme,\n\tgit_transport_cb cb,\n\tvoid *param)\n{\n\tgit_buf prefix = GIT_BUF_INIT;\n\ttransport_definition *d, *definition = NULL;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(scheme);\n\tassert(cb);\n\n\tif ((error = git_buf_printf(&prefix, \"%s://\", scheme)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strcasecmp(d->prefix, prefix.ptr) == 0) {\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tdefinition = git__calloc(1, sizeof(transport_definition));\n\tGITERR_CHECK_ALLOC(definition);\n\n\tdefinition->prefix = git_buf_detach(&prefix);\n\tdefinition->fn = cb;\n\tdefinition->param = param;\n\n\tif (git_vector_insert(&custom_transports, definition) < 0)\n\t\tgoto on_error;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&prefix);\n\tgit__free(definition);\n\treturn error;\n}",
    "includes": [
      "#include \"path.h\"",
      "#include \"git2/sys/transport.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/types.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_vector custom_transports = GIT_VECTOR_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "definition"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&prefix"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&custom_transports",
            "definition"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&prefix"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "definition"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(transport_definition)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "d->prefix",
            "prefix.ptr"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&custom_transports",
            "i",
            "d"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&prefix",
            "\"%s://\"",
            "scheme"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "cb"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "scheme"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic git_vector custom_transports = GIT_VECTOR_INIT;\n\nint git_transport_register(\n\tconst char *scheme,\n\tgit_transport_cb cb,\n\tvoid *param)\n{\n\tgit_buf prefix = GIT_BUF_INIT;\n\ttransport_definition *d, *definition = NULL;\n\tsize_t i;\n\tint error = 0;\n\n\tassert(scheme);\n\tassert(cb);\n\n\tif ((error = git_buf_printf(&prefix, \"%s://\", scheme)) < 0)\n\t\tgoto on_error;\n\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strcasecmp(d->prefix, prefix.ptr) == 0) {\n\t\t\terror = GIT_EEXISTS;\n\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\tdefinition = git__calloc(1, sizeof(transport_definition));\n\tGITERR_CHECK_ALLOC(definition);\n\n\tdefinition->prefix = git_buf_detach(&prefix);\n\tdefinition->fn = cb;\n\tdefinition->param = param;\n\n\tif (git_vector_insert(&custom_transports, definition) < 0)\n\t\tgoto on_error;\n\n\treturn 0;\n\non_error:\n\tgit_buf_free(&prefix);\n\tgit__free(definition);\n\treturn error;\n}"
  },
  {
    "function_name": "git_transport_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
    "lines": "118-139",
    "snippet": "int git_transport_new(git_transport **out, git_remote *owner, const char *url)\n{\n\tgit_transport_cb fn;\n\tgit_transport *transport;\n\tvoid *param;\n\tint error;\n\n\tif ((error = transport_find_fn(&fn, url, &param)) == GIT_ENOTFOUND) {\n\t\tgiterr_set(GITERR_NET, \"Unsupported URL protocol\");\n\t\treturn -1;\n\t} else if (error < 0)\n\t\treturn error;\n\n\tif ((error = fn(&transport, owner, param)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(transport, GIT_TRANSPORT_VERSION, \"git_transport\");\n\n\t*out = transport;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"path.h\"",
      "#include \"git2/sys/transport.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/types.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "transport",
            "GIT_TRANSPORT_VERSION",
            "\"git_transport\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "&transport",
            "owner",
            "param"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "transport_find_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
          "lines": "72-112",
          "snippet": "static int transport_find_fn(\n\tgit_transport_cb *out,\n\tconst char *url,\n\tvoid **param)\n{\n\ttransport_definition *definition = transport_find_by_url(url);\n\n#ifdef GIT_WIN32\n\t/* On Windows, it might not be possible to discern between absolute local\n\t * and ssh paths - first check if this is a valid local path that points\n\t * to a directory and if so assume local path, else assume SSH */\n\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\t/* For other systems, perform the SSH check first, to avoid going to the\n\t * filesystem if it is not necessary */\n\n\t/* It could be a SSH remote path. Check to see if there's a :\n\t * SSH is an unsupported transport mechanism in this version of libgit2 */\n\tif (!definition && strrchr(url, ':')) {\n\t\t// re-search transports again with ssh:// as url so that we can find a third party ssh transport\n\t\tdefinition = transport_find_by_url(\"ssh://\");\n\t}\n\n#ifndef GIT_WIN32\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\tif (!definition)\n\t\treturn GIT_ENOTFOUND;\n\n\t*out = definition->fn;\n\t*param = definition->param;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"path.h\"",
            "#include \"git2/sys/transport.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static transport_definition local_transport_definition = { \"file://\", git_transport_local, NULL };",
            "static transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic transport_definition local_transport_definition = { \"file://\", git_transport_local, NULL };\nstatic transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};\n\nstatic int transport_find_fn(\n\tgit_transport_cb *out,\n\tconst char *url,\n\tvoid **param)\n{\n\ttransport_definition *definition = transport_find_by_url(url);\n\n#ifdef GIT_WIN32\n\t/* On Windows, it might not be possible to discern between absolute local\n\t * and ssh paths - first check if this is a valid local path that points\n\t * to a directory and if so assume local path, else assume SSH */\n\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\t/* For other systems, perform the SSH check first, to avoid going to the\n\t * filesystem if it is not necessary */\n\n\t/* It could be a SSH remote path. Check to see if there's a :\n\t * SSH is an unsupported transport mechanism in this version of libgit2 */\n\tif (!definition && strrchr(url, ':')) {\n\t\t// re-search transports again with ssh:// as url so that we can find a third party ssh transport\n\t\tdefinition = transport_find_by_url(\"ssh://\");\n\t}\n\n#ifndef GIT_WIN32\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\tif (!definition)\n\t\treturn GIT_ENOTFOUND;\n\n\t*out = definition->fn;\n\t*param = definition->param;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_NET",
            "\"Unsupported URL protocol\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nint git_transport_new(git_transport **out, git_remote *owner, const char *url)\n{\n\tgit_transport_cb fn;\n\tgit_transport *transport;\n\tvoid *param;\n\tint error;\n\n\tif ((error = transport_find_fn(&fn, url, &param)) == GIT_ENOTFOUND) {\n\t\tgiterr_set(GITERR_NET, \"Unsupported URL protocol\");\n\t\treturn -1;\n\t} else if (error < 0)\n\t\treturn error;\n\n\tif ((error = fn(&transport, owner, param)) < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(transport, GIT_TRANSPORT_VERSION, \"git_transport\");\n\n\t*out = transport;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "transport_find_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
    "lines": "72-112",
    "snippet": "static int transport_find_fn(\n\tgit_transport_cb *out,\n\tconst char *url,\n\tvoid **param)\n{\n\ttransport_definition *definition = transport_find_by_url(url);\n\n#ifdef GIT_WIN32\n\t/* On Windows, it might not be possible to discern between absolute local\n\t * and ssh paths - first check if this is a valid local path that points\n\t * to a directory and if so assume local path, else assume SSH */\n\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\t/* For other systems, perform the SSH check first, to avoid going to the\n\t * filesystem if it is not necessary */\n\n\t/* It could be a SSH remote path. Check to see if there's a :\n\t * SSH is an unsupported transport mechanism in this version of libgit2 */\n\tif (!definition && strrchr(url, ':')) {\n\t\t// re-search transports again with ssh:// as url so that we can find a third party ssh transport\n\t\tdefinition = transport_find_by_url(\"ssh://\");\n\t}\n\n#ifndef GIT_WIN32\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\tif (!definition)\n\t\treturn GIT_ENOTFOUND;\n\n\t*out = definition->fn;\n\t*param = definition->param;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"path.h\"",
      "#include \"git2/sys/transport.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/types.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static transport_definition local_transport_definition = { \"file://\", git_transport_local, NULL };",
      "static transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "url"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "url"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transport_find_by_url",
          "args": [
            "\"ssh://\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "transport_find_by_url",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
          "lines": "48-70",
          "snippet": "static transport_definition * transport_find_by_url(const char *url)\n{\n\tsize_t i = 0;\n\ttransport_definition *d;\n\n\t/* Find a user transport who wants to deal with this URI */\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t/* Find a system transport for this URI */\n\tfor (i = 0; i < GIT_TRANSPORT_COUNT; ++i) {\n\t\td = &transports[i];\n\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"path.h\"",
            "#include \"git2/sys/transport.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2/net.h\"",
            "#include \"git2/remote.h\"",
            "#include \"git2/types.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define GIT_TRANSPORT_COUNT (sizeof(transports)/sizeof(transports[0])) - 1"
          ],
          "globals_used": [
            "static transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};",
            "static git_vector custom_transports = GIT_VECTOR_INIT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\n#define GIT_TRANSPORT_COUNT (sizeof(transports)/sizeof(transports[0])) - 1\n\nstatic transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};\nstatic git_vector custom_transports = GIT_VECTOR_INIT;\n\nstatic transport_definition * transport_find_by_url(const char *url)\n{\n\tsize_t i = 0;\n\ttransport_definition *d;\n\n\t/* Find a user transport who wants to deal with this URI */\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t/* Find a system transport for this URI */\n\tfor (i = 0; i < GIT_TRANSPORT_COUNT; ++i) {\n\t\td = &transports[i];\n\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "url",
            "':'"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\nstatic transport_definition local_transport_definition = { \"file://\", git_transport_local, NULL };\nstatic transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};\n\nstatic int transport_find_fn(\n\tgit_transport_cb *out,\n\tconst char *url,\n\tvoid **param)\n{\n\ttransport_definition *definition = transport_find_by_url(url);\n\n#ifdef GIT_WIN32\n\t/* On Windows, it might not be possible to discern between absolute local\n\t * and ssh paths - first check if this is a valid local path that points\n\t * to a directory and if so assume local path, else assume SSH */\n\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\t/* For other systems, perform the SSH check first, to avoid going to the\n\t * filesystem if it is not necessary */\n\n\t/* It could be a SSH remote path. Check to see if there's a :\n\t * SSH is an unsupported transport mechanism in this version of libgit2 */\n\tif (!definition && strrchr(url, ':')) {\n\t\t// re-search transports again with ssh:// as url so that we can find a third party ssh transport\n\t\tdefinition = transport_find_by_url(\"ssh://\");\n\t}\n\n#ifndef GIT_WIN32\n\t/* Check to see if the path points to a file on the local file system */\n\tif (!definition && git_path_exists(url) && git_path_isdir(url))\n\t\tdefinition = &local_transport_definition;\n#endif\n\n\tif (!definition)\n\t\treturn GIT_ENOTFOUND;\n\n\t*out = definition->fn;\n\t*param = definition->param;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "transport_find_by_url",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transport.c",
    "lines": "48-70",
    "snippet": "static transport_definition * transport_find_by_url(const char *url)\n{\n\tsize_t i = 0;\n\ttransport_definition *d;\n\n\t/* Find a user transport who wants to deal with this URI */\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t/* Find a system transport for this URI */\n\tfor (i = 0; i < GIT_TRANSPORT_COUNT; ++i) {\n\t\td = &transports[i];\n\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"path.h\"",
      "#include \"git2/sys/transport.h\"",
      "#include \"git2/transport.h\"",
      "#include \"git2/net.h\"",
      "#include \"git2/remote.h\"",
      "#include \"git2/types.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define GIT_TRANSPORT_COUNT (sizeof(transports)/sizeof(transports[0])) - 1"
    ],
    "globals_used": [
      "static transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};",
      "static git_vector custom_transports = GIT_VECTOR_INIT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "url",
            "d->prefix",
            "strlen(d->prefix)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncasecmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "214-225",
          "snippet": "int git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncasecmp(const char *a, const char *b, size_t sz)\n{\n\tint al, bl;\n\n\tdo {\n\t\tal = (unsigned char)git__tolower(*a);\n\t\tbl = (unsigned char)git__tolower(*b);\n\t\t++a, ++b;\n\t} while (--sz && al && al == bl);\n\n\treturn al - bl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "d->prefix"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "d->prefix"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&custom_transports",
            "i",
            "d"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"path.h\"\n#include \"git2/sys/transport.h\"\n#include \"git2/transport.h\"\n#include \"git2/net.h\"\n#include \"git2/remote.h\"\n#include \"git2/types.h\"\n#include \"common.h\"\n\n#define GIT_TRANSPORT_COUNT (sizeof(transports)/sizeof(transports[0])) - 1\n\nstatic transport_definition transports[] = {\n\t{ \"git://\",   git_transport_smart, &git_subtransport_definition },\n\t{ \"http://\",  git_transport_smart, &http_subtransport_definition },\n#if defined(GIT_OPENSSL) || defined(GIT_WINHTTP) || defined(GIT_SECURE_TRANSPORT)\n\t{ \"https://\", git_transport_smart, &http_subtransport_definition },\n#endif\n\t{ \"file://\",  git_transport_local, NULL },\n#ifdef GIT_SSH\n\t{ \"ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"ssh+git://\",   git_transport_smart, &ssh_subtransport_definition },\n\t{ \"git+ssh://\",   git_transport_smart, &ssh_subtransport_definition },\n#endif\n\t{ NULL, 0, 0 }\n};\nstatic git_vector custom_transports = GIT_VECTOR_INIT;\n\nstatic transport_definition * transport_find_by_url(const char *url)\n{\n\tsize_t i = 0;\n\ttransport_definition *d;\n\n\t/* Find a user transport who wants to deal with this URI */\n\tgit_vector_foreach(&custom_transports, i, d) {\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\t/* Find a system transport for this URI */\n\tfor (i = 0; i < GIT_TRANSPORT_COUNT; ++i) {\n\t\td = &transports[i];\n\n\t\tif (strncasecmp(url, d->prefix, strlen(d->prefix)) == 0) {\n\t\t\treturn d;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  }
]