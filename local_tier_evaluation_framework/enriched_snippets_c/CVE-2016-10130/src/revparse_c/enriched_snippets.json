[
  {
    "function_name": "git_revparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "878-913",
    "snippet": "int git_revparse(\n\tgit_revspec *revspec,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tconst char *dotdot;\n\tint error = 0;\n\n\tassert(revspec && repo && spec);\n\n\tmemset(revspec, 0x0, sizeof(*revspec));\n\n\tif ((dotdot = strstr(spec, \"..\")) != NULL) {\n\t\tchar *lstr;\n\t\tconst char *rstr;\n\t\trevspec->flags = GIT_REVPARSE_RANGE;\n\n\t\tlstr = git__substrdup(spec, dotdot - spec);\n\t\trstr = dotdot + 2;\n\t\tif (dotdot[2] == '.') {\n\t\t\trevspec->flags |= GIT_REVPARSE_MERGE_BASE;\n\t\t\trstr++;\n\t\t}\n\n\t\terror = git_revparse_single(&revspec->from, repo, lstr);\n\t\tif (!error)\n\t\t\terror = git_revparse_single(&revspec->to, repo, rstr);\n\n\t\tgit__free((void*)lstr);\n\t} else {\n\t\trevspec->flags = GIT_REVPARSE_SINGLE;\n\t\terror = git_revparse_single(&revspec->from, repo, spec);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revparse_single",
          "args": [
            "&revspec->from",
            "repo",
            "spec"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "git_revparse_single",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "855-876",
          "snippet": "int git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "(void*)lstr"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__substrdup",
          "args": [
            "spec",
            "dotdot - spec"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "git__substrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "201-213",
          "snippet": "GIT_INLINE(char *) git__substrdup(const char *start, size_t n)\n{\n\tchar *ptr;\n\tsize_t alloclen;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, n, 1) ||\n\t\t!(ptr = git__malloc(alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(ptr, start, n);\n\tptr[n] = '\\0';\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__substrdup(const char *start, size_t n)\n{\n\tchar *ptr;\n\tsize_t alloclen;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, n, 1) ||\n\t\t!(ptr = git__malloc(alloclen)))\n\t\treturn NULL;\n\n\tmemcpy(ptr, start, n);\n\tptr[n] = '\\0';\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "spec",
            "\"..\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "revspec",
            "0x0",
            "sizeof(*revspec)"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "revspec && repo && spec"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint git_revparse(\n\tgit_revspec *revspec,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tconst char *dotdot;\n\tint error = 0;\n\n\tassert(revspec && repo && spec);\n\n\tmemset(revspec, 0x0, sizeof(*revspec));\n\n\tif ((dotdot = strstr(spec, \"..\")) != NULL) {\n\t\tchar *lstr;\n\t\tconst char *rstr;\n\t\trevspec->flags = GIT_REVPARSE_RANGE;\n\n\t\tlstr = git__substrdup(spec, dotdot - spec);\n\t\trstr = dotdot + 2;\n\t\tif (dotdot[2] == '.') {\n\t\t\trevspec->flags |= GIT_REVPARSE_MERGE_BASE;\n\t\t\trstr++;\n\t\t}\n\n\t\terror = git_revparse_single(&revspec->from, repo, lstr);\n\t\tif (!error)\n\t\t\terror = git_revparse_single(&revspec->to, repo, rstr);\n\n\t\tgit__free((void*)lstr);\n\t} else {\n\t\trevspec->flags = GIT_REVPARSE_SINGLE;\n\t\terror = git_revparse_single(&revspec->from, repo, spec);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_revparse_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "855-876",
    "snippet": "int git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "obj"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revparse_ext",
          "args": [
            "&obj",
            "&ref",
            "repo",
            "spec"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "git_revparse_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "829-853",
          "snippet": "int git_revparse_ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tsize_t identifier_len;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\tif ((error = revparse__ext(&obj, &ref, &identifier_len, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\t*object_out = obj;\n\t*reference_out = ref;\n\tGIT_UNUSED(identifier_len);\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint git_revparse_ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tsize_t identifier_len;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\tif ((error = revparse__ext(&obj, &ref, &identifier_len, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\t*object_out = obj;\n\t*reference_out = ref;\n\tGIT_UNUSED(identifier_len);\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint git_revparse_single(git_object **out, git_repository *repo, const char *spec)\n{\n\tint error;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\t*out = NULL;\n\n\tif ((error = git_revparse_ext(&obj, &ref, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\tgit_reference_free(ref);\n\n\t*out = obj;\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}"
  },
  {
    "function_name": "git_revparse_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "829-853",
    "snippet": "int git_revparse_ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tsize_t identifier_len;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\tif ((error = revparse__ext(&obj, &ref, &identifier_len, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\t*object_out = obj;\n\t*reference_out = ref;\n\tGIT_UNUSED(identifier_len);\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "obj"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "identifier_len"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revparse__ext",
          "args": [
            "&obj",
            "&ref",
            "&identifier_len",
            "repo",
            "spec"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "revparse__ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "661-827",
          "snippet": "int revparse__ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tassert(object_out && reference_out && repo && spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_buf_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_buf_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgiterr_set(GITERR_INVALID, \"Unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t{\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Fall through */\n\t\t\t}\n\t\t}\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\"Failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint revparse__ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tassert(object_out && reference_out && repo && spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_buf_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_buf_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgiterr_set(GITERR_INVALID, \"Unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t{\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Fall through */\n\t\t\t}\n\t\t}\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\"Failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint git_revparse_ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tsize_t identifier_len;\n\tgit_object *obj = NULL;\n\tgit_reference *ref = NULL;\n\n\tif ((error = revparse__ext(&obj, &ref, &identifier_len, repo, spec)) < 0)\n\t\tgoto cleanup;\n\n\t*object_out = obj;\n\t*reference_out = ref;\n\tGIT_UNUSED(identifier_len);\n\n\treturn 0;\n\ncleanup:\n\tgit_object_free(obj);\n\tgit_reference_free(ref);\n\treturn error;\n}"
  },
  {
    "function_name": "revparse__ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "661-827",
    "snippet": "int revparse__ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tassert(object_out && reference_out && repo && spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_buf_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_buf_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgiterr_set(GITERR_INVALID, \"Unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t{\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Fall through */\n\t\t\t}\n\t\t}\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\"Failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "reference"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "base_rev"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Failed to parse revision specifier - Invalid pattern '%s'\"",
            "spec"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_base_rev_loaded",
          "args": [
            "&base_rev",
            "&reference",
            "spec",
            "identifier_len",
            "repo",
            "false"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_base_rev_loaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "608-629",
          "snippet": "static int ensure_base_rev_loaded(git_object **object, git_reference **reference, const char *spec, size_t identifier_len, git_repository *repo, bool allow_empty_identifier)\n{\n\tint error;\n\tgit_buf identifier = GIT_BUF_INIT;\n\n\tif (*object != NULL)\n\t\treturn 0;\n\n\tif (*reference != NULL)\n\t\treturn object_from_reference(object, *reference);\n\n\tif (!allow_empty_identifier && identifier_len == 0)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\terror = revparse_lookup_object(object, reference, repo, git_buf_cstr(&identifier));\n\tgit_buf_free(&identifier);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_base_rev_loaded(git_object **object, git_reference **reference, const char *spec, size_t identifier_len, git_repository *repo, bool allow_empty_identifier)\n{\n\tint error;\n\tgit_buf identifier = GIT_BUF_INIT;\n\n\tif (*object != NULL)\n\t\treturn 0;\n\n\tif (*reference != NULL)\n\t\treturn object_from_reference(object, *reference);\n\n\tif (!allow_empty_identifier && identifier_len == 0)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\terror = revparse_lookup_object(object, reference, repo, git_buf_cstr(&identifier));\n\tgit_buf_free(&identifier);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_left_hand_identifier_is_not_known_yet",
          "args": [
            "base_rev",
            "reference"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_left_hand_identifier_is_not_known_yet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "653-659",
          "snippet": "static int ensure_left_hand_identifier_is_not_known_yet(git_object *object, git_reference *reference)\n{\n\tif (!ensure_base_rev_is_not_known_yet(object) && reference == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_left_hand_identifier_is_not_known_yet(git_object *object, git_reference *reference)\n{\n\tif (!ensure_base_rev_is_not_known_yet(object) && reference == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_at_syntax",
          "args": [
            "&temp_object",
            "&reference",
            "spec",
            "identifier_len",
            "repo",
            "git_buf_cstr(&buf)"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "handle_at_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "312-354",
          "snippet": "static int handle_at_syntax(git_object **out, git_reference **ref, const char *spec, size_t identifier_len, git_repository* repo, const char *curly_braces_content)\n{\n\tbool is_numeric;\n\tint parsed = 0, error = -1;\n\tgit_buf identifier = GIT_BUF_INIT;\n\tgit_time_t timestamp;\n\n\tassert(*out == NULL);\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\tis_numeric = !try_parse_numeric(&parsed, curly_braces_content);\n\n\tif (*curly_braces_content == '-' && (!is_numeric || parsed == 0)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_numeric) {\n\t\tif (parsed < 0)\n\t\t\terror = retrieve_previously_checked_out_branch_or_revision(out, ref, repo, git_buf_cstr(&identifier), -parsed);\n\t\telse\n\t\t\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), parsed);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (!strcmp(curly_braces_content, \"u\") || !strcmp(curly_braces_content, \"upstream\")) {\n\t\terror = retrieve_remote_tracking_reference(ref, git_buf_cstr(&identifier), repo);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (git__date_parse(&timestamp, curly_braces_content) < 0)\n\t\tgoto cleanup;\n\n\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), (size_t)timestamp);\n\ncleanup:\n\tgit_buf_free(&identifier);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_at_syntax(git_object **out, git_reference **ref, const char *spec, size_t identifier_len, git_repository* repo, const char *curly_braces_content)\n{\n\tbool is_numeric;\n\tint parsed = 0, error = -1;\n\tgit_buf identifier = GIT_BUF_INIT;\n\tgit_time_t timestamp;\n\n\tassert(*out == NULL);\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\tis_numeric = !try_parse_numeric(&parsed, curly_braces_content);\n\n\tif (*curly_braces_content == '-' && (!is_numeric || parsed == 0)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_numeric) {\n\t\tif (parsed < 0)\n\t\t\terror = retrieve_previously_checked_out_branch_or_revision(out, ref, repo, git_buf_cstr(&identifier), -parsed);\n\t\telse\n\t\t\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), parsed);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (!strcmp(curly_braces_content, \"u\") || !strcmp(curly_braces_content, \"upstream\")) {\n\t\terror = retrieve_remote_tracking_reference(ref, git_buf_cstr(&identifier), repo);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (git__date_parse(&timestamp, curly_braces_content) < 0)\n\t\tgoto cleanup;\n\n\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), (size_t)timestamp);\n\ncleanup:\n\tgit_buf_free(&identifier);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ensure_base_rev_is_not_known_yet",
          "args": [
            "base_rev"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_base_rev_is_not_known_yet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "631-637",
          "snippet": "static int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_curly_braces_content",
          "args": [
            "&buf",
            "spec",
            "&pos"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "extract_curly_braces_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "522-545",
          "snippet": "static int extract_curly_braces_content(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '@');\n\n\t(*pos)++;\n\n\tif (spec[*pos] == '\\0' || spec[*pos] != '{')\n\t\treturn GIT_EINVALIDSPEC;\n\n\t(*pos)++;\n\n\twhile (spec[*pos] != '}') {\n\t\tif (spec[*pos] == '\\0')\n\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\tgit_buf_putc(buf, spec[(*pos)++]);\n\t}\n\n\t(*pos)++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int extract_curly_braces_content(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '@');\n\n\t(*pos)++;\n\n\tif (spec[*pos] == '\\0' || spec[*pos] != '{')\n\t\treturn GIT_EINVALIDSPEC;\n\n\t(*pos)++;\n\n\twhile (spec[*pos] != '}') {\n\t\tif (spec[*pos] == '\\0')\n\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\tgit_buf_putc(buf, spec[(*pos)++]);\n\t}\n\n\t(*pos)++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Unimplemented\""
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_grep_syntax",
          "args": [
            "&temp_object",
            "repo",
            "NULL",
            "git_buf_cstr(&buf) + 1"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "handle_grep_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "475-502",
          "snippet": "static int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tregex_t preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tregfree(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tregex_t preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tregfree(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_colon_syntax",
          "args": [
            "&temp_object",
            "base_rev",
            "git_buf_cstr(&buf)"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "handle_colon_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "416-447",
          "snippet": "static int handle_colon_syntax(\n\tgit_object **out,\n\tgit_object *obj,\n\tconst char *path)\n{\n\tgit_object *tree;\n\tint error = -1;\n\tgit_tree_entry *entry = NULL;\n\n\tif ((error = git_object_peel(&tree, obj, GIT_OBJ_TREE)) < 0)\n\t\treturn error == GIT_ENOTFOUND ? GIT_EINVALIDSPEC : error;\n\n\tif (*path == '\\0') {\n\t\t*out = tree;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: Handle the relative path syntax\n\t * (:./relative/path and :../relative/path)\n\t */\n\tif ((error = git_tree_entry_bypath(&entry, (git_tree *)tree, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_tree_entry_to_object(out, git_object_owner(tree), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_object_free(tree);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_colon_syntax(\n\tgit_object **out,\n\tgit_object *obj,\n\tconst char *path)\n{\n\tgit_object *tree;\n\tint error = -1;\n\tgit_tree_entry *entry = NULL;\n\n\tif ((error = git_object_peel(&tree, obj, GIT_OBJ_TREE)) < 0)\n\t\treturn error == GIT_ENOTFOUND ? GIT_EINVALIDSPEC : error;\n\n\tif (*path == '\\0') {\n\t\t*out = tree;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: Handle the relative path syntax\n\t * (:./relative/path and :../relative/path)\n\t */\n\tif ((error = git_tree_entry_bypath(&entry, (git_tree *)tree, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_tree_entry_to_object(out, git_object_owner(tree), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_object_free(tree);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "any_left_hand_identifier",
          "args": [
            "base_rev",
            "reference",
            "identifier_len"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "any_left_hand_identifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "639-651",
          "snippet": "static bool any_left_hand_identifier(git_object *object, git_reference *reference, size_t identifier_len)\n{\n\tif (object != NULL)\n\t\treturn true;\n\n\tif (reference != NULL)\n\t\treturn true;\n\n\tif (identifier_len > 0)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic bool any_left_hand_identifier(git_object *object, git_reference *reference, size_t identifier_len)\n{\n\tif (object != NULL)\n\t\treturn true;\n\n\tif (reference != NULL)\n\t\treturn true;\n\n\tif (identifier_len > 0)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_path",
          "args": [
            "&buf",
            "spec",
            "&pos"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "extract_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "547-561",
          "snippet": "static int extract_path(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == ':');\n\n\t(*pos)++;\n\n\tif (git_buf_puts(buf, spec + *pos) < 0)\n\t\treturn -1;\n\n\t*pos += git_buf_len(buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int extract_path(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == ':');\n\n\t(*pos)++;\n\n\tif (git_buf_puts(buf, spec + *pos) < 0)\n\t\treturn -1;\n\n\t*pos += git_buf_len(buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_linear_syntax",
          "args": [
            "&temp_object",
            "base_rev",
            "n"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "handle_linear_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "401-414",
          "snippet": "static int handle_linear_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\terror = git_commit_nth_gen_ancestor((git_commit **)out, (git_commit*)temp_commit, n);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_linear_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\terror = git_commit_nth_gen_ancestor((git_commit **)out, (git_commit*)temp_commit, n);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_how_many",
          "args": [
            "&n",
            "spec",
            "&pos"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "extract_how_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "563-592",
          "snippet": "static int extract_how_many(int *n, const char *spec, size_t *pos)\n{\n\tconst char *end_ptr;\n\tint parsed, accumulated;\n\tchar kind = spec[*pos];\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '~');\n\n\taccumulated = 0;\n\n\tdo {\n\t\tdo {\n\t\t\t(*pos)++;\n\t\t\taccumulated++;\n\t\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t\tif (git__isdigit(spec[*pos])) {\n\t\t\tif (git__strtol32(&parsed, spec + *pos, &end_ptr, 10) < 0)\n\t\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\t\taccumulated += (parsed - 1);\n\t\t\t*pos = end_ptr - spec;\n\t\t}\n\n\t} \twhile (spec[(*pos)] == kind && kind == '~');\n\n\t*n = accumulated;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int extract_how_many(int *n, const char *spec, size_t *pos)\n{\n\tconst char *end_ptr;\n\tint parsed, accumulated;\n\tchar kind = spec[*pos];\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '~');\n\n\taccumulated = 0;\n\n\tdo {\n\t\tdo {\n\t\t\t(*pos)++;\n\t\t\taccumulated++;\n\t\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t\tif (git__isdigit(spec[*pos])) {\n\t\t\tif (git__strtol32(&parsed, spec + *pos, &end_ptr, 10) < 0)\n\t\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\t\taccumulated += (parsed - 1);\n\t\t\t*pos = end_ptr - spec;\n\t\t}\n\n\t} \twhile (spec[(*pos)] == kind && kind == '~');\n\n\t*n = accumulated;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_caret_parent_syntax",
          "args": [
            "&temp_object",
            "base_rev",
            "n"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "handle_caret_parent_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "381-399",
          "snippet": "static int handle_caret_parent_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\tif (n == 0) {\n\t\t*out = temp_commit;\n\t\treturn 0;\n\t}\n\n\terror = git_commit_parent((git_commit **)out, (git_commit*)temp_commit, n - 1);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_caret_parent_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\tif (n == 0) {\n\t\t*out = temp_commit;\n\t\treturn 0;\n\t}\n\n\terror = git_commit_parent((git_commit **)out, (git_commit*)temp_commit, n - 1);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_caret_curly_syntax",
          "args": [
            "&temp_object",
            "base_rev",
            "git_buf_cstr(&buf)"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "handle_caret_curly_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "504-520",
          "snippet": "static int handle_caret_curly_syntax(git_object **out, git_object *obj, const char *curly_braces_content)\n{\n\tgit_otype expected_type;\n\n\tif (*curly_braces_content == '\\0')\n\t\treturn dereference_to_non_tag(out, obj);\n\n\tif (*curly_braces_content == '/')\n\t\treturn handle_grep_syntax(out, git_object_owner(obj), git_object_id(obj), curly_braces_content + 1);\n\n\texpected_type = parse_obj_type(curly_braces_content);\n\n\tif (expected_type == GIT_OBJ_BAD)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn git_object_peel(out, obj, expected_type);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_caret_curly_syntax(git_object **out, git_object *obj, const char *curly_braces_content)\n{\n\tgit_otype expected_type;\n\n\tif (*curly_braces_content == '\\0')\n\t\treturn dereference_to_non_tag(out, obj);\n\n\tif (*curly_braces_content == '/')\n\t\treturn handle_grep_syntax(out, git_object_owner(obj), git_object_id(obj), curly_braces_content + 1);\n\n\texpected_type = parse_obj_type(curly_braces_content);\n\n\tif (expected_type == GIT_OBJ_BAD)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn git_object_peel(out, obj, expected_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "object_out && reference_out && repo && spec"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nint revparse__ext(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tsize_t *identifier_len_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tsize_t pos = 0, identifier_len = 0;\n\tint error = -1, n;\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tgit_reference *reference = NULL;\n\tgit_object *base_rev = NULL;\n\n\tbool should_return_reference = true;\n\n\tassert(object_out && reference_out && repo && spec);\n\n\t*object_out = NULL;\n\t*reference_out = NULL;\n\n\twhile (spec[pos]) {\n\t\tswitch (spec[pos]) {\n\t\tcase '^':\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_curly_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t} else {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_caret_parent_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tgit_object_free(base_rev);\n\t\t\t\tbase_rev = temp_object;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase '~':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_how_many(&n, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif ((error = handle_linear_syntax(&temp_object, base_rev, n)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase ':':\n\t\t{\n\t\t\tgit_object *temp_object = NULL;\n\n\t\t\tshould_return_reference = false;\n\n\t\t\tif ((error = extract_path(&buf, spec, &pos)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (any_left_hand_identifier(base_rev, reference, identifier_len)) {\n\t\t\t\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, true)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_colon_syntax(&temp_object, base_rev, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t} else {\n\t\t\t\tif (*git_buf_cstr(&buf) == '/') {\n\t\t\t\t\tif ((error = handle_grep_syntax(&temp_object, repo, NULL, git_buf_cstr(&buf) + 1)) < 0)\n\t\t\t\t\t\tgoto cleanup;\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t * TODO: support merge-stage path lookup (\":2:Makefile\")\n\t\t\t\t\t * and plain index blob lookup (:i-am/a/blob)\n\t\t\t\t\t */\n\t\t\t\t\tgiterr_set(GITERR_INVALID, \"Unimplemented\");\n\t\t\t\t\terror = GIT_ERROR;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgit_object_free(base_rev);\n\t\t\tbase_rev = temp_object;\n\t\t\tbreak;\n\t\t}\n\n\t\tcase '@':\n\t\t{\n\t\t\tif (spec[pos+1] == '{') {\n\t\t\t\tgit_object *temp_object = NULL;\n\n\t\t\t\tif ((error = extract_curly_braces_content(&buf, spec, &pos)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = ensure_base_rev_is_not_known_yet(base_rev)) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif ((error = handle_at_syntax(&temp_object, &reference, spec, identifier_len, repo, git_buf_cstr(&buf))) < 0)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tif (temp_object != NULL)\n\t\t\t\t\tbase_rev = temp_object;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* Fall through */\n\t\t\t}\n\t\t}\n\n\t\tdefault:\n\t\t\tif ((error = ensure_left_hand_identifier_is_not_known_yet(base_rev, reference)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tpos++;\n\t\t\tidentifier_len++;\n\t\t}\n\t}\n\n\tif ((error = ensure_base_rev_loaded(&base_rev, &reference, spec, identifier_len, repo, false)) < 0)\n\t\tgoto cleanup;\n\n\tif (!should_return_reference) {\n\t\tgit_reference_free(reference);\n\t\treference = NULL;\n\t}\n\n\t*object_out = base_rev;\n\t*reference_out = reference;\n\t*identifier_len_out = identifier_len;\n\terror = 0;\n\ncleanup:\n\tif (error) {\n\t\tif (error == GIT_EINVALIDSPEC)\n\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\"Failed to parse revision specifier - Invalid pattern '%s'\", spec);\n\n\t\tgit_object_free(base_rev);\n\t\tgit_reference_free(reference);\n\t}\n\n\tgit_buf_free(&buf);\n\treturn error;\n}"
  },
  {
    "function_name": "ensure_left_hand_identifier_is_not_known_yet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "653-659",
    "snippet": "static int ensure_left_hand_identifier_is_not_known_yet(git_object *object, git_reference *reference)\n{\n\tif (!ensure_base_rev_is_not_known_yet(object) && reference == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ensure_base_rev_is_not_known_yet",
          "args": [
            "object"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_base_rev_is_not_known_yet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "631-637",
          "snippet": "static int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_left_hand_identifier_is_not_known_yet(git_object *object, git_reference *reference)\n{\n\tif (!ensure_base_rev_is_not_known_yet(object) && reference == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}"
  },
  {
    "function_name": "any_left_hand_identifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "639-651",
    "snippet": "static bool any_left_hand_identifier(git_object *object, git_reference *reference, size_t identifier_len)\n{\n\tif (object != NULL)\n\t\treturn true;\n\n\tif (reference != NULL)\n\t\treturn true;\n\n\tif (identifier_len > 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic bool any_left_hand_identifier(git_object *object, git_reference *reference, size_t identifier_len)\n{\n\tif (object != NULL)\n\t\treturn true;\n\n\tif (reference != NULL)\n\t\treturn true;\n\n\tif (identifier_len > 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "ensure_base_rev_is_not_known_yet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "631-637",
    "snippet": "static int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_base_rev_is_not_known_yet(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn 0;\n\n\treturn GIT_EINVALIDSPEC;\n}"
  },
  {
    "function_name": "ensure_base_rev_loaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "608-629",
    "snippet": "static int ensure_base_rev_loaded(git_object **object, git_reference **reference, const char *spec, size_t identifier_len, git_repository *repo, bool allow_empty_identifier)\n{\n\tint error;\n\tgit_buf identifier = GIT_BUF_INIT;\n\n\tif (*object != NULL)\n\t\treturn 0;\n\n\tif (*reference != NULL)\n\t\treturn object_from_reference(object, *reference);\n\n\tif (!allow_empty_identifier && identifier_len == 0)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\terror = revparse_lookup_object(object, reference, repo, git_buf_cstr(&identifier));\n\tgit_buf_free(&identifier);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&identifier"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revparse_lookup_object",
          "args": [
            "object",
            "reference",
            "repo",
            "git_buf_cstr(&identifier)"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "revparse_lookup_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "87-123",
          "snippet": "static int revparse_lookup_object(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = maybe_sha(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\terror = git_reference_dwim(&ref, repo, spec);\n\tif (!error) {\n\n\t\terror = git_object_lookup(\n\t\t\tobject_out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\n\t\tif (!error)\n\t\t\t*reference_out = ref;\n\n\t\treturn error;\n\t}\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tif ((strlen(spec) < GIT_OID_HEXSZ) &&\n\t\t((error = maybe_abbrev(object_out, repo, spec)) != GIT_ENOTFOUND))\n\t\t\treturn error;\n\n\tif ((error = maybe_describe(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgiterr_set(GITERR_REFERENCE, \"Revspec '%s' not found.\", spec);\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int revparse_lookup_object(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = maybe_sha(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\terror = git_reference_dwim(&ref, repo, spec);\n\tif (!error) {\n\n\t\terror = git_object_lookup(\n\t\t\tobject_out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\n\t\tif (!error)\n\t\t\t*reference_out = ref;\n\n\t\treturn error;\n\t}\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tif ((strlen(spec) < GIT_OID_HEXSZ) &&\n\t\t((error = maybe_abbrev(object_out, repo, spec)) != GIT_ENOTFOUND))\n\t\t\treturn error;\n\n\tif ((error = maybe_describe(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgiterr_set(GITERR_REFERENCE, \"Revspec '%s' not found.\", spec);\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&identifier"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&identifier",
            "spec",
            "identifier_len"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_from_reference",
          "args": [
            "object",
            "*reference"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "object_from_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "594-606",
          "snippet": "static int object_from_reference(git_object **object, git_reference *reference)\n{\n\tgit_reference *resolved = NULL;\n\tint error;\n\n\tif (git_reference_resolve(&resolved, reference) < 0)\n\t\treturn -1;\n\n\terror = git_object_lookup(object, reference->db->repo, git_reference_target(resolved), GIT_OBJ_ANY);\n\tgit_reference_free(resolved);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int object_from_reference(git_object **object, git_reference *reference)\n{\n\tgit_reference *resolved = NULL;\n\tint error;\n\n\tif (git_reference_resolve(&resolved, reference) < 0)\n\t\treturn -1;\n\n\terror = git_object_lookup(object, reference->db->repo, git_reference_target(resolved), GIT_OBJ_ANY);\n\tgit_reference_free(resolved);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int ensure_base_rev_loaded(git_object **object, git_reference **reference, const char *spec, size_t identifier_len, git_repository *repo, bool allow_empty_identifier)\n{\n\tint error;\n\tgit_buf identifier = GIT_BUF_INIT;\n\n\tif (*object != NULL)\n\t\treturn 0;\n\n\tif (*reference != NULL)\n\t\treturn object_from_reference(object, *reference);\n\n\tif (!allow_empty_identifier && identifier_len == 0)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\terror = revparse_lookup_object(object, reference, repo, git_buf_cstr(&identifier));\n\tgit_buf_free(&identifier);\n\n\treturn error;\n}"
  },
  {
    "function_name": "object_from_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "594-606",
    "snippet": "static int object_from_reference(git_object **object, git_reference *reference)\n{\n\tgit_reference *resolved = NULL;\n\tint error;\n\n\tif (git_reference_resolve(&resolved, reference) < 0)\n\t\treturn -1;\n\n\terror = git_object_lookup(object, reference->db->repo, git_reference_target(resolved), GIT_OBJ_ANY);\n\tgit_reference_free(resolved);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "resolved"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "object",
            "reference->db->repo",
            "git_reference_target(resolved)",
            "GIT_OBJ_ANY"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "resolved"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_resolve",
          "args": [
            "&resolved",
            "reference"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_resolve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "617-630",
          "snippet": "int git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_resolve(git_reference **ref_out, const git_reference *ref)\n{\n\tswitch (git_reference_type(ref)) {\n\tcase GIT_REF_OID:\n\t\treturn git_reference_lookup(ref_out, ref->db->repo, ref->name);\n\n\tcase GIT_REF_SYMBOLIC:\n\t\treturn git_reference_lookup_resolved(ref_out, ref->db->repo, ref->target.symbolic, -1);\n\n\tdefault:\n\t\tgiterr_set(GITERR_REFERENCE, \"Invalid reference\");\n\t\treturn -1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int object_from_reference(git_object **object, git_reference *reference)\n{\n\tgit_reference *resolved = NULL;\n\tint error;\n\n\tif (git_reference_resolve(&resolved, reference) < 0)\n\t\treturn -1;\n\n\terror = git_object_lookup(object, reference->db->repo, git_reference_target(resolved), GIT_OBJ_ANY);\n\tgit_reference_free(resolved);\n\n\treturn error;\n}"
  },
  {
    "function_name": "extract_how_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "563-592",
    "snippet": "static int extract_how_many(int *n, const char *spec, size_t *pos)\n{\n\tconst char *end_ptr;\n\tint parsed, accumulated;\n\tchar kind = spec[*pos];\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '~');\n\n\taccumulated = 0;\n\n\tdo {\n\t\tdo {\n\t\t\t(*pos)++;\n\t\t\taccumulated++;\n\t\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t\tif (git__isdigit(spec[*pos])) {\n\t\t\tif (git__strtol32(&parsed, spec + *pos, &end_ptr, 10) < 0)\n\t\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\t\taccumulated += (parsed - 1);\n\t\t\t*pos = end_ptr - spec;\n\t\t}\n\n\t} \twhile (spec[(*pos)] == kind && kind == '~');\n\n\t*n = accumulated;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strtol32",
          "args": [
            "&parsed",
            "spec + *pos",
            "&end_ptr",
            "10"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "git__strtol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "149-167",
          "snippet": "int git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isdigit",
          "args": [
            "spec[*pos]"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "git__isdigit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "449-452",
          "snippet": "GIT_INLINE(bool) git__isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spec[*pos] == '^' || spec[*pos] == '~'"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int extract_how_many(int *n, const char *spec, size_t *pos)\n{\n\tconst char *end_ptr;\n\tint parsed, accumulated;\n\tchar kind = spec[*pos];\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '~');\n\n\taccumulated = 0;\n\n\tdo {\n\t\tdo {\n\t\t\t(*pos)++;\n\t\t\taccumulated++;\n\t\t} while (spec[(*pos)] == kind && kind == '~');\n\n\t\tif (git__isdigit(spec[*pos])) {\n\t\t\tif (git__strtol32(&parsed, spec + *pos, &end_ptr, 10) < 0)\n\t\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\t\taccumulated += (parsed - 1);\n\t\t\t*pos = end_ptr - spec;\n\t\t}\n\n\t} \twhile (spec[(*pos)] == kind && kind == '~');\n\n\t*n = accumulated;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extract_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "547-561",
    "snippet": "static int extract_path(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == ':');\n\n\t(*pos)++;\n\n\tif (git_buf_puts(buf, spec + *pos) < 0)\n\t\treturn -1;\n\n\t*pos += git_buf_len(buf);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "buf"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "buf",
            "spec + *pos"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spec[*pos] == ':'"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int extract_path(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == ':');\n\n\t(*pos)++;\n\n\tif (git_buf_puts(buf, spec + *pos) < 0)\n\t\treturn -1;\n\n\t*pos += git_buf_len(buf);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extract_curly_braces_content",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "522-545",
    "snippet": "static int extract_curly_braces_content(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '@');\n\n\t(*pos)++;\n\n\tif (spec[*pos] == '\\0' || spec[*pos] != '{')\n\t\treturn GIT_EINVALIDSPEC;\n\n\t(*pos)++;\n\n\twhile (spec[*pos] != '}') {\n\t\tif (spec[*pos] == '\\0')\n\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\tgit_buf_putc(buf, spec[(*pos)++]);\n\t}\n\n\t(*pos)++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "buf",
            "spec[(*pos)++]"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "spec[*pos] == '^' || spec[*pos] == '@'"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int extract_curly_braces_content(git_buf *buf, const char *spec, size_t *pos)\n{\n\tgit_buf_clear(buf);\n\n\tassert(spec[*pos] == '^' || spec[*pos] == '@');\n\n\t(*pos)++;\n\n\tif (spec[*pos] == '\\0' || spec[*pos] != '{')\n\t\treturn GIT_EINVALIDSPEC;\n\n\t(*pos)++;\n\n\twhile (spec[*pos] != '}') {\n\t\tif (spec[*pos] == '\\0')\n\t\t\treturn GIT_EINVALIDSPEC;\n\n\t\tgit_buf_putc(buf, spec[(*pos)++]);\n\t}\n\n\t(*pos)++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_caret_curly_syntax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "504-520",
    "snippet": "static int handle_caret_curly_syntax(git_object **out, git_object *obj, const char *curly_braces_content)\n{\n\tgit_otype expected_type;\n\n\tif (*curly_braces_content == '\\0')\n\t\treturn dereference_to_non_tag(out, obj);\n\n\tif (*curly_braces_content == '/')\n\t\treturn handle_grep_syntax(out, git_object_owner(obj), git_object_id(obj), curly_braces_content + 1);\n\n\texpected_type = parse_obj_type(curly_braces_content);\n\n\tif (expected_type == GIT_OBJ_BAD)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn git_object_peel(out, obj, expected_type);\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "out",
            "obj",
            "expected_type"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_obj_type",
          "args": [
            "curly_braces_content"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "parse_obj_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "356-371",
          "snippet": "static git_otype parse_obj_type(const char *str)\n{\n\tif (!strcmp(str, \"commit\"))\n\t\treturn GIT_OBJ_COMMIT;\n\n\tif (!strcmp(str, \"tree\"))\n\t\treturn GIT_OBJ_TREE;\n\n\tif (!strcmp(str, \"blob\"))\n\t\treturn GIT_OBJ_BLOB;\n\n\tif (!strcmp(str, \"tag\"))\n\t\treturn GIT_OBJ_TAG;\n\n\treturn GIT_OBJ_BAD;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic git_otype parse_obj_type(const char *str)\n{\n\tif (!strcmp(str, \"commit\"))\n\t\treturn GIT_OBJ_COMMIT;\n\n\tif (!strcmp(str, \"tree\"))\n\t\treturn GIT_OBJ_TREE;\n\n\tif (!strcmp(str, \"blob\"))\n\t\treturn GIT_OBJ_BLOB;\n\n\tif (!strcmp(str, \"tag\"))\n\t\treturn GIT_OBJ_TAG;\n\n\treturn GIT_OBJ_BAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_grep_syntax",
          "args": [
            "out",
            "git_object_owner(obj)",
            "git_object_id(obj)",
            "curly_braces_content + 1"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "handle_grep_syntax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "475-502",
          "snippet": "static int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tregex_t preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tregfree(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tregex_t preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tregfree(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "obj"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "obj"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dereference_to_non_tag",
          "args": [
            "out",
            "obj"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "dereference_to_non_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "373-379",
          "snippet": "static int dereference_to_non_tag(git_object **out, git_object *obj)\n{\n\tif (git_object_type(obj) == GIT_OBJ_TAG)\n\t\treturn git_tag_peel(out, (git_tag *)obj);\n\n\treturn git_object_dup(out, obj);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int dereference_to_non_tag(git_object **out, git_object *obj)\n{\n\tif (git_object_type(obj) == GIT_OBJ_TAG)\n\t\treturn git_tag_peel(out, (git_tag *)obj);\n\n\treturn git_object_dup(out, obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_caret_curly_syntax(git_object **out, git_object *obj, const char *curly_braces_content)\n{\n\tgit_otype expected_type;\n\n\tif (*curly_braces_content == '\\0')\n\t\treturn dereference_to_non_tag(out, obj);\n\n\tif (*curly_braces_content == '/')\n\t\treturn handle_grep_syntax(out, git_object_owner(obj), git_object_id(obj), curly_braces_content + 1);\n\n\texpected_type = parse_obj_type(curly_braces_content);\n\n\tif (expected_type == GIT_OBJ_BAD)\n\t\treturn GIT_EINVALIDSPEC;\n\n\treturn git_object_peel(out, obj, expected_type);\n}"
  },
  {
    "function_name": "handle_grep_syntax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "475-502",
    "snippet": "static int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tregex_t preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tregfree(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_revwalk_free",
          "args": [
            "walk"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "555-567",
          "snippet": "void git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_free(git_revwalk *walk)\n{\n\tif (walk == NULL)\n\t\treturn;\n\n\tgit_revwalk_reset(walk);\n\tgit_odb_free(walk->odb);\n\n\tgit_oidmap_free(walk->commits);\n\tgit_pool_clear(&walk->commit_pool);\n\tgit_pqueue_free(&walk->iterator_time);\n\tgit__free(walk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&preg"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_and_search",
          "args": [
            "out",
            "walk",
            "&preg"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "walk_and_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "449-473",
          "snippet": "static int walk_and_search(git_object **out, git_revwalk *walk, regex_t *regex)\n{\n\tint error;\n\tgit_oid oid;\n\tgit_object *obj;\n\n\twhile (!(error = git_revwalk_next(&oid, walk))) {\n\n\t\terror = git_object_lookup(&obj, git_revwalk_repository(walk), &oid, GIT_OBJ_COMMIT);\n\t\tif ((error < 0) && (error != GIT_ENOTFOUND))\n\t\t\treturn -1;\n\n\t\tif (!regexec(regex, git_commit_message((git_commit*)obj), 0, NULL, 0)) {\n\t\t\t*out = obj;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgit_object_free(obj);\n\t}\n\n\tif (error < 0 && error == GIT_ITEROVER)\n\t\terror = GIT_ENOTFOUND;\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int walk_and_search(git_object **out, git_revwalk *walk, regex_t *regex)\n{\n\tint error;\n\tgit_oid oid;\n\tgit_object *obj;\n\n\twhile (!(error = git_revwalk_next(&oid, walk))) {\n\n\t\terror = git_object_lookup(&obj, git_revwalk_repository(walk), &oid, GIT_OBJ_COMMIT);\n\t\tif ((error < 0) && (error != GIT_ENOTFOUND))\n\t\t\treturn -1;\n\n\t\tif (!regexec(regex, git_commit_message((git_commit*)obj), 0, NULL, 0)) {\n\t\t\t*out = obj;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgit_object_free(obj);\n\t}\n\n\tif (error < 0 && error == GIT_ITEROVER)\n\t\terror = GIT_ENOTFOUND;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_push",
          "args": [
            "walk",
            "spec_oid"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_push_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "281-304",
          "snippet": "int git_revwalk_push_range(git_revwalk *walk, const char *range)\n{\n\tgit_revspec revspec;\n\tint error = 0;\n\n\tif ((error = git_revparse(&revspec, walk->repo, range)))\n\t\treturn error;\n\n\tif (revspec.flags & GIT_REVPARSE_MERGE_BASE) {\n\t\t/* TODO: support \"<commit>...<commit>\" */\n\t\tgiterr_set(GITERR_INVALID, \"Symmetric differences not implemented in revwalk\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = push_commit(walk, git_object_id(revspec.from), 1, false)))\n\t\tgoto out;\n\n\terror = push_commit(walk, git_object_id(revspec.to), 0, false);\n\nout:\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n\treturn error;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_push_range(git_revwalk *walk, const char *range)\n{\n\tgit_revspec revspec;\n\tint error = 0;\n\n\tif ((error = git_revparse(&revspec, walk->repo, range)))\n\t\treturn error;\n\n\tif (revspec.flags & GIT_REVPARSE_MERGE_BASE) {\n\t\t/* TODO: support \"<commit>...<commit>\" */\n\t\tgiterr_set(GITERR_INVALID, \"Symmetric differences not implemented in revwalk\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif ((error = push_commit(walk, git_object_id(revspec.from), 1, false)))\n\t\tgoto out;\n\n\terror = push_commit(walk, git_object_id(revspec.to), 0, false);\n\nout:\n\tgit_object_free(revspec.from);\n\tgit_object_free(revspec.to);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_push_glob",
          "args": [
            "walk",
            "\"refs/*\""
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_push_glob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "251-255",
          "snippet": "int git_revwalk_push_glob(git_revwalk *walk, const char *glob)\n{\n\tassert(walk && glob);\n\treturn push_glob(walk, glob, 0);\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_push_glob(git_revwalk *walk, const char *glob)\n{\n\tassert(walk && glob);\n\treturn push_glob(walk, glob, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_sorting",
          "args": [
            "walk",
            "GIT_SORT_TIME"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_sorting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "575-591",
          "snippet": "void git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)\n{\n\tassert(walk);\n\n\tif (walk->walking)\n\t\tgit_revwalk_reset(walk);\n\n\twalk->sorting = sort_mode;\n\n\tif (walk->sorting & GIT_SORT_TIME) {\n\t\twalk->get_next = &revwalk_next_timesort;\n\t\twalk->enqueue = &revwalk_enqueue_timesort;\n\t} else {\n\t\twalk->get_next = &revwalk_next_unsorted;\n\t\twalk->enqueue = &revwalk_enqueue_unsorted;\n\t}\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_revwalk_sorting(git_revwalk *walk, unsigned int sort_mode)\n{\n\tassert(walk);\n\n\tif (walk->walking)\n\t\tgit_revwalk_reset(walk);\n\n\twalk->sorting = sort_mode;\n\n\tif (walk->sorting & GIT_SORT_TIME) {\n\t\twalk->get_next = &revwalk_next_timesort;\n\t\twalk->enqueue = &revwalk_enqueue_timesort;\n\t} else {\n\t\twalk->get_next = &revwalk_next_unsorted;\n\t\twalk->enqueue = &revwalk_enqueue_unsorted;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_new",
          "args": [
            "&walk",
            "repo"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "529-553",
          "snippet": "int git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_new(git_revwalk **revwalk_out, git_repository *repo)\n{\n\tgit_revwalk *walk = git__calloc(1, sizeof(git_revwalk));\n\tGITERR_CHECK_ALLOC(walk);\n\n\twalk->commits = git_oidmap_alloc();\n\tGITERR_CHECK_ALLOC(walk->commits);\n\n\tif (git_pqueue_init(&walk->iterator_time, 0, 8, git_commit_list_time_cmp) < 0)\n\t\treturn -1;\n\n\tgit_pool_init(&walk->commit_pool, COMMIT_ALLOC);\n\twalk->get_next = &revwalk_next_unsorted;\n\twalk->enqueue = &revwalk_enqueue_unsorted;\n\n\twalk->repo = repo;\n\n\tif (git_repository_odb(&walk->odb, repo) < 0) {\n\t\tgit_revwalk_free(walk);\n\t\treturn -1;\n\t}\n\n\t*revwalk_out = walk;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_regex",
          "args": [
            "&preg",
            "pattern"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "build_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "44-62",
          "snippet": "static int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_grep_syntax(git_object **out, git_repository *repo, const git_oid *spec_oid, const char *pattern)\n{\n\tregex_t preg;\n\tgit_revwalk *walk = NULL;\n\tint error;\n\n\tif ((error = build_regex(&preg, pattern)) < 0)\n\t\treturn error;\n\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\tgoto cleanup;\n\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\n\tif (spec_oid == NULL) {\n\t\tif ((error = git_revwalk_push_glob(walk, \"refs/*\")) < 0)\n\t\t\tgoto cleanup;\n\t} else if ((error = git_revwalk_push(walk, spec_oid)) < 0)\n\t\t\tgoto cleanup;\n\n\terror = walk_and_search(out, walk, &preg);\n\ncleanup:\n\tregfree(&preg);\n\tgit_revwalk_free(walk);\n\n\treturn error;\n}"
  },
  {
    "function_name": "walk_and_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "449-473",
    "snippet": "static int walk_and_search(git_object **out, git_revwalk *walk, regex_t *regex)\n{\n\tint error;\n\tgit_oid oid;\n\tgit_object *obj;\n\n\twhile (!(error = git_revwalk_next(&oid, walk))) {\n\n\t\terror = git_object_lookup(&obj, git_revwalk_repository(walk), &oid, GIT_OBJ_COMMIT);\n\t\tif ((error < 0) && (error != GIT_ENOTFOUND))\n\t\t\treturn -1;\n\n\t\tif (!regexec(regex, git_commit_message((git_commit*)obj), 0, NULL, 0)) {\n\t\t\t*out = obj;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgit_object_free(obj);\n\t}\n\n\tif (error < 0 && error == GIT_ITEROVER)\n\t\terror = GIT_ENOTFOUND;\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "obj"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "regex",
            "git_commit_message((git_commit*)obj)",
            "0",
            "NULL",
            "0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_message",
          "args": [
            "(git_commit*)obj"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "433-456",
          "snippet": "GIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nGIT_COMMIT_GETTER(const git_signature *, author, commit->author)\nGIT_COMMIT_GETTER(const git_signature *, committer, commit->committer)\nGIT_COMMIT_GETTER(const char *, message_raw, commit->raw_message)\nGIT_COMMIT_GETTER(const char *, message_encoding, commit->message_encoding)\nGIT_COMMIT_GETTER(const char *, raw_header, commit->raw_header)\nGIT_COMMIT_GETTER(git_time_t, time, commit->committer->when.time)\nGIT_COMMIT_GETTER(int, time_offset, commit->committer->when.offset)\nGIT_COMMIT_GETTER(unsigned int, parentcount, (unsigned int)git_array_size(commit->parent_ids))\nGIT_COMMIT_GETTER(const git_oid *, tree_id, &commit->tree_id)\n\nconst char *git_commit_message(const git_commit *commit)\n{\n\tconst char *message;\n\n\tassert(commit);\n\n\tmessage = commit->raw_message;\n\n\t/* trim leading newlines from raw message */\n\twhile (*message && *message == '\\n')\n\t\t++message;\n\n\treturn message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "&obj",
            "git_revwalk_repository(walk)",
            "&oid",
            "GIT_OBJ_COMMIT"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_repository",
          "args": [
            "walk"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_repository",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "569-573",
          "snippet": "git_repository *git_revwalk_repository(git_revwalk *walk)\n{\n\tassert(walk);\n\treturn walk->repo;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\ngit_repository *git_revwalk_repository(git_revwalk *walk)\n{\n\tassert(walk);\n\treturn walk->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_revwalk_next",
          "args": [
            "&oid",
            "walk"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "git_revwalk_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revwalk.c",
          "lines": "598-622",
          "snippet": "int git_revwalk_next(git_oid *oid, git_revwalk *walk)\n{\n\tint error;\n\tgit_commit_list_node *next;\n\n\tassert(walk && oid);\n\n\tif (!walk->walking) {\n\t\tif ((error = prepare_walk(walk)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = walk->get_next(&next, walk);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgit_revwalk_reset(walk);\n\t\tgiterr_clear();\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tif (!error)\n\t\tgit_oid_cpy(oid, &next->oid);\n\n\treturn error;\n}",
          "includes": [
            "#include \"merge.h\"",
            "#include \"git2/revparse.h\"",
            "#include \"revwalk.h\"",
            "#include \"pool.h\"",
            "#include \"odb.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"merge.h\"\n#include \"git2/revparse.h\"\n#include \"revwalk.h\"\n#include \"pool.h\"\n#include \"odb.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_revwalk_next(git_oid *oid, git_revwalk *walk)\n{\n\tint error;\n\tgit_commit_list_node *next;\n\n\tassert(walk && oid);\n\n\tif (!walk->walking) {\n\t\tif ((error = prepare_walk(walk)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = walk->get_next(&next, walk);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgit_revwalk_reset(walk);\n\t\tgiterr_clear();\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tif (!error)\n\t\tgit_oid_cpy(oid, &next->oid);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int walk_and_search(git_object **out, git_revwalk *walk, regex_t *regex)\n{\n\tint error;\n\tgit_oid oid;\n\tgit_object *obj;\n\n\twhile (!(error = git_revwalk_next(&oid, walk))) {\n\n\t\terror = git_object_lookup(&obj, git_revwalk_repository(walk), &oid, GIT_OBJ_COMMIT);\n\t\tif ((error < 0) && (error != GIT_ENOTFOUND))\n\t\t\treturn -1;\n\n\t\tif (!regexec(regex, git_commit_message((git_commit*)obj), 0, NULL, 0)) {\n\t\t\t*out = obj;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgit_object_free(obj);\n\t}\n\n\tif (error < 0 && error == GIT_ITEROVER)\n\t\terror = GIT_ENOTFOUND;\n\n\treturn error;\n}"
  },
  {
    "function_name": "handle_colon_syntax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "416-447",
    "snippet": "static int handle_colon_syntax(\n\tgit_object **out,\n\tgit_object *obj,\n\tconst char *path)\n{\n\tgit_object *tree;\n\tint error = -1;\n\tgit_tree_entry *entry = NULL;\n\n\tif ((error = git_object_peel(&tree, obj, GIT_OBJ_TREE)) < 0)\n\t\treturn error == GIT_ENOTFOUND ? GIT_EINVALIDSPEC : error;\n\n\tif (*path == '\\0') {\n\t\t*out = tree;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: Handle the relative path syntax\n\t * (:./relative/path and :../relative/path)\n\t */\n\tif ((error = git_tree_entry_bypath(&entry, (git_tree *)tree, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_tree_entry_to_object(out, git_object_owner(tree), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_object_free(tree);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "tree"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_free",
          "args": [
            "entry"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "229-235",
          "snippet": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_to_object",
          "args": [
            "out",
            "git_object_owner(tree)",
            "entry"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_to_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "296-303",
          "snippet": "int git_tree_entry_to_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_tree_entry *entry)\n{\n\tassert(entry && object_out);\n\treturn git_object_lookup(object_out, repo, entry->oid, GIT_OBJ_ANY);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_entry_to_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_tree_entry *entry)\n{\n\tassert(entry && object_out);\n\treturn git_object_lookup(object_out, repo, entry->oid, GIT_OBJ_ANY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "tree"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_bypath",
          "args": [
            "&entry",
            "(git_tree *)tree",
            "path"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "897-957",
          "snippet": "int git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "&tree",
            "obj",
            "GIT_OBJ_TREE"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_colon_syntax(\n\tgit_object **out,\n\tgit_object *obj,\n\tconst char *path)\n{\n\tgit_object *tree;\n\tint error = -1;\n\tgit_tree_entry *entry = NULL;\n\n\tif ((error = git_object_peel(&tree, obj, GIT_OBJ_TREE)) < 0)\n\t\treturn error == GIT_ENOTFOUND ? GIT_EINVALIDSPEC : error;\n\n\tif (*path == '\\0') {\n\t\t*out = tree;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * TODO: Handle the relative path syntax\n\t * (:./relative/path and :../relative/path)\n\t */\n\tif ((error = git_tree_entry_bypath(&entry, (git_tree *)tree, path)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_tree_entry_to_object(out, git_object_owner(tree), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_object_free(tree);\n\n\treturn error;\n}"
  },
  {
    "function_name": "handle_linear_syntax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "401-414",
    "snippet": "static int handle_linear_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\terror = git_commit_nth_gen_ancestor((git_commit **)out, (git_commit*)temp_commit, n);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "temp_commit"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_nth_gen_ancestor",
          "args": [
            "(git_commit **)out",
            "(git_commit*)temp_commit",
            "n"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_nth_gen_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "559-590",
          "snippet": "int git_commit_nth_gen_ancestor(\n\tgit_commit **ancestor,\n\tconst git_commit *commit,\n\tunsigned int n)\n{\n\tgit_commit *current, *parent = NULL;\n\tint error;\n\n\tassert(ancestor && commit);\n\n\tif (git_object_dup((git_object **) &current, (git_object *) commit) < 0)\n\t\treturn -1;\n\n\tif (n == 0) {\n\t\t*ancestor = current;\n\t\treturn 0;\n\t}\n\n\twhile (n--) {\n\t\terror = git_commit_parent(&parent, current, 0);\n\n\t\tgit_commit_free(current);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tcurrent = parent;\n\t}\n\n\t*ancestor = parent;\n\treturn 0;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_nth_gen_ancestor(\n\tgit_commit **ancestor,\n\tconst git_commit *commit,\n\tunsigned int n)\n{\n\tgit_commit *current, *parent = NULL;\n\tint error;\n\n\tassert(ancestor && commit);\n\n\tif (git_object_dup((git_object **) &current, (git_object *) commit) < 0)\n\t\treturn -1;\n\n\tif (n == 0) {\n\t\t*ancestor = current;\n\t\treturn 0;\n\t}\n\n\twhile (n--) {\n\t\terror = git_commit_parent(&parent, current, 0);\n\n\t\tgit_commit_free(current);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tcurrent = parent;\n\t}\n\n\t*ancestor = parent;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "&temp_commit",
            "obj",
            "GIT_OBJ_COMMIT"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_linear_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\terror = git_commit_nth_gen_ancestor((git_commit **)out, (git_commit*)temp_commit, n);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}"
  },
  {
    "function_name": "handle_caret_parent_syntax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "381-399",
    "snippet": "static int handle_caret_parent_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\tif (n == 0) {\n\t\t*out = temp_commit;\n\t\treturn 0;\n\t}\n\n\terror = git_commit_parent((git_commit **)out, (git_commit*)temp_commit, n - 1);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "temp_commit"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "(git_commit **)out",
            "(git_commit*)temp_commit",
            "n - 1"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "&temp_commit",
            "obj",
            "GIT_OBJ_COMMIT"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_caret_parent_syntax(git_object **out, git_object *obj, int n)\n{\n\tgit_object *temp_commit = NULL;\n\tint error;\n\n\tif ((error = git_object_peel(&temp_commit, obj, GIT_OBJ_COMMIT)) < 0)\n\t\treturn (error == GIT_EAMBIGUOUS || error == GIT_ENOTFOUND) ?\n\t\t\tGIT_EINVALIDSPEC : error;\n\n\tif (n == 0) {\n\t\t*out = temp_commit;\n\t\treturn 0;\n\t}\n\n\terror = git_commit_parent((git_commit **)out, (git_commit*)temp_commit, n - 1);\n\n\tgit_object_free(temp_commit);\n\treturn error;\n}"
  },
  {
    "function_name": "dereference_to_non_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "373-379",
    "snippet": "static int dereference_to_non_tag(git_object **out, git_object *obj)\n{\n\tif (git_object_type(obj) == GIT_OBJ_TAG)\n\t\treturn git_tag_peel(out, (git_tag *)obj);\n\n\treturn git_object_dup(out, obj);\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_dup",
          "args": [
            "out",
            "obj"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "383-388",
          "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tag_peel",
          "args": [
            "out",
            "(git_tag *)obj"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "514-517",
          "snippet": "int git_tag_peel(git_object **tag_target, const git_tag *tag)\n{\n\treturn git_object_peel(tag_target, (const git_object *)tag, GIT_OBJ_ANY);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_peel(git_object **tag_target, const git_tag *tag)\n{\n\treturn git_object_peel(tag_target, (const git_object *)tag, GIT_OBJ_ANY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "obj"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int dereference_to_non_tag(git_object **out, git_object *obj)\n{\n\tif (git_object_type(obj) == GIT_OBJ_TAG)\n\t\treturn git_tag_peel(out, (git_tag *)obj);\n\n\treturn git_object_dup(out, obj);\n}"
  },
  {
    "function_name": "parse_obj_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "356-371",
    "snippet": "static git_otype parse_obj_type(const char *str)\n{\n\tif (!strcmp(str, \"commit\"))\n\t\treturn GIT_OBJ_COMMIT;\n\n\tif (!strcmp(str, \"tree\"))\n\t\treturn GIT_OBJ_TREE;\n\n\tif (!strcmp(str, \"blob\"))\n\t\treturn GIT_OBJ_BLOB;\n\n\tif (!strcmp(str, \"tag\"))\n\t\treturn GIT_OBJ_TAG;\n\n\treturn GIT_OBJ_BAD;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"tag\""
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic git_otype parse_obj_type(const char *str)\n{\n\tif (!strcmp(str, \"commit\"))\n\t\treturn GIT_OBJ_COMMIT;\n\n\tif (!strcmp(str, \"tree\"))\n\t\treturn GIT_OBJ_TREE;\n\n\tif (!strcmp(str, \"blob\"))\n\t\treturn GIT_OBJ_BLOB;\n\n\tif (!strcmp(str, \"tag\"))\n\t\treturn GIT_OBJ_TAG;\n\n\treturn GIT_OBJ_BAD;\n}"
  },
  {
    "function_name": "handle_at_syntax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "312-354",
    "snippet": "static int handle_at_syntax(git_object **out, git_reference **ref, const char *spec, size_t identifier_len, git_repository* repo, const char *curly_braces_content)\n{\n\tbool is_numeric;\n\tint parsed = 0, error = -1;\n\tgit_buf identifier = GIT_BUF_INIT;\n\tgit_time_t timestamp;\n\n\tassert(*out == NULL);\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\tis_numeric = !try_parse_numeric(&parsed, curly_braces_content);\n\n\tif (*curly_braces_content == '-' && (!is_numeric || parsed == 0)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_numeric) {\n\t\tif (parsed < 0)\n\t\t\terror = retrieve_previously_checked_out_branch_or_revision(out, ref, repo, git_buf_cstr(&identifier), -parsed);\n\t\telse\n\t\t\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), parsed);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (!strcmp(curly_braces_content, \"u\") || !strcmp(curly_braces_content, \"upstream\")) {\n\t\terror = retrieve_remote_tracking_reference(ref, git_buf_cstr(&identifier), repo);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (git__date_parse(&timestamp, curly_braces_content) < 0)\n\t\tgoto cleanup;\n\n\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), (size_t)timestamp);\n\ncleanup:\n\tgit_buf_free(&identifier);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&identifier"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_revobject_from_reflog",
          "args": [
            "out",
            "ref",
            "repo",
            "git_buf_cstr(&identifier)",
            "(size_t)timestamp"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_revobject_from_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "255-282",
          "snippet": "static int retrieve_revobject_from_reflog(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref;\n\tgit_oid oid;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (position == 0) {\n\t\terror = git_object_lookup(out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = retrieve_oid_from_reflog(&oid, ref, position)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_object_lookup(out, repo, &oid, GIT_OBJ_ANY);\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_revobject_from_reflog(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref;\n\tgit_oid oid;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (position == 0) {\n\t\terror = git_object_lookup(out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = retrieve_oid_from_reflog(&oid, ref, position)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_object_lookup(out, repo, &oid, GIT_OBJ_ANY);\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&identifier"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__date_parse",
          "args": [
            "&timestamp",
            "curly_braces_content"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "git__date_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/date.c",
          "lines": "860-876",
          "snippet": "int git__date_parse(git_time_t *out, const char *date)\n{\n\ttime_t time_sec;\n\tgit_time_t timestamp;\n\tint offset, error_ret=0;\n\n\tif (!parse_date_basic(date, &timestamp, &offset)) {\n\t\t*out = timestamp;\n\t\treturn 0;\n\t}\n\n\tif (time(&time_sec) == -1)\n\t\treturn -1;\n\n\t*out = approxidate_str(date, time_sec, &error_ret);\n   return error_ret;\n}",
          "includes": [
            "#include <time.h>",
            "#include <ctype.h>",
            "#include \"posix.h\"",
            "#include \"cache.h\"",
            "#include \"util.h\"",
            "#include <sys/time.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <ctype.h>\n#include \"posix.h\"\n#include \"cache.h\"\n#include \"util.h\"\n#include <sys/time.h>\n#include \"common.h\"\n\nint git__date_parse(git_time_t *out, const char *date)\n{\n\ttime_t time_sec;\n\tgit_time_t timestamp;\n\tint offset, error_ret=0;\n\n\tif (!parse_date_basic(date, &timestamp, &offset)) {\n\t\t*out = timestamp;\n\t\treturn 0;\n\t}\n\n\tif (time(&time_sec) == -1)\n\t\treturn -1;\n\n\t*out = approxidate_str(date, time_sec, &error_ret);\n   return error_ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_remote_tracking_reference",
          "args": [
            "ref",
            "git_buf_cstr(&identifier)",
            "repo"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_remote_tracking_reference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "284-310",
          "snippet": "static int retrieve_remote_tracking_reference(git_reference **base_ref, const char *identifier, git_repository *repo)\n{\n\tgit_reference *tracking, *ref;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (!git_reference_is_branch(ref)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_branch_upstream(&tracking, ref)) < 0)\n\t\tgoto cleanup;\n\n\t*base_ref = tracking;\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_remote_tracking_reference(git_reference **base_ref, const char *identifier, git_repository *repo)\n{\n\tgit_reference *tracking, *ref;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (!git_reference_is_branch(ref)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_branch_upstream(&tracking, ref)) < 0)\n\t\tgoto cleanup;\n\n\t*base_ref = tracking;\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "curly_braces_content",
            "\"upstream\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_previously_checked_out_branch_or_revision",
          "args": [
            "out",
            "ref",
            "repo",
            "git_buf_cstr(&identifier)",
            "-parsed"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_previously_checked_out_branch_or_revision",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "140-203",
          "snippet": "static int retrieve_previously_checked_out_branch_or_revision(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref = NULL;\n\tgit_reflog *reflog = NULL;\n\tregex_t preg;\n\tint error = -1;\n\tsize_t i, numentries, cur;\n\tconst git_reflog_entry *entry;\n\tconst char *msg;\n\tregmatch_t regexmatches[2];\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tcur = position;\n\n\tif (*identifier != '\\0' || *base_ref != NULL)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (build_regex(&preg, \"checkout: moving from (.*) to .*\") < 0)\n\t\treturn -1;\n\n\tif (git_reference_lookup(&ref, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reflog_read(&reflog, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tnumentries  = git_reflog_entrycount(reflog);\n\n\tfor (i = 0; i < numentries; i++) {\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\tmsg = git_reflog_entry_message(entry);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tif (regexec(&preg, msg, 2, regexmatches, 0))\n\t\t\tcontinue;\n\n\t\tcur--;\n\n\t\tif (cur > 0)\n\t\t\tcontinue;\n\n\t\tgit_buf_put(&buf, msg+regexmatches[1].rm_so, regexmatches[1].rm_eo - regexmatches[1].rm_so);\n\n\t\tif ((error = git_reference_dwim(base_ref, repo, git_buf_cstr(&buf))) == 0)\n\t\t\tgoto cleanup;\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\terror = maybe_abbrev(out, repo, git_buf_cstr(&buf));\n\n\t\tgoto cleanup;\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ncleanup:\n\tgit_reference_free(ref);\n\tgit_buf_free(&buf);\n\tregfree(&preg);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_previously_checked_out_branch_or_revision(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref = NULL;\n\tgit_reflog *reflog = NULL;\n\tregex_t preg;\n\tint error = -1;\n\tsize_t i, numentries, cur;\n\tconst git_reflog_entry *entry;\n\tconst char *msg;\n\tregmatch_t regexmatches[2];\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tcur = position;\n\n\tif (*identifier != '\\0' || *base_ref != NULL)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (build_regex(&preg, \"checkout: moving from (.*) to .*\") < 0)\n\t\treturn -1;\n\n\tif (git_reference_lookup(&ref, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reflog_read(&reflog, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tnumentries  = git_reflog_entrycount(reflog);\n\n\tfor (i = 0; i < numentries; i++) {\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\tmsg = git_reflog_entry_message(entry);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tif (regexec(&preg, msg, 2, regexmatches, 0))\n\t\t\tcontinue;\n\n\t\tcur--;\n\n\t\tif (cur > 0)\n\t\t\tcontinue;\n\n\t\tgit_buf_put(&buf, msg+regexmatches[1].rm_so, regexmatches[1].rm_eo - regexmatches[1].rm_so);\n\n\t\tif ((error = git_reference_dwim(base_ref, repo, git_buf_cstr(&buf))) == 0)\n\t\t\tgoto cleanup;\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\terror = maybe_abbrev(out, repo, git_buf_cstr(&buf));\n\n\t\tgoto cleanup;\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ncleanup:\n\tgit_reference_free(ref);\n\tgit_buf_free(&buf);\n\tregfree(&preg);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_parse_numeric",
          "args": [
            "&parsed",
            "curly_braces_content"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "try_parse_numeric",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "125-138",
          "snippet": "static int try_parse_numeric(int *n, const char *curly_braces_content)\n{\n\tint32_t content;\n\tconst char *end_ptr;\n\n\tif (git__strtol32(&content, curly_braces_content, &end_ptr, 10) < 0)\n\t\treturn -1;\n\n\tif (*end_ptr != '\\0')\n\t\treturn -1;\n\n\t*n = (int)content;\n\treturn 0;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int try_parse_numeric(int *n, const char *curly_braces_content)\n{\n\tint32_t content;\n\tconst char *end_ptr;\n\n\tif (git__strtol32(&content, curly_braces_content, &end_ptr, 10) < 0)\n\t\treturn -1;\n\n\tif (*end_ptr != '\\0')\n\t\treturn -1;\n\n\t*n = (int)content;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&identifier",
            "spec",
            "identifier_len"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "*out == NULL"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int handle_at_syntax(git_object **out, git_reference **ref, const char *spec, size_t identifier_len, git_repository* repo, const char *curly_braces_content)\n{\n\tbool is_numeric;\n\tint parsed = 0, error = -1;\n\tgit_buf identifier = GIT_BUF_INIT;\n\tgit_time_t timestamp;\n\n\tassert(*out == NULL);\n\n\tif (git_buf_put(&identifier, spec, identifier_len) < 0)\n\t\treturn -1;\n\n\tis_numeric = !try_parse_numeric(&parsed, curly_braces_content);\n\n\tif (*curly_braces_content == '-' && (!is_numeric || parsed == 0)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif (is_numeric) {\n\t\tif (parsed < 0)\n\t\t\terror = retrieve_previously_checked_out_branch_or_revision(out, ref, repo, git_buf_cstr(&identifier), -parsed);\n\t\telse\n\t\t\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), parsed);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (!strcmp(curly_braces_content, \"u\") || !strcmp(curly_braces_content, \"upstream\")) {\n\t\terror = retrieve_remote_tracking_reference(ref, git_buf_cstr(&identifier), repo);\n\n\t\tgoto cleanup;\n\t}\n\n\tif (git__date_parse(&timestamp, curly_braces_content) < 0)\n\t\tgoto cleanup;\n\n\terror = retrieve_revobject_from_reflog(out, ref, repo, git_buf_cstr(&identifier), (size_t)timestamp);\n\ncleanup:\n\tgit_buf_free(&identifier);\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_remote_tracking_reference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "284-310",
    "snippet": "static int retrieve_remote_tracking_reference(git_reference **base_ref, const char *identifier, git_repository *repo)\n{\n\tgit_reference *tracking, *ref;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (!git_reference_is_branch(ref)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_branch_upstream(&tracking, ref)) < 0)\n\t\tgoto cleanup;\n\n\t*base_ref = tracking;\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_branch_upstream",
          "args": [
            "&tracking",
            "ref"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "git_branch_upstream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/branch.c",
          "lines": "490-508",
          "snippet": "int git_branch_upstream(\n\tgit_reference **tracking_out,\n\tconst git_reference *branch)\n{\n\tint error;\n\tgit_buf tracking_name = GIT_BUF_INIT;\n\n\tif ((error = git_branch_upstream_name(&tracking_name,\n\t\tgit_reference_owner(branch), git_reference_name(branch))) < 0)\n\t\t\treturn error;\n\n\terror = git_reference_lookup(\n\t\ttracking_out,\n\t\tgit_reference_owner(branch),\n\t\tgit_buf_cstr(&tracking_name));\n\n\tgit_buf_free(&tracking_name);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/branch.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"remote.h\"",
            "#include \"refs.h\"",
            "#include \"refspec.h\"",
            "#include \"config.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/branch.h\"\n#include \"annotated_commit.h\"\n#include \"remote.h\"\n#include \"refs.h\"\n#include \"refspec.h\"\n#include \"config.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_branch_upstream(\n\tgit_reference **tracking_out,\n\tconst git_reference *branch)\n{\n\tint error;\n\tgit_buf tracking_name = GIT_BUF_INIT;\n\n\tif ((error = git_branch_upstream_name(&tracking_name,\n\t\tgit_reference_owner(branch), git_reference_name(branch))) < 0)\n\t\t\treturn error;\n\n\terror = git_reference_lookup(\n\t\ttracking_out,\n\t\tgit_reference_owner(branch),\n\t\tgit_buf_cstr(&tracking_name));\n\n\tgit_buf_free(&tracking_name);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_is_branch",
          "args": [
            "ref"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_is_branch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "1177-1181",
          "snippet": "int git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_is_branch(const git_reference *ref)\n{\n\tassert(ref);\n\treturn git_reference__is_branch(ref->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_dwim",
          "args": [
            "&ref",
            "repo",
            "identifier"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_dwim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "236-298",
          "snippet": "int git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_remote_tracking_reference(git_reference **base_ref, const char *identifier, git_repository *repo)\n{\n\tgit_reference *tracking, *ref;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (!git_reference_is_branch(ref)) {\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = git_branch_upstream(&tracking, ref)) < 0)\n\t\tgoto cleanup;\n\n\t*base_ref = tracking;\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_revobject_from_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "255-282",
    "snippet": "static int retrieve_revobject_from_reflog(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref;\n\tgit_oid oid;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (position == 0) {\n\t\terror = git_object_lookup(out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = retrieve_oid_from_reflog(&oid, ref, position)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_object_lookup(out, repo, &oid, GIT_OBJ_ANY);\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "out",
            "repo",
            "&oid",
            "GIT_OBJ_ANY"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_oid_from_reflog",
          "args": [
            "&oid",
            "ref",
            "position"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_oid_from_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "205-253",
          "snippet": "static int retrieve_oid_from_reflog(git_oid *oid, git_reference *ref, size_t identifier)\n{\n\tgit_reflog *reflog;\n\tsize_t numentries;\n\tconst git_reflog_entry *entry;\n\tbool search_by_pos = (identifier <= 100000000);\n\n\tif (git_reflog_read(&reflog, git_reference_owner(ref), git_reference_name(ref)) < 0)\n\t\treturn -1;\n\n\tnumentries = git_reflog_entrycount(reflog);\n\n\tif (search_by_pos) {\n\t\tif (numentries < identifier + 1)\n\t\t\tgoto notfound;\n\n\t\tentry = git_reflog_entry_byindex(reflog, identifier);\n\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t} else {\n\t\tsize_t i;\n\t\tgit_time commit_time;\n\n\t\tfor (i = 0; i < numentries; i++) {\n\t\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\t\tcommit_time = git_reflog_entry_committer(entry)->when;\n\n\t\t\tif (commit_time.time > (git_time_t)identifier)\n\t\t\t\tcontinue;\n\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numentries)\n\t\t\tgoto notfound;\n\t}\n\n\tgit_reflog_free(reflog);\n\treturn 0;\n\nnotfound:\n\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"Reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ,\n\t\tgit_reference_name(ref), numentries, identifier);\n\n\tgit_reflog_free(reflog);\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_oid_from_reflog(git_oid *oid, git_reference *ref, size_t identifier)\n{\n\tgit_reflog *reflog;\n\tsize_t numentries;\n\tconst git_reflog_entry *entry;\n\tbool search_by_pos = (identifier <= 100000000);\n\n\tif (git_reflog_read(&reflog, git_reference_owner(ref), git_reference_name(ref)) < 0)\n\t\treturn -1;\n\n\tnumentries = git_reflog_entrycount(reflog);\n\n\tif (search_by_pos) {\n\t\tif (numentries < identifier + 1)\n\t\t\tgoto notfound;\n\n\t\tentry = git_reflog_entry_byindex(reflog, identifier);\n\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t} else {\n\t\tsize_t i;\n\t\tgit_time commit_time;\n\n\t\tfor (i = 0; i < numentries; i++) {\n\t\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\t\tcommit_time = git_reflog_entry_committer(entry)->when;\n\n\t\t\tif (commit_time.time > (git_time_t)identifier)\n\t\t\t\tcontinue;\n\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numentries)\n\t\t\tgoto notfound;\n\t}\n\n\tgit_reflog_free(reflog);\n\treturn 0;\n\nnotfound:\n\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"Reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ,\n\t\tgit_reference_name(ref), numentries, identifier);\n\n\tgit_reflog_free(reflog);\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_dwim",
          "args": [
            "&ref",
            "repo",
            "identifier"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_dwim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "236-298",
          "snippet": "int git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_revobject_from_reflog(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref;\n\tgit_oid oid;\n\tint error = -1;\n\n\tif (*base_ref == NULL) {\n\t\tif ((error = git_reference_dwim(&ref, repo, identifier)) < 0)\n\t\t\treturn error;\n\t} else {\n\t\tref = *base_ref;\n\t\t*base_ref = NULL;\n\t}\n\n\tif (position == 0) {\n\t\terror = git_object_lookup(out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\t\tgoto cleanup;\n\t}\n\n\tif ((error = retrieve_oid_from_reflog(&oid, ref, position)) < 0)\n\t\tgoto cleanup;\n\n\terror = git_object_lookup(out, repo, &oid, GIT_OBJ_ANY);\n\ncleanup:\n\tgit_reference_free(ref);\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_oid_from_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "205-253",
    "snippet": "static int retrieve_oid_from_reflog(git_oid *oid, git_reference *ref, size_t identifier)\n{\n\tgit_reflog *reflog;\n\tsize_t numentries;\n\tconst git_reflog_entry *entry;\n\tbool search_by_pos = (identifier <= 100000000);\n\n\tif (git_reflog_read(&reflog, git_reference_owner(ref), git_reference_name(ref)) < 0)\n\t\treturn -1;\n\n\tnumentries = git_reflog_entrycount(reflog);\n\n\tif (search_by_pos) {\n\t\tif (numentries < identifier + 1)\n\t\t\tgoto notfound;\n\n\t\tentry = git_reflog_entry_byindex(reflog, identifier);\n\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t} else {\n\t\tsize_t i;\n\t\tgit_time commit_time;\n\n\t\tfor (i = 0; i < numentries; i++) {\n\t\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\t\tcommit_time = git_reflog_entry_committer(entry)->when;\n\n\t\t\tif (commit_time.time > (git_time_t)identifier)\n\t\t\t\tcontinue;\n\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numentries)\n\t\t\tgoto notfound;\n\t}\n\n\tgit_reflog_free(reflog);\n\treturn 0;\n\nnotfound:\n\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"Reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ,\n\t\tgit_reference_name(ref), numentries, identifier);\n\n\tgit_reflog_free(reflog);\n\treturn GIT_ENOTFOUND;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reflog_free",
          "args": [
            "reflog"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "29-49",
          "snippet": "void git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ",
            "git_reference_name(ref)",
            "numentries",
            "identifier"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "ref"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "oid",
            "git_reflog_entry_id_new(entry)"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_id_new",
          "args": [
            "entry"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_id_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "168-172",
          "snippet": "const git_oid * git_reflog_entry_id_new(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn &entry->oid_cur;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_oid * git_reflog_entry_id_new(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn &entry->oid_cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_committer",
          "args": [
            "entry"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_committer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "174-178",
          "snippet": "const git_signature * git_reflog_entry_committer(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn entry->committer;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_signature * git_reflog_entry_committer(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn entry->committer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_byindex",
          "args": [
            "reflog",
            "i"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "151-160",
          "snippet": "const git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entrycount",
          "args": [
            "reflog"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "145-149",
          "snippet": "size_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nsize_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_read",
          "args": [
            "&reflog",
            "git_reference_owner(ref)",
            "git_reference_name(ref)"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "51-62",
          "snippet": "int git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nint git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_owner",
          "args": [
            "ref"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "315-319",
          "snippet": "git_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_repository *git_reference_owner(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->db->repo;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_oid_from_reflog(git_oid *oid, git_reference *ref, size_t identifier)\n{\n\tgit_reflog *reflog;\n\tsize_t numentries;\n\tconst git_reflog_entry *entry;\n\tbool search_by_pos = (identifier <= 100000000);\n\n\tif (git_reflog_read(&reflog, git_reference_owner(ref), git_reference_name(ref)) < 0)\n\t\treturn -1;\n\n\tnumentries = git_reflog_entrycount(reflog);\n\n\tif (search_by_pos) {\n\t\tif (numentries < identifier + 1)\n\t\t\tgoto notfound;\n\n\t\tentry = git_reflog_entry_byindex(reflog, identifier);\n\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t} else {\n\t\tsize_t i;\n\t\tgit_time commit_time;\n\n\t\tfor (i = 0; i < numentries; i++) {\n\t\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\t\tcommit_time = git_reflog_entry_committer(entry)->when;\n\n\t\t\tif (commit_time.time > (git_time_t)identifier)\n\t\t\t\tcontinue;\n\n\t\t\tgit_oid_cpy(oid, git_reflog_entry_id_new(entry));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numentries)\n\t\t\tgoto notfound;\n\t}\n\n\tgit_reflog_free(reflog);\n\treturn 0;\n\nnotfound:\n\tgiterr_set(\n\t\tGITERR_REFERENCE,\n\t\t\"Reflog for '%s' has only %\"PRIuZ\" entries, asked for %\"PRIuZ,\n\t\tgit_reference_name(ref), numentries, identifier);\n\n\tgit_reflog_free(reflog);\n\treturn GIT_ENOTFOUND;\n}"
  },
  {
    "function_name": "retrieve_previously_checked_out_branch_or_revision",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "140-203",
    "snippet": "static int retrieve_previously_checked_out_branch_or_revision(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref = NULL;\n\tgit_reflog *reflog = NULL;\n\tregex_t preg;\n\tint error = -1;\n\tsize_t i, numentries, cur;\n\tconst git_reflog_entry *entry;\n\tconst char *msg;\n\tregmatch_t regexmatches[2];\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tcur = position;\n\n\tif (*identifier != '\\0' || *base_ref != NULL)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (build_regex(&preg, \"checkout: moving from (.*) to .*\") < 0)\n\t\treturn -1;\n\n\tif (git_reference_lookup(&ref, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reflog_read(&reflog, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tnumentries  = git_reflog_entrycount(reflog);\n\n\tfor (i = 0; i < numentries; i++) {\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\tmsg = git_reflog_entry_message(entry);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tif (regexec(&preg, msg, 2, regexmatches, 0))\n\t\t\tcontinue;\n\n\t\tcur--;\n\n\t\tif (cur > 0)\n\t\t\tcontinue;\n\n\t\tgit_buf_put(&buf, msg+regexmatches[1].rm_so, regexmatches[1].rm_eo - regexmatches[1].rm_so);\n\n\t\tif ((error = git_reference_dwim(base_ref, repo, git_buf_cstr(&buf))) == 0)\n\t\t\tgoto cleanup;\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\terror = maybe_abbrev(out, repo, git_buf_cstr(&buf));\n\n\t\tgoto cleanup;\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ncleanup:\n\tgit_reference_free(ref);\n\tgit_buf_free(&buf);\n\tregfree(&preg);\n\tgit_reflog_free(reflog);\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reflog_free",
          "args": [
            "reflog"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "29-49",
          "snippet": "void git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&preg"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&buf"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "ref"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_abbrev",
          "args": [
            "out",
            "repo",
            "git_buf_cstr(&buf)"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_abbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "37-42",
          "snippet": "static int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&buf"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_dwim",
          "args": [
            "base_ref",
            "repo",
            "git_buf_cstr(&buf)"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_dwim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "236-298",
          "snippet": "int git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&buf",
            "msg+regexmatches[1].rm_so",
            "regexmatches[1].rm_eo - regexmatches[1].rm_so"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "&preg",
            "msg",
            "2",
            "regexmatches",
            "0"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_message",
          "args": [
            "entry"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "180-184",
          "snippet": "const char * git_reflog_entry_message(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn entry->msg;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst char * git_reflog_entry_message(const git_reflog_entry *entry)\n{\n\tassert(entry);\n\treturn entry->msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entry_byindex",
          "args": [
            "reflog",
            "i"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "151-160",
          "snippet": "const git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nconst git_reflog_entry * git_reflog_entry_byindex(const git_reflog *reflog, size_t idx)\n{\n\tassert(reflog);\n\n\tif (idx >= reflog->entries.length)\n\t\treturn NULL;\n\n\treturn git_vector_get(\n\t\t&reflog->entries, reflog_inverse_index(idx, reflog->entries.length));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_entrycount",
          "args": [
            "reflog"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "145-149",
          "snippet": "size_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nsize_t git_reflog_entrycount(git_reflog *reflog)\n{\n\tassert(reflog);\n\treturn reflog->entries.length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_read",
          "args": [
            "&reflog",
            "repo",
            "GIT_HEAD_FILE"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "51-62",
          "snippet": "int git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nint git_reflog_read(git_reflog **reflog, git_repository *repo,  const char *name)\n{\n\tgit_refdb *refdb;\n\tint error;\n\n\tassert(reflog && repo && name);\n\n\tif ((error = git_repository_refdb__weakptr(&refdb, repo)) < 0)\n\t\treturn error;\n\n\treturn git_refdb_reflog_read(reflog, refdb, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&ref",
            "repo",
            "GIT_HEAD_FILE"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_regex",
          "args": [
            "&preg",
            "\"checkout: moving from (.*) to .*\""
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "build_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "44-62",
          "snippet": "static int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int retrieve_previously_checked_out_branch_or_revision(git_object **out, git_reference **base_ref, git_repository *repo, const char *identifier, size_t position)\n{\n\tgit_reference *ref = NULL;\n\tgit_reflog *reflog = NULL;\n\tregex_t preg;\n\tint error = -1;\n\tsize_t i, numentries, cur;\n\tconst git_reflog_entry *entry;\n\tconst char *msg;\n\tregmatch_t regexmatches[2];\n\tgit_buf buf = GIT_BUF_INIT;\n\n\tcur = position;\n\n\tif (*identifier != '\\0' || *base_ref != NULL)\n\t\treturn GIT_EINVALIDSPEC;\n\n\tif (build_regex(&preg, \"checkout: moving from (.*) to .*\") < 0)\n\t\treturn -1;\n\n\tif (git_reference_lookup(&ref, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tif (git_reflog_read(&reflog, repo, GIT_HEAD_FILE) < 0)\n\t\tgoto cleanup;\n\n\tnumentries  = git_reflog_entrycount(reflog);\n\n\tfor (i = 0; i < numentries; i++) {\n\t\tentry = git_reflog_entry_byindex(reflog, i);\n\t\tmsg = git_reflog_entry_message(entry);\n\t\tif (!msg)\n\t\t\tcontinue;\n\n\t\tif (regexec(&preg, msg, 2, regexmatches, 0))\n\t\t\tcontinue;\n\n\t\tcur--;\n\n\t\tif (cur > 0)\n\t\t\tcontinue;\n\n\t\tgit_buf_put(&buf, msg+regexmatches[1].rm_so, regexmatches[1].rm_eo - regexmatches[1].rm_so);\n\n\t\tif ((error = git_reference_dwim(base_ref, repo, git_buf_cstr(&buf))) == 0)\n\t\t\tgoto cleanup;\n\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\n\t\terror = maybe_abbrev(out, repo, git_buf_cstr(&buf));\n\n\t\tgoto cleanup;\n\t}\n\n\terror = GIT_ENOTFOUND;\n\ncleanup:\n\tgit_reference_free(ref);\n\tgit_buf_free(&buf);\n\tregfree(&preg);\n\tgit_reflog_free(reflog);\n\treturn error;\n}"
  },
  {
    "function_name": "try_parse_numeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "125-138",
    "snippet": "static int try_parse_numeric(int *n, const char *curly_braces_content)\n{\n\tint32_t content;\n\tconst char *end_ptr;\n\n\tif (git__strtol32(&content, curly_braces_content, &end_ptr, 10) < 0)\n\t\treturn -1;\n\n\tif (*end_ptr != '\\0')\n\t\treturn -1;\n\n\t*n = (int)content;\n\treturn 0;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strtol32",
          "args": [
            "&content",
            "curly_braces_content",
            "&end_ptr",
            "10"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "git__strtol32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "149-167",
          "snippet": "int git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strtol32(int32_t *result, const char *nptr, const char **endptr, int base)\n{\n\tint error;\n\tint32_t tmp_int;\n\tint64_t tmp_long;\n\n\tif ((error = git__strtol64(&tmp_long, nptr, endptr, base)) < 0)\n\t\treturn error;\n\n\ttmp_int = tmp_long & 0xFFFFFFFF;\n\tif (tmp_int != tmp_long) {\n\t\tgiterr_set(GITERR_INVALID, \"Failed to convert. '%s' is too large\", nptr);\n\t\treturn -1;\n\t}\n\n\t*result = tmp_int;\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int try_parse_numeric(int *n, const char *curly_braces_content)\n{\n\tint32_t content;\n\tconst char *end_ptr;\n\n\tif (git__strtol32(&content, curly_braces_content, &end_ptr, 10) < 0)\n\t\treturn -1;\n\n\tif (*end_ptr != '\\0')\n\t\treturn -1;\n\n\t*n = (int)content;\n\treturn 0;\n}"
  },
  {
    "function_name": "revparse_lookup_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "87-123",
    "snippet": "static int revparse_lookup_object(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = maybe_sha(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\terror = git_reference_dwim(&ref, repo, spec);\n\tif (!error) {\n\n\t\terror = git_object_lookup(\n\t\t\tobject_out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\n\t\tif (!error)\n\t\t\t*reference_out = ref;\n\n\t\treturn error;\n\t}\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tif ((strlen(spec) < GIT_OID_HEXSZ) &&\n\t\t((error = maybe_abbrev(object_out, repo, spec)) != GIT_ENOTFOUND))\n\t\t\treturn error;\n\n\tif ((error = maybe_describe(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgiterr_set(GITERR_REFERENCE, \"Revspec '%s' not found.\", spec);\n\treturn GIT_ENOTFOUND;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Revspec '%s' not found.\"",
            "spec"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_describe",
          "args": [
            "object_out",
            "repo",
            "spec"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_describe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "64-85",
          "snippet": "static int maybe_describe(git_object**out, git_repository *repo, const char *spec)\n{\n\tconst char *substr;\n\tint error;\n\tregex_t regex;\n\n\tsubstr = strstr(spec, \"-g\");\n\n\tif (substr == NULL)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (build_regex(&regex, \".+-[0-9]+-g[0-9a-fA-F]+\") < 0)\n\t\treturn -1;\n\n\terror = regexec(&regex, spec, 0, NULL, 0);\n\tregfree(&regex);\n\n\tif (error)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_abbrev(out, repo, substr+2);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_describe(git_object**out, git_repository *repo, const char *spec)\n{\n\tconst char *substr;\n\tint error;\n\tregex_t regex;\n\n\tsubstr = strstr(spec, \"-g\");\n\n\tif (substr == NULL)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (build_regex(&regex, \".+-[0-9]+-g[0-9a-fA-F]+\") < 0)\n\t\treturn -1;\n\n\terror = regexec(&regex, spec, 0, NULL, 0);\n\tregfree(&regex);\n\n\tif (error)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_abbrev(out, repo, substr+2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_abbrev",
          "args": [
            "object_out",
            "repo",
            "spec"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_abbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "37-42",
          "snippet": "static int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "spec"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "object_out",
            "repo",
            "git_reference_target(ref)",
            "GIT_OBJ_ANY"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_dwim",
          "args": [
            "&ref",
            "repo",
            "spec"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_dwim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "236-298",
          "snippet": "int git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_dwim(git_reference **out, git_repository *repo, const char *refname)\n{\n\tint error = 0, i;\n\tbool fallbackmode = true, foundvalid = false;\n\tgit_reference *ref;\n\tgit_buf refnamebuf = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\n\tstatic const char* formatters[] = {\n\t\t\"%s\",\n\t\tGIT_REFS_DIR \"%s\",\n\t\tGIT_REFS_TAGS_DIR \"%s\",\n\t\tGIT_REFS_HEADS_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s\",\n\t\tGIT_REFS_REMOTES_DIR \"%s/\" GIT_HEAD_FILE,\n\t\tNULL\n\t};\n\n\tif (*refname)\n\t\tgit_buf_puts(&name, refname);\n\telse {\n\t\tgit_buf_puts(&name, GIT_HEAD_FILE);\n\t\tfallbackmode = false;\n\t}\n\n\tfor (i = 0; formatters[i] && (fallbackmode || i == 0); i++) {\n\n\t\tgit_buf_clear(&refnamebuf);\n\n\t\tif ((error = git_buf_printf(&refnamebuf, formatters[i], git_buf_cstr(&name))) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif (!git_reference_is_valid_name(git_buf_cstr(&refnamebuf))) {\n\t\t\terror = GIT_EINVALIDSPEC;\n\t\t\tcontinue;\n\t\t}\n\t\tfoundvalid = true;\n\n\t\terror = git_reference_lookup_resolved(&ref, repo, git_buf_cstr(&refnamebuf), -1);\n\n\t\tif (!error) {\n\t\t\t*out = ref;\n\t\t\terror = 0;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tif (error && !foundvalid) {\n\t\t/* never found a valid reference name */\n\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\"Could not use '%s' as valid reference name\", git_buf_cstr(&name));\n\t}\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgiterr_set(GITERR_REFERENCE, \"no reference found for shorthand '%s'\", refname);\n\n\tgit_buf_free(&name);\n\tgit_buf_free(&refnamebuf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_sha",
          "args": [
            "object_out",
            "repo",
            "spec"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_sha",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "27-35",
          "snippet": "static int maybe_sha(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\tif (speclen != GIT_OID_HEXSZ)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_sha(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\tif (speclen != GIT_OID_HEXSZ)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int revparse_lookup_object(\n\tgit_object **object_out,\n\tgit_reference **reference_out,\n\tgit_repository *repo,\n\tconst char *spec)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = maybe_sha(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\terror = git_reference_dwim(&ref, repo, spec);\n\tif (!error) {\n\n\t\terror = git_object_lookup(\n\t\t\tobject_out, repo, git_reference_target(ref), GIT_OBJ_ANY);\n\n\t\tif (!error)\n\t\t\t*reference_out = ref;\n\n\t\treturn error;\n\t}\n\n\tif (error != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tif ((strlen(spec) < GIT_OID_HEXSZ) &&\n\t\t((error = maybe_abbrev(object_out, repo, spec)) != GIT_ENOTFOUND))\n\t\t\treturn error;\n\n\tif ((error = maybe_describe(object_out, repo, spec)) != GIT_ENOTFOUND)\n\t\treturn error;\n\n\tgiterr_set(GITERR_REFERENCE, \"Revspec '%s' not found.\", spec);\n\treturn GIT_ENOTFOUND;\n}"
  },
  {
    "function_name": "maybe_describe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "64-85",
    "snippet": "static int maybe_describe(git_object**out, git_repository *repo, const char *spec)\n{\n\tconst char *substr;\n\tint error;\n\tregex_t regex;\n\n\tsubstr = strstr(spec, \"-g\");\n\n\tif (substr == NULL)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (build_regex(&regex, \".+-[0-9]+-g[0-9a-fA-F]+\") < 0)\n\t\treturn -1;\n\n\terror = regexec(&regex, spec, 0, NULL, 0);\n\tregfree(&regex);\n\n\tif (error)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_abbrev(out, repo, substr+2);\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_abbrev",
          "args": [
            "out",
            "repo",
            "substr+2"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_abbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "37-42",
          "snippet": "static int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&regex"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "&regex",
            "spec",
            "0",
            "NULL",
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_regex",
          "args": [
            "&regex",
            "\".+-[0-9]+-g[0-9a-fA-F]+\""
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "build_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "44-62",
          "snippet": "static int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "spec",
            "\"-g\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_describe(git_object**out, git_repository *repo, const char *spec)\n{\n\tconst char *substr;\n\tint error;\n\tregex_t regex;\n\n\tsubstr = strstr(spec, \"-g\");\n\n\tif (substr == NULL)\n\t\treturn GIT_ENOTFOUND;\n\n\tif (build_regex(&regex, \".+-[0-9]+-g[0-9a-fA-F]+\") < 0)\n\t\treturn -1;\n\n\terror = regexec(&regex, spec, 0, NULL, 0);\n\tregfree(&regex);\n\n\tif (error)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_abbrev(out, repo, substr+2);\n}"
  },
  {
    "function_name": "build_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "44-62",
    "snippet": "static int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "regex"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set_regex",
          "args": [
            "regex",
            "error"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_regex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "106-119",
          "snippet": "int giterr_set_regex(const regex_t *regex, int error_code)\n{\n\tchar error_buf[1024];\n\n\tassert(error_code);\n\n\tregerror(error_code, regex, error_buf, sizeof(error_buf));\n\tgiterr_set_str(GITERR_REGEX, error_buf);\n\n\tif (error_code == REG_NOMATCH)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn GIT_EINVALIDSPEC;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nint giterr_set_regex(const regex_t *regex, int error_code)\n{\n\tchar error_buf[1024];\n\n\tassert(error_code);\n\n\tregerror(error_code, regex, error_buf, sizeof(error_buf));\n\tgiterr_set_str(GITERR_REGEX, error_buf);\n\n\tif (error_code == REG_NOMATCH)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn GIT_EINVALIDSPEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "regcomp",
          "args": [
            "regex",
            "pattern",
            "REG_EXTENDED"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REGEX",
            "\"Empty pattern\""
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int build_regex(regex_t *regex, const char *pattern)\n{\n\tint error;\n\n\tif (*pattern == '\\0') {\n\t\tgiterr_set(GITERR_REGEX, \"Empty pattern\");\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\terror = regcomp(regex, pattern, REG_EXTENDED);\n\tif (!error)\n\t\treturn 0;\n\n\terror = giterr_set_regex(regex, error);\n\n\tregfree(regex);\n\n\treturn error;\n}"
  },
  {
    "function_name": "maybe_abbrev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "37-42",
    "snippet": "static int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_sha_or_abbrev",
          "args": [
            "out",
            "repo",
            "spec",
            "speclen"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_sha_or_abbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "17-25",
          "snippet": "static int maybe_sha_or_abbrev(git_object** out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJ_ANY);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_sha_or_abbrev(git_object** out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJ_ANY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "spec"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_abbrev(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}"
  },
  {
    "function_name": "maybe_sha",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "27-35",
    "snippet": "static int maybe_sha(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\tif (speclen != GIT_OID_HEXSZ)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maybe_sha_or_abbrev",
          "args": [
            "out",
            "repo",
            "spec",
            "speclen"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_sha_or_abbrev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
          "lines": "17-25",
          "snippet": "static int maybe_sha_or_abbrev(git_object** out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJ_ANY);\n}",
          "includes": [
            "#include \"git2.h\"",
            "#include \"refdb.h\"",
            "#include \"tree.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_sha_or_abbrev(git_object** out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJ_ANY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "spec"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_sha(git_object** out, git_repository *repo, const char *spec)\n{\n\tsize_t speclen = strlen(spec);\n\n\tif (speclen != GIT_OID_HEXSZ)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn maybe_sha_or_abbrev(out, repo, spec, speclen);\n}"
  },
  {
    "function_name": "maybe_sha_or_abbrev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/revparse.c",
    "lines": "17-25",
    "snippet": "static int maybe_sha_or_abbrev(git_object** out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJ_ANY);\n}",
    "includes": [
      "#include \"git2.h\"",
      "#include \"refdb.h\"",
      "#include \"tree.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include <assert.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup_prefix",
          "args": [
            "out",
            "repo",
            "&oid",
            "speclen",
            "GIT_OBJ_ANY"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "110-195",
          "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromstrn",
          "args": [
            "&oid",
            "spec",
            "speclen"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstrn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "23-47",
          "snippet": "int git_oid_fromstrn(git_oid *out, const char *str, size_t length)\n{\n\tsize_t p;\n\tint v;\n\n\tassert(out && str);\n\n\tif (!length)\n\t\treturn oid_error_invalid(\"too short\");\n\n\tif (length > GIT_OID_HEXSZ)\n\t\treturn oid_error_invalid(\"too long\");\n\n\tmemset(out->id, 0, GIT_OID_RAWSZ);\n\n\tfor (p = 0; p < length; p++) {\n\t\tv = git__fromhex(str[p]);\n\t\tif (v < 0)\n\t\t\treturn oid_error_invalid(\"contains invalid characters\");\n\n\t\tout->id[p / 2] |= (unsigned char)(v << (p % 2 ? 0 : 4));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstrn(git_oid *out, const char *str, size_t length)\n{\n\tsize_t p;\n\tint v;\n\n\tassert(out && str);\n\n\tif (!length)\n\t\treturn oid_error_invalid(\"too short\");\n\n\tif (length > GIT_OID_HEXSZ)\n\t\treturn oid_error_invalid(\"too long\");\n\n\tmemset(out->id, 0, GIT_OID_RAWSZ);\n\n\tfor (p = 0; p < length; p++) {\n\t\tv = git__fromhex(str[p]);\n\t\tif (v < 0)\n\t\t\treturn oid_error_invalid(\"contains invalid characters\");\n\n\t\tout->id[p / 2] |= (unsigned char)(v << (p % 2 ? 0 : 4));\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"git2.h\"\n#include \"refdb.h\"\n#include \"tree.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include <assert.h>\n\nstatic int maybe_sha_or_abbrev(git_object** out, git_repository *repo, const char *spec, size_t speclen)\n{\n\tgit_oid oid;\n\n\tif (git_oid_fromstrn(&oid, spec, speclen) < 0)\n\t\treturn GIT_ENOTFOUND;\n\n\treturn git_object_lookup_prefix(out, repo, &oid, speclen, GIT_OBJ_ANY);\n}"
  }
]