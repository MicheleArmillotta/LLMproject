[
  {
    "function_name": "git_object__is_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "467-489",
    "snippet": "bool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool git_object__strict_input_validation = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"the requested type does not match the type in the ODB\""
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read_header",
          "args": [
            "&len",
            "&actual_type",
            "odb",
            "id"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "749-760",
          "snippet": "int git_odb_read_header(size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id)\n{\n\tint error;\n\tgit_odb_object *object;\n\n\terror = git_odb__read_header_or_object(&object, len_p, type_p, db, id);\n\n\tif (object)\n\t\tgit_odb_object_free(object);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read_header(size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id)\n{\n\tint error;\n\tgit_odb_object *object;\n\n\terror = git_odb__read_header_or_object(&object, len_p, type_p, db, id);\n\n\tif (object)\n\t\tgit_odb_object_free(object);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nbool git_object__strict_input_validation = true;\n\nbool git_object__is_valid(\n\tgit_repository *repo, const git_oid *id, git_otype expected_type)\n{\n\tgit_odb *odb;\n\tgit_otype actual_type;\n\tsize_t len;\n\tint error;\n\n\tif (!git_object__strict_input_validation)\n\t\treturn true;\n\n\tif ((error = git_repository_odb__weakptr(&odb, repo)) < 0 ||\n\t\t(error = git_odb_read_header(&len, &actual_type, odb, id)) < 0)\n\t\treturn false;\n\n\tif (expected_type != GIT_OBJ_ANY && expected_type != actual_type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"the requested type does not match the type in the ODB\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "git_object_short_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "425-465",
    "snippet": "int git_object_short_id(git_buf *out, const git_object *obj)\n{\n\tgit_repository *repo;\n\tint len = GIT_ABBREV_DEFAULT, error;\n\tgit_oid id = {{0}};\n\tgit_odb *odb;\n\n\tassert(out && obj);\n\n\tgit_buf_sanitize(out);\n\trepo = git_object_owner(obj);\n\n\tif ((error = git_repository__cvar(&len, repo, GIT_CVAR_ABBREV)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\treturn error;\n\n\twhile (len < GIT_OID_HEXSZ) {\n\t\t/* set up short oid */\n\t\tmemcpy(&id.id, &obj->cached.oid.id, (len + 1) / 2);\n\t\tif (len & 1)\n\t\t\tid.id[len / 2] &= 0xf0;\n\n\t\terror = git_odb_exists_prefix(NULL, odb, &id, len);\n\t\tif (error != GIT_EAMBIGUOUS)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\tlen++;\n\t}\n\n\tif (!error && !(error = git_buf_grow(out, len + 1))) {\n\t\tgit_oid_tostr(out->ptr, len + 1, &id);\n\t\tout->size = len;\n\t}\n\n\tgit_odb_free(odb);\n\n\treturn error;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_free",
          "args": [
            "odb"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "619-625",
          "snippet": "void git_odb_free(git_odb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, odb_free);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_free(git_odb *db)\n{\n\tif (db == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(db, odb_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr",
          "args": [
            "out->ptr",
            "len + 1",
            "&id"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "119-131",
          "snippet": "char *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_grow",
          "args": [
            "out",
            "len + 1"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_grow_by",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "106-116",
          "snippet": "int git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nint git_buf_grow_by(git_buf *buffer, size_t additional_size)\n{\n\tsize_t newsize;\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&newsize, buffer->size, additional_size)) {\n\t\tbuffer->ptr = git_buf__oom;\n\t\treturn -1;\n\t}\n\n\treturn git_buf_try_grow(buffer, newsize, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_exists_prefix",
          "args": [
            "NULL",
            "odb",
            "&id",
            "len"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_exists_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "709-747",
          "snippet": "int git_odb_exists_prefix(\n\tgit_oid *out, git_odb *db, const git_oid *short_id, size_t len)\n{\n\tint error;\n\tgit_oid key = {{0}}; \n\n\tassert(db && short_id);\n\n\tif (len < GIT_OID_MINPREFIXLEN)\n\t\treturn git_odb__error_ambiguous(\"prefix length too short\");\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tif (git_odb_exists(db, short_id)) {\n\t\t\tif (out)\n\t\t\t\tgit_oid_cpy(out, short_id);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn git_odb__error_notfound(\n\t\t\t\t\"no match for id prefix\", short_id, len);\n\t\t}\n\t}\n\n\t/* just copy valid part of short_id */\n\tmemcpy(&key.id, short_id->id, (len + 1) / 2);\n\tif (len & 1)\n\t\tkey.id[len / 2] &= 0xF0;\n\n\terror = odb_exists_prefix_1(out, db, &key, len, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_exists_prefix_1(out, db, &key, len, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id prefix\", &key, len);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_exists_prefix(\n\tgit_oid *out, git_odb *db, const git_oid *short_id, size_t len)\n{\n\tint error;\n\tgit_oid key = {{0}}; \n\n\tassert(db && short_id);\n\n\tif (len < GIT_OID_MINPREFIXLEN)\n\t\treturn git_odb__error_ambiguous(\"prefix length too short\");\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tif (git_odb_exists(db, short_id)) {\n\t\t\tif (out)\n\t\t\t\tgit_oid_cpy(out, short_id);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn git_odb__error_notfound(\n\t\t\t\t\"no match for id prefix\", short_id, len);\n\t\t}\n\t}\n\n\t/* just copy valid part of short_id */\n\tmemcpy(&key.id, short_id->id, (len + 1) / 2);\n\tif (len & 1)\n\t\tkey.id[len / 2] &= 0xF0;\n\n\terror = odb_exists_prefix_1(out, db, &key, len, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_exists_prefix_1(out, db, &key, len, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id prefix\", &key, len);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&id.id",
            "&obj->cached.oid.id",
            "(len + 1) / 2"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_repository_odb",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "764-771",
          "snippet": "int git_repository_odb(git_odb **out, git_repository *repo)\n{\n\tif (git_repository_odb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb(git_odb **out, git_repository *repo)\n{\n\tif (git_repository_odb__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&len",
            "repo",
            "GIT_CVAR_ABBREV"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "obj"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sanitize",
          "args": [
            "out"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sanitize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "128-135",
          "snippet": "void git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_sanitize(git_buf *buf)\n{\n\tif (buf->ptr == NULL) {\n\t\tassert(buf->size == 0 && buf->asize == 0);\n\t\tbuf->ptr = git_buf__initbuf;\n\t} else if (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && obj"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_short_id(git_buf *out, const git_object *obj)\n{\n\tgit_repository *repo;\n\tint len = GIT_ABBREV_DEFAULT, error;\n\tgit_oid id = {{0}};\n\tgit_odb *odb;\n\n\tassert(out && obj);\n\n\tgit_buf_sanitize(out);\n\trepo = git_object_owner(obj);\n\n\tif ((error = git_repository__cvar(&len, repo, GIT_CVAR_ABBREV)) < 0)\n\t\treturn error;\n\n\tif ((error = git_repository_odb(&odb, repo)) < 0)\n\t\treturn error;\n\n\twhile (len < GIT_OID_HEXSZ) {\n\t\t/* set up short oid */\n\t\tmemcpy(&id.id, &obj->cached.oid.id, (len + 1) / 2);\n\t\tif (len & 1)\n\t\t\tid.id[len / 2] &= 0xf0;\n\n\t\terror = git_odb_exists_prefix(NULL, odb, &id, len);\n\t\tif (error != GIT_EAMBIGUOUS)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\tlen++;\n\t}\n\n\tif (!error && !(error = git_buf_grow(out, len + 1))) {\n\t\tgit_oid_tostr(out->ptr, len + 1, &id);\n\t\tout->size = len;\n\t}\n\n\tgit_odb_free(odb);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_object_lookup_bypath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "390-423",
    "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "tree"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_free",
          "args": [
            "entry"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "229-235",
          "snippet": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_to_object",
          "args": [
            "out",
            "git_object_owner(treeish)",
            "entry"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_to_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "296-303",
          "snippet": "int git_tree_entry_to_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_tree_entry *entry)\n{\n\tassert(entry && object_out);\n\treturn git_object_lookup(object_out, repo, entry->oid, GIT_OBJ_ANY);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_entry_to_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_tree_entry *entry)\n{\n\tassert(entry && object_out);\n\treturn git_object_lookup(object_out, repo, entry->oid, GIT_OBJ_ANY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_owner",
          "args": [
            "treeish"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "221-225",
          "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"object at path '%s' is not of the asked-for type %d\"",
            "path",
            "type"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_type",
          "args": [
            "entry"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "284-294",
          "snippet": "git_otype git_tree_entry_type(const git_tree_entry *entry)\n{\n\tassert(entry);\n\n\tif (S_ISGITLINK(entry->attr))\n\t\treturn GIT_OBJ_COMMIT;\n\telse if (S_ISDIR(entry->attr))\n\t\treturn GIT_OBJ_TREE;\n\telse\n\t\treturn GIT_OBJ_BLOB;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\ngit_otype git_tree_entry_type(const git_tree_entry *entry)\n{\n\tassert(entry);\n\n\tif (S_ISGITLINK(entry->attr))\n\t\treturn GIT_OBJ_COMMIT;\n\telse if (S_ISDIR(entry->attr))\n\t\treturn GIT_OBJ_TREE;\n\telse\n\t\treturn GIT_OBJ_BLOB;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_bypath",
          "args": [
            "&entry",
            "tree",
            "path"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "897-957",
          "snippet": "int git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_peel",
          "args": [
            "(git_object**)&tree",
            "treeish",
            "GIT_OBJ_TREE"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "327-381",
          "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && treeish && path"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
  },
  {
    "function_name": "git_object_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "383-388",
    "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_cached_obj_incref",
          "args": [
            "source"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "git_cached_obj_incref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cache.h",
          "lines": "59-63",
          "snippet": "GIT_INLINE(void) git_cached_obj_incref(void *_obj)\n{\n\tgit_cached_obj *obj = _obj;\n\tgit_atomic_inc(&obj->refcount);\n}",
          "includes": [
            "#include \"oidmap.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"oidmap.h\"\n#include \"thread-utils.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(void) git_cached_obj_incref(void *_obj)\n{\n\tgit_cached_obj *obj = _obj;\n\tgit_atomic_inc(&obj->refcount);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_object_peel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "327-381",
    "snippet": "int git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "peel_error",
          "args": [
            "error",
            "git_object_id(object)",
            "target_type"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "peel_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "285-299",
          "snippet": "static int peel_error(int error, const git_oid *oid, git_otype type)\n{\n\tconst char *type_name;\n\tchar hex_oid[GIT_OID_HEXSZ + 1];\n\n\ttype_name = git_object_type2string(type);\n\n\tgit_oid_fmt(hex_oid, oid);\n\thex_oid[GIT_OID_HEXSZ] = '\\0';\n\n\tgiterr_set(GITERR_OBJECT, \"The git_object of id '%s' can not be \"\n\t\t\"successfully peeled into a %s (git_otype=%i).\", hex_oid, type_name, type);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic int peel_error(int error, const git_oid *oid, git_otype type)\n{\n\tconst char *type_name;\n\tchar hex_oid[GIT_OID_HEXSZ + 1];\n\n\ttype_name = git_object_type2string(type);\n\n\tgit_oid_fmt(hex_oid, oid);\n\thex_oid[GIT_OID_HEXSZ] = '\\0';\n\n\tgiterr_set(GITERR_OBJECT, \"The git_object of id '%s' can not be \"\n\t\t\"successfully peeled into a %s (git_otype=%i).\", hex_oid, type_name, type);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_id",
          "args": [
            "object"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "209-213",
          "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "deref"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "object"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dereference_object",
          "args": [
            "&deref",
            "source"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "dereference_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "265-283",
          "snippet": "static int dereference_object(git_object **dereferenced, git_object *obj)\n{\n\tgit_otype type = git_object_type(obj);\n\n\tswitch (type) {\n\tcase GIT_OBJ_COMMIT:\n\t\treturn git_commit_tree((git_tree **)dereferenced, (git_commit*)obj);\n\n\tcase GIT_OBJ_TAG:\n\t\treturn git_tag_target(dereferenced, (git_tag*)obj);\n\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\treturn GIT_EPEEL;\n\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic int dereference_object(git_object **dereferenced, git_object *obj)\n{\n\tgit_otype type = git_object_type(obj);\n\n\tswitch (type) {\n\tcase GIT_OBJ_COMMIT:\n\t\treturn git_commit_tree((git_tree **)dereferenced, (git_commit*)obj);\n\n\tcase GIT_OBJ_TAG:\n\t\treturn git_tag_target(dereferenced, (git_tag*)obj);\n\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\treturn GIT_EPEEL;\n\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_dup",
          "args": [
            "peeled",
            "(git_object *)object"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "383-388",
          "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_type_combination",
          "args": [
            "git_object_type(object)",
            "target_type"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "check_type_combination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "301-325",
          "snippet": "static int check_type_combination(git_otype type, git_otype target)\n{\n\tif (type == target)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\t/* a blob or tree can never be peeled to anything but themselves */\n\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\t/* a commit can only be peeled to a tree */\n\t\tif (target != GIT_OBJ_TREE && target != GIT_OBJ_ANY)\n\t\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\t/* a tag may point to anything, so we let anything through */\n\t\tbreak;\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic int check_type_combination(git_otype type, git_otype target)\n{\n\tif (type == target)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\t/* a blob or tree can never be peeled to anything but themselves */\n\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\t/* a commit can only be peeled to a tree */\n\t\tif (target != GIT_OBJ_TREE && target != GIT_OBJ_ANY)\n\t\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\t/* a tag may point to anything, so we let anything through */\n\t\tbreak;\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "object && peeled"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_peel(\n\tgit_object **peeled,\n\tconst git_object *object,\n\tgit_otype target_type)\n{\n\tgit_object *source, *deref = NULL;\n\tint error;\n\n\tassert(object && peeled);\n\n\tassert(target_type == GIT_OBJ_TAG ||\n\t\ttarget_type == GIT_OBJ_COMMIT ||\n\t\ttarget_type == GIT_OBJ_TREE ||\n\t\ttarget_type == GIT_OBJ_BLOB ||\n\t\ttarget_type == GIT_OBJ_ANY);\n\n\tif ((error = check_type_combination(git_object_type(object), target_type)) < 0)\n\t\treturn peel_error(error, git_object_id(object), target_type);\n\n\tif (git_object_type(object) == target_type)\n\t\treturn git_object_dup(peeled, (git_object *)object);\n\n\tsource = (git_object *)object;\n\n\twhile (!(error = dereference_object(&deref, source))) {\n\n\t\tif (source != object)\n\t\t\tgit_object_free(source);\n\n\t\tif (git_object_type(deref) == target_type) {\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (target_type == GIT_OBJ_ANY &&\n\t\t\tgit_object_type(deref) != git_object_type(object))\n\t\t{\n\t\t\t*peeled = deref;\n\t\t\treturn 0;\n\t\t}\n\n\t\tsource = deref;\n\t\tderef = NULL;\n\t}\n\n\tif (source != object)\n\t\tgit_object_free(source);\n\n\tgit_object_free(deref);\n\n\tif (error)\n\t\terror = peel_error(error, git_object_id(object), target_type);\n\n\treturn error;\n}"
  },
  {
    "function_name": "check_type_combination",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "301-325",
    "snippet": "static int check_type_combination(git_otype type, git_otype target)\n{\n\tif (type == target)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\t/* a blob or tree can never be peeled to anything but themselves */\n\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\t/* a commit can only be peeled to a tree */\n\t\tif (target != GIT_OBJ_TREE && target != GIT_OBJ_ANY)\n\t\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\t/* a tag may point to anything, so we let anything through */\n\t\tbreak;\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic int check_type_combination(git_otype type, git_otype target)\n{\n\tif (type == target)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\t/* a blob or tree can never be peeled to anything but themselves */\n\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_COMMIT:\n\t\t/* a commit can only be peeled to a tree */\n\t\tif (target != GIT_OBJ_TREE && target != GIT_OBJ_ANY)\n\t\t\treturn GIT_EINVALIDSPEC;\n\t\tbreak;\n\tcase GIT_OBJ_TAG:\n\t\t/* a tag may point to anything, so we let anything through */\n\t\tbreak;\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "peel_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "285-299",
    "snippet": "static int peel_error(int error, const git_oid *oid, git_otype type)\n{\n\tconst char *type_name;\n\tchar hex_oid[GIT_OID_HEXSZ + 1];\n\n\ttype_name = git_object_type2string(type);\n\n\tgit_oid_fmt(hex_oid, oid);\n\thex_oid[GIT_OID_HEXSZ] = '\\0';\n\n\tgiterr_set(GITERR_OBJECT, \"The git_object of id '%s' can not be \"\n\t\t\"successfully peeled into a %s (git_otype=%i).\", hex_oid, type_name, type);\n\n\treturn error;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OBJECT",
            "\"The git_object of id '%s' can not be \"\n\t\t\"successfully peeled into a %s (git_otype=%i).\"",
            "hex_oid",
            "type_name",
            "type"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "hex_oid",
            "oid"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type2string",
          "args": [
            "type"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_type2string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "227-233",
          "snippet": "const char *git_object_type2string(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn \"\";\n\n\treturn git_objects_table[type].str;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nconst char *git_object_type2string(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn \"\";\n\n\treturn git_objects_table[type].str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic int peel_error(int error, const git_oid *oid, git_otype type)\n{\n\tconst char *type_name;\n\tchar hex_oid[GIT_OID_HEXSZ + 1];\n\n\ttype_name = git_object_type2string(type);\n\n\tgit_oid_fmt(hex_oid, oid);\n\thex_oid[GIT_OID_HEXSZ] = '\\0';\n\n\tgiterr_set(GITERR_OBJECT, \"The git_object of id '%s' can not be \"\n\t\t\"successfully peeled into a %s (git_otype=%i).\", hex_oid, type_name, type);\n\n\treturn error;\n}"
  },
  {
    "function_name": "dereference_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "265-283",
    "snippet": "static int dereference_object(git_object **dereferenced, git_object *obj)\n{\n\tgit_otype type = git_object_type(obj);\n\n\tswitch (type) {\n\tcase GIT_OBJ_COMMIT:\n\t\treturn git_commit_tree((git_tree **)dereferenced, (git_commit*)obj);\n\n\tcase GIT_OBJ_TAG:\n\t\treturn git_tag_target(dereferenced, (git_tag*)obj);\n\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\treturn GIT_EPEEL;\n\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tag_target",
          "args": [
            "dereferenced",
            "(git_tag*)obj"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "27-31",
          "snippet": "int git_tag_target(git_object **target, const git_tag *t)\n{\n\tassert(t);\n\treturn git_object_lookup(target, t->object.repo, &t->target, t->type);\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tag_target(git_object **target, const git_tag *t)\n{\n\tassert(t);\n\treturn git_object_lookup(target, t->object.repo, &t->target, t->type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "(git_tree **)dereferenced",
            "(git_commit*)obj"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "obj"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic int dereference_object(git_object **dereferenced, git_object *obj)\n{\n\tgit_otype type = git_object_type(obj);\n\n\tswitch (type) {\n\tcase GIT_OBJ_COMMIT:\n\t\treturn git_commit_tree((git_tree **)dereferenced, (git_commit*)obj);\n\n\tcase GIT_OBJ_TAG:\n\t\treturn git_tag_target(dereferenced, (git_tag*)obj);\n\n\tcase GIT_OBJ_BLOB:\n\tcase GIT_OBJ_TREE:\n\t\treturn GIT_EPEEL;\n\n\tdefault:\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n}"
  },
  {
    "function_name": "git_object__size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "257-263",
    "snippet": "size_t git_object__size(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn git_objects_table[type].size;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "git_objects_table"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nsize_t git_object__size(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn git_objects_table[type].size;\n}"
  },
  {
    "function_name": "git_object_typeisloose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "249-255",
    "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "git_objects_table"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
  },
  {
    "function_name": "git_object_string2type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "235-247",
    "snippet": "git_otype git_object_string2type(const char *str)\n{\n\tsize_t i;\n\n\tif (!str || !*str)\n\t\treturn GIT_OBJ_BAD;\n\n\tfor (i = 0; i < ARRAY_SIZE(git_objects_table); i++)\n\t\tif (!strcmp(str, git_objects_table[i].str))\n\t\t\treturn (git_otype)i;\n\n\treturn GIT_OBJ_BAD;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "git_objects_table[i].str"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "git_objects_table"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\ngit_otype git_object_string2type(const char *str)\n{\n\tsize_t i;\n\n\tif (!str || !*str)\n\t\treturn GIT_OBJ_BAD;\n\n\tfor (i = 0; i < ARRAY_SIZE(git_objects_table); i++)\n\t\tif (!strcmp(str, git_objects_table[i].str))\n\t\t\treturn (git_otype)i;\n\n\treturn GIT_OBJ_BAD;\n}"
  },
  {
    "function_name": "git_object_type2string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "227-233",
    "snippet": "const char *git_object_type2string(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn \"\";\n\n\treturn git_objects_table[type].str;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "git_objects_table"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nconst char *git_object_type2string(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn \"\";\n\n\treturn git_objects_table[type].str;\n}"
  },
  {
    "function_name": "git_object_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "221-225",
    "snippet": "git_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "obj"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_object_owner(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->repo;\n}"
  },
  {
    "function_name": "git_object_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "215-219",
    "snippet": "git_otype git_object_type(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->cached.type;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "obj"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_otype git_object_type(const git_object *obj)\n{\n\tassert(obj);\n\treturn obj->cached.type;\n}"
  },
  {
    "function_name": "git_object_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "209-213",
    "snippet": "const git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "obj"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_object_id(const git_object *obj)\n{\n\tassert(obj);\n\treturn &obj->cached.oid;\n}"
  },
  {
    "function_name": "git_object_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "201-207",
    "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_cached_obj_decref",
          "args": [
            "object"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git_cached_obj_decref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cache.c",
          "lines": "262-281",
          "snippet": "void git_cached_obj_decref(void *_obj)\n{\n\tgit_cached_obj *obj = _obj;\n\n\tif (git_atomic_dec(&obj->refcount) == 0) {\n\t\tswitch (obj->flags) {\n\t\tcase GIT_CACHE_STORE_RAW:\n\t\t\tgit_odb_object__free(_obj);\n\t\t\tbreak;\n\n\t\tcase GIT_CACHE_STORE_PARSED:\n\t\t\tgit_object__free(_obj);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgit__free(_obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"object.h\"",
            "#include \"odb.h\"",
            "#include \"cache.h\"",
            "#include \"util.h\"",
            "#include \"thread-utils.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"object.h\"\n#include \"odb.h\"\n#include \"cache.h\"\n#include \"util.h\"\n#include \"thread-utils.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid git_cached_obj_decref(void *_obj)\n{\n\tgit_cached_obj *obj = _obj;\n\n\tif (git_atomic_dec(&obj->refcount) == 0) {\n\t\tswitch (obj->flags) {\n\t\tcase GIT_CACHE_STORE_RAW:\n\t\t\tgit_odb_object__free(_obj);\n\t\t\tbreak;\n\n\t\tcase GIT_CACHE_STORE_PARSED:\n\t\t\tgit_object__free(_obj);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgit__free(_obj);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
  },
  {
    "function_name": "git_object_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "197-199",
    "snippet": "int git_object_lookup(git_object **object_out, git_repository *repo, const git_oid *id, git_otype type) {\n\treturn git_object_lookup_prefix(object_out, repo, id, GIT_OID_HEXSZ, type);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_lookup_prefix",
          "args": [
            "object_out",
            "repo",
            "id",
            "GIT_OID_HEXSZ",
            "type"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "110-195",
          "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup(git_object **object_out, git_repository *repo, const git_oid *id, git_otype type) {\n\treturn git_object_lookup_prefix(object_out, repo, id, GIT_OID_HEXSZ, type);\n}"
  },
  {
    "function_name": "git_object_lookup_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "110-195",
    "snippet": "int git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_odb_object_free",
          "args": [
            "odb_obj"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "137-143",
          "snippet": "void git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nvoid git_odb_object_free(git_odb_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__from_odb_object",
          "args": [
            "object_out",
            "repo",
            "odb_obj",
            "type"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__from_odb_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "52-97",
          "snippet": "int git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read_prefix",
          "args": [
            "&odb_obj",
            "odb",
            "&short_oid",
            "len"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "933-967",
          "snippet": "int git_odb_read_prefix(\n\tgit_odb_object **out, git_odb *db, const git_oid *short_id, size_t len)\n{\n\tgit_oid key = {{0}};\n\tint error;\n\n\tassert(out && db);\n\n\tif (len < GIT_OID_MINPREFIXLEN)\n\t\treturn git_odb__error_ambiguous(\"prefix length too short\");\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\t*out = git_cache_get_raw(odb_cache(db), short_id);\n\t\tif (*out != NULL)\n\t\t\treturn 0;\n\t}\n\n\t/* just copy valid part of short_id */\n\tmemcpy(&key.id, short_id->id, (len + 1) / 2);\n\tif (len & 1)\n\t\tkey.id[len / 2] &= 0xF0;\n\n\terror = read_prefix_1(out, db, &key, len, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = read_prefix_1(out, db, &key, len, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for prefix\", &key, len);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read_prefix(\n\tgit_odb_object **out, git_odb *db, const git_oid *short_id, size_t len)\n{\n\tgit_oid key = {{0}};\n\tint error;\n\n\tassert(out && db);\n\n\tif (len < GIT_OID_MINPREFIXLEN)\n\t\treturn git_odb__error_ambiguous(\"prefix length too short\");\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\t*out = git_cache_get_raw(odb_cache(db), short_id);\n\t\tif (*out != NULL)\n\t\t\treturn 0;\n\t}\n\n\t/* just copy valid part of short_id */\n\tmemcpy(&key.id, short_id->id, (len + 1) / 2);\n\tif (len & 1)\n\t\tkey.id[len / 2] &= 0xF0;\n\n\terror = read_prefix_1(out, db, &key, len, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = read_prefix_1(out, db, &key, len, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for prefix\", &key, len);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid__cpy_prefix",
          "args": [
            "&short_oid",
            "id",
            "len"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cpy_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "47-54",
          "snippet": "GIT_INLINE(void) git_oid__cpy_prefix(\n\tgit_oid *out, const git_oid *id, size_t len)\n{\n\tmemcpy(&out->id, id->id, (len + 1) / 2);\n\n\tif (len & 1)\n\t\tout->id[len / 2] &= 0xF0;\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(void) git_oid__cpy_prefix(\n\tgit_oid *out, const git_oid *id, size_t len)\n{\n\tmemcpy(&out->id, id->id, (len + 1) / 2);\n\n\tif (len & 1)\n\t\tout->id[len / 2] &= 0xF0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb_read",
          "args": [
            "&odb_obj",
            "odb",
            "id"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "862-881",
          "snippet": "int git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb_read(git_odb_object **out, git_odb *db, const git_oid *id)\n{\n\tint error;\n\n\tassert(out && db && id);\n\n\t*out = git_cache_get_raw(odb_cache(db), id);\n\tif (*out != NULL)\n\t\treturn 0;\n\n\terror = odb_read_1(out, db, id, false);\n\n\tif (error == GIT_ENOTFOUND && !git_odb_refresh(db))\n\t\terror = odb_read_1(out, db, id, true);\n\n\tif (error == GIT_ENOTFOUND)\n\t\treturn git_odb__error_notfound(\"no match for id\", id, GIT_OID_HEXSZ);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!\"Wrong caching type in the global object cache\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"The requested type does not match the type in ODB\""
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "object"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_cache_get_any",
          "args": [
            "&repo->objects",
            "id"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "git_cache_get_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cache.c",
          "lines": "257-260",
          "snippet": "void *git_cache_get_any(git_cache *cache, const git_oid *oid)\n{\n\treturn cache_get(cache, oid, GIT_CACHE_STORE_ANY);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"object.h\"",
            "#include \"odb.h\"",
            "#include \"cache.h\"",
            "#include \"util.h\"",
            "#include \"thread-utils.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"object.h\"\n#include \"odb.h\"\n#include \"cache.h\"\n#include \"util.h\"\n#include \"thread-utils.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid *git_cache_get_any(git_cache *cache, const git_oid *oid)\n{\n\treturn cache_get(cache, oid, GIT_CACHE_STORE_ANY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_odb__weakptr",
          "args": [
            "&odb",
            "repo"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_odb__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "733-762",
          "snippet": "int git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_odb__weakptr(git_odb **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(repo && out);\n\n\tif (repo->_odb == NULL) {\n\t\tgit_buf odb_path = GIT_BUF_INIT;\n\t\tgit_odb *odb;\n\n\t\tif ((error = git_buf_joinpath(&odb_path, repo->path_repository, GIT_OBJECTS_DIR)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_odb_open(&odb, odb_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(odb, repo);\n\n\t\t\todb = git__compare_and_swap(&repo->_odb, NULL, odb);\n\t\t\tif (odb != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(odb, NULL);\n\t\t\t\tgit_odb_free(odb);\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&odb_path);\n\t}\n\n\t*out = repo->_odb;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && object_out && id"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_prefix(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tconst git_oid *id,\n\tsize_t len,\n\tgit_otype type)\n{\n\tgit_object *object = NULL;\n\tgit_odb *odb = NULL;\n\tgit_odb_object *odb_obj = NULL;\n\tint error = 0;\n\n\tassert(repo && object_out && id);\n\n\tif (len < GIT_OID_MINPREFIXLEN) {\n\t\tgiterr_set(GITERR_OBJECT, \"Ambiguous lookup - OID prefix is too short\");\n\t\treturn GIT_EAMBIGUOUS;\n\t}\n\n\terror = git_repository_odb__weakptr(&odb, repo);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (len > GIT_OID_HEXSZ)\n\t\tlen = GIT_OID_HEXSZ;\n\n\tif (len == GIT_OID_HEXSZ) {\n\t\tgit_cached_obj *cached = NULL;\n\n\t\t/* We want to match the full id : we can first look up in the cache,\n\t\t * since there is no need to check for non ambiguousity\n\t\t */\n\t\tcached = git_cache_get_any(&repo->objects, id);\n\t\tif (cached != NULL) {\n\t\t\tif (cached->flags == GIT_CACHE_STORE_PARSED) {\n\t\t\t\tobject = (git_object *)cached;\n\n\t\t\t\tif (type != GIT_OBJ_ANY && type != object->cached.type) {\n\t\t\t\t\tgit_object_free(object);\n\t\t\t\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\t\t\t\"The requested type does not match the type in ODB\");\n\t\t\t\t\treturn GIT_ENOTFOUND;\n\t\t\t\t}\n\n\t\t\t\t*object_out = object;\n\t\t\t\treturn 0;\n\t\t\t} else if (cached->flags == GIT_CACHE_STORE_RAW) {\n\t\t\t\todb_obj = (git_odb_object *)cached;\n\t\t\t} else {\n\t\t\t\tassert(!\"Wrong caching type in the global object cache\");\n\t\t\t}\n\t\t} else {\n\t\t\t/* Object was not found in the cache, let's explore the backends.\n\t\t\t * We could just use git_odb_read_unique_short_oid,\n\t\t\t * it is the same cost for packed and loose object backends,\n\t\t\t * but it may be much more costly for sqlite and hiredis.\n\t\t\t */\n\t\t\terror = git_odb_read(&odb_obj, odb, id);\n\t\t}\n\t} else {\n\t\tgit_oid short_oid = {{ 0 }};\n\n\t\tgit_oid__cpy_prefix(&short_oid, id, len);\n\n\t\t/* If len < GIT_OID_HEXSZ (a strict short oid was given), we have\n\t\t * 2 options :\n\t\t * - We always search in the cache first. If we find that short oid is\n\t\t *\tambiguous, we can stop. But in all the other cases, we must then\n\t\t *\texplore all the backends (to find an object if there was match,\n\t\t *\tor to check that oid is not ambiguous if we have found 1 match in\n\t\t *\tthe cache)\n\t\t * - We never explore the cache, go right to exploring the backends\n\t\t * We chose the latter : we explore directly the backends.\n\t\t */\n\t\terror = git_odb_read_prefix(&odb_obj, odb, &short_oid, len);\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\terror = git_object__from_odb_object(object_out, repo, odb_obj, type);\n\n\tgit_odb_object_free(odb_obj);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_object__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "99-108",
    "snippet": "void git_object__free(void *obj)\n{\n\tgit_otype type = ((git_object *)obj)->cached.type;\n\n\tif (type < 0 || ((size_t)type) >= ARRAY_SIZE(git_objects_table) ||\n\t\t!git_objects_table[type].free)\n\t\tgit__free(obj);\n\telse\n\t\tgit_objects_table[type].free(obj);\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_objects_table[type].free",
          "args": [
            "obj"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "obj"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "git_objects_table"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nvoid git_object__free(void *obj)\n{\n\tgit_otype type = ((git_object *)obj)->cached.type;\n\n\tif (type < 0 || ((size_t)type) >= ARRAY_SIZE(git_objects_table) ||\n\t\t!git_objects_table[type].free)\n\t\tgit__free(obj);\n\telse\n\t\tgit_objects_table[type].free(obj);\n}"
  },
  {
    "function_name": "git_object__from_odb_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
    "lines": "52-97",
    "snippet": "int git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}",
    "includes": [
      "#include \"tag.h\"",
      "#include \"oid.h\"",
      "#include \"blob.h\"",
      "#include \"tree.h\"",
      "#include \"commit.h\"",
      "#include \"repository.h\"",
      "#include \"common.h\"",
      "#include \"git2/object.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_cache_store_parsed",
          "args": [
            "&repo->objects",
            "object"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_cache_store_parsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/cache.c",
          "lines": "241-245",
          "snippet": "void *git_cache_store_parsed(git_cache *cache, git_object *entry)\n{\n\tentry->cached.flags = GIT_CACHE_STORE_PARSED;\n\treturn cache_store(cache, (git_cached_obj *)entry);\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"object.h\"",
            "#include \"odb.h\"",
            "#include \"cache.h\"",
            "#include \"util.h\"",
            "#include \"thread-utils.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"object.h\"\n#include \"odb.h\"\n#include \"cache.h\"\n#include \"util.h\"\n#include \"thread-utils.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nvoid *git_cache_store_parsed(git_cache *cache, git_object *entry)\n{\n\tentry->cached.flags = GIT_CACHE_STORE_PARSED;\n\treturn cache_store(cache, (git_cached_obj *)entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "def->free",
          "args": [
            "object"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "def->parse",
          "args": [
            "object",
            "odb_obj"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "def->free && def->parse"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&object->cached.oid",
            "&odb_obj->cached.oid"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "object"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "object_size"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"The requested type is invalid\""
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object__size",
          "args": [
            "odb_obj->cached.type"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "git_object__size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "257-263",
          "snippet": "size_t git_object__size(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn git_objects_table[type].size;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nsize_t git_object__size(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn git_objects_table[type].size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "object_out"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object__from_odb_object(\n\tgit_object **object_out,\n\tgit_repository *repo,\n\tgit_odb_object *odb_obj,\n\tgit_otype type)\n{\n\tint error;\n\tsize_t object_size;\n\tgit_object_def *def;\n\tgit_object *object = NULL;\n\n\tassert(object_out);\n\t*object_out = NULL;\n\n\t/* Validate type match */\n\tif (type != GIT_OBJ_ANY && type != odb_obj->cached.type) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"The requested type does not match the type in the ODB\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif ((object_size = git_object__size(odb_obj->cached.type)) == 0) {\n\t\tgiterr_set(GITERR_INVALID, \"The requested type is invalid\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t/* Allocate and initialize base object */\n\tobject = git__calloc(1, object_size);\n\tGITERR_CHECK_ALLOC(object);\n\n\tgit_oid_cpy(&object->cached.oid, &odb_obj->cached.oid);\n\tobject->cached.type = odb_obj->cached.type;\n\tobject->cached.size = odb_obj->cached.size;\n\tobject->repo = repo;\n\n\t/* Parse raw object data */\n\tdef = &git_objects_table[odb_obj->cached.type];\n\tassert(def->free && def->parse);\n\n\tif ((error = def->parse(object, odb_obj)) < 0)\n\t\tdef->free(object);\n\telse\n\t\t*object_out = git_cache_store_parsed(&repo->objects, object);\n\n\treturn error;\n}"
  }
]