[
  {
    "function_name": "git_buf_text_puts_escape_regex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.h",
    "lines": "46-49",
    "snippet": "GIT_INLINE(int) git_buf_text_puts_escape_regex(git_buf *buf, const char *string)\n{\n\treturn git_buf_text_puts_escaped(buf, string, \"^.[]$()|*+?{}\\\\\", \"\\\\\");\n}",
    "includes": [
      "#include \"buffer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_text_puts_escaped",
          "args": [
            "buf",
            "string",
            "\"^.[]$()|*+?{}\\\\\"",
            "\"\\\\\""
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_text_puts_escaped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buf_text.c",
          "lines": "9-57",
          "snippet": "int git_buf_text_puts_escaped(\n\tgit_buf *buf,\n\tconst char *string,\n\tconst char *esc_chars,\n\tconst char *esc_with)\n{\n\tconst char *scan;\n\tsize_t total = 0, esc_len = strlen(esc_with), count, alloclen;\n\n\tif (!string)\n\t\treturn 0;\n\n\tfor (scan = string; *scan; ) {\n\t\t/* count run of non-escaped characters */\n\t\tcount = strcspn(scan, esc_chars);\n\t\ttotal += count;\n\t\tscan += count;\n\t\t/* count run of escaped characters */\n\t\tcount = strspn(scan, esc_chars);\n\t\ttotal += count * (esc_len + 1);\n\t\tscan += count;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, total, 1);\n\tif (git_buf_grow_by(buf, alloclen) < 0)\n\t\treturn -1;\n\n\tfor (scan = string; *scan; ) {\n\t\tcount = strcspn(scan, esc_chars);\n\n\t\tmemmove(buf->ptr + buf->size, scan, count);\n\t\tscan += count;\n\t\tbuf->size += count;\n\n\t\tfor (count = strspn(scan, esc_chars); count > 0; --count) {\n\t\t\t/* copy escape sequence */\n\t\t\tmemmove(buf->ptr + buf->size, esc_with, esc_len);\n\t\t\tbuf->size += esc_len;\n\t\t\t/* copy character to be escaped */\n\t\t\tbuf->ptr[buf->size] = *scan;\n\t\t\tbuf->size++;\n\t\t\tscan++;\n\t\t}\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buf_text.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buf_text.h\"\n\nint git_buf_text_puts_escaped(\n\tgit_buf *buf,\n\tconst char *string,\n\tconst char *esc_chars,\n\tconst char *esc_with)\n{\n\tconst char *scan;\n\tsize_t total = 0, esc_len = strlen(esc_with), count, alloclen;\n\n\tif (!string)\n\t\treturn 0;\n\n\tfor (scan = string; *scan; ) {\n\t\t/* count run of non-escaped characters */\n\t\tcount = strcspn(scan, esc_chars);\n\t\ttotal += count;\n\t\tscan += count;\n\t\t/* count run of escaped characters */\n\t\tcount = strspn(scan, esc_chars);\n\t\ttotal += count * (esc_len + 1);\n\t\tscan += count;\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, total, 1);\n\tif (git_buf_grow_by(buf, alloclen) < 0)\n\t\treturn -1;\n\n\tfor (scan = string; *scan; ) {\n\t\tcount = strcspn(scan, esc_chars);\n\n\t\tmemmove(buf->ptr + buf->size, scan, count);\n\t\tscan += count;\n\t\tbuf->size += count;\n\n\t\tfor (count = strspn(scan, esc_chars); count > 0; --count) {\n\t\t\t/* copy escape sequence */\n\t\t\tmemmove(buf->ptr + buf->size, esc_with, esc_len);\n\t\t\tbuf->size += esc_len;\n\t\t\t/* copy character to be escaped */\n\t\t\tbuf->ptr[buf->size] = *scan;\n\t\t\tbuf->size++;\n\t\t\tscan++;\n\t\t}\n\t}\n\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer.h\"\n\nGIT_INLINE(int) git_buf_text_puts_escape_regex(git_buf *buf, const char *string)\n{\n\treturn git_buf_text_puts_escaped(buf, string, \"^.[]$()|*+?{}\\\\\", \"\\\\\");\n}"
  }
]