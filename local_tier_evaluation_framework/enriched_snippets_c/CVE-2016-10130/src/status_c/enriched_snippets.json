[
  {
    "function_name": "git_status_list_get_perfdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "544-563",
    "snippet": "int git_status_list_get_perfdata(\n\tgit_diff_perfdata *out, const git_status_list *status)\n{\n\tassert(out);\n\tGITERR_CHECK_VERSION(out, GIT_DIFF_PERFDATA_VERSION, \"git_diff_perfdata\");\n\n\tout->stat_calls = 0;\n\tout->oid_calculations = 0;\n\n\tif (status->head2idx) {\n\t\tout->stat_calls += status->head2idx->perf.stat_calls;\n\t\tout->oid_calculations += status->head2idx->perf.oid_calculations;\n\t}\n\tif (status->idx2wd) {\n\t\tout->stat_calls += status->idx2wd->perf.stat_calls;\n\t\tout->oid_calculations += status->idx2wd->perf.oid_calculations;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "out",
            "GIT_DIFF_PERFDATA_VERSION",
            "\"git_diff_perfdata\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_list_get_perfdata(\n\tgit_diff_perfdata *out, const git_status_list *status)\n{\n\tassert(out);\n\tGITERR_CHECK_VERSION(out, GIT_DIFF_PERFDATA_VERSION, \"git_diff_perfdata\");\n\n\tout->stat_calls = 0;\n\tout->oid_calculations = 0;\n\n\tif (status->head2idx) {\n\t\tout->stat_calls += status->head2idx->perf.stat_calls;\n\t\tout->oid_calculations += status->head2idx->perf.oid_calculations;\n\t}\n\tif (status->idx2wd) {\n\t\tout->stat_calls += status->idx2wd->perf.stat_calls;\n\t\tout->oid_calculations += status->idx2wd->perf.oid_calculations;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_status_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "537-542",
    "snippet": "int git_status_init_options(git_status_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_status_options, GIT_STATUS_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_status_options",
            "GIT_STATUS_OPTIONS_INIT"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_init_options(git_status_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_status_options, GIT_STATUS_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_status_should_ignore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "529-535",
    "snippet": "int git_status_should_ignore(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *path)\n{\n\treturn git_ignore_path_is_ignored(ignored, repo, path);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_ignore_path_is_ignored",
          "args": [
            "ignored",
            "repo",
            "path"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore_path_is_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "494-554",
          "snippet": "int git_ignore_path_is_ignored(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *pathname)\n{\n\tint error;\n\tconst char *workdir;\n\tgit_attr_path path;\n\tgit_ignores ignores;\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tassert(ignored && pathname);\n\n\tworkdir = repo ? git_repository_workdir(repo) : NULL;\n\n\tmemset(&path, 0, sizeof(path));\n\tmemset(&ignores, 0, sizeof(ignores));\n\n\tif ((error = git_attr_path__init(&path, pathname, workdir, GIT_DIR_FLAG_UNKNOWN)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, path.path, &ignores)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\t/* first process builtins - success means path was found */\n\t\tif (ignore_lookup_in_rules(ignored, ignores.ign_internal, &path))\n\t\t\tgoto cleanup;\n\n\t\t/* next process files in the path */\n\t\tgit_vector_foreach(&ignores.ign_path, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* last process global ignores */\n\t\tgit_vector_foreach(&ignores.ign_global, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* move up one directory */\n\t\tif (path.basename == path.path)\n\t\t\tbreak;\n\t\tpath.basename[-1] = '\\0';\n\t\twhile (path.basename > path.path && *path.basename != '/')\n\t\t\tpath.basename--;\n\t\tif (path.basename > path.path)\n\t\t\tpath.basename++;\n\t\tpath.is_dir = 1;\n\n\t\tif ((error = git_ignore__pop_dir(&ignores)) < 0)\n\t\t\tbreak;\n\t}\n\n\t*ignored = 0;\n\ncleanup:\n\tgit_attr_path__free(&path);\n\tgit_ignore__free(&ignores);\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore_path_is_ignored(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *pathname)\n{\n\tint error;\n\tconst char *workdir;\n\tgit_attr_path path;\n\tgit_ignores ignores;\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tassert(ignored && pathname);\n\n\tworkdir = repo ? git_repository_workdir(repo) : NULL;\n\n\tmemset(&path, 0, sizeof(path));\n\tmemset(&ignores, 0, sizeof(ignores));\n\n\tif ((error = git_attr_path__init(&path, pathname, workdir, GIT_DIR_FLAG_UNKNOWN)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, path.path, &ignores)) < 0)\n\t\tgoto cleanup;\n\n\twhile (1) {\n\t\t/* first process builtins - success means path was found */\n\t\tif (ignore_lookup_in_rules(ignored, ignores.ign_internal, &path))\n\t\t\tgoto cleanup;\n\n\t\t/* next process files in the path */\n\t\tgit_vector_foreach(&ignores.ign_path, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* last process global ignores */\n\t\tgit_vector_foreach(&ignores.ign_global, i, file) {\n\t\t\tif (ignore_lookup_in_rules(ignored, file, &path))\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* move up one directory */\n\t\tif (path.basename == path.path)\n\t\t\tbreak;\n\t\tpath.basename[-1] = '\\0';\n\t\twhile (path.basename > path.path && *path.basename != '/')\n\t\t\tpath.basename--;\n\t\tif (path.basename > path.path)\n\t\t\tpath.basename++;\n\t\tpath.is_dir = 1;\n\n\t\tif ((error = git_ignore__pop_dir(&ignores)) < 0)\n\t\t\tbreak;\n\t}\n\n\t*ignored = 0;\n\ncleanup:\n\tgit_attr_path__free(&path);\n\tgit_ignore__free(&ignores);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_should_ignore(\n\tint *ignored,\n\tgit_repository *repo,\n\tconst char *path)\n{\n\treturn git_ignore_path_is_ignored(ignored, repo, path);\n}"
  },
  {
    "function_name": "git_status_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "478-527",
    "snippet": "int git_status_file(\n\tunsigned int *status_flags,\n\tgit_repository *repo,\n\tconst char *path)\n{\n\tint error;\n\tgit_status_options opts = GIT_STATUS_OPTIONS_INIT;\n\tstruct status_file_info sfi = {0};\n\tgit_index *index;\n\n\tassert(status_flags && repo && path);\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0)\n\t\treturn error;\n\n\tif ((sfi.expected = git__strdup(path)) == NULL)\n\t\treturn -1;\n\tif (index->ignore_case)\n\t\tsfi.fnm_flags = FNM_CASEFOLD;\n\n\topts.show = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\topts.flags = GIT_STATUS_OPT_INCLUDE_IGNORED |\n\t\tGIT_STATUS_OPT_RECURSE_IGNORED_DIRS |\n\t\tGIT_STATUS_OPT_INCLUDE_UNTRACKED |\n\t\tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS |\n\t\tGIT_STATUS_OPT_INCLUDE_UNMODIFIED |\n\t\tGIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH;\n\topts.pathspec.count = 1;\n\topts.pathspec.strings = &sfi.expected;\n\n\terror = git_status_foreach_ext(repo, &opts, get_one_status, &sfi);\n\n\tif (error < 0 && sfi.ambiguous) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Ambiguous path '%s' given to git_status_file\", sfi.expected);\n\t\terror = GIT_EAMBIGUOUS;\n\t}\n\n\tif (!error && !sfi.count) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to get status of nonexistent file '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\n\t*status_flags = sfi.status;\n\n\tgit__free(sfi.expected);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "sfi.expected"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Attempt to get status of nonexistent file '%s'\"",
            "path"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_status_foreach_ext",
          "args": [
            "repo",
            "&opts",
            "get_one_status",
            "&sfi"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_foreach_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "413-442",
          "snippet": "int git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "path"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "repo"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "status_flags && repo && path"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_file(\n\tunsigned int *status_flags,\n\tgit_repository *repo,\n\tconst char *path)\n{\n\tint error;\n\tgit_status_options opts = GIT_STATUS_OPTIONS_INIT;\n\tstruct status_file_info sfi = {0};\n\tgit_index *index;\n\n\tassert(status_flags && repo && path);\n\n\tif ((error = git_repository_index__weakptr(&index, repo)) < 0)\n\t\treturn error;\n\n\tif ((sfi.expected = git__strdup(path)) == NULL)\n\t\treturn -1;\n\tif (index->ignore_case)\n\t\tsfi.fnm_flags = FNM_CASEFOLD;\n\n\topts.show = GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\topts.flags = GIT_STATUS_OPT_INCLUDE_IGNORED |\n\t\tGIT_STATUS_OPT_RECURSE_IGNORED_DIRS |\n\t\tGIT_STATUS_OPT_INCLUDE_UNTRACKED |\n\t\tGIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS |\n\t\tGIT_STATUS_OPT_INCLUDE_UNMODIFIED |\n\t\tGIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH;\n\topts.pathspec.count = 1;\n\topts.pathspec.strings = &sfi.expected;\n\n\terror = git_status_foreach_ext(repo, &opts, get_one_status, &sfi);\n\n\tif (error < 0 && sfi.ambiguous) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Ambiguous path '%s' given to git_status_file\", sfi.expected);\n\t\terror = GIT_EAMBIGUOUS;\n\t}\n\n\tif (!error && !sfi.count) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Attempt to get status of nonexistent file '%s'\", path);\n\t\terror = GIT_ENOTFOUND;\n\t}\n\n\t*status_flags = sfi.status;\n\n\tgit__free(sfi.expected);\n\n\treturn error;\n}"
  },
  {
    "function_name": "get_one_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "457-476",
    "snippet": "static int get_one_status(const char *path, unsigned int status, void *data)\n{\n\tstruct status_file_info *sfi = data;\n\tint (*strcomp)(const char *a, const char *b);\n\n\tsfi->count++;\n\tsfi->status = status;\n\n\tstrcomp = (sfi->fnm_flags & FNM_CASEFOLD) ? git__strcasecmp : git__strcmp;\n\n\tif (sfi->count > 1 ||\n\t\t(strcomp(sfi->expected, path) != 0 &&\n\t\t p_fnmatch(sfi->expected, path, sfi->fnm_flags) != 0))\n\t{\n\t\tsfi->ambiguous = true;\n\t\treturn GIT_EAMBIGUOUS; /* giterr_set will be done by caller */\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "sfi->expected",
            "path",
            "sfi->fnm_flags"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcomp",
          "args": [
            "sfi->expected",
            "path"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic int get_one_status(const char *path, unsigned int status, void *data)\n{\n\tstruct status_file_info *sfi = data;\n\tint (*strcomp)(const char *a, const char *b);\n\n\tsfi->count++;\n\tsfi->status = status;\n\n\tstrcomp = (sfi->fnm_flags & FNM_CASEFOLD) ? git__strcasecmp : git__strcmp;\n\n\tif (sfi->count > 1 ||\n\t\t(strcomp(sfi->expected, path) != 0 &&\n\t\t p_fnmatch(sfi->expected, path, sfi->fnm_flags) != 0))\n\t{\n\t\tsfi->ambiguous = true;\n\t\treturn GIT_EAMBIGUOUS; /* giterr_set will be done by caller */\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_status_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "444-447",
    "snippet": "int git_status_foreach(git_repository *repo, git_status_cb cb, void *payload)\n{\n\treturn git_status_foreach_ext(repo, NULL, cb, payload);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_status_foreach_ext",
          "args": [
            "repo",
            "NULL",
            "cb",
            "payload"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_foreach_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "413-442",
          "snippet": "int git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_foreach(git_repository *repo, git_status_cb cb, void *payload)\n{\n\treturn git_status_foreach_ext(repo, NULL, cb, payload);\n}"
  },
  {
    "function_name": "git_status_foreach_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "413-442",
    "snippet": "int git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_status_list_free",
          "args": [
            "status"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "399-411",
          "snippet": "void git_status_list_free(git_status_list *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit_diff_free(status->head2idx);\n\tgit_diff_free(status->idx2wd);\n\n\tgit_vector_free_deep(&status->paired);\n\n\tgit__memzero(status, sizeof(*status));\n\tgit__free(status);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nvoid git_status_list_free(git_status_list *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit_diff_free(status->head2idx);\n\tgit_diff_free(status->idx2wd);\n\n\tgit_vector_free_deep(&status->paired);\n\n\tgit__memzero(status, sizeof(*status));\n\tgit__free(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "path",
            "status_entry->status",
            "payload"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "is_dirty_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "447-454",
          "snippet": "static int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&status->paired",
            "i",
            "status_entry"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_status_list_new",
          "args": [
            "&status",
            "repo",
            "opts"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_list_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "259-383",
          "snippet": "int git_status_list_new(\n\tgit_status_list **out,\n\tgit_repository *repo,\n\tconst git_status_options *opts)\n{\n\tgit_index *index = NULL;\n\tgit_status_list *status = NULL;\n\tgit_diff_options diffopt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_find_options findopt = GIT_DIFF_FIND_OPTIONS_INIT;\n\tgit_tree *head = NULL;\n\tgit_status_show_t show =\n\t\topts ? opts->show : GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\tint error = 0;\n\tunsigned int flags = opts ? opts->flags : GIT_STATUS_OPT_DEFAULTS;\n\n\t*out = NULL;\n\n\tif (status_validate_options(opts) < 0)\n\t\treturn -1;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"status\")) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0)\n\t\treturn error;\n\n\t/* if there is no HEAD, that's okay - we'll make an empty iterator */\n\tif ((error = git_repository_head_tree(&head, repo)) < 0) {\n\t\tif (error != GIT_ENOTFOUND && error != GIT_EUNBORNBRANCH)\n\t\t\tgoto done;\n\t\tgiterr_clear();\n\t}\n\n\t/* refresh index from disk unless prevented */\n\tif ((flags & GIT_STATUS_OPT_NO_REFRESH) == 0 &&\n\t\tgit_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\tstatus = git_status_list_alloc(index);\n\tGITERR_CHECK_ALLOC(status);\n\n\tif (opts) {\n\t\tmemcpy(&status->opts, opts, sizeof(git_status_options));\n\t\tmemcpy(&diffopt.pathspec, &opts->pathspec, sizeof(diffopt.pathspec));\n\t}\n\n\tdiffopt.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tfindopt.flags = GIT_DIFF_FIND_FOR_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNTRACKED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_IGNORED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_IGNORED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNMODIFIED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNMODIFIED;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_IGNORED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_IGNORED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_IGNORE_SUBMODULES;\n\tif ((flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_UPDATE_INDEX;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_RENAMES_FROM_REWRITES) != 0)\n\t\tfindopt.flags = findopt.flags |\n\t\t\tGIT_DIFF_FIND_AND_BREAK_REWRITES |\n\t\t\tGIT_DIFF_FIND_RENAMES_FROM_REWRITES |\n\t\t\tGIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;\n\n\tif (show != GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tif ((error = git_diff_tree_to_index(\n\t\t\t\t&status->head2idx, repo, head, index, &diffopt)) < 0)\n\t\t\tgoto done;\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->head2idx, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (show != GIT_STATUS_SHOW_INDEX_ONLY) {\n\t\tif ((error = git_diff_index_to_workdir(\n\t\t\t\t&status->idx2wd, repo, index, &diffopt)) < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->idx2wd, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\terror = git_diff__paired_foreach(\n\t\tstatus->head2idx, status->idx2wd, status_collect, status);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_SENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_cmp);\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_icmp);\n\n\tif ((flags &\n\t\t (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX |\n\t\t  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR |\n\t\t  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY |\n\t\t  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)) != 0)\n\t\tgit_vector_sort(&status->paired);\n\ndone:\n\tif (error < 0) {\n\t\tgit_status_list_free(status);\n\t\tstatus = NULL;\n\t}\n\n\t*out = status;\n\n\tgit_tree_free(head);\n\tgit_index_free(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_list_new(\n\tgit_status_list **out,\n\tgit_repository *repo,\n\tconst git_status_options *opts)\n{\n\tgit_index *index = NULL;\n\tgit_status_list *status = NULL;\n\tgit_diff_options diffopt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_find_options findopt = GIT_DIFF_FIND_OPTIONS_INIT;\n\tgit_tree *head = NULL;\n\tgit_status_show_t show =\n\t\topts ? opts->show : GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\tint error = 0;\n\tunsigned int flags = opts ? opts->flags : GIT_STATUS_OPT_DEFAULTS;\n\n\t*out = NULL;\n\n\tif (status_validate_options(opts) < 0)\n\t\treturn -1;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"status\")) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0)\n\t\treturn error;\n\n\t/* if there is no HEAD, that's okay - we'll make an empty iterator */\n\tif ((error = git_repository_head_tree(&head, repo)) < 0) {\n\t\tif (error != GIT_ENOTFOUND && error != GIT_EUNBORNBRANCH)\n\t\t\tgoto done;\n\t\tgiterr_clear();\n\t}\n\n\t/* refresh index from disk unless prevented */\n\tif ((flags & GIT_STATUS_OPT_NO_REFRESH) == 0 &&\n\t\tgit_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\tstatus = git_status_list_alloc(index);\n\tGITERR_CHECK_ALLOC(status);\n\n\tif (opts) {\n\t\tmemcpy(&status->opts, opts, sizeof(git_status_options));\n\t\tmemcpy(&diffopt.pathspec, &opts->pathspec, sizeof(diffopt.pathspec));\n\t}\n\n\tdiffopt.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tfindopt.flags = GIT_DIFF_FIND_FOR_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNTRACKED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_IGNORED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_IGNORED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNMODIFIED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNMODIFIED;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_IGNORED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_IGNORED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_IGNORE_SUBMODULES;\n\tif ((flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_UPDATE_INDEX;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_RENAMES_FROM_REWRITES) != 0)\n\t\tfindopt.flags = findopt.flags |\n\t\t\tGIT_DIFF_FIND_AND_BREAK_REWRITES |\n\t\t\tGIT_DIFF_FIND_RENAMES_FROM_REWRITES |\n\t\t\tGIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;\n\n\tif (show != GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tif ((error = git_diff_tree_to_index(\n\t\t\t\t&status->head2idx, repo, head, index, &diffopt)) < 0)\n\t\t\tgoto done;\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->head2idx, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (show != GIT_STATUS_SHOW_INDEX_ONLY) {\n\t\tif ((error = git_diff_index_to_workdir(\n\t\t\t\t&status->idx2wd, repo, index, &diffopt)) < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->idx2wd, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\terror = git_diff__paired_foreach(\n\t\tstatus->head2idx, status->idx2wd, status_collect, status);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_SENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_cmp);\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_icmp);\n\n\tif ((flags &\n\t\t (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX |\n\t\t  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR |\n\t\t  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY |\n\t\t  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)) != 0)\n\t\tgit_vector_sort(&status->paired);\n\ndone:\n\tif (error < 0) {\n\t\tgit_status_list_free(status);\n\t\tstatus = NULL;\n\t}\n\n\t*out = status;\n\n\tgit_tree_free(head);\n\tgit_index_free(index);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_foreach_ext(\n\tgit_repository *repo,\n\tconst git_status_options *opts,\n\tgit_status_cb cb,\n\tvoid *payload)\n{\n\tgit_status_list *status;\n\tconst git_status_entry *status_entry;\n\tsize_t i;\n\tint error = 0;\n\n\tif ((error = git_status_list_new(&status, repo, opts)) < 0) {\n\t\treturn error;\n\t}\n\n\tgit_vector_foreach(&status->paired, i, status_entry) {\n\t\tconst char *path = status_entry->head_to_index ?\n\t\t\tstatus_entry->head_to_index->old_file.path :\n\t\t\tstatus_entry->index_to_workdir->old_file.path;\n\n\t\tif ((error = cb(path, status_entry->status, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tgit_status_list_free(status);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_status_list_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "399-411",
    "snippet": "void git_status_list_free(git_status_list *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit_diff_free(status->head2idx);\n\tgit_diff_free(status->idx2wd);\n\n\tgit_vector_free_deep(&status->paired);\n\n\tgit__memzero(status, sizeof(*status));\n\tgit__free(status);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "status"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__memzero",
          "args": [
            "status",
            "sizeof(*status)"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "git__memzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "521-531",
          "snippet": "GIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&status->paired"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "status->idx2wd"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nvoid git_status_list_free(git_status_list *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit_diff_free(status->head2idx);\n\tgit_diff_free(status->idx2wd);\n\n\tgit_vector_free_deep(&status->paired);\n\n\tgit__memzero(status, sizeof(*status));\n\tgit__free(status);\n}"
  },
  {
    "function_name": "git_status_byindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "392-397",
    "snippet": "const git_status_entry *git_status_byindex(git_status_list *status, size_t i)\n{\n\tassert(status);\n\n\treturn git_vector_get(&status->paired, i);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&status->paired",
            "i"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "status"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nconst git_status_entry *git_status_byindex(git_status_list *status, size_t i)\n{\n\tassert(status);\n\n\treturn git_vector_get(&status->paired, i);\n}"
  },
  {
    "function_name": "git_status_list_entrycount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "385-390",
    "snippet": "size_t git_status_list_entrycount(git_status_list *status)\n{\n\tassert(status);\n\n\treturn status->paired.length;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "status"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nsize_t git_status_list_entrycount(git_status_list *status)\n{\n\tassert(status);\n\n\treturn status->paired.length;\n}"
  },
  {
    "function_name": "git_status_list_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "259-383",
    "snippet": "int git_status_list_new(\n\tgit_status_list **out,\n\tgit_repository *repo,\n\tconst git_status_options *opts)\n{\n\tgit_index *index = NULL;\n\tgit_status_list *status = NULL;\n\tgit_diff_options diffopt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_find_options findopt = GIT_DIFF_FIND_OPTIONS_INIT;\n\tgit_tree *head = NULL;\n\tgit_status_show_t show =\n\t\topts ? opts->show : GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\tint error = 0;\n\tunsigned int flags = opts ? opts->flags : GIT_STATUS_OPT_DEFAULTS;\n\n\t*out = NULL;\n\n\tif (status_validate_options(opts) < 0)\n\t\treturn -1;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"status\")) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0)\n\t\treturn error;\n\n\t/* if there is no HEAD, that's okay - we'll make an empty iterator */\n\tif ((error = git_repository_head_tree(&head, repo)) < 0) {\n\t\tif (error != GIT_ENOTFOUND && error != GIT_EUNBORNBRANCH)\n\t\t\tgoto done;\n\t\tgiterr_clear();\n\t}\n\n\t/* refresh index from disk unless prevented */\n\tif ((flags & GIT_STATUS_OPT_NO_REFRESH) == 0 &&\n\t\tgit_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\tstatus = git_status_list_alloc(index);\n\tGITERR_CHECK_ALLOC(status);\n\n\tif (opts) {\n\t\tmemcpy(&status->opts, opts, sizeof(git_status_options));\n\t\tmemcpy(&diffopt.pathspec, &opts->pathspec, sizeof(diffopt.pathspec));\n\t}\n\n\tdiffopt.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tfindopt.flags = GIT_DIFF_FIND_FOR_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNTRACKED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_IGNORED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_IGNORED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNMODIFIED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNMODIFIED;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_IGNORED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_IGNORED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_IGNORE_SUBMODULES;\n\tif ((flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_UPDATE_INDEX;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_RENAMES_FROM_REWRITES) != 0)\n\t\tfindopt.flags = findopt.flags |\n\t\t\tGIT_DIFF_FIND_AND_BREAK_REWRITES |\n\t\t\tGIT_DIFF_FIND_RENAMES_FROM_REWRITES |\n\t\t\tGIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;\n\n\tif (show != GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tif ((error = git_diff_tree_to_index(\n\t\t\t\t&status->head2idx, repo, head, index, &diffopt)) < 0)\n\t\t\tgoto done;\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->head2idx, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (show != GIT_STATUS_SHOW_INDEX_ONLY) {\n\t\tif ((error = git_diff_index_to_workdir(\n\t\t\t\t&status->idx2wd, repo, index, &diffopt)) < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->idx2wd, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\terror = git_diff__paired_foreach(\n\t\tstatus->head2idx, status->idx2wd, status_collect, status);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_SENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_cmp);\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_icmp);\n\n\tif ((flags &\n\t\t (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX |\n\t\t  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR |\n\t\t  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY |\n\t\t  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)) != 0)\n\t\tgit_vector_sort(&status->paired);\n\ndone:\n\tif (error < 0) {\n\t\tgit_status_list_free(status);\n\t\tstatus = NULL;\n\t}\n\n\t*out = status;\n\n\tgit_tree_free(head);\n\tgit_index_free(index);\n\n\treturn error;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_free",
          "args": [
            "index"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "477-483",
          "snippet": "void git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_free(git_index *index)\n{\n\tif (index == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(index, index_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "head"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_status_list_free",
          "args": [
            "status"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "399-411",
          "snippet": "void git_status_list_free(git_status_list *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit_diff_free(status->head2idx);\n\tgit_diff_free(status->idx2wd);\n\n\tgit_vector_free_deep(&status->paired);\n\n\tgit__memzero(status, sizeof(*status));\n\tgit__free(status);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nvoid git_status_list_free(git_status_list *status)\n{\n\tif (status == NULL)\n\t\treturn;\n\n\tgit_diff_free(status->head2idx);\n\tgit_diff_free(status->idx2wd);\n\n\tgit_vector_free_deep(&status->paired);\n\n\tgit__memzero(status, sizeof(*status));\n\tgit__free(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&status->paired"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&status->paired",
            "status_entry_icmp"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__paired_foreach",
          "args": [
            "status->head2idx",
            "status->idx2wd",
            "status_collect",
            "status"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__paired_foreach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1526-1615",
          "snippet": "int git_diff__paired_foreach(\n\tgit_diff *head2idx,\n\tgit_diff *idx2wd,\n\tint (*cb)(git_diff_delta *h2i, git_diff_delta *i2w, void *payload),\n\tvoid *payload)\n{\n\tint cmp, error = 0;\n\tgit_diff_delta *h2i, *i2w;\n\tsize_t i, j, i_max, j_max;\n\tint (*strcomp)(const char *, const char *) = git__strcmp;\n\tbool h2i_icase, i2w_icase, icase_mismatch;\n\n\ti_max = head2idx ? head2idx->deltas.length : 0;\n\tj_max = idx2wd ? idx2wd->deltas.length : 0;\n\tif (!i_max && !j_max)\n\t\treturn 0;\n\n\t/* At some point, tree-to-index diffs will probably never ignore case,\n\t * even if that isn't true now.  Index-to-workdir diffs may or may not\n\t * ignore case, but the index filename for the idx2wd diff should\n\t * still be using the canonical case-preserving name.\n\t *\n\t * Therefore the main thing we need to do here is make sure the diffs\n\t * are traversed in a compatible order.  To do this, we temporarily\n\t * resort a mismatched diff to get the order correct.\n\t *\n\t * In order to traverse renames in the index->workdir, we need to\n\t * ensure that we compare the index name on both sides, so we\n\t * always sort by the old name in the i2w list.\n\t */\n\th2i_icase = head2idx != NULL &&\n\t\t(head2idx->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ti2w_icase = idx2wd != NULL &&\n\t\t(idx2wd->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ticase_mismatch =\n\t\t(head2idx != NULL && idx2wd != NULL && h2i_icase != i2w_icase);\n\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__cmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\tif (i2w_icase && !icase_mismatch) {\n\t\tstrcomp = git__strcasecmp;\n\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_casecmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t} else if (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\tfor (i = 0, j = 0; i < i_max || j < j_max; ) {\n\t\th2i = head2idx ? GIT_VECTOR_GET(&head2idx->deltas, i) : NULL;\n\t\ti2w = idx2wd ? GIT_VECTOR_GET(&idx2wd->deltas, j) : NULL;\n\n\t\tcmp = !i2w ? -1 : !h2i ? 1 :\n\t\t\tstrcomp(h2i->new_file.path, i2w->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\ti++; i2w = NULL;\n\t\t} else if (cmp > 0) {\n\t\t\tj++; h2i = NULL;\n\t\t} else {\n\t\t\ti++; j++;\n\t\t}\n\n\t\tif ((error = cb(h2i, i2w, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* restore case-insensitive delta sort */\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__casecmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\t/* restore idx2wd sort by new path */\n\tif (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas,\n\t\t\ti2w_icase ? git_diff_delta__casecmp : git_diff_delta__cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__paired_foreach(\n\tgit_diff *head2idx,\n\tgit_diff *idx2wd,\n\tint (*cb)(git_diff_delta *h2i, git_diff_delta *i2w, void *payload),\n\tvoid *payload)\n{\n\tint cmp, error = 0;\n\tgit_diff_delta *h2i, *i2w;\n\tsize_t i, j, i_max, j_max;\n\tint (*strcomp)(const char *, const char *) = git__strcmp;\n\tbool h2i_icase, i2w_icase, icase_mismatch;\n\n\ti_max = head2idx ? head2idx->deltas.length : 0;\n\tj_max = idx2wd ? idx2wd->deltas.length : 0;\n\tif (!i_max && !j_max)\n\t\treturn 0;\n\n\t/* At some point, tree-to-index diffs will probably never ignore case,\n\t * even if that isn't true now.  Index-to-workdir diffs may or may not\n\t * ignore case, but the index filename for the idx2wd diff should\n\t * still be using the canonical case-preserving name.\n\t *\n\t * Therefore the main thing we need to do here is make sure the diffs\n\t * are traversed in a compatible order.  To do this, we temporarily\n\t * resort a mismatched diff to get the order correct.\n\t *\n\t * In order to traverse renames in the index->workdir, we need to\n\t * ensure that we compare the index name on both sides, so we\n\t * always sort by the old name in the i2w list.\n\t */\n\th2i_icase = head2idx != NULL &&\n\t\t(head2idx->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ti2w_icase = idx2wd != NULL &&\n\t\t(idx2wd->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ticase_mismatch =\n\t\t(head2idx != NULL && idx2wd != NULL && h2i_icase != i2w_icase);\n\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__cmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\tif (i2w_icase && !icase_mismatch) {\n\t\tstrcomp = git__strcasecmp;\n\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_casecmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t} else if (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\tfor (i = 0, j = 0; i < i_max || j < j_max; ) {\n\t\th2i = head2idx ? GIT_VECTOR_GET(&head2idx->deltas, i) : NULL;\n\t\ti2w = idx2wd ? GIT_VECTOR_GET(&idx2wd->deltas, j) : NULL;\n\n\t\tcmp = !i2w ? -1 : !h2i ? 1 :\n\t\t\tstrcomp(h2i->new_file.path, i2w->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\ti++; i2w = NULL;\n\t\t} else if (cmp > 0) {\n\t\t\tj++; h2i = NULL;\n\t\t} else {\n\t\t\ti++; j++;\n\t\t}\n\n\t\tif ((error = cb(h2i, i2w, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* restore case-insensitive delta sort */\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__casecmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\t/* restore idx2wd sort by new path */\n\tif (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas,\n\t\t\ti2w_icase ? git_diff_delta__casecmp : git_diff_delta__cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_find_similar",
          "args": [
            "status->idx2wd",
            "&findopt"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_find_similar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "795-1112",
          "snippet": "int git_diff_find_similar(\n\tgit_diff *diff,\n\tconst git_diff_find_options *given_opts)\n{\n\tsize_t s, t;\n\tint error = 0, result;\n\tuint16_t similarity;\n\tgit_diff_delta *src, *tgt;\n\tgit_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT;\n\tsize_t num_deltas, num_srcs = 0, num_tgts = 0;\n\tsize_t tried_srcs = 0, tried_tgts = 0;\n\tsize_t num_rewrites = 0, num_updates = 0, num_bumped = 0;\n\tsize_t sigcache_size;\n\tvoid **sigcache = NULL; /* cache of similarity metric file signatures */\n\tdiff_find_match *tgt2src = NULL;\n\tdiff_find_match *src2tgt = NULL;\n\tdiff_find_match *tgt2src_copy = NULL;\n\tdiff_find_match *best_match;\n\tgit_diff_file swap;\n\n\tif ((error = normalize_find_opts(diff, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tnum_deltas = diff->deltas.length;\n\n\t/* TODO: maybe abort if deltas.length > rename_limit ??? */\n\tif (!git__is_uint32(num_deltas))\n\t\tgoto cleanup;\n\n\t/* No flags set; nothing to do */\n\tif ((opts.flags & GIT_DIFF_FIND_ALL) == 0)\n\t\tgoto cleanup;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sigcache_size, num_deltas, 2);\n\tsigcache = git__calloc(sigcache_size, sizeof(void *));\n\tGITERR_CHECK_ALLOC(sigcache);\n\n\t/* Label rename sources and targets\n\t *\n\t * This will also set self-similarity scores for MODIFIED files and\n\t * mark them for splitting if break-rewrites is enabled\n\t */\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\tif (is_rename_source(diff, &opts, t, sigcache))\n\t\t\t++num_srcs;\n\n\t\tif (is_rename_target(diff, &opts, t, sigcache))\n\t\t\t++num_tgts;\n\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0)\n\t\t\tnum_rewrites++;\n\t}\n\n\t/* if there are no candidate srcs or tgts, we're done */\n\tif (!num_srcs || !num_tgts)\n\t\tgoto cleanup;\n\n\tsrc2tgt = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(src2tgt);\n\ttgt2src = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(tgt2src);\n\n\tif (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\ttgt2src_copy = git__calloc(num_deltas, sizeof(diff_find_match));\n\t\tGITERR_CHECK_ALLOC(tgt2src_copy);\n\t}\n\n\t/*\n\t * Find best-fit matches for rename / copy candidates\n\t */\n\nfind_best_matches:\n\ttried_tgts = num_bumped = 0;\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\ttried_srcs = 0;\n\n\t\tgit_vector_foreach(&diff->deltas, s, src) {\n\t\t\t/* skip things that are not rename sources */\n\t\t\tif ((src->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* calculate similarity for this pair and find best match */\n\t\t\tif (s == t)\n\t\t\t\tresult = -1; /* don't measure self-similarity here */\n\t\t\telse if ((error = similarity_measure(\n\t\t\t\t&result, diff, &opts, sigcache, 2 * s, 2 * t + 1)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (result < 0)\n\t\t\t\tcontinue;\n\t\t\tsimilarity = (uint16_t)result;\n\n\t\t\t/* is this a better rename? */\n\t\t\tif (tgt2src[t].similarity < similarity &&\n\t\t\t\tsrc2tgt[s].similarity < similarity)\n\t\t\t{\n\t\t\t\t/* eject old mapping */\n\t\t\t\tif (src2tgt[s].similarity > 0) {\n\t\t\t\t\ttgt2src[src2tgt[s].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\t\t\t\tif (tgt2src[t].similarity > 0) {\n\t\t\t\t\tsrc2tgt[tgt2src[t].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\n\t\t\t\t/* write new mapping */\n\t\t\t\ttgt2src[t].idx = s;\n\t\t\t\ttgt2src[t].similarity = similarity;\n\t\t\t\tsrc2tgt[s].idx = t;\n\t\t\t\tsrc2tgt[s].similarity = similarity;\n\t\t\t}\n\n\t\t\t/* keep best absolute match for copies */\n\t\t\tif (tgt2src_copy != NULL &&\n\t\t\t\ttgt2src_copy[t].similarity < similarity)\n\t\t\t{\n\t\t\t\ttgt2src_copy[t].idx = s;\n\t\t\t\ttgt2src_copy[t].similarity = similarity;\n\t\t\t}\n\n\t\t\tif (++tried_srcs >= num_srcs)\n\t\t\t\tbreak;\n\n\t\t\t/* cap on maximum targets we'll examine (per \"tgt\" file) */\n\t\t\tif (tried_srcs > opts.rename_limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tried_tgts >= num_tgts)\n\t\t\tbreak;\n\t}\n\n\tif (num_bumped > 0) /* try again if we bumped some items */\n\t\tgoto find_best_matches;\n\n\t/*\n\t * Rewrite the diffs with renames / copies\n\t */\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\t/* check if this delta was the target of a similarity */\n\t\tif (tgt2src[t].similarity)\n\t\t\tbest_match = &tgt2src[t];\n\t\telse if (tgt2src_copy && tgt2src_copy[t].similarity)\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\telse\n\t\t\tcontinue;\n\n\t\ts = best_match->idx;\n\t\tsrc = GIT_VECTOR_GET(&diff->deltas, s);\n\n\t\t/* possible scenarios:\n\t\t * 1. from DELETE to ADD/UNTRACK/IGNORE = RENAME\n\t\t * 2. from DELETE to SPLIT/TYPECHANGE = RENAME + DELETE\n\t\t * 3. from SPLIT/TYPECHANGE to ADD/UNTRACK/IGNORE = ADD + RENAME\n\t\t * 4. from SPLIT/TYPECHANGE to SPLIT/TYPECHANGE = RENAME + SPLIT\n\t\t * 5. from OTHER to ADD/UNTRACK/IGNORE = OTHER + COPY\n\t\t */\n\n\t\tif (src->status == GIT_DELTA_DELETED) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\t\t\tnum_rewrites++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(tgt));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tassert(src->status == GIT_DELTA_DELETED);\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\t\t\t\tmemset(&src->new_file, 0, sizeof(src->new_file));\n\t\t\t\tsrc->new_file.path = src->old_file.path;\n\t\t\t\tsrc->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tnum_updates++;\n\n\t\t\t\tif (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (delta_is_split(src)) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->status = (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ?\n\t\t\t\t\tGIT_DELTA_UNTRACKED : GIT_DELTA_ADDED;\n\t\t\t\tsrc->nfiles = 1;\n\t\t\t\tmemset(&src->old_file, 0, sizeof(src->old_file));\n\t\t\t\tsrc->old_file.path = src->new_file.path;\n\t\t\t\tsrc->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tnum_updates++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(src));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\t\t\t\tnum_updates++;\n\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\n\t\t\t\t/* if we've just swapped the new element into the correct\n\t\t\t\t * place, clear the SPLIT flag\n\t\t\t\t */\n\t\t\t\tif (tgt2src[s].idx == t &&\n\t\t\t\t\ttgt2src[s].similarity >\n\t\t\t\t\topts.rename_from_rewrite_threshold) {\n\t\t\t\t\tsrc->status     = GIT_DELTA_RENAMED;\n\t\t\t\t\tsrc->similarity = tgt2src[s].similarity;\n\t\t\t\t\ttgt2src[s].similarity = 0;\n\t\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\t\tnum_rewrites--;\n\t\t\t\t}\n\t\t\t\t/* otherwise, if we just overwrote a source, update mapping */\n\t\t\t\telse if (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\n\t\t\t\tnum_updates++;\n\t\t\t}\n\t\t}\n\n\t\telse if (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\t\tif (tgt2src_copy[t].similarity < opts.copy_threshold)\n\t\t\t\tcontinue;\n\n\t\t\t/* always use best possible source for copy */\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\t\tsrc = GIT_VECTOR_GET(&diff->deltas, best_match->idx);\n\n\t\t\tif (delta_is_split(tgt)) {\n\t\t\t\terror = insert_delete_side_of_split(diff, &diff->deltas, tgt);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tnum_rewrites--;\n\t\t\t}\n\n\t\t\tif (!delta_is_split(tgt) && !delta_is_new_only(tgt))\n\t\t\t\tcontinue;\n\n\t\t\ttgt->status     = GIT_DELTA_COPIED;\n\t\t\ttgt->similarity = best_match->similarity;\n\t\t\ttgt->nfiles     = 2;\n\t\t\tmemcpy(&tgt->old_file, &src->old_file, sizeof(tgt->old_file));\n\t\t\ttgt->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\n\t\t\tnum_updates++;\n\t\t}\n\t}\n\n\t/*\n\t * Actually split and delete entries as needed\n\t */\n\n\tif (num_rewrites > 0 || num_updates > 0)\n\t\terror = apply_splits_and_deletes(\n\t\t\tdiff, diff->deltas.length - num_rewrites,\n\t\t\tFLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY));\n\ncleanup:\n\tgit__free(tgt2src);\n\tgit__free(src2tgt);\n\tgit__free(tgt2src_copy);\n\n\tif (sigcache) {\n\t\tfor (t = 0; t < num_deltas * 2; ++t) {\n\t\t\tif (sigcache[t] != NULL)\n\t\t\t\topts.metric->free_signature(sigcache[t], opts.metric->payload);\n\t\t}\n\t\tgit__free(sigcache);\n\t}\n\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_find_similar(\n\tgit_diff *diff,\n\tconst git_diff_find_options *given_opts)\n{\n\tsize_t s, t;\n\tint error = 0, result;\n\tuint16_t similarity;\n\tgit_diff_delta *src, *tgt;\n\tgit_diff_find_options opts = GIT_DIFF_FIND_OPTIONS_INIT;\n\tsize_t num_deltas, num_srcs = 0, num_tgts = 0;\n\tsize_t tried_srcs = 0, tried_tgts = 0;\n\tsize_t num_rewrites = 0, num_updates = 0, num_bumped = 0;\n\tsize_t sigcache_size;\n\tvoid **sigcache = NULL; /* cache of similarity metric file signatures */\n\tdiff_find_match *tgt2src = NULL;\n\tdiff_find_match *src2tgt = NULL;\n\tdiff_find_match *tgt2src_copy = NULL;\n\tdiff_find_match *best_match;\n\tgit_diff_file swap;\n\n\tif ((error = normalize_find_opts(diff, &opts, given_opts)) < 0)\n\t\treturn error;\n\n\tnum_deltas = diff->deltas.length;\n\n\t/* TODO: maybe abort if deltas.length > rename_limit ??? */\n\tif (!git__is_uint32(num_deltas))\n\t\tgoto cleanup;\n\n\t/* No flags set; nothing to do */\n\tif ((opts.flags & GIT_DIFF_FIND_ALL) == 0)\n\t\tgoto cleanup;\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&sigcache_size, num_deltas, 2);\n\tsigcache = git__calloc(sigcache_size, sizeof(void *));\n\tGITERR_CHECK_ALLOC(sigcache);\n\n\t/* Label rename sources and targets\n\t *\n\t * This will also set self-similarity scores for MODIFIED files and\n\t * mark them for splitting if break-rewrites is enabled\n\t */\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\tif (is_rename_source(diff, &opts, t, sigcache))\n\t\t\t++num_srcs;\n\n\t\tif (is_rename_target(diff, &opts, t, sigcache))\n\t\t\t++num_tgts;\n\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__TO_SPLIT) != 0)\n\t\t\tnum_rewrites++;\n\t}\n\n\t/* if there are no candidate srcs or tgts, we're done */\n\tif (!num_srcs || !num_tgts)\n\t\tgoto cleanup;\n\n\tsrc2tgt = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(src2tgt);\n\ttgt2src = git__calloc(num_deltas, sizeof(diff_find_match));\n\tGITERR_CHECK_ALLOC(tgt2src);\n\n\tif (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\ttgt2src_copy = git__calloc(num_deltas, sizeof(diff_find_match));\n\t\tGITERR_CHECK_ALLOC(tgt2src_copy);\n\t}\n\n\t/*\n\t * Find best-fit matches for rename / copy candidates\n\t */\n\nfind_best_matches:\n\ttried_tgts = num_bumped = 0;\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\ttried_srcs = 0;\n\n\t\tgit_vector_foreach(&diff->deltas, s, src) {\n\t\t\t/* skip things that are not rename sources */\n\t\t\tif ((src->flags & GIT_DIFF_FLAG__IS_RENAME_SOURCE) == 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* calculate similarity for this pair and find best match */\n\t\t\tif (s == t)\n\t\t\t\tresult = -1; /* don't measure self-similarity here */\n\t\t\telse if ((error = similarity_measure(\n\t\t\t\t&result, diff, &opts, sigcache, 2 * s, 2 * t + 1)) < 0)\n\t\t\t\tgoto cleanup;\n\n\t\t\tif (result < 0)\n\t\t\t\tcontinue;\n\t\t\tsimilarity = (uint16_t)result;\n\n\t\t\t/* is this a better rename? */\n\t\t\tif (tgt2src[t].similarity < similarity &&\n\t\t\t\tsrc2tgt[s].similarity < similarity)\n\t\t\t{\n\t\t\t\t/* eject old mapping */\n\t\t\t\tif (src2tgt[s].similarity > 0) {\n\t\t\t\t\ttgt2src[src2tgt[s].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\t\t\t\tif (tgt2src[t].similarity > 0) {\n\t\t\t\t\tsrc2tgt[tgt2src[t].idx].similarity = 0;\n\t\t\t\t\tnum_bumped++;\n\t\t\t\t}\n\n\t\t\t\t/* write new mapping */\n\t\t\t\ttgt2src[t].idx = s;\n\t\t\t\ttgt2src[t].similarity = similarity;\n\t\t\t\tsrc2tgt[s].idx = t;\n\t\t\t\tsrc2tgt[s].similarity = similarity;\n\t\t\t}\n\n\t\t\t/* keep best absolute match for copies */\n\t\t\tif (tgt2src_copy != NULL &&\n\t\t\t\ttgt2src_copy[t].similarity < similarity)\n\t\t\t{\n\t\t\t\ttgt2src_copy[t].idx = s;\n\t\t\t\ttgt2src_copy[t].similarity = similarity;\n\t\t\t}\n\n\t\t\tif (++tried_srcs >= num_srcs)\n\t\t\t\tbreak;\n\n\t\t\t/* cap on maximum targets we'll examine (per \"tgt\" file) */\n\t\t\tif (tried_srcs > opts.rename_limit)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (++tried_tgts >= num_tgts)\n\t\t\tbreak;\n\t}\n\n\tif (num_bumped > 0) /* try again if we bumped some items */\n\t\tgoto find_best_matches;\n\n\t/*\n\t * Rewrite the diffs with renames / copies\n\t */\n\n\tgit_vector_foreach(&diff->deltas, t, tgt) {\n\t\t/* skip things that are not rename targets */\n\t\tif ((tgt->flags & GIT_DIFF_FLAG__IS_RENAME_TARGET) == 0)\n\t\t\tcontinue;\n\n\t\t/* check if this delta was the target of a similarity */\n\t\tif (tgt2src[t].similarity)\n\t\t\tbest_match = &tgt2src[t];\n\t\telse if (tgt2src_copy && tgt2src_copy[t].similarity)\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\telse\n\t\t\tcontinue;\n\n\t\ts = best_match->idx;\n\t\tsrc = GIT_VECTOR_GET(&diff->deltas, s);\n\n\t\t/* possible scenarios:\n\t\t * 1. from DELETE to ADD/UNTRACK/IGNORE = RENAME\n\t\t * 2. from DELETE to SPLIT/TYPECHANGE = RENAME + DELETE\n\t\t * 3. from SPLIT/TYPECHANGE to ADD/UNTRACK/IGNORE = ADD + RENAME\n\t\t * 4. from SPLIT/TYPECHANGE to SPLIT/TYPECHANGE = RENAME + SPLIT\n\t\t * 5. from OTHER to ADD/UNTRACK/IGNORE = OTHER + COPY\n\t\t */\n\n\t\tif (src->status == GIT_DELTA_DELETED) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->flags |= GIT_DIFF_FLAG__TO_DELETE;\n\t\t\t\tnum_rewrites++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(tgt));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tassert(src->status == GIT_DELTA_DELETED);\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\t\t\t\tmemset(&src->new_file, 0, sizeof(src->new_file));\n\t\t\t\tsrc->new_file.path = src->old_file.path;\n\t\t\t\tsrc->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tnum_updates++;\n\n\t\t\t\tif (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\telse if (delta_is_split(src)) {\n\n\t\t\tif (delta_is_new_only(tgt)) {\n\n\t\t\t\tif (best_match->similarity < opts.rename_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\n\t\t\t\tsrc->status = (diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ?\n\t\t\t\t\tGIT_DELTA_UNTRACKED : GIT_DELTA_ADDED;\n\t\t\t\tsrc->nfiles = 1;\n\t\t\t\tmemset(&src->old_file, 0, sizeof(src->old_file));\n\t\t\t\tsrc->old_file.path = src->new_file.path;\n\t\t\t\tsrc->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\tnum_rewrites--;\n\n\t\t\t\tnum_updates++;\n\t\t\t} else {\n\t\t\t\tassert(delta_is_split(src));\n\n\t\t\t\tif (best_match->similarity < opts.rename_from_rewrite_threshold)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tmemcpy(&swap, &tgt->old_file, sizeof(swap));\n\n\t\t\t\tdelta_make_rename(tgt, src, best_match->similarity);\n\t\t\t\tnum_rewrites--;\n\t\t\t\tnum_updates++;\n\n\t\t\t\tmemcpy(&src->old_file, &swap, sizeof(src->old_file));\n\n\t\t\t\t/* if we've just swapped the new element into the correct\n\t\t\t\t * place, clear the SPLIT flag\n\t\t\t\t */\n\t\t\t\tif (tgt2src[s].idx == t &&\n\t\t\t\t\ttgt2src[s].similarity >\n\t\t\t\t\topts.rename_from_rewrite_threshold) {\n\t\t\t\t\tsrc->status     = GIT_DELTA_RENAMED;\n\t\t\t\t\tsrc->similarity = tgt2src[s].similarity;\n\t\t\t\t\ttgt2src[s].similarity = 0;\n\t\t\t\t\tsrc->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\t\t\t\t\tnum_rewrites--;\n\t\t\t\t}\n\t\t\t\t/* otherwise, if we just overwrote a source, update mapping */\n\t\t\t\telse if (src2tgt[t].similarity > 0 && src2tgt[t].idx > t) {\n\t\t\t\t\t/* what used to be at src t is now at src s */\n\t\t\t\t\ttgt2src[src2tgt[t].idx].idx = s;\n\t\t\t\t}\n\n\t\t\t\tnum_updates++;\n\t\t\t}\n\t\t}\n\n\t\telse if (FLAG_SET(&opts, GIT_DIFF_FIND_COPIES)) {\n\t\t\tif (tgt2src_copy[t].similarity < opts.copy_threshold)\n\t\t\t\tcontinue;\n\n\t\t\t/* always use best possible source for copy */\n\t\t\tbest_match = &tgt2src_copy[t];\n\t\t\tsrc = GIT_VECTOR_GET(&diff->deltas, best_match->idx);\n\n\t\t\tif (delta_is_split(tgt)) {\n\t\t\t\terror = insert_delete_side_of_split(diff, &diff->deltas, tgt);\n\t\t\t\tif (error < 0)\n\t\t\t\t\tgoto cleanup;\n\t\t\t\tnum_rewrites--;\n\t\t\t}\n\n\t\t\tif (!delta_is_split(tgt) && !delta_is_new_only(tgt))\n\t\t\t\tcontinue;\n\n\t\t\ttgt->status     = GIT_DELTA_COPIED;\n\t\t\ttgt->similarity = best_match->similarity;\n\t\t\ttgt->nfiles     = 2;\n\t\t\tmemcpy(&tgt->old_file, &src->old_file, sizeof(tgt->old_file));\n\t\t\ttgt->flags &= ~GIT_DIFF_FLAG__TO_SPLIT;\n\n\t\t\tnum_updates++;\n\t\t}\n\t}\n\n\t/*\n\t * Actually split and delete entries as needed\n\t */\n\n\tif (num_rewrites > 0 || num_updates > 0)\n\t\terror = apply_splits_and_deletes(\n\t\t\tdiff, diff->deltas.length - num_rewrites,\n\t\t\tFLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES) &&\n\t\t\t!FLAG_SET(&opts, GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY));\n\ncleanup:\n\tgit__free(tgt2src);\n\tgit__free(src2tgt);\n\tgit__free(tgt2src_copy);\n\n\tif (sigcache) {\n\t\tfor (t = 0; t < num_deltas * 2; ++t) {\n\t\t\tif (sigcache[t] != NULL)\n\t\t\t\topts.metric->free_signature(sigcache[t], opts.metric->payload);\n\t\t}\n\t\tgit__free(sigcache);\n\t}\n\n\tif (!given_opts || !given_opts->metric)\n\t\tgit__free(opts.metric);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&status->idx2wd",
            "repo",
            "index",
            "&diffopt"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&status->head2idx",
            "repo",
            "head",
            "index",
            "&diffopt"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&diffopt.pathspec",
            "&opts->pathspec",
            "sizeof(diffopt.pathspec)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&status->opts",
            "opts",
            "sizeof(git_status_options)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "status"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_status_list_alloc",
          "args": [
            "index"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "git_status_list_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "219-235",
          "snippet": "static git_status_list *git_status_list_alloc(git_index *index)\n{\n\tgit_status_list *status = NULL;\n\tint (*entrycmp)(const void *a, const void *b);\n\n\tif (!(status = git__calloc(1, sizeof(git_status_list))))\n\t\treturn NULL;\n\n\tentrycmp = index->ignore_case ? status_entry_icmp : status_entry_cmp;\n\n\tif (git_vector_init(&status->paired, 0, entrycmp) < 0) {\n\t\tgit__free(status);\n\t\treturn NULL;\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic git_status_list *git_status_list_alloc(git_index *index)\n{\n\tgit_status_list *status = NULL;\n\tint (*entrycmp)(const void *a, const void *b);\n\n\tif (!(status = git__calloc(1, sizeof(git_status_list))))\n\t\treturn NULL;\n\n\tentrycmp = index->ignore_case ? status_entry_icmp : status_entry_cmp;\n\n\tif (git_vector_init(&status->paired, 0, entrycmp) < 0) {\n\t\tgit__free(status);\n\t\treturn NULL;\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_read",
          "args": [
            "index",
            "false"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2928-3062",
          "snippet": "int git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_head_tree",
          "args": [
            "&head",
            "repo"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_head_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1914-1931",
          "snippet": "int git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_head_tree(git_tree **tree, git_repository *repo)\n{\n\tgit_reference *head;\n\tgit_object *obj;\n\tint error;\n\n\tif ((error = git_repository_head(&head, repo)) < 0)\n\t\treturn error;\n\n\tif ((error = git_reference_peel(&obj, head, GIT_OBJ_TREE)) < 0)\n\t\tgoto cleanup;\n\n\t*tree = (git_tree *)obj;\n\ncleanup:\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "852-859",
          "snippet": "int git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index(git_index **out, git_repository *repo)\n{\n\tif (git_repository_index__weakptr(out, repo) < 0)\n\t\treturn -1;\n\n\tGIT_REFCOUNT_INC(*out);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"status\""
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "status_validate_options",
          "args": [
            "opts"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "status_validate_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "237-257",
          "snippet": "static int status_validate_options(const git_status_options *opts)\n{\n\tif (!opts)\n\t\treturn 0;\n\n\tGITERR_CHECK_VERSION(opts, GIT_STATUS_OPTIONS_VERSION, \"git_status_options\");\n\n\tif (opts->show > GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tgiterr_set(GITERR_INVALID, \"Unknown status 'show' option\");\n\t\treturn -1;\n\t}\n\n\tif ((opts->flags & GIT_STATUS_OPT_NO_REFRESH) != 0 &&\n\t\t(opts->flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Updating index from status \"\n\t\t\t\"is not allowed when index refresh is disabled\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic int status_validate_options(const git_status_options *opts)\n{\n\tif (!opts)\n\t\treturn 0;\n\n\tGITERR_CHECK_VERSION(opts, GIT_STATUS_OPTIONS_VERSION, \"git_status_options\");\n\n\tif (opts->show > GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tgiterr_set(GITERR_INVALID, \"Unknown status 'show' option\");\n\t\treturn -1;\n\t}\n\n\tif ((opts->flags & GIT_STATUS_OPT_NO_REFRESH) != 0 &&\n\t\t(opts->flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Updating index from status \"\n\t\t\t\"is not allowed when index refresh is disabled\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nint git_status_list_new(\n\tgit_status_list **out,\n\tgit_repository *repo,\n\tconst git_status_options *opts)\n{\n\tgit_index *index = NULL;\n\tgit_status_list *status = NULL;\n\tgit_diff_options diffopt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff_find_options findopt = GIT_DIFF_FIND_OPTIONS_INIT;\n\tgit_tree *head = NULL;\n\tgit_status_show_t show =\n\t\topts ? opts->show : GIT_STATUS_SHOW_INDEX_AND_WORKDIR;\n\tint error = 0;\n\tunsigned int flags = opts ? opts->flags : GIT_STATUS_OPT_DEFAULTS;\n\n\t*out = NULL;\n\n\tif (status_validate_options(opts) < 0)\n\t\treturn -1;\n\n\tif ((error = git_repository__ensure_not_bare(repo, \"status\")) < 0 ||\n\t\t(error = git_repository_index(&index, repo)) < 0)\n\t\treturn error;\n\n\t/* if there is no HEAD, that's okay - we'll make an empty iterator */\n\tif ((error = git_repository_head_tree(&head, repo)) < 0) {\n\t\tif (error != GIT_ENOTFOUND && error != GIT_EUNBORNBRANCH)\n\t\t\tgoto done;\n\t\tgiterr_clear();\n\t}\n\n\t/* refresh index from disk unless prevented */\n\tif ((flags & GIT_STATUS_OPT_NO_REFRESH) == 0 &&\n\t\tgit_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\tstatus = git_status_list_alloc(index);\n\tGITERR_CHECK_ALLOC(status);\n\n\tif (opts) {\n\t\tmemcpy(&status->opts, opts, sizeof(git_status_options));\n\t\tmemcpy(&diffopt.pathspec, &opts->pathspec, sizeof(diffopt.pathspec));\n\t}\n\n\tdiffopt.flags = GIT_DIFF_INCLUDE_TYPECHANGE;\n\tfindopt.flags = GIT_DIFF_FIND_FOR_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNTRACKED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_IGNORED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_IGNORED;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNMODIFIED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNMODIFIED;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_UNTRACKED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_DISABLE_PATHSPEC_MATCH;\n\tif ((flags & GIT_STATUS_OPT_RECURSE_IGNORED_DIRS) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_RECURSE_IGNORED_DIRS;\n\tif ((flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_IGNORE_SUBMODULES;\n\tif ((flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_UPDATE_INDEX;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE;\n\tif ((flags & GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED) != 0)\n\t\tdiffopt.flags = diffopt.flags | GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED;\n\n\tif ((flags & GIT_STATUS_OPT_RENAMES_FROM_REWRITES) != 0)\n\t\tfindopt.flags = findopt.flags |\n\t\t\tGIT_DIFF_FIND_AND_BREAK_REWRITES |\n\t\t\tGIT_DIFF_FIND_RENAMES_FROM_REWRITES |\n\t\t\tGIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY;\n\n\tif (show != GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tif ((error = git_diff_tree_to_index(\n\t\t\t\t&status->head2idx, repo, head, index, &diffopt)) < 0)\n\t\t\tgoto done;\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->head2idx, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (show != GIT_STATUS_SHOW_INDEX_ONLY) {\n\t\tif ((error = git_diff_index_to_workdir(\n\t\t\t\t&status->idx2wd, repo, index, &diffopt)) < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((flags & GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR) != 0 &&\n\t\t\t(error = git_diff_find_similar(status->idx2wd, &findopt)) < 0)\n\t\t\tgoto done;\n\t}\n\n\terror = git_diff__paired_foreach(\n\t\tstatus->head2idx, status->idx2wd, status_collect, status);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_SENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_cmp);\n\tif (flags & GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)\n\t\tgit_vector_set_cmp(&status->paired, status_entry_icmp);\n\n\tif ((flags &\n\t\t (GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX |\n\t\t  GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR |\n\t\t  GIT_STATUS_OPT_SORT_CASE_SENSITIVELY |\n\t\t  GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY)) != 0)\n\t\tgit_vector_sort(&status->paired);\n\ndone:\n\tif (error < 0) {\n\t\tgit_status_list_free(status);\n\t\tstatus = NULL;\n\t}\n\n\t*out = status;\n\n\tgit_tree_free(head);\n\tgit_index_free(index);\n\n\treturn error;\n}"
  },
  {
    "function_name": "status_validate_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "237-257",
    "snippet": "static int status_validate_options(const git_status_options *opts)\n{\n\tif (!opts)\n\t\treturn 0;\n\n\tGITERR_CHECK_VERSION(opts, GIT_STATUS_OPTIONS_VERSION, \"git_status_options\");\n\n\tif (opts->show > GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tgiterr_set(GITERR_INVALID, \"Unknown status 'show' option\");\n\t\treturn -1;\n\t}\n\n\tif ((opts->flags & GIT_STATUS_OPT_NO_REFRESH) != 0 &&\n\t\t(opts->flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Updating index from status \"\n\t\t\t\"is not allowed when index refresh is disabled\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Updating index from status \"\n\t\t\t\"is not allowed when index refresh is disabled\""
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "opts",
            "GIT_STATUS_OPTIONS_VERSION",
            "\"git_status_options\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic int status_validate_options(const git_status_options *opts)\n{\n\tif (!opts)\n\t\treturn 0;\n\n\tGITERR_CHECK_VERSION(opts, GIT_STATUS_OPTIONS_VERSION, \"git_status_options\");\n\n\tif (opts->show > GIT_STATUS_SHOW_WORKDIR_ONLY) {\n\t\tgiterr_set(GITERR_INVALID, \"Unknown status 'show' option\");\n\t\treturn -1;\n\t}\n\n\tif ((opts->flags & GIT_STATUS_OPT_NO_REFRESH) != 0 &&\n\t\t(opts->flags & GIT_STATUS_OPT_UPDATE_INDEX) != 0) {\n\t\tgiterr_set(GITERR_INVALID, \"Updating index from status \"\n\t\t\t\"is not allowed when index refresh is disabled\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_status_list_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "219-235",
    "snippet": "static git_status_list *git_status_list_alloc(git_index *index)\n{\n\tgit_status_list *status = NULL;\n\tint (*entrycmp)(const void *a, const void *b);\n\n\tif (!(status = git__calloc(1, sizeof(git_status_list))))\n\t\treturn NULL;\n\n\tentrycmp = index->ignore_case ? status_entry_icmp : status_entry_cmp;\n\n\tif (git_vector_init(&status->paired, 0, entrycmp) < 0) {\n\t\tgit__free(status);\n\t\treturn NULL;\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "status"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&status->paired",
            "0",
            "entrycmp"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_status_list)"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic git_status_list *git_status_list_alloc(git_index *index)\n{\n\tgit_status_list *status = NULL;\n\tint (*entrycmp)(const void *a, const void *b);\n\n\tif (!(status = git__calloc(1, sizeof(git_status_list))))\n\t\treturn NULL;\n\n\tentrycmp = index->ignore_case ? status_entry_icmp : status_entry_cmp;\n\n\tif (git_vector_init(&status->paired, 0, entrycmp) < 0) {\n\t\tgit__free(status);\n\t\treturn NULL;\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "status_entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "214-217",
    "snippet": "static int status_entry_cmp(const void *a, const void *b)\n{\n\treturn status_entry_cmp_base(a, b, git__strcmp);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "status_entry_cmp_base",
          "args": [
            "a",
            "b",
            "git__strcmp"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "status_entry_cmp_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "185-207",
          "snippet": "GIT_INLINE(int) status_entry_cmp_base(\n\tconst void *a,\n\tconst void *b,\n\tint (*strcomp)(const char *a, const char *b))\n{\n\tconst git_status_entry *entry_a = a;\n\tconst git_status_entry *entry_b = b;\n\tconst git_diff_delta *delta_a, *delta_b;\n\n\tdelta_a = entry_a->index_to_workdir ? entry_a->index_to_workdir :\n\t\tentry_a->head_to_index;\n\tdelta_b = entry_b->index_to_workdir ? entry_b->index_to_workdir :\n\t\tentry_b->head_to_index;\n\n\tif (!delta_a && delta_b)\n\t\treturn -1;\n\tif (delta_a && !delta_b)\n\t\treturn 1;\n\tif (!delta_a && !delta_b)\n\t\treturn 0;\n\n\treturn strcomp(delta_a->new_file.path, delta_b->new_file.path);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) status_entry_cmp_base(\n\tconst void *a,\n\tconst void *b,\n\tint (*strcomp)(const char *a, const char *b))\n{\n\tconst git_status_entry *entry_a = a;\n\tconst git_status_entry *entry_b = b;\n\tconst git_diff_delta *delta_a, *delta_b;\n\n\tdelta_a = entry_a->index_to_workdir ? entry_a->index_to_workdir :\n\t\tentry_a->head_to_index;\n\tdelta_b = entry_b->index_to_workdir ? entry_b->index_to_workdir :\n\t\tentry_b->head_to_index;\n\n\tif (!delta_a && delta_b)\n\t\treturn -1;\n\tif (delta_a && !delta_b)\n\t\treturn 1;\n\tif (!delta_a && !delta_b)\n\t\treturn 0;\n\n\treturn strcomp(delta_a->new_file.path, delta_b->new_file.path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic int status_entry_cmp(const void *a, const void *b)\n{\n\treturn status_entry_cmp_base(a, b, git__strcmp);\n}"
  },
  {
    "function_name": "status_entry_icmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "209-212",
    "snippet": "static int status_entry_icmp(const void *a, const void *b)\n{\n\treturn status_entry_cmp_base(a, b, git__strcasecmp);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "status_entry_cmp_base",
          "args": [
            "a",
            "b",
            "git__strcasecmp"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "status_entry_cmp_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "185-207",
          "snippet": "GIT_INLINE(int) status_entry_cmp_base(\n\tconst void *a,\n\tconst void *b,\n\tint (*strcomp)(const char *a, const char *b))\n{\n\tconst git_status_entry *entry_a = a;\n\tconst git_status_entry *entry_b = b;\n\tconst git_diff_delta *delta_a, *delta_b;\n\n\tdelta_a = entry_a->index_to_workdir ? entry_a->index_to_workdir :\n\t\tentry_a->head_to_index;\n\tdelta_b = entry_b->index_to_workdir ? entry_b->index_to_workdir :\n\t\tentry_b->head_to_index;\n\n\tif (!delta_a && delta_b)\n\t\treturn -1;\n\tif (delta_a && !delta_b)\n\t\treturn 1;\n\tif (!delta_a && !delta_b)\n\t\treturn 0;\n\n\treturn strcomp(delta_a->new_file.path, delta_b->new_file.path);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) status_entry_cmp_base(\n\tconst void *a,\n\tconst void *b,\n\tint (*strcomp)(const char *a, const char *b))\n{\n\tconst git_status_entry *entry_a = a;\n\tconst git_status_entry *entry_b = b;\n\tconst git_diff_delta *delta_a, *delta_b;\n\n\tdelta_a = entry_a->index_to_workdir ? entry_a->index_to_workdir :\n\t\tentry_a->head_to_index;\n\tdelta_b = entry_b->index_to_workdir ? entry_b->index_to_workdir :\n\t\tentry_b->head_to_index;\n\n\tif (!delta_a && delta_b)\n\t\treturn -1;\n\tif (delta_a && !delta_b)\n\t\treturn 1;\n\tif (!delta_a && !delta_b)\n\t\treturn 0;\n\n\treturn strcomp(delta_a->new_file.path, delta_b->new_file.path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic int status_entry_icmp(const void *a, const void *b)\n{\n\treturn status_entry_cmp_base(a, b, git__strcasecmp);\n}"
  },
  {
    "function_name": "status_entry_cmp_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "185-207",
    "snippet": "GIT_INLINE(int) status_entry_cmp_base(\n\tconst void *a,\n\tconst void *b,\n\tint (*strcomp)(const char *a, const char *b))\n{\n\tconst git_status_entry *entry_a = a;\n\tconst git_status_entry *entry_b = b;\n\tconst git_diff_delta *delta_a, *delta_b;\n\n\tdelta_a = entry_a->index_to_workdir ? entry_a->index_to_workdir :\n\t\tentry_a->head_to_index;\n\tdelta_b = entry_b->index_to_workdir ? entry_b->index_to_workdir :\n\t\tentry_b->head_to_index;\n\n\tif (!delta_a && delta_b)\n\t\treturn -1;\n\tif (delta_a && !delta_b)\n\t\treturn 1;\n\tif (!delta_a && !delta_b)\n\t\treturn 0;\n\n\treturn strcomp(delta_a->new_file.path, delta_b->new_file.path);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcomp",
          "args": [
            "delta_a->new_file.path",
            "delta_b->new_file.path"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) status_entry_cmp_base(\n\tconst void *a,\n\tconst void *b,\n\tint (*strcomp)(const char *a, const char *b))\n{\n\tconst git_status_entry *entry_a = a;\n\tconst git_status_entry *entry_b = b;\n\tconst git_diff_delta *delta_a, *delta_b;\n\n\tdelta_a = entry_a->index_to_workdir ? entry_a->index_to_workdir :\n\t\tentry_a->head_to_index;\n\tdelta_b = entry_b->index_to_workdir ? entry_b->index_to_workdir :\n\t\tentry_b->head_to_index;\n\n\tif (!delta_a && delta_b)\n\t\treturn -1;\n\tif (delta_a && !delta_b)\n\t\treturn 1;\n\tif (!delta_a && !delta_b)\n\t\treturn 0;\n\n\treturn strcomp(delta_a->new_file.path, delta_b->new_file.path);\n}"
  },
  {
    "function_name": "status_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "164-183",
    "snippet": "static int status_collect(\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd,\n\tvoid *payload)\n{\n\tgit_status_list *status = payload;\n\tgit_status_entry *status_entry;\n\n\tif (!status_is_included(status, head2idx, idx2wd))\n\t\treturn 0;\n\n\tstatus_entry = git__malloc(sizeof(git_status_entry));\n\tGITERR_CHECK_ALLOC(status_entry);\n\n\tstatus_entry->status = status_compute(status, head2idx, idx2wd);\n\tstatus_entry->head_to_index = head2idx;\n\tstatus_entry->index_to_workdir = idx2wd;\n\n\treturn git_vector_insert(&status->paired, status_entry);\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&status->paired",
            "status_entry"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "status_compute",
          "args": [
            "status",
            "head2idx",
            "idx2wd"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "status_compute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "148-162",
          "snippet": "static git_status_t status_compute(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tif (head2idx)\n\t\tst |= index_delta2status(head2idx);\n\n\tif (idx2wd)\n\t\tst |= workdir_delta2status(status->idx2wd, idx2wd);\n\n\treturn st;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic git_status_t status_compute(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tif (head2idx)\n\t\tst |= index_delta2status(head2idx);\n\n\tif (idx2wd)\n\t\tst |= workdir_delta2status(status->idx2wd, idx2wd);\n\n\treturn st;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "status_entry"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(git_status_entry)"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "status_is_included",
          "args": [
            "status",
            "head2idx",
            "idx2wd"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "status_is_included",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "118-146",
          "snippet": "static bool status_is_included(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tif (!(status->opts.flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES))\n\t\treturn 1;\n\n\t/* if excluding submodules and this is a submodule everywhere */\n\tif (head2idx) {\n\t\tif (head2idx->status != GIT_DELTA_ADDED &&\n\t\t\thead2idx->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (head2idx->status != GIT_DELTA_DELETED &&\n\t\t\thead2idx->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\tif (idx2wd) {\n\t\tif (idx2wd->status != GIT_DELTA_ADDED &&\n\t\t\tidx2wd->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (idx2wd->status != GIT_DELTA_DELETED &&\n\t\t\tidx2wd->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\n\t/* only get here if every valid mode is GIT_FILEMODE_COMMIT */\n\treturn 0;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic bool status_is_included(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tif (!(status->opts.flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES))\n\t\treturn 1;\n\n\t/* if excluding submodules and this is a submodule everywhere */\n\tif (head2idx) {\n\t\tif (head2idx->status != GIT_DELTA_ADDED &&\n\t\t\thead2idx->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (head2idx->status != GIT_DELTA_DELETED &&\n\t\t\thead2idx->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\tif (idx2wd) {\n\t\tif (idx2wd->status != GIT_DELTA_ADDED &&\n\t\t\tidx2wd->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (idx2wd->status != GIT_DELTA_DELETED &&\n\t\t\tidx2wd->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\n\t/* only get here if every valid mode is GIT_FILEMODE_COMMIT */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic int status_collect(\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd,\n\tvoid *payload)\n{\n\tgit_status_list *status = payload;\n\tgit_status_entry *status_entry;\n\n\tif (!status_is_included(status, head2idx, idx2wd))\n\t\treturn 0;\n\n\tstatus_entry = git__malloc(sizeof(git_status_entry));\n\tGITERR_CHECK_ALLOC(status_entry);\n\n\tstatus_entry->status = status_compute(status, head2idx, idx2wd);\n\tstatus_entry->head_to_index = head2idx;\n\tstatus_entry->index_to_workdir = idx2wd;\n\n\treturn git_vector_insert(&status->paired, status_entry);\n}"
  },
  {
    "function_name": "status_compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "148-162",
    "snippet": "static git_status_t status_compute(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tif (head2idx)\n\t\tst |= index_delta2status(head2idx);\n\n\tif (idx2wd)\n\t\tst |= workdir_delta2status(status->idx2wd, idx2wd);\n\n\treturn st;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "workdir_delta2status",
          "args": [
            "status->idx2wd",
            "idx2wd"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "workdir_delta2status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "57-116",
          "snippet": "static unsigned int workdir_delta2status(\n\tgit_diff *diff, git_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (idx2wd->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tst = GIT_STATUS_WT_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\t\tst = GIT_STATUS_WT_UNREADABLE;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_WT_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_WT_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_IGNORED:\n\t\tst = GIT_STATUS_IGNORED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_WT_RENAMED;\n\n\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id)) {\n\t\t\t/* if OIDs don't match, we might need to calculate them now to\n\t\t\t * discern between RENAMED vs RENAMED+MODIFED\n\t\t\t */\n\t\t\tif (git_oid_iszero(&idx2wd->old_file.id) &&\n\t\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->old_file.id, diff, idx2wd->old_file.path,\n\t\t\t\t\tidx2wd->old_file.mode, idx2wd->old_file.size))\n\t\t\tidx2wd->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (git_oid_iszero(&idx2wd->new_file.id) &&\n\t\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->new_file.id, diff, idx2wd->new_file.path,\n\t\t\t\t\tidx2wd->new_file.mode, idx2wd->new_file.size))\n\t\t\t\tidx2wd->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id))\n\t\t\t\tst |= GIT_STATUS_WT_MODIFIED;\n\t\t}\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_WT_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic unsigned int workdir_delta2status(\n\tgit_diff *diff, git_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (idx2wd->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tst = GIT_STATUS_WT_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\t\tst = GIT_STATUS_WT_UNREADABLE;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_WT_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_WT_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_IGNORED:\n\t\tst = GIT_STATUS_IGNORED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_WT_RENAMED;\n\n\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id)) {\n\t\t\t/* if OIDs don't match, we might need to calculate them now to\n\t\t\t * discern between RENAMED vs RENAMED+MODIFED\n\t\t\t */\n\t\t\tif (git_oid_iszero(&idx2wd->old_file.id) &&\n\t\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->old_file.id, diff, idx2wd->old_file.path,\n\t\t\t\t\tidx2wd->old_file.mode, idx2wd->old_file.size))\n\t\t\tidx2wd->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (git_oid_iszero(&idx2wd->new_file.id) &&\n\t\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->new_file.id, diff, idx2wd->new_file.path,\n\t\t\t\t\tidx2wd->new_file.mode, idx2wd->new_file.size))\n\t\t\t\tidx2wd->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id))\n\t\t\t\tst |= GIT_STATUS_WT_MODIFIED;\n\t\t}\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_WT_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_delta2status",
          "args": [
            "head2idx"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "index_delta2status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
          "lines": "23-55",
          "snippet": "static unsigned int index_delta2status(const git_diff_delta *head2idx)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (head2idx->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\t\tst = GIT_STATUS_INDEX_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_INDEX_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_INDEX_RENAMED;\n\n\t\tif (!git_oid_equal(&head2idx->old_file.id, &head2idx->new_file.id))\n\t\t\tst |= GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_INDEX_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"git2/diff.h\"",
            "#include \"index.h\"",
            "#include \"ignore.h\"",
            "#include \"repository.h\"",
            "#include \"git2/status.h\"",
            "#include \"status.h\"",
            "#include \"tree.h\"",
            "#include \"vector.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic unsigned int index_delta2status(const git_diff_delta *head2idx)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (head2idx->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\t\tst = GIT_STATUS_INDEX_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_INDEX_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_INDEX_RENAMED;\n\n\t\tif (!git_oid_equal(&head2idx->old_file.id, &head2idx->new_file.id))\n\t\t\tst |= GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_INDEX_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic git_status_t status_compute(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tif (head2idx)\n\t\tst |= index_delta2status(head2idx);\n\n\tif (idx2wd)\n\t\tst |= workdir_delta2status(status->idx2wd, idx2wd);\n\n\treturn st;\n}"
  },
  {
    "function_name": "status_is_included",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "118-146",
    "snippet": "static bool status_is_included(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tif (!(status->opts.flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES))\n\t\treturn 1;\n\n\t/* if excluding submodules and this is a submodule everywhere */\n\tif (head2idx) {\n\t\tif (head2idx->status != GIT_DELTA_ADDED &&\n\t\t\thead2idx->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (head2idx->status != GIT_DELTA_DELETED &&\n\t\t\thead2idx->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\tif (idx2wd) {\n\t\tif (idx2wd->status != GIT_DELTA_ADDED &&\n\t\t\tidx2wd->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (idx2wd->status != GIT_DELTA_DELETED &&\n\t\t\tidx2wd->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\n\t/* only get here if every valid mode is GIT_FILEMODE_COMMIT */\n\treturn 0;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic bool status_is_included(\n\tgit_status_list *status,\n\tgit_diff_delta *head2idx,\n\tgit_diff_delta *idx2wd)\n{\n\tif (!(status->opts.flags & GIT_STATUS_OPT_EXCLUDE_SUBMODULES))\n\t\treturn 1;\n\n\t/* if excluding submodules and this is a submodule everywhere */\n\tif (head2idx) {\n\t\tif (head2idx->status != GIT_DELTA_ADDED &&\n\t\t\thead2idx->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (head2idx->status != GIT_DELTA_DELETED &&\n\t\t\thead2idx->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\tif (idx2wd) {\n\t\tif (idx2wd->status != GIT_DELTA_ADDED &&\n\t\t\tidx2wd->old_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t\tif (idx2wd->status != GIT_DELTA_DELETED &&\n\t\t\tidx2wd->new_file.mode != GIT_FILEMODE_COMMIT)\n\t\t\treturn 1;\n\t}\n\n\t/* only get here if every valid mode is GIT_FILEMODE_COMMIT */\n\treturn 0;\n}"
  },
  {
    "function_name": "workdir_delta2status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "57-116",
    "snippet": "static unsigned int workdir_delta2status(\n\tgit_diff *diff, git_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (idx2wd->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tst = GIT_STATUS_WT_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\t\tst = GIT_STATUS_WT_UNREADABLE;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_WT_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_WT_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_IGNORED:\n\t\tst = GIT_STATUS_IGNORED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_WT_RENAMED;\n\n\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id)) {\n\t\t\t/* if OIDs don't match, we might need to calculate them now to\n\t\t\t * discern between RENAMED vs RENAMED+MODIFED\n\t\t\t */\n\t\t\tif (git_oid_iszero(&idx2wd->old_file.id) &&\n\t\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->old_file.id, diff, idx2wd->old_file.path,\n\t\t\t\t\tidx2wd->old_file.mode, idx2wd->old_file.size))\n\t\t\tidx2wd->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (git_oid_iszero(&idx2wd->new_file.id) &&\n\t\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->new_file.id, diff, idx2wd->new_file.path,\n\t\t\t\t\tidx2wd->new_file.mode, idx2wd->new_file.size))\n\t\t\t\tidx2wd->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id))\n\t\t\t\tst |= GIT_STATUS_WT_MODIFIED;\n\t\t}\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_WT_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&idx2wd->old_file.id",
            "&idx2wd->new_file.id"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__oid_for_file",
          "args": [
            "&idx2wd->new_file.id",
            "diff",
            "idx2wd->new_file.path",
            "idx2wd->new_file.mode",
            "idx2wd->new_file.size"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__oid_for_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "589-604",
          "snippet": "int git_diff__oid_for_file(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst char *path,\n\tuint16_t mode,\n\tgit_off_t size)\n{\n\tgit_index_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.mode = mode;\n\tentry.file_size = size;\n\tentry.path = (char *)path;\n\n\treturn git_diff__oid_for_entry(out, diff, &entry, mode, NULL);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__oid_for_file(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst char *path,\n\tuint16_t mode,\n\tgit_off_t size)\n{\n\tgit_index_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.mode = mode;\n\tentry.file_size = size;\n\tentry.path = (char *)path;\n\n\treturn git_diff__oid_for_entry(out, diff, &entry, mode, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&idx2wd->new_file.id"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic unsigned int workdir_delta2status(\n\tgit_diff *diff, git_diff_delta *idx2wd)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (idx2wd->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tst = GIT_STATUS_WT_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\t\tst = GIT_STATUS_WT_UNREADABLE;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_WT_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_WT_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_IGNORED:\n\t\tst = GIT_STATUS_IGNORED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_WT_RENAMED;\n\n\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id)) {\n\t\t\t/* if OIDs don't match, we might need to calculate them now to\n\t\t\t * discern between RENAMED vs RENAMED+MODIFED\n\t\t\t */\n\t\t\tif (git_oid_iszero(&idx2wd->old_file.id) &&\n\t\t\t\tdiff->old_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->old_file.id, diff, idx2wd->old_file.path,\n\t\t\t\t\tidx2wd->old_file.mode, idx2wd->old_file.size))\n\t\t\tidx2wd->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (git_oid_iszero(&idx2wd->new_file.id) &&\n\t\t\t\tdiff->new_src == GIT_ITERATOR_TYPE_WORKDIR &&\n\t\t\t\t!git_diff__oid_for_file(\n\t\t\t\t\t&idx2wd->new_file.id, diff, idx2wd->new_file.path,\n\t\t\t\t\tidx2wd->new_file.mode, idx2wd->new_file.size))\n\t\t\t\tidx2wd->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\t\t\tif (!git_oid_equal(&idx2wd->old_file.id, &idx2wd->new_file.id))\n\t\t\t\tst |= GIT_STATUS_WT_MODIFIED;\n\t\t}\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_WT_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}"
  },
  {
    "function_name": "index_delta2status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/status.c",
    "lines": "23-55",
    "snippet": "static unsigned int index_delta2status(const git_diff_delta *head2idx)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (head2idx->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\t\tst = GIT_STATUS_INDEX_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_INDEX_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_INDEX_RENAMED;\n\n\t\tif (!git_oid_equal(&head2idx->old_file.id, &head2idx->new_file.id))\n\t\t\tst |= GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_INDEX_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}",
    "includes": [
      "#include \"diff.h\"",
      "#include \"git2/diff.h\"",
      "#include \"index.h\"",
      "#include \"ignore.h\"",
      "#include \"repository.h\"",
      "#include \"git2/status.h\"",
      "#include \"status.h\"",
      "#include \"tree.h\"",
      "#include \"vector.h\"",
      "#include \"hash.h\"",
      "#include \"fileops.h\"",
      "#include \"git2.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&head2idx->old_file.id",
            "&head2idx->new_file.id"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"diff.h\"\n#include \"git2/diff.h\"\n#include \"index.h\"\n#include \"ignore.h\"\n#include \"repository.h\"\n#include \"git2/status.h\"\n#include \"status.h\"\n#include \"tree.h\"\n#include \"vector.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2.h\"\n#include \"common.h\"\n\nstatic unsigned int index_delta2status(const git_diff_delta *head2idx)\n{\n\tgit_status_t st = GIT_STATUS_CURRENT;\n\n\tswitch (head2idx->status) {\n\tcase GIT_DELTA_ADDED:\n\tcase GIT_DELTA_COPIED:\n\t\tst = GIT_STATUS_INDEX_NEW;\n\t\tbreak;\n\tcase GIT_DELTA_DELETED:\n\t\tst = GIT_STATUS_INDEX_DELETED;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tst = GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_RENAMED:\n\t\tst = GIT_STATUS_INDEX_RENAMED;\n\n\t\tif (!git_oid_equal(&head2idx->old_file.id, &head2idx->new_file.id))\n\t\t\tst |= GIT_STATUS_INDEX_MODIFIED;\n\t\tbreak;\n\tcase GIT_DELTA_TYPECHANGE:\n\t\tst = GIT_STATUS_INDEX_TYPECHANGE;\n\t\tbreak;\n\tcase GIT_DELTA_CONFLICTED:\n\t\tst = GIT_STATUS_CONFLICTED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn st;\n}"
  }
]