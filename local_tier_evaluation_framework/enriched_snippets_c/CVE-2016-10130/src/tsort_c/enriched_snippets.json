[
  {
    "function_name": "git__tsort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "382-385",
    "snippet": "void git__tsort(void **dst, size_t size, git__tsort_cmp cmp)\n{\n\tgit__tsort_r(dst, size, tsort_r_cmp, cmp);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__tsort_r",
          "args": [
            "dst",
            "size",
            "tsort_r_cmp",
            "cmp"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nvoid git__tsort(void **dst, size_t size, git__tsort_cmp cmp)\n{\n\tgit__tsort_r(dst, size, tsort_r_cmp, cmp);\n}"
  },
  {
    "function_name": "tsort_r_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "377-380",
    "snippet": "static int tsort_r_cmp(const void *a, const void *b, void *payload)\n{\n\treturn ((git__tsort_cmp)payload)(a, b);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "a",
            "b"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic int tsort_r_cmp(const void *a, const void *b, void *payload)\n{\n\treturn ((git__tsort_cmp)payload)(a, b);\n}"
  },
  {
    "function_name": "collapse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "256-308",
    "snippet": "static ssize_t collapse(void **dst, struct tsort_run *stack, ssize_t stack_curr, struct tsort_store *store, ssize_t size)\n{\n\tssize_t A, B, C;\n\n\twhile (1) {\n\t\t/* if the stack only has one thing on it, we are done with the collapse */\n\t\tif (stack_curr <= 1)\n\t\t\tbreak;\n\n\t\t/* if this is the last merge, just do it */\n\t\tif ((stack_curr == 2) && (stack[0].length + stack[1].length == size)) {\n\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\tstack[0].length += stack[1].length;\n\t\t\tstack_curr--;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if the invariant is off for a stack of 2 elements */\n\t\telse if ((stack_curr == 2) && (stack[0].length <= stack[1].length)) {\n\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\tstack[0].length += stack[1].length;\n\t\t\tstack_curr--;\n\t\t\tbreak;\n\t\t}\n\t\telse if (stack_curr == 2)\n\t\t\tbreak;\n\n\t\tA = stack[stack_curr - 3].length;\n\t\tB = stack[stack_curr - 2].length;\n\t\tC = stack[stack_curr - 1].length;\n\n\t\t/* check first invariant */\n\t\tif (A <= B + C) {\n\t\t\tif (A < C) {\n\t\t\t\tmerge(dst, stack, stack_curr - 1, store);\n\t\t\t\tstack[stack_curr - 3].length += stack[stack_curr - 2].length;\n\t\t\t\tstack[stack_curr - 2] = stack[stack_curr - 1];\n\t\t\t\tstack_curr--;\n\t\t\t} else {\n\t\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\t\tstack[stack_curr - 2].length += stack[stack_curr - 1].length;\n\t\t\t\tstack_curr--;\n\t\t\t}\n\t\t} else if (B <= C) {\n\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\tstack[stack_curr - 2].length += stack[stack_curr - 1].length;\n\t\t\tstack_curr--;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\treturn stack_curr;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "merge",
          "args": [
            "dst",
            "stack",
            "stack_curr",
            "store"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
          "lines": "206-254",
          "snippet": "static void merge(void **dst, const struct tsort_run *stack, ssize_t stack_curr, struct tsort_store *store)\n{\n\tconst ssize_t A = stack[stack_curr - 2].length;\n\tconst ssize_t B = stack[stack_curr - 1].length;\n\tconst ssize_t curr = stack[stack_curr - 2].start;\n\n\tvoid **storage;\n\tssize_t i, j, k;\n\n\tif (resize(store, MIN(A, B)) < 0)\n\t\treturn;\n\n\tstorage = store->storage;\n\n\t/* left merge */\n\tif (A < B) {\n\t\tmemcpy(storage, &dst[curr], A * sizeof(void *));\n\t\ti = 0;\n\t\tj = curr + A;\n\n\t\tfor (k = curr; k < curr + A + B; k++) {\n\t\t\tif ((i < A) && (j < curr + A + B)) {\n\t\t\t\tif (store->cmp(storage[i], dst[j], store->payload) <= 0)\n\t\t\t\t\tdst[k] = storage[i++];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = dst[j++];\n\t\t\t} else if (i < A) {\n\t\t\t\tdst[k] = storage[i++];\n\t\t\t} else\n\t\t\t\tdst[k] = dst[j++];\n\t\t}\n\t} else {\n\t\tmemcpy(storage, &dst[curr + A], B * sizeof(void *));\n\t\ti = B - 1;\n\t\tj = curr + A - 1;\n\n\t\tfor (k = curr + A + B - 1; k >= curr; k--) {\n\t\t\tif ((i >= 0) && (j >= curr)) {\n\t\t\t\tif (store->cmp(dst[j], storage[i], store->payload) > 0)\n\t\t\t\t\tdst[k] = dst[j--];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = storage[i--];\n\t\t\t} else if (i >= 0)\n\t\t\t\tdst[k] = storage[i--];\n\t\t\telse\n\t\t\t\tdst[k] = dst[j--];\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic void merge(void **dst, const struct tsort_run *stack, ssize_t stack_curr, struct tsort_store *store)\n{\n\tconst ssize_t A = stack[stack_curr - 2].length;\n\tconst ssize_t B = stack[stack_curr - 1].length;\n\tconst ssize_t curr = stack[stack_curr - 2].start;\n\n\tvoid **storage;\n\tssize_t i, j, k;\n\n\tif (resize(store, MIN(A, B)) < 0)\n\t\treturn;\n\n\tstorage = store->storage;\n\n\t/* left merge */\n\tif (A < B) {\n\t\tmemcpy(storage, &dst[curr], A * sizeof(void *));\n\t\ti = 0;\n\t\tj = curr + A;\n\n\t\tfor (k = curr; k < curr + A + B; k++) {\n\t\t\tif ((i < A) && (j < curr + A + B)) {\n\t\t\t\tif (store->cmp(storage[i], dst[j], store->payload) <= 0)\n\t\t\t\t\tdst[k] = storage[i++];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = dst[j++];\n\t\t\t} else if (i < A) {\n\t\t\t\tdst[k] = storage[i++];\n\t\t\t} else\n\t\t\t\tdst[k] = dst[j++];\n\t\t}\n\t} else {\n\t\tmemcpy(storage, &dst[curr + A], B * sizeof(void *));\n\t\ti = B - 1;\n\t\tj = curr + A - 1;\n\n\t\tfor (k = curr + A + B - 1; k >= curr; k--) {\n\t\t\tif ((i >= 0) && (j >= curr)) {\n\t\t\t\tif (store->cmp(dst[j], storage[i], store->payload) > 0)\n\t\t\t\t\tdst[k] = dst[j--];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = storage[i--];\n\t\t\t} else if (i >= 0)\n\t\t\t\tdst[k] = storage[i--];\n\t\t\telse\n\t\t\t\tdst[k] = dst[j--];\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic ssize_t collapse(void **dst, struct tsort_run *stack, ssize_t stack_curr, struct tsort_store *store, ssize_t size)\n{\n\tssize_t A, B, C;\n\n\twhile (1) {\n\t\t/* if the stack only has one thing on it, we are done with the collapse */\n\t\tif (stack_curr <= 1)\n\t\t\tbreak;\n\n\t\t/* if this is the last merge, just do it */\n\t\tif ((stack_curr == 2) && (stack[0].length + stack[1].length == size)) {\n\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\tstack[0].length += stack[1].length;\n\t\t\tstack_curr--;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* check if the invariant is off for a stack of 2 elements */\n\t\telse if ((stack_curr == 2) && (stack[0].length <= stack[1].length)) {\n\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\tstack[0].length += stack[1].length;\n\t\t\tstack_curr--;\n\t\t\tbreak;\n\t\t}\n\t\telse if (stack_curr == 2)\n\t\t\tbreak;\n\n\t\tA = stack[stack_curr - 3].length;\n\t\tB = stack[stack_curr - 2].length;\n\t\tC = stack[stack_curr - 1].length;\n\n\t\t/* check first invariant */\n\t\tif (A <= B + C) {\n\t\t\tif (A < C) {\n\t\t\t\tmerge(dst, stack, stack_curr - 1, store);\n\t\t\t\tstack[stack_curr - 3].length += stack[stack_curr - 2].length;\n\t\t\t\tstack[stack_curr - 2] = stack[stack_curr - 1];\n\t\t\t\tstack_curr--;\n\t\t\t} else {\n\t\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\t\tstack[stack_curr - 2].length += stack[stack_curr - 1].length;\n\t\t\t\tstack_curr--;\n\t\t\t}\n\t\t} else if (B <= C) {\n\t\t\tmerge(dst, stack, stack_curr, store);\n\t\t\tstack[stack_curr - 2].length += stack[stack_curr - 1].length;\n\t\t\tstack_curr--;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\treturn stack_curr;\n}"
  },
  {
    "function_name": "merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "206-254",
    "snippet": "static void merge(void **dst, const struct tsort_run *stack, ssize_t stack_curr, struct tsort_store *store)\n{\n\tconst ssize_t A = stack[stack_curr - 2].length;\n\tconst ssize_t B = stack[stack_curr - 1].length;\n\tconst ssize_t curr = stack[stack_curr - 2].start;\n\n\tvoid **storage;\n\tssize_t i, j, k;\n\n\tif (resize(store, MIN(A, B)) < 0)\n\t\treturn;\n\n\tstorage = store->storage;\n\n\t/* left merge */\n\tif (A < B) {\n\t\tmemcpy(storage, &dst[curr], A * sizeof(void *));\n\t\ti = 0;\n\t\tj = curr + A;\n\n\t\tfor (k = curr; k < curr + A + B; k++) {\n\t\t\tif ((i < A) && (j < curr + A + B)) {\n\t\t\t\tif (store->cmp(storage[i], dst[j], store->payload) <= 0)\n\t\t\t\t\tdst[k] = storage[i++];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = dst[j++];\n\t\t\t} else if (i < A) {\n\t\t\t\tdst[k] = storage[i++];\n\t\t\t} else\n\t\t\t\tdst[k] = dst[j++];\n\t\t}\n\t} else {\n\t\tmemcpy(storage, &dst[curr + A], B * sizeof(void *));\n\t\ti = B - 1;\n\t\tj = curr + A - 1;\n\n\t\tfor (k = curr + A + B - 1; k >= curr; k--) {\n\t\t\tif ((i >= 0) && (j >= curr)) {\n\t\t\t\tif (store->cmp(dst[j], storage[i], store->payload) > 0)\n\t\t\t\t\tdst[k] = dst[j--];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = storage[i--];\n\t\t\t} else if (i >= 0)\n\t\t\t\tdst[k] = storage[i--];\n\t\t\telse\n\t\t\t\tdst[k] = dst[j--];\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "store->cmp",
          "args": [
            "dst[j]",
            "storage[i]",
            "store->payload"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "storage",
            "&dst[curr + A]",
            "B * sizeof(void *)"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store->cmp",
          "args": [
            "storage[i]",
            "dst[j]",
            "store->payload"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "storage",
            "&dst[curr]",
            "A * sizeof(void *)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resize",
          "args": [
            "store",
            "MIN(A, B)"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
          "lines": "184-204",
          "snippet": "static int resize(struct tsort_store *store, size_t new_size)\n{\n\tif (store->alloc < new_size) {\n\t\tvoid **tempstore;\n\n\t\ttempstore = git__reallocarray(store->storage, new_size, sizeof(void *));\n\n\t\t/**\n\t\t * Do not propagate on OOM; this will abort the sort and\n\t\t * leave the array unsorted, but no error code will be\n\t\t * raised\n\t\t */\n\t\tif (tempstore == NULL)\n\t\t\treturn -1;\n\n\t\tstore->storage = tempstore;\n\t\tstore->alloc = new_size;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic int resize(struct tsort_store *store, size_t new_size)\n{\n\tif (store->alloc < new_size) {\n\t\tvoid **tempstore;\n\n\t\ttempstore = git__reallocarray(store->storage, new_size, sizeof(void *));\n\n\t\t/**\n\t\t * Do not propagate on OOM; this will abort the sort and\n\t\t * leave the array unsorted, but no error code will be\n\t\t * raised\n\t\t */\n\t\tif (tempstore == NULL)\n\t\t\treturn -1;\n\n\t\tstore->storage = tempstore;\n\t\tstore->alloc = new_size;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "A",
            "B"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic void merge(void **dst, const struct tsort_run *stack, ssize_t stack_curr, struct tsort_store *store)\n{\n\tconst ssize_t A = stack[stack_curr - 2].length;\n\tconst ssize_t B = stack[stack_curr - 1].length;\n\tconst ssize_t curr = stack[stack_curr - 2].start;\n\n\tvoid **storage;\n\tssize_t i, j, k;\n\n\tif (resize(store, MIN(A, B)) < 0)\n\t\treturn;\n\n\tstorage = store->storage;\n\n\t/* left merge */\n\tif (A < B) {\n\t\tmemcpy(storage, &dst[curr], A * sizeof(void *));\n\t\ti = 0;\n\t\tj = curr + A;\n\n\t\tfor (k = curr; k < curr + A + B; k++) {\n\t\t\tif ((i < A) && (j < curr + A + B)) {\n\t\t\t\tif (store->cmp(storage[i], dst[j], store->payload) <= 0)\n\t\t\t\t\tdst[k] = storage[i++];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = dst[j++];\n\t\t\t} else if (i < A) {\n\t\t\t\tdst[k] = storage[i++];\n\t\t\t} else\n\t\t\t\tdst[k] = dst[j++];\n\t\t}\n\t} else {\n\t\tmemcpy(storage, &dst[curr + A], B * sizeof(void *));\n\t\ti = B - 1;\n\t\tj = curr + A - 1;\n\n\t\tfor (k = curr + A + B - 1; k >= curr; k--) {\n\t\t\tif ((i >= 0) && (j >= curr)) {\n\t\t\t\tif (store->cmp(dst[j], storage[i], store->payload) > 0)\n\t\t\t\t\tdst[k] = dst[j--];\n\t\t\t\telse\n\t\t\t\t\tdst[k] = storage[i--];\n\t\t\t} else if (i >= 0)\n\t\t\t\tdst[k] = storage[i--];\n\t\t\telse\n\t\t\t\tdst[k] = dst[j--];\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "resize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "184-204",
    "snippet": "static int resize(struct tsort_store *store, size_t new_size)\n{\n\tif (store->alloc < new_size) {\n\t\tvoid **tempstore;\n\n\t\ttempstore = git__reallocarray(store->storage, new_size, sizeof(void *));\n\n\t\t/**\n\t\t * Do not propagate on OOM; this will abort the sort and\n\t\t * leave the array unsorted, but no error code will be\n\t\t * raised\n\t\t */\n\t\tif (tempstore == NULL)\n\t\t\treturn -1;\n\n\t\tstore->storage = tempstore;\n\t\tstore->alloc = new_size;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__reallocarray",
          "args": [
            "store->storage",
            "new_size",
            "sizeof(void *)"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "git__reallocarray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "227-232",
          "snippet": "GIT_INLINE(void *) git__reallocarray(void *ptr, size_t nelem, size_t elsize)\n{\n\tsize_t newsize;\n\treturn GIT_MULTIPLY_SIZET_OVERFLOW(&newsize, nelem, elsize) ?\n\t\tNULL : realloc(ptr, newsize);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__reallocarray(void *ptr, size_t nelem, size_t elsize)\n{\n\tsize_t newsize;\n\treturn GIT_MULTIPLY_SIZET_OVERFLOW(&newsize, nelem, elsize) ?\n\t\tNULL : realloc(ptr, newsize);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic int resize(struct tsort_store *store, size_t new_size)\n{\n\tif (store->alloc < new_size) {\n\t\tvoid **tempstore;\n\n\t\ttempstore = git__reallocarray(store->storage, new_size, sizeof(void *));\n\n\t\t/**\n\t\t * Do not propagate on OOM; this will abort the sort and\n\t\t * leave the array unsorted, but no error code will be\n\t\t * raised\n\t\t */\n\t\tif (tempstore == NULL)\n\t\t\treturn -1;\n\n\t\tstore->storage = tempstore;\n\t\tstore->alloc = new_size;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "check_invariant",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "167-182",
    "snippet": "static int check_invariant(struct tsort_run *stack, ssize_t stack_curr)\n{\n\tif (stack_curr < 2)\n\t\treturn 1;\n\n\telse if (stack_curr == 2) {\n\t\tconst ssize_t A = stack[stack_curr - 2].length;\n\t\tconst ssize_t B = stack[stack_curr - 1].length;\n\t\treturn (A > B);\n\t} else {\n\t\tconst ssize_t A = stack[stack_curr - 3].length;\n\t\tconst ssize_t B = stack[stack_curr - 2].length;\n\t\tconst ssize_t C = stack[stack_curr - 1].length;\n\t\treturn !((A <= B + C) || (B <= C));\n\t}\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nstatic int check_invariant(struct tsort_run *stack, ssize_t stack_curr)\n{\n\tif (stack_curr < 2)\n\t\treturn 1;\n\n\telse if (stack_curr == 2) {\n\t\tconst ssize_t A = stack[stack_curr - 2].length;\n\t\tconst ssize_t B = stack[stack_curr - 1].length;\n\t\treturn (A > B);\n\t} else {\n\t\tconst ssize_t A = stack[stack_curr - 3].length;\n\t\tconst ssize_t B = stack[stack_curr - 2].length;\n\t\tconst ssize_t C = stack[stack_curr - 1].length;\n\t\treturn !((A <= B + C) || (B <= C));\n\t}\n}"
  },
  {
    "function_name": "compute_minrun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "157-165",
    "snippet": "static size_t compute_minrun(size_t n)\n{\n\tint r = 0;\n\twhile (n >= 64) {\n\t\tr |= n & 1;\n\t\tn >>= 1;\n\t}\n\treturn n + r;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nstatic size_t compute_minrun(size_t n)\n{\n\tint r = 0;\n\twhile (n >= 64) {\n\t\tr |= n & 1;\n\t\tn >>= 1;\n\t}\n\treturn n + r;\n}"
  },
  {
    "function_name": "count_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "122-155",
    "snippet": "static ssize_t count_run(\n\tvoid **dst, ssize_t start, ssize_t size, struct tsort_store *store)\n{\n\tssize_t curr = start + 2;\n\n\tif (size - start == 1)\n\t\treturn 1;\n\n\tif (start >= size - 2) {\n\t\tif (store->cmp(dst[size - 2], dst[size - 1], store->payload) > 0) {\n\t\t\tvoid *tmp = dst[size - 1];\n\t\t\tdst[size - 1] = dst[size - 2];\n\t\t\tdst[size - 2] = tmp;\n\t\t}\n\n\t\treturn 2;\n\t}\n\n\tif (store->cmp(dst[start], dst[start + 1], store->payload) <= 0) {\n\t\twhile (curr < size - 1 &&\n\t\t\t\tstore->cmp(dst[curr - 1], dst[curr], store->payload) <= 0)\n\t\t\tcurr++;\n\n\t\treturn curr - start;\n\t} else {\n\t\twhile (curr < size - 1 &&\n\t\t\t\tstore->cmp(dst[curr - 1], dst[curr], store->payload) > 0)\n\t\t\tcurr++;\n\n\t\t/* reverse in-place */\n\t\treverse_elements(dst, start, curr - 1);\n\t\treturn curr - start;\n\t}\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reverse_elements",
          "args": [
            "dst",
            "start",
            "curr - 1"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_elements",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
          "lines": "110-120",
          "snippet": "static void reverse_elements(void **dst, ssize_t start, ssize_t end)\n{\n\twhile (start < end) {\n\t\tvoid *tmp = dst[start];\n\t\tdst[start] = dst[end];\n\t\tdst[end] = tmp;\n\n\t\tstart++;\n\t\tend--;\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic void reverse_elements(void **dst, ssize_t start, ssize_t end)\n{\n\twhile (start < end) {\n\t\tvoid *tmp = dst[start];\n\t\tdst[start] = dst[end];\n\t\tdst[end] = tmp;\n\n\t\tstart++;\n\t\tend--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "store->cmp",
          "args": [
            "dst[curr - 1]",
            "dst[curr]",
            "store->payload"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store->cmp",
          "args": [
            "dst[curr - 1]",
            "dst[curr]",
            "store->payload"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store->cmp",
          "args": [
            "dst[start]",
            "dst[start + 1]",
            "store->payload"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store->cmp",
          "args": [
            "dst[size - 2]",
            "dst[size - 1]",
            "store->payload"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic ssize_t count_run(\n\tvoid **dst, ssize_t start, ssize_t size, struct tsort_store *store)\n{\n\tssize_t curr = start + 2;\n\n\tif (size - start == 1)\n\t\treturn 1;\n\n\tif (start >= size - 2) {\n\t\tif (store->cmp(dst[size - 2], dst[size - 1], store->payload) > 0) {\n\t\t\tvoid *tmp = dst[size - 1];\n\t\t\tdst[size - 1] = dst[size - 2];\n\t\t\tdst[size - 2] = tmp;\n\t\t}\n\n\t\treturn 2;\n\t}\n\n\tif (store->cmp(dst[start], dst[start + 1], store->payload) <= 0) {\n\t\twhile (curr < size - 1 &&\n\t\t\t\tstore->cmp(dst[curr - 1], dst[curr], store->payload) <= 0)\n\t\t\tcurr++;\n\n\t\treturn curr - start;\n\t} else {\n\t\twhile (curr < size - 1 &&\n\t\t\t\tstore->cmp(dst[curr - 1], dst[curr], store->payload) > 0)\n\t\t\tcurr++;\n\n\t\t/* reverse in-place */\n\t\treverse_elements(dst, start, curr - 1);\n\t\treturn curr - start;\n\t}\n}"
  },
  {
    "function_name": "reverse_elements",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "110-120",
    "snippet": "static void reverse_elements(void **dst, ssize_t start, ssize_t end)\n{\n\twhile (start < end) {\n\t\tvoid *tmp = dst[start];\n\t\tdst[start] = dst[end];\n\t\tdst[end] = tmp;\n\n\t\tstart++;\n\t\tend--;\n\t}\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n\nstatic void reverse_elements(void **dst, ssize_t start, ssize_t end)\n{\n\twhile (start < end) {\n\t\tvoid *tmp = dst[start];\n\t\tdst[start] = dst[end];\n\t\tdst[end] = tmp;\n\n\t\tstart++;\n\t\tend--;\n\t}\n}"
  },
  {
    "function_name": "bisort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "73-94",
    "snippet": "static void bisort(\n\tvoid **dst, size_t start, size_t size, git__sort_r_cmp cmp, void *payload)\n{\n\tsize_t i;\n\tvoid *x;\n\tint location;\n\n\tfor (i = start; i < size; i++) {\n\t\tint j;\n\t\t/* If this entry is already correct, just move along */\n\t\tif (cmp(dst[i - 1], dst[i], payload) <= 0)\n\t\t\tcontinue;\n\n\t\t/* Else we need to find the right place, shift everything over, and squeeze in */\n\t\tx = dst[i];\n\t\tlocation = binsearch(dst, x, i, cmp, payload);\n\t\tfor (j = (int)i - 1; j >= location; j--) {\n\t\t\tdst[j + 1] = dst[j];\n\t\t}\n\t\tdst[location] = x;\n\t}\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "binsearch",
          "args": [
            "dst",
            "x",
            "i",
            "cmp",
            "payload"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "binsearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
          "lines": "26-70",
          "snippet": "static int binsearch(\n\tvoid **dst, const void *x, size_t size, git__sort_r_cmp cmp, void *payload)\n{\n\tint l, c, r;\n\tvoid *lx, *cx;\n\n\tassert(size > 0);\n\n\tl = 0;\n\tr = (int)size - 1;\n\tc = r >> 1;\n\tlx = dst[l];\n\n\t/* check for beginning conditions */\n\tif (cmp(x, lx, payload) < 0)\n\t\treturn 0;\n\n\telse if (cmp(x, lx, payload) == 0) {\n\t\tint i = 1;\n\t\twhile (cmp(x, dst[i], payload) == 0)\n\t\t\ti++;\n\t\treturn i;\n\t}\n\n\t/* guaranteed not to be >= rx */\n\tcx = dst[c];\n\twhile (1) {\n\t\tconst int val = cmp(x, cx, payload);\n\t\tif (val < 0) {\n\t\t\tif (c - l <= 1) return c;\n\t\t\tr = c;\n\t\t} else if (val > 0) {\n\t\t\tif (r - c <= 1) return c + 1;\n\t\t\tl = c;\n\t\t\tlx = cx;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tcx = dst[++c];\n\t\t\t} while (cmp(x, cx, payload) == 0);\n\t\t\treturn c;\n\t\t}\n\t\tc = l + ((r - l) >> 1);\n\t\tcx = dst[c];\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic int binsearch(\n\tvoid **dst, const void *x, size_t size, git__sort_r_cmp cmp, void *payload)\n{\n\tint l, c, r;\n\tvoid *lx, *cx;\n\n\tassert(size > 0);\n\n\tl = 0;\n\tr = (int)size - 1;\n\tc = r >> 1;\n\tlx = dst[l];\n\n\t/* check for beginning conditions */\n\tif (cmp(x, lx, payload) < 0)\n\t\treturn 0;\n\n\telse if (cmp(x, lx, payload) == 0) {\n\t\tint i = 1;\n\t\twhile (cmp(x, dst[i], payload) == 0)\n\t\t\ti++;\n\t\treturn i;\n\t}\n\n\t/* guaranteed not to be >= rx */\n\tcx = dst[c];\n\twhile (1) {\n\t\tconst int val = cmp(x, cx, payload);\n\t\tif (val < 0) {\n\t\t\tif (c - l <= 1) return c;\n\t\t\tr = c;\n\t\t} else if (val > 0) {\n\t\t\tif (r - c <= 1) return c + 1;\n\t\t\tl = c;\n\t\t\tlx = cx;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tcx = dst[++c];\n\t\t\t} while (cmp(x, cx, payload) == 0);\n\t\t\treturn c;\n\t\t}\n\t\tc = l + ((r - l) >> 1);\n\t\tcx = dst[c];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmp",
          "args": [
            "dst[i - 1]",
            "dst[i]",
            "payload"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "tsort_r_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
          "lines": "377-380",
          "snippet": "static int tsort_r_cmp(const void *a, const void *b, void *payload)\n{\n\treturn ((git__tsort_cmp)payload)(a, b);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic int tsort_r_cmp(const void *a, const void *b, void *payload)\n{\n\treturn ((git__tsort_cmp)payload)(a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic void bisort(\n\tvoid **dst, size_t start, size_t size, git__sort_r_cmp cmp, void *payload)\n{\n\tsize_t i;\n\tvoid *x;\n\tint location;\n\n\tfor (i = start; i < size; i++) {\n\t\tint j;\n\t\t/* If this entry is already correct, just move along */\n\t\tif (cmp(dst[i - 1], dst[i], payload) <= 0)\n\t\t\tcontinue;\n\n\t\t/* Else we need to find the right place, shift everything over, and squeeze in */\n\t\tx = dst[i];\n\t\tlocation = binsearch(dst, x, i, cmp, payload);\n\t\tfor (j = (int)i - 1; j >= location; j--) {\n\t\t\tdst[j + 1] = dst[j];\n\t\t}\n\t\tdst[location] = x;\n\t}\n}"
  },
  {
    "function_name": "binsearch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
    "lines": "26-70",
    "snippet": "static int binsearch(\n\tvoid **dst, const void *x, size_t size, git__sort_r_cmp cmp, void *payload)\n{\n\tint l, c, r;\n\tvoid *lx, *cx;\n\n\tassert(size > 0);\n\n\tl = 0;\n\tr = (int)size - 1;\n\tc = r >> 1;\n\tlx = dst[l];\n\n\t/* check for beginning conditions */\n\tif (cmp(x, lx, payload) < 0)\n\t\treturn 0;\n\n\telse if (cmp(x, lx, payload) == 0) {\n\t\tint i = 1;\n\t\twhile (cmp(x, dst[i], payload) == 0)\n\t\t\ti++;\n\t\treturn i;\n\t}\n\n\t/* guaranteed not to be >= rx */\n\tcx = dst[c];\n\twhile (1) {\n\t\tconst int val = cmp(x, cx, payload);\n\t\tif (val < 0) {\n\t\t\tif (c - l <= 1) return c;\n\t\t\tr = c;\n\t\t} else if (val > 0) {\n\t\t\tif (r - c <= 1) return c + 1;\n\t\t\tl = c;\n\t\t\tlx = cx;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tcx = dst[++c];\n\t\t\t} while (cmp(x, cx, payload) == 0);\n\t\t\treturn c;\n\t\t}\n\t\tc = l + ((r - l) >> 1);\n\t\tcx = dst[c];\n\t}\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp",
          "args": [
            "x",
            "cx",
            "payload"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "tsort_r_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tsort.c",
          "lines": "377-380",
          "snippet": "static int tsort_r_cmp(const void *a, const void *b, void *payload)\n{\n\treturn ((git__tsort_cmp)payload)(a, b);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic int tsort_r_cmp(const void *a, const void *b, void *payload)\n{\n\treturn ((git__tsort_cmp)payload)(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "size > 0"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic int binsearch(\n\tvoid **dst, const void *x, size_t size, git__sort_r_cmp cmp, void *payload)\n{\n\tint l, c, r;\n\tvoid *lx, *cx;\n\n\tassert(size > 0);\n\n\tl = 0;\n\tr = (int)size - 1;\n\tc = r >> 1;\n\tlx = dst[l];\n\n\t/* check for beginning conditions */\n\tif (cmp(x, lx, payload) < 0)\n\t\treturn 0;\n\n\telse if (cmp(x, lx, payload) == 0) {\n\t\tint i = 1;\n\t\twhile (cmp(x, dst[i], payload) == 0)\n\t\t\ti++;\n\t\treturn i;\n\t}\n\n\t/* guaranteed not to be >= rx */\n\tcx = dst[c];\n\twhile (1) {\n\t\tconst int val = cmp(x, cx, payload);\n\t\tif (val < 0) {\n\t\t\tif (c - l <= 1) return c;\n\t\t\tr = c;\n\t\t} else if (val > 0) {\n\t\t\tif (r - c <= 1) return c + 1;\n\t\t\tl = c;\n\t\t\tlx = cx;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\tcx = dst[++c];\n\t\t\t} while (cmp(x, cx, payload) == 0);\n\t\t\treturn c;\n\t\t}\n\t\tc = l + ((r - l) >> 1);\n\t\tcx = dst[c];\n\t}\n}"
  }
]