[
  {
    "function_name": "p_inet_pton",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "687-723",
    "snippet": "int p_inet_pton(int af, const char *src, void *dst)\n{\n\tstruct sockaddr_storage sin;\n\tvoid *addr;\n\tint sin_len = sizeof(struct sockaddr_storage), addr_len;\n\tint error = 0;\n\n\tif (af == AF_INET) {\n\t\taddr = &((struct sockaddr_in *)&sin)->sin_addr;\n\t\taddr_len = sizeof(struct in_addr);\n\t} else if (af == AF_INET6) {\n\t\taddr = &((struct sockaddr_in6 *)&sin)->sin6_addr;\n\t\taddr_len = sizeof(struct in6_addr);\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tif ((error = WSAStringToAddressA((LPSTR)src, af, NULL, (LPSOCKADDR)&sin, &sin_len)) == 0) {\n\t\tmemcpy(dst, addr, addr_len);\n\t\treturn 1;\n\t}\n\n\tswitch(WSAGetLastError()) {\n\tcase WSAEINVAL:\n\t\treturn 0;\n\tcase WSAEFAULT:\n\t\terrno = ENOSPC;\n\t\treturn -1;\n\tcase WSA_NOT_ENOUGH_MEMORY:\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\terrno = EINVAL;\n\treturn -1;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "addr",
            "addr_len"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAStringToAddressA",
          "args": [
            "(LPSTR)src",
            "af",
            "NULL",
            "(LPSOCKADDR)&sin",
            "&sin_len"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_inet_pton(int af, const char *src, void *dst)\n{\n\tstruct sockaddr_storage sin;\n\tvoid *addr;\n\tint sin_len = sizeof(struct sockaddr_storage), addr_len;\n\tint error = 0;\n\n\tif (af == AF_INET) {\n\t\taddr = &((struct sockaddr_in *)&sin)->sin_addr;\n\t\taddr_len = sizeof(struct in_addr);\n\t} else if (af == AF_INET6) {\n\t\taddr = &((struct sockaddr_in6 *)&sin)->sin6_addr;\n\t\taddr_len = sizeof(struct in6_addr);\n\t} else {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn -1;\n\t}\n\n\tif ((error = WSAStringToAddressA((LPSTR)src, af, NULL, (LPSOCKADDR)&sin, &sin_len)) == 0) {\n\t\tmemcpy(dst, addr, addr_len);\n\t\treturn 1;\n\t}\n\n\tswitch(WSAGetLastError()) {\n\tcase WSAEINVAL:\n\t\treturn 0;\n\tcase WSAEFAULT:\n\t\terrno = ENOSPC;\n\t\treturn -1;\n\tcase WSA_NOT_ENOUGH_MEMORY:\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\n\terrno = EINVAL;\n\treturn -1;\n}"
  },
  {
    "function_name": "p_gmtime_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "674-685",
    "snippet": "struct tm *\np_gmtime_r (const time_t *timer, struct tm *result)\n{\n\tstruct tm *local_result;\n\tlocal_result = gmtime (timer);\n\n\tif (local_result == NULL || result == NULL)\n\t\treturn NULL;\n\n\tmemcpy (result, local_result, sizeof (struct tm));\n\treturn result;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "local_result",
            "sizeof (struct tm)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmtime",
          "args": [
            "timer"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstruct tm *\np_gmtime_r (const time_t *timer, struct tm *result)\n{\n\tstruct tm *local_result;\n\tlocal_result = gmtime (timer);\n\n\tif (local_result == NULL || result == NULL)\n\t\treturn NULL;\n\n\tmemcpy (result, local_result, sizeof (struct tm));\n\treturn result;\n}"
  },
  {
    "function_name": "p_localtime_r",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "662-673",
    "snippet": "struct tm *\np_localtime_r (const time_t *timer, struct tm *result)\n{\n\tstruct tm *local_result;\n\tlocal_result = localtime (timer);\n\n\tif (local_result == NULL || result == NULL)\n\t\treturn NULL;\n\n\tmemcpy (result, local_result, sizeof (struct tm));\n\treturn result;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "local_result",
            "sizeof (struct tm)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "timer"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstruct tm *\np_localtime_r (const time_t *timer, struct tm *result)\n{\n\tstruct tm *local_result;\n\tlocal_result = localtime (timer);\n\n\tif (local_result == NULL || result == NULL)\n\t\treturn NULL;\n\n\tmemcpy (result, local_result, sizeof (struct tm));\n\treturn result;\n}"
  },
  {
    "function_name": "p_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "650-656",
    "snippet": "int p_send(GIT_SOCKET socket, const void *buffer, size_t length, int flags)\n{\n\tif ((size_t)((int)length) != length)\n\t\treturn -1; /* giterr_set will be done by caller */\n\n\treturn send(socket, buffer, (int)length, flags);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send",
          "args": [
            "socket",
            "buffer",
            "(int)length",
            "flags"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "p_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "650-656",
          "snippet": "int p_send(GIT_SOCKET socket, const void *buffer, size_t length, int flags)\n{\n\tif ((size_t)((int)length) != length)\n\t\treturn -1; /* giterr_set will be done by caller */\n\n\treturn send(socket, buffer, (int)length, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_send(GIT_SOCKET socket, const void *buffer, size_t length, int flags)\n{\n\tif ((size_t)((int)length) != length)\n\t\treturn -1; /* giterr_set will be done by caller */\n\n\treturn send(socket, buffer, (int)length, flags);\n}"
  },
  {
    "function_name": "p_recv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "642-648",
    "snippet": "int p_recv(GIT_SOCKET socket, void *buffer, size_t length, int flags)\n{\n\tif ((size_t)((int)length) != length)\n\t\treturn -1; /* giterr_set will be done by caller */\n\n\treturn recv(socket, buffer, (int)length, flags);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "socket",
            "buffer",
            "(int)length",
            "flags"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "p_recv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "642-648",
          "snippet": "int p_recv(GIT_SOCKET socket, void *buffer, size_t length, int flags)\n{\n\tif ((size_t)((int)length) != length)\n\t\treturn -1; /* giterr_set will be done by caller */\n\n\treturn recv(socket, buffer, (int)length, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_recv(GIT_SOCKET socket, void *buffer, size_t length, int flags)\n{\n\tif ((size_t)((int)length) != length)\n\t\treturn -1; /* giterr_set will be done by caller */\n\n\treturn recv(socket, buffer, (int)length, flags);\n}"
  },
  {
    "function_name": "p_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "609-640",
    "snippet": "int p_rename(const char *from, const char *to)\n{\n\tgit_win32_path wfrom;\n\tgit_win32_path wto;\n\tint rename_tries;\n\tint rename_succeeded;\n\tint error;\n\n\tif (git_win32_path_from_utf8(wfrom, from) < 0 ||\n\t\tgit_win32_path_from_utf8(wto, to) < 0)\n\t\treturn -1;\n\n\t/* wait up to 50ms if file is locked by another thread or process */\n\trename_tries = 0;\n\trename_succeeded = 0;\n\twhile (rename_tries < 10) {\n\t\tif (ensure_writable(wto) == 0 &&\n\t\t    MoveFileExW(wfrom, wto, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED) != 0) {\n\t\t\trename_succeeded = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\terror = GetLastError();\n\t\tif (error == ERROR_SHARING_VIOLATION || error == ERROR_ACCESS_DENIED) {\n\t\t\tSleep(5);\n\t\t\trename_tries++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t\n\treturn rename_succeeded ? 0 : -1;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Sleep",
          "args": [
            "5"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MoveFileExW",
          "args": [
            "wfrom",
            "wto",
            "MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ensure_writable",
          "args": [
            "wto"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ensure_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "584-607",
          "snippet": "static int ensure_writable(wchar_t *fpath)\n{\n\tDWORD attrs;\n\n\tattrs = GetFileAttributesW(fpath);\n\tif (attrs == INVALID_FILE_ATTRIBUTES) {\n\t\tif (GetLastError() == ERROR_FILE_NOT_FOUND)\n\t\t\treturn 0;\n\n\t\tgiterr_set(GITERR_OS, \"failed to get attributes\");\n\t\treturn -1;\n\t}\n\n\tif (!(attrs & FILE_ATTRIBUTE_READONLY))\n\t\treturn 0;\n\n\tattrs &= ~FILE_ATTRIBUTE_READONLY;\n\tif (!SetFileAttributesW(fpath, attrs)) {\n\t\tgiterr_set(GITERR_OS, \"failed to set attributes\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int ensure_writable(wchar_t *fpath)\n{\n\tDWORD attrs;\n\n\tattrs = GetFileAttributesW(fpath);\n\tif (attrs == INVALID_FILE_ATTRIBUTES) {\n\t\tif (GetLastError() == ERROR_FILE_NOT_FOUND)\n\t\t\treturn 0;\n\n\t\tgiterr_set(GITERR_OS, \"failed to get attributes\");\n\t\treturn -1;\n\t}\n\n\tif (!(attrs & FILE_ATTRIBUTE_READONLY))\n\t\treturn 0;\n\n\tattrs &= ~FILE_ATTRIBUTE_READONLY;\n\tif (!SetFileAttributesW(fpath, attrs)) {\n\t\tgiterr_set(GITERR_OS, \"failed to set attributes\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "wto",
            "to"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_rename(const char *from, const char *to)\n{\n\tgit_win32_path wfrom;\n\tgit_win32_path wto;\n\tint rename_tries;\n\tint rename_succeeded;\n\tint error;\n\n\tif (git_win32_path_from_utf8(wfrom, from) < 0 ||\n\t\tgit_win32_path_from_utf8(wto, to) < 0)\n\t\treturn -1;\n\n\t/* wait up to 50ms if file is locked by another thread or process */\n\trename_tries = 0;\n\trename_succeeded = 0;\n\twhile (rename_tries < 10) {\n\t\tif (ensure_writable(wto) == 0 &&\n\t\t    MoveFileExW(wfrom, wto, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED) != 0) {\n\t\t\trename_succeeded = 1;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\terror = GetLastError();\n\t\tif (error == ERROR_SHARING_VIOLATION || error == ERROR_ACCESS_DENIED) {\n\t\t\tSleep(5);\n\t\t\trename_tries++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\t\n\treturn rename_succeeded ? 0 : -1;\n}"
  },
  {
    "function_name": "ensure_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "584-607",
    "snippet": "static int ensure_writable(wchar_t *fpath)\n{\n\tDWORD attrs;\n\n\tattrs = GetFileAttributesW(fpath);\n\tif (attrs == INVALID_FILE_ATTRIBUTES) {\n\t\tif (GetLastError() == ERROR_FILE_NOT_FOUND)\n\t\t\treturn 0;\n\n\t\tgiterr_set(GITERR_OS, \"failed to get attributes\");\n\t\treturn -1;\n\t}\n\n\tif (!(attrs & FILE_ATTRIBUTE_READONLY))\n\t\treturn 0;\n\n\tattrs &= ~FILE_ATTRIBUTE_READONLY;\n\tif (!SetFileAttributesW(fpath, attrs)) {\n\t\tgiterr_set(GITERR_OS, \"failed to set attributes\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"failed to set attributes\""
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetFileAttributesW",
          "args": [
            "fpath",
            "attrs"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFileAttributesW",
          "args": [
            "fpath"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int ensure_writable(wchar_t *fpath)\n{\n\tDWORD attrs;\n\n\tattrs = GetFileAttributesW(fpath);\n\tif (attrs == INVALID_FILE_ATTRIBUTES) {\n\t\tif (GetLastError() == ERROR_FILE_NOT_FOUND)\n\t\t\treturn 0;\n\n\t\tgiterr_set(GITERR_OS, \"failed to get attributes\");\n\t\treturn -1;\n\t}\n\n\tif (!(attrs & FILE_ATTRIBUTE_READONLY))\n\t\treturn 0;\n\n\tattrs &= ~FILE_ATTRIBUTE_READONLY;\n\tif (!SetFileAttributesW(fpath, attrs)) {\n\t\tgiterr_set(GITERR_OS, \"failed to set attributes\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "p_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "574-582",
    "snippet": "int p_access(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _waccess(buf, mode & WIN32_MODE_MASK);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [
      "#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_waccess",
          "args": [
            "buf",
            "mode & WIN32_MODE_MASK"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\n#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)\n\nint p_access(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _waccess(buf, mode & WIN32_MODE_MASK);\n}"
  },
  {
    "function_name": "p_mkstemp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "561-572",
    "snippet": "int p_mkstemp(char *tmp_path)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1500\n\tif (_mktemp_s(tmp_path, strlen(tmp_path) + 1) != 0)\n\t\treturn -1;\n#else\n\tif (_mktemp(tmp_path) == NULL)\n\t\treturn -1;\n#endif\n\n\treturn p_open(tmp_path, O_RDWR | O_CREAT | O_EXCL, 0744); //-V536\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "tmp_path",
            "O_RDWR | O_CREAT | O_EXCL",
            "0744"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "283-300",
          "snippet": "int p_open(const char *path, int flags, ...)\n{\n\tgit_win32_path buf;\n\tmode_t mode = 0;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn _wopen(buf, flags | STANDARD_OPEN_FLAGS, mode & WIN32_MODE_MASK);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [
            "#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)",
            "#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\n#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)\n#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)\n\nint p_open(const char *path, int flags, ...)\n{\n\tgit_win32_path buf;\n\tmode_t mode = 0;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn _wopen(buf, flags | STANDARD_OPEN_FLAGS, mode & WIN32_MODE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_mktemp",
          "args": [
            "tmp_path"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_mktemp_s",
          "args": [
            "tmp_path",
            "strlen(tmp_path) + 1"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp_path"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_mkstemp(char *tmp_path)\n{\n#if defined(_MSC_VER) && _MSC_VER >= 1500\n\tif (_mktemp_s(tmp_path, strlen(tmp_path) + 1) != 0)\n\t\treturn -1;\n#else\n\tif (_mktemp(tmp_path) == NULL)\n\t\treturn -1;\n#endif\n\n\treturn p_open(tmp_path, O_RDWR | O_CREAT | O_EXCL, 0744); //-V536\n}"
  },
  {
    "function_name": "p_snprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "548-558",
    "snippet": "int p_snprintf(char *buffer, size_t count, const char *format, ...)\n{\n\tva_list va;\n\tint r;\n\n\tva_start(va, format);\n\tr = p_vsnprintf(buffer, count, format, va);\n\tva_end(va);\n\n\treturn r;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "va"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_vsnprintf",
          "args": [
            "buffer",
            "count",
            "format",
            "va"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "p_vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "525-546",
          "snippet": "int p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "va",
            "format"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_snprintf(char *buffer, size_t count, const char *format, ...)\n{\n\tva_list va;\n\tint r;\n\n\tva_start(va, format);\n\tr = p_vsnprintf(buffer, count, format, va);\n\tva_end(va);\n\n\treturn r;\n}"
  },
  {
    "function_name": "p_vsnprintf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "525-546",
    "snippet": "int p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buffer",
            "count",
            "format",
            "argptr"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "p_vsnprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "525-546",
          "snippet": "int p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "_vscprintf",
          "args": [
            "format",
            "argptr"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_vsnprintf_s",
          "args": [
            "buffer",
            "count",
            "_TRUNCATE",
            "format",
            "argptr"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_vscprintf",
          "args": [
            "format",
            "argptr"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_vsnprintf(char *buffer, size_t count, const char *format, va_list argptr)\n{\n#if defined(_MSC_VER)\n\tint len;\n\n\tif (count == 0)\n\t\treturn _vscprintf(format, argptr);\n\n\t#if _MSC_VER >= 1500\n\tlen = _vsnprintf_s(buffer, count, _TRUNCATE, format, argptr);\n\t#else\n\tlen = _vsnprintf(buffer, count, format, argptr);\n\t#endif\n\n\tif (len < 0)\n\t\treturn _vscprintf(format, argptr);\n\n\treturn len;\n#else /* MinGW */\n\treturn vsnprintf(buffer, count, format, argptr);\n#endif\n}"
  },
  {
    "function_name": "p_realpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "484-523",
    "snippet": "char *p_realpath(const char *orig_path, char *buffer)\n{\n\tgit_win32_path orig_path_w, buffer_w;\n\n\tif (git_win32_path_from_utf8(orig_path_w, orig_path) < 0)\n\t\treturn NULL;\n\n\t/* Note that if the path provided is a relative path, then the current directory\n\t * is used to resolve the path -- which is a concurrency issue because the current\n\t * directory is a process-wide variable. */\n\tif (!GetFullPathNameW(orig_path_w, GIT_WIN_PATH_UTF16, buffer_w, NULL)) {\n\t\tif (GetLastError() == ERROR_INSUFFICIENT_BUFFER)\n\t\t\terrno = ENAMETOOLONG;\n\t\telse\n\t\t\terrno = EINVAL;\n\n\t\treturn NULL;\n\t}\n\n\t/* The path must exist. */\n\tif (GetFileAttributesW(buffer_w) == INVALID_FILE_ATTRIBUTES) {\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\n\tif (!buffer && !(buffer = git__malloc(GIT_WIN_PATH_UTF8))) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\t/* Convert the path to UTF-8. If the caller provided a buffer, then it\n\t * is assumed to be GIT_WIN_PATH_UTF8 characters in size. If it isn't,\n\t * then we may overflow. */\n\tif (git_win32_path_to_utf8(buffer, buffer_w) < 0)\n\t\treturn NULL;\n\n\tgit_path_mkposix(buffer);\n\n\treturn buffer;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_mkposix",
          "args": [
            "buffer"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_mkposix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.h",
          "lines": "110-118",
          "snippet": "GIT_INLINE(void) git_path_mkposix(char *path)\n{\n\twhile (*path) {\n\t\tif (*path == '\\\\')\n\t\t\t*path = '/';\n\n\t\tpath++;\n\t}\n}",
          "includes": [
            "#include <iconv.h>",
            "#include \"vector.h\"",
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iconv.h>\n#include \"vector.h\"\n#include \"buffer.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nGIT_INLINE(void) git_path_mkposix(char *path)\n{\n\twhile (*path) {\n\t\tif (*path == '\\\\')\n\t\t\t*path = '/';\n\n\t\tpath++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_to_utf8",
          "args": [
            "buffer",
            "buffer_w"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "255-279",
          "snippet": "int git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "GIT_WIN_PATH_UTF8"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetFileAttributesW",
          "args": [
            "buffer_w"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetFullPathNameW",
          "args": [
            "orig_path_w",
            "GIT_WIN_PATH_UTF16",
            "buffer_w",
            "NULL"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "orig_path_w",
            "orig_path"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nchar *p_realpath(const char *orig_path, char *buffer)\n{\n\tgit_win32_path orig_path_w, buffer_w;\n\n\tif (git_win32_path_from_utf8(orig_path_w, orig_path) < 0)\n\t\treturn NULL;\n\n\t/* Note that if the path provided is a relative path, then the current directory\n\t * is used to resolve the path -- which is a concurrency issue because the current\n\t * directory is a process-wide variable. */\n\tif (!GetFullPathNameW(orig_path_w, GIT_WIN_PATH_UTF16, buffer_w, NULL)) {\n\t\tif (GetLastError() == ERROR_INSUFFICIENT_BUFFER)\n\t\t\terrno = ENAMETOOLONG;\n\t\telse\n\t\t\terrno = EINVAL;\n\n\t\treturn NULL;\n\t}\n\n\t/* The path must exist. */\n\tif (GetFileAttributesW(buffer_w) == INVALID_FILE_ATTRIBUTES) {\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\n\tif (!buffer && !(buffer = git__malloc(GIT_WIN_PATH_UTF8))) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\n\t/* Convert the path to UTF-8. If the caller provided a buffer, then it\n\t * is assumed to be GIT_WIN_PATH_UTF8 characters in size. If it isn't,\n\t * then we may overflow. */\n\tif (git_win32_path_to_utf8(buffer, buffer_w) < 0)\n\t\treturn NULL;\n\n\tgit_path_mkposix(buffer);\n\n\treturn buffer;\n}"
  },
  {
    "function_name": "p_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "454-482",
    "snippet": "int p_rmdir(const char* path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wrmdir(buf);\n\n\tif (error == -1) {\n\t\tswitch (GetLastError()) {\n\t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open\n\t\t\t * handle to the directory.\"  This sounds like what everybody else calls\n\t\t\t * EBUSY.  Let's convert appropriate error codes.\n\t\t\t */\n\t\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\t\terrno = EBUSY;\n\t\t\t\tbreak;\n\n\t\t\t/* This error can be returned when trying to rmdir an extant file. */\n\t\t\tcase ERROR_DIRECTORY:\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_wrmdir",
          "args": [
            "buf"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_rmdir(const char* path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wrmdir(buf);\n\n\tif (error == -1) {\n\t\tswitch (GetLastError()) {\n\t\t\t/* _wrmdir() is documented to return EACCES if \"A program has an open\n\t\t\t * handle to the directory.\"  This sounds like what everybody else calls\n\t\t\t * EBUSY.  Let's convert appropriate error codes.\n\t\t\t */\n\t\t\tcase ERROR_SHARING_VIOLATION:\n\t\t\t\terrno = EBUSY;\n\t\t\t\tbreak;\n\n\t\t\t/* This error can be returned when trying to rmdir an extant file. */\n\t\t\tcase ERROR_DIRECTORY:\n\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "p_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "444-452",
    "snippet": "int p_chmod(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchmod(buf, mode);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wchmod",
          "args": [
            "buf",
            "mode"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_chmod(const char* path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchmod(buf, mode);\n}"
  },
  {
    "function_name": "p_chdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "434-442",
    "snippet": "int p_chdir(const char* path)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchdir(buf);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wchdir",
          "args": [
            "buf"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_chdir(const char* path)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wchdir(buf);\n}"
  },
  {
    "function_name": "p_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "417-432",
    "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "follow_and_lstat_link",
          "args": [
            "path_w",
            "buf"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "follow_and_lstat_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "391-399",
          "snippet": "static int follow_and_lstat_link(git_win32_path path, struct stat* buf)\n{\n\tgit_win32_path target_w;\n\n\tif (getfinalpath_w(target_w, path) < 0)\n\t\treturn -1;\n\n\treturn lstat_w(target_w, buf, false);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int follow_and_lstat_link(git_win32_path path, struct stat* buf)\n{\n\tgit_win32_path target_w;\n\n\tif (getfinalpath_w(target_w, path) < 0)\n\t\treturn -1;\n\n\treturn lstat_w(target_w, buf, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "buf->st_mode"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat_w",
          "args": [
            "path_w",
            "buf",
            "false"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "lstat_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "137-188",
          "snippet": "static int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "path_w",
            "path"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "p_fstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "401-415",
    "snippet": "int p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__file_information_to_stat",
          "args": [
            "buf",
            "&fhInfo"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__file_information_to_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.h",
          "lines": "142-153",
          "snippet": "GIT_INLINE(void) git_win32__file_information_to_stat(\n\tstruct stat *st,\n\tconst BY_HANDLE_FILE_INFORMATION *fileinfo)\n{\n\tgit_win32__stat_init(st,\n\t\tfileinfo->dwFileAttributes,\n\t\tfileinfo->nFileSizeHigh,\n\t\tfileinfo->nFileSizeLow,\n\t\tfileinfo->ftCreationTime,\n\t\tfileinfo->ftLastAccessTime,\n\t\tfileinfo->ftLastWriteTime);\n}",
          "includes": [
            "#include \"path_w32.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"path_w32.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n\nGIT_INLINE(void) git_win32__file_information_to_stat(\n\tstruct stat *st,\n\tconst BY_HANDLE_FILE_INFORMATION *fileinfo)\n{\n\tgit_win32__stat_init(st,\n\t\tfileinfo->dwFileAttributes,\n\t\tfileinfo->nFileSizeHigh,\n\t\tfileinfo->nFileSizeLow,\n\t\tfileinfo->ftCreationTime,\n\t\tfileinfo->ftLastAccessTime,\n\t\tfileinfo->ftLastWriteTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetFileInformationByHandle",
          "args": [
            "fh",
            "&fhInfo"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_fstat(int fd, struct stat *buf)\n{\n\tBY_HANDLE_FILE_INFORMATION fhInfo;\n\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE ||\n\t\t!GetFileInformationByHandle(fh, &fhInfo)) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tgit_win32__file_information_to_stat(buf, &fhInfo);\n\treturn 0;\n}"
  },
  {
    "function_name": "follow_and_lstat_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "391-399",
    "snippet": "static int follow_and_lstat_link(git_win32_path path, struct stat* buf)\n{\n\tgit_win32_path target_w;\n\n\tif (getfinalpath_w(target_w, path) < 0)\n\t\treturn -1;\n\n\treturn lstat_w(target_w, buf, false);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lstat_w",
          "args": [
            "target_w",
            "buf",
            "false"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "lstat_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "137-188",
          "snippet": "static int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getfinalpath_w",
          "args": [
            "target_w",
            "path"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "getfinalpath_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "360-389",
          "snippet": "static int getfinalpath_w(\n\tgit_win32_path dest,\n\tconst wchar_t *path)\n{\n\tPFGetFinalPathNameByHandleW pgfp = get_fpnbyhandle();\n\tHANDLE hFile;\n\tDWORD dwChars;\n\n\tif (!pgfp)\n\t\treturn -1;\n\n\t/* Use FILE_FLAG_BACKUP_SEMANTICS so we can open a directory. Do not\n\t* specify FILE_FLAG_OPEN_REPARSE_POINT; we want to open a handle to the\n\t* target of the link. */\n\thFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,\n\t\tNULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (INVALID_HANDLE_VALUE == hFile)\n\t\treturn -1;\n\n\t/* Call GetFinalPathNameByHandle */\n\tdwChars = pgfp(hFile, dest, GIT_WIN_PATH_UTF16, FILE_NAME_NORMALIZED);\n\tCloseHandle(hFile);\n\n\tif (!dwChars || dwChars >= GIT_WIN_PATH_UTF16)\n\t\treturn -1;\n\n\t/* The path may be delivered to us with a prefix; canonicalize */\n\treturn (int)git_win32__canonicalize_path(dest, dwChars);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int getfinalpath_w(\n\tgit_win32_path dest,\n\tconst wchar_t *path)\n{\n\tPFGetFinalPathNameByHandleW pgfp = get_fpnbyhandle();\n\tHANDLE hFile;\n\tDWORD dwChars;\n\n\tif (!pgfp)\n\t\treturn -1;\n\n\t/* Use FILE_FLAG_BACKUP_SEMANTICS so we can open a directory. Do not\n\t* specify FILE_FLAG_OPEN_REPARSE_POINT; we want to open a handle to the\n\t* target of the link. */\n\thFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,\n\t\tNULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (INVALID_HANDLE_VALUE == hFile)\n\t\treturn -1;\n\n\t/* Call GetFinalPathNameByHandle */\n\tdwChars = pgfp(hFile, dest, GIT_WIN_PATH_UTF16, FILE_NAME_NORMALIZED);\n\tCloseHandle(hFile);\n\n\tif (!dwChars || dwChars >= GIT_WIN_PATH_UTF16)\n\t\treturn -1;\n\n\t/* The path may be delivered to us with a prefix; canonicalize */\n\treturn (int)git_win32__canonicalize_path(dest, dwChars);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int follow_and_lstat_link(git_win32_path path, struct stat* buf)\n{\n\tgit_win32_path target_w;\n\n\tif (getfinalpath_w(target_w, path) < 0)\n\t\treturn -1;\n\n\treturn lstat_w(target_w, buf, false);\n}"
  },
  {
    "function_name": "getfinalpath_w",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "360-389",
    "snippet": "static int getfinalpath_w(\n\tgit_win32_path dest,\n\tconst wchar_t *path)\n{\n\tPFGetFinalPathNameByHandleW pgfp = get_fpnbyhandle();\n\tHANDLE hFile;\n\tDWORD dwChars;\n\n\tif (!pgfp)\n\t\treturn -1;\n\n\t/* Use FILE_FLAG_BACKUP_SEMANTICS so we can open a directory. Do not\n\t* specify FILE_FLAG_OPEN_REPARSE_POINT; we want to open a handle to the\n\t* target of the link. */\n\thFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,\n\t\tNULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (INVALID_HANDLE_VALUE == hFile)\n\t\treturn -1;\n\n\t/* Call GetFinalPathNameByHandle */\n\tdwChars = pgfp(hFile, dest, GIT_WIN_PATH_UTF16, FILE_NAME_NORMALIZED);\n\tCloseHandle(hFile);\n\n\tif (!dwChars || dwChars >= GIT_WIN_PATH_UTF16)\n\t\treturn -1;\n\n\t/* The path may be delivered to us with a prefix; canonicalize */\n\treturn (int)git_win32__canonicalize_path(dest, dwChars);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_win32__canonicalize_path",
          "args": [
            "dest",
            "dwChars"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__canonicalize_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "130-163",
          "snippet": "size_t git_win32__canonicalize_path(wchar_t *str, size_t len)\n{\n\tstatic const wchar_t dosdevices_prefix[] = L\"\\\\\\?\\?\\\\\";\n\tstatic const wchar_t nt_prefix[] = L\"\\\\\\\\?\\\\\";\n\tstatic const wchar_t unc_prefix[] = L\"UNC\\\\\";\n\tsize_t to_advance = 0;\n\n\t/* \"\\??\\\" -- DOS Devices prefix */\n\tif (len >= CONST_STRLEN(dosdevices_prefix) &&\n\t\t!wcsncmp(str, dosdevices_prefix, CONST_STRLEN(dosdevices_prefix))) {\n\t\tto_advance += CONST_STRLEN(dosdevices_prefix);\n\t\tlen -= CONST_STRLEN(dosdevices_prefix);\n\t}\n\t/* \"\\\\?\\\" -- NT namespace prefix */\n\telse if (len >= CONST_STRLEN(nt_prefix) &&\n\t\t!wcsncmp(str, nt_prefix, CONST_STRLEN(nt_prefix))) {\n\t\tto_advance += CONST_STRLEN(nt_prefix);\n\t\tlen -= CONST_STRLEN(nt_prefix);\n\t}\n\n\t/* \"\\??\\UNC\\\", \"\\\\?\\UNC\\\" -- UNC prefix */\n\tif (to_advance && len >= CONST_STRLEN(unc_prefix) &&\n\t\t!wcsncmp(str + to_advance, unc_prefix, CONST_STRLEN(unc_prefix))) {\n\t\tto_advance += CONST_STRLEN(unc_prefix);\n\t\tlen -= CONST_STRLEN(unc_prefix);\n\t}\n\n\tif (to_advance) {\n\t\tmemmove(str, str + to_advance, len * sizeof(wchar_t));\n\t\tstr[len] = L'\\0';\n\t}\n\n\treturn git_win32__path_trim_end(str, len);\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nsize_t git_win32__canonicalize_path(wchar_t *str, size_t len)\n{\n\tstatic const wchar_t dosdevices_prefix[] = L\"\\\\\\?\\?\\\\\";\n\tstatic const wchar_t nt_prefix[] = L\"\\\\\\\\?\\\\\";\n\tstatic const wchar_t unc_prefix[] = L\"UNC\\\\\";\n\tsize_t to_advance = 0;\n\n\t/* \"\\??\\\" -- DOS Devices prefix */\n\tif (len >= CONST_STRLEN(dosdevices_prefix) &&\n\t\t!wcsncmp(str, dosdevices_prefix, CONST_STRLEN(dosdevices_prefix))) {\n\t\tto_advance += CONST_STRLEN(dosdevices_prefix);\n\t\tlen -= CONST_STRLEN(dosdevices_prefix);\n\t}\n\t/* \"\\\\?\\\" -- NT namespace prefix */\n\telse if (len >= CONST_STRLEN(nt_prefix) &&\n\t\t!wcsncmp(str, nt_prefix, CONST_STRLEN(nt_prefix))) {\n\t\tto_advance += CONST_STRLEN(nt_prefix);\n\t\tlen -= CONST_STRLEN(nt_prefix);\n\t}\n\n\t/* \"\\??\\UNC\\\", \"\\\\?\\UNC\\\" -- UNC prefix */\n\tif (to_advance && len >= CONST_STRLEN(unc_prefix) &&\n\t\t!wcsncmp(str + to_advance, unc_prefix, CONST_STRLEN(unc_prefix))) {\n\t\tto_advance += CONST_STRLEN(unc_prefix);\n\t\tlen -= CONST_STRLEN(unc_prefix);\n\t}\n\n\tif (to_advance) {\n\t\tmemmove(str, str + to_advance, len * sizeof(wchar_t));\n\t\tstr[len] = L'\\0';\n\t}\n\n\treturn git_win32__path_trim_end(str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CloseHandle",
          "args": [
            "hFile"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgfp",
          "args": [
            "hFile",
            "dest",
            "GIT_WIN_PATH_UTF16",
            "FILE_NAME_NORMALIZED"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileW",
          "args": [
            "path",
            "GENERIC_READ",
            "FILE_SHARE_READ | FILE_SHARE_DELETE",
            "NULL",
            "OPEN_EXISTING",
            "FILE_FLAG_BACKUP_SEMANTICS",
            "NULL"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fpnbyhandle",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "get_fpnbyhandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "341-358",
          "snippet": "static PFGetFinalPathNameByHandleW get_fpnbyhandle(void)\n{\n\tstatic PFGetFinalPathNameByHandleW pFunc = NULL;\n\tPFGetFinalPathNameByHandleW toReturn = pFunc;\n\n\tif (!toReturn) {\n\t\tHMODULE hModule = GetModuleHandleW(L\"kernel32\");\n\n\t\tif (hModule)\n\t\t\ttoReturn = (PFGetFinalPathNameByHandleW)GetProcAddress(hModule, \"GetFinalPathNameByHandleW\");\n\n\t\tpFunc = toReturn;\n\t}\n\n\tassert(toReturn);\n\n\treturn toReturn;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic PFGetFinalPathNameByHandleW get_fpnbyhandle(void)\n{\n\tstatic PFGetFinalPathNameByHandleW pFunc = NULL;\n\tPFGetFinalPathNameByHandleW toReturn = pFunc;\n\n\tif (!toReturn) {\n\t\tHMODULE hModule = GetModuleHandleW(L\"kernel32\");\n\n\t\tif (hModule)\n\t\t\ttoReturn = (PFGetFinalPathNameByHandleW)GetProcAddress(hModule, \"GetFinalPathNameByHandleW\");\n\n\t\tpFunc = toReturn;\n\t}\n\n\tassert(toReturn);\n\n\treturn toReturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int getfinalpath_w(\n\tgit_win32_path dest,\n\tconst wchar_t *path)\n{\n\tPFGetFinalPathNameByHandleW pgfp = get_fpnbyhandle();\n\tHANDLE hFile;\n\tDWORD dwChars;\n\n\tif (!pgfp)\n\t\treturn -1;\n\n\t/* Use FILE_FLAG_BACKUP_SEMANTICS so we can open a directory. Do not\n\t* specify FILE_FLAG_OPEN_REPARSE_POINT; we want to open a handle to the\n\t* target of the link. */\n\thFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,\n\t\tNULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (INVALID_HANDLE_VALUE == hFile)\n\t\treturn -1;\n\n\t/* Call GetFinalPathNameByHandle */\n\tdwChars = pgfp(hFile, dest, GIT_WIN_PATH_UTF16, FILE_NAME_NORMALIZED);\n\tCloseHandle(hFile);\n\n\tif (!dwChars || dwChars >= GIT_WIN_PATH_UTF16)\n\t\treturn -1;\n\n\t/* The path may be delivered to us with a prefix; canonicalize */\n\treturn (int)git_win32__canonicalize_path(dest, dwChars);\n}"
  },
  {
    "function_name": "get_fpnbyhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "341-358",
    "snippet": "static PFGetFinalPathNameByHandleW get_fpnbyhandle(void)\n{\n\tstatic PFGetFinalPathNameByHandleW pFunc = NULL;\n\tPFGetFinalPathNameByHandleW toReturn = pFunc;\n\n\tif (!toReturn) {\n\t\tHMODULE hModule = GetModuleHandleW(L\"kernel32\");\n\n\t\tif (hModule)\n\t\t\ttoReturn = (PFGetFinalPathNameByHandleW)GetProcAddress(hModule, \"GetFinalPathNameByHandleW\");\n\n\t\tpFunc = toReturn;\n\t}\n\n\tassert(toReturn);\n\n\treturn toReturn;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "toReturn"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "hModule",
            "\"GetFinalPathNameByHandleW\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetModuleHandleW",
          "args": [
            "L\"kernel32\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic PFGetFinalPathNameByHandleW get_fpnbyhandle(void)\n{\n\tstatic PFGetFinalPathNameByHandleW pFunc = NULL;\n\tPFGetFinalPathNameByHandleW toReturn = pFunc;\n\n\tif (!toReturn) {\n\t\tHMODULE hModule = GetModuleHandleW(L\"kernel32\");\n\n\t\tif (hModule)\n\t\t\ttoReturn = (PFGetFinalPathNameByHandleW)GetProcAddress(hModule, \"GetFinalPathNameByHandleW\");\n\n\t\tpFunc = toReturn;\n\t}\n\n\tassert(toReturn);\n\n\treturn toReturn;\n}"
  },
  {
    "function_name": "p_getcwd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "314-335",
    "snippet": "int p_getcwd(char *buffer_out, size_t size)\n{\n\tgit_win32_path buf;\n\twchar_t *cwd = _wgetcwd(buf, GIT_WIN_PATH_UTF16);\n\n\tif (!cwd)\n\t\treturn -1;\n\n\t/* Convert the working directory back to UTF-8 */\n\tif (git__utf16_to_8(buffer_out, size, cwd) < 0) {\n\t\tDWORD code = GetLastError();\n\n\t\tif (code == ERROR_INSUFFICIENT_BUFFER)\n\t\t\terrno = ERANGE;\n\t\telse\n\t\t\terrno = EINVAL;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__utf16_to_8",
          "args": [
            "buffer_out",
            "size",
            "cwd"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "git__utf16_to_8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/utf-conv.c",
          "lines": "48-59",
          "snippet": "int git__utf16_to_8(char *dest, size_t dest_size, const wchar_t *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t * turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t * length. WideCharToMultiByte never returns int's minvalue, so underflow is not possible */\n\tif ((len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size, NULL, NULL) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}",
          "includes": [
            "#include \"utf-conv.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utf-conv.h\"\n#include \"common.h\"\n\nint git__utf16_to_8(char *dest, size_t dest_size, const wchar_t *src)\n{\n\tint len;\n\n\t/* Length of -1 indicates NULL termination of the input string. Subtract 1 from the result to\n\t * turn 0 into -1 (an error code) and to not count the NULL terminator as part of the string's\n\t * length. WideCharToMultiByte never returns int's minvalue, so underflow is not possible */\n\tif ((len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, src, -1, dest, (int)dest_size, NULL, NULL) - 1) < 0)\n\t\tgit__set_errno();\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_wgetcwd",
          "args": [
            "buf",
            "GIT_WIN_PATH_UTF16"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_getcwd(char *buffer_out, size_t size)\n{\n\tgit_win32_path buf;\n\twchar_t *cwd = _wgetcwd(buf, GIT_WIN_PATH_UTF16);\n\n\tif (!cwd)\n\t\treturn -1;\n\n\t/* Convert the working directory back to UTF-8 */\n\tif (git__utf16_to_8(buffer_out, size, cwd) < 0) {\n\t\tDWORD code = GetLastError();\n\n\t\tif (code == ERROR_INSUFFICIENT_BUFFER)\n\t\t\terrno = ERANGE;\n\t\telse\n\t\t\terrno = EINVAL;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "p_creat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "302-312",
    "snippet": "int p_creat(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wopen(buf,\n\t\t_O_WRONLY | _O_CREAT | _O_TRUNC | STANDARD_OPEN_FLAGS,\n\t\tmode & WIN32_MODE_MASK);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [
      "#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)",
      "#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wopen",
          "args": [
            "buf",
            "_O_WRONLY | _O_CREAT | _O_TRUNC | STANDARD_OPEN_FLAGS",
            "mode & WIN32_MODE_MASK"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\n#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)\n#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)\n\nint p_creat(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wopen(buf,\n\t\t_O_WRONLY | _O_CREAT | _O_TRUNC | STANDARD_OPEN_FLAGS,\n\t\tmode & WIN32_MODE_MASK);\n}"
  },
  {
    "function_name": "p_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "283-300",
    "snippet": "int p_open(const char *path, int flags, ...)\n{\n\tgit_win32_path buf;\n\tmode_t mode = 0;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn _wopen(buf, flags | STANDARD_OPEN_FLAGS, mode & WIN32_MODE_MASK);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [
      "#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)",
      "#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wopen",
          "args": [
            "buf",
            "flags | STANDARD_OPEN_FLAGS",
            "mode & WIN32_MODE_MASK"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "arg_list"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "arg_list",
            "int"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "arg_list",
            "flags"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\n#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)\n#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)\n\nint p_open(const char *path, int flags, ...)\n{\n\tgit_win32_path buf;\n\tmode_t mode = 0;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn _wopen(buf, flags | STANDARD_OPEN_FLAGS, mode & WIN32_MODE_MASK);\n}"
  },
  {
    "function_name": "p_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "275-281",
    "snippet": "int p_symlink(const char *old, const char *new)\n{\n\t/* Real symlinks on NTFS require admin privileges. Until this changes,\n\t * libgit2 just creates a text file with the link target in the contents.\n\t */\n\treturn git_futils_fake_symlink(old, new);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_futils_fake_symlink",
          "args": [
            "old",
            "new"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_fake_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "786-795",
          "snippet": "int git_futils_fake_symlink(const char *old, const char *new)\n{\n\tint retcode = GIT_ERROR;\n\tint fd = git_futils_creat_withpath(new, 0755, 0644);\n\tif (fd >= 0) {\n\t\tretcode = p_write(fd, old, strlen(old));\n\t\tp_close(fd);\n\t}\n\treturn retcode;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_fake_symlink(const char *old, const char *new)\n{\n\tint retcode = GIT_ERROR;\n\tint fd = git_futils_creat_withpath(new, 0755, 0644);\n\tif (fd >= 0) {\n\t\tretcode = p_write(fd, old, strlen(old));\n\t\tp_close(fd);\n\t}\n\treturn retcode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_symlink(const char *old, const char *new)\n{\n\t/* Real symlinks on NTFS require admin privileges. Until this changes,\n\t * libgit2 just creates a text file with the link target in the contents.\n\t */\n\treturn git_futils_fake_symlink(old, new);\n}"
  },
  {
    "function_name": "p_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "251-273",
    "snippet": "int p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "target",
            "bufsiz"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(size_t)len",
            "bufsiz"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_to_utf8",
          "args": [
            "target",
            "target_w"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_to_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "255-279",
          "snippet": "int git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_to_utf8(git_win32_utf8_path dest, const wchar_t *src)\n{\n\tchar *out = dest;\n\tint len;\n\n\t/* Strip NT namespacing \"\\\\?\\\" */\n\tif (path__is_nt_namespace(src)) {\n\t\tsrc += 4;\n\n\t\t/* \"\\\\?\\UNC\\server\\share\" -> \"\\\\server\\share\" */\n\t\tif (wcsncmp(src, L\"UNC\\\\\", 4) == 0) {\n\t\t\tsrc += 4;\n\n\t\t\tmemcpy(dest, \"\\\\\\\\\", 2);\n\t\t\tout = dest + 2;\n\t\t}\n\t}\n\n\tif ((len = git__utf16_to_8(out, GIT_WIN_PATH_UTF8, src)) < 0)\n\t\treturn len;\n\n\tgit_path_mkposix(dest);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_readlink_w",
          "args": [
            "target_w",
            "path_w"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_readlink_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "324-387",
          "snippet": "int git_win32_path_readlink_w(git_win32_path dest, const git_win32_path path)\n{\n\tBYTE buf[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n\tGIT_REPARSE_DATA_BUFFER *reparse_buf = (GIT_REPARSE_DATA_BUFFER *)buf;\n\tHANDLE handle = NULL;\n\tDWORD ioctl_ret;\n\twchar_t *target;\n\tsize_t target_len;\n\n\tint error = -1;\n\n\thandle = CreateFileW(path, GENERIC_READ,\n\t\tFILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING,\n\t\tFILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (handle == INVALID_HANDLE_VALUE) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (!DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0,\n\t\treparse_buf, sizeof(buf), &ioctl_ret, NULL)) {\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tswitch (reparse_buf->ReparseTag) {\n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\ttarget = reparse_buf->SymbolicLinkReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\ttarget = reparse_buf->MountPointReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->MountPointReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tdefault:\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tif (path_is_volume(target, target_len)) {\n\t\t/* This path is a reparse point that represents another volume mounted\n\t\t* at this location, it is not a symbolic link our input was canonical.\n\t\t*/\n\t\terrno = EINVAL;\n\t\terror = -1;\n\t} else if (target_len) {\n\t\t/* The path may need to have a prefix removed. */\n\t\ttarget_len = git_win32__canonicalize_path(target, target_len);\n\n\t\t/* Need one additional character in the target buffer\n\t\t* for the terminating NULL. */\n\t\tif (GIT_WIN_PATH_UTF16 > target_len) {\n\t\t\twcscpy(dest, target);\n\t\t\terror = (int)target_len;\n\t\t}\n\t}\n\non_error:\n\tCloseHandle(handle);\n\treturn error;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_win32_path_readlink_w(git_win32_path dest, const git_win32_path path)\n{\n\tBYTE buf[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n\tGIT_REPARSE_DATA_BUFFER *reparse_buf = (GIT_REPARSE_DATA_BUFFER *)buf;\n\tHANDLE handle = NULL;\n\tDWORD ioctl_ret;\n\twchar_t *target;\n\tsize_t target_len;\n\n\tint error = -1;\n\n\thandle = CreateFileW(path, GENERIC_READ,\n\t\tFILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING,\n\t\tFILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, NULL);\n\n\tif (handle == INVALID_HANDLE_VALUE) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\n\tif (!DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0,\n\t\treparse_buf, sizeof(buf), &ioctl_ret, NULL)) {\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tswitch (reparse_buf->ReparseTag) {\n\tcase IO_REPARSE_TAG_SYMLINK:\n\t\ttarget = reparse_buf->SymbolicLinkReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->SymbolicLinkReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tcase IO_REPARSE_TAG_MOUNT_POINT:\n\t\ttarget = reparse_buf->MountPointReparseBuffer.PathBuffer +\n\t\t\t(reparse_buf->MountPointReparseBuffer.SubstituteNameOffset / sizeof(WCHAR));\n\t\ttarget_len = reparse_buf->MountPointReparseBuffer.SubstituteNameLength / sizeof(WCHAR);\n\tbreak;\n\tdefault:\n\t\terrno = EINVAL;\n\t\tgoto on_error;\n\t}\n\n\tif (path_is_volume(target, target_len)) {\n\t\t/* This path is a reparse point that represents another volume mounted\n\t\t* at this location, it is not a symbolic link our input was canonical.\n\t\t*/\n\t\terrno = EINVAL;\n\t\terror = -1;\n\t} else if (target_len) {\n\t\t/* The path may need to have a prefix removed. */\n\t\ttarget_len = git_win32__canonicalize_path(target, target_len);\n\n\t\t/* Need one additional character in the target buffer\n\t\t* for the terminating NULL. */\n\t\tif (GIT_WIN_PATH_UTF16 > target_len) {\n\t\t\twcscpy(dest, target);\n\t\t\terror = (int)target_len;\n\t\t}\n\t}\n\non_error:\n\tCloseHandle(handle);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "path_w",
            "path"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_readlink(const char *path, char *buf, size_t bufsiz)\n{\n\tgit_win32_path path_w, target_w;\n\tgit_win32_utf8_path target;\n\tint len;\n\n\t/* readlink(2) does not NULL-terminate the string written\n\t * to the target buffer. Furthermore, the target buffer need\n\t * not be large enough to hold the entire result. A truncated\n\t * result should be written in this case. Since this truncation\n\t * could occur in the middle of the encoding of a code point,\n\t * we need to buffer the result on the stack. */\n\n\tif (git_win32_path_from_utf8(path_w, path) < 0 ||\n\t\tgit_win32_path_readlink_w(target_w, path_w) < 0 ||\n\t\t(len = git_win32_path_to_utf8(target, target_w)) < 0)\n\t\treturn -1;\n\n\tbufsiz = min((size_t)len, bufsiz);\n\tmemcpy(buf, target, bufsiz);\n\n\treturn (int)bufsiz;\n}"
  },
  {
    "function_name": "p_futimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "226-249",
    "snippet": "int p_futimes(int fd, const struct p_timeval times[2])\n{\n\tHANDLE handle;\n\tFILETIME atime = {0}, mtime = {0};\n\n\tif (times == NULL) {\n\t\tSYSTEMTIME st;\n\n\t\tGetSystemTime(&st);\n\t\tSystemTimeToFileTime(&st, &atime);\n\t\tSystemTimeToFileTime(&st, &mtime);\n\t} else {\n\t\tgit_win32__timeval_to_filetime(&atime, times[0]);\n\t\tgit_win32__timeval_to_filetime(&mtime, times[1]);\n\t}\n\n\tif ((handle = (HANDLE)_get_osfhandle(fd)) == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\tif (SetFileTime(handle, NULL, &atime, &mtime) == 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetFileTime",
          "args": [
            "handle",
            "NULL",
            "&atime",
            "&mtime"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__timeval_to_filetime",
          "args": [
            "&mtime",
            "times[1]"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__timeval_to_filetime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.h",
          "lines": "98-106",
          "snippet": "GIT_INLINE(void) git_win32__timeval_to_filetime(\n\tFILETIME *ft, const struct p_timeval tv)\n{\n\tlong long ticks = (tv.tv_sec * 10000000LL) +\n\t\t(tv.tv_usec * 10LL) + 116444736000000000LL;\n\n\tft->dwHighDateTime = ((ticks >> 32) & 0xffffffffLL);\n\tft->dwLowDateTime = (ticks & 0xffffffffLL);\n}",
          "includes": [
            "#include \"path_w32.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"path_w32.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n\nGIT_INLINE(void) git_win32__timeval_to_filetime(\n\tFILETIME *ft, const struct p_timeval tv)\n{\n\tlong long ticks = (tv.tv_sec * 10000000LL) +\n\t\t(tv.tv_usec * 10LL) + 116444736000000000LL;\n\n\tft->dwHighDateTime = ((ticks >> 32) & 0xffffffffLL);\n\tft->dwLowDateTime = (ticks & 0xffffffffLL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SystemTimeToFileTime",
          "args": [
            "&st",
            "&mtime"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SystemTimeToFileTime",
          "args": [
            "&st",
            "&atime"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetSystemTime",
          "args": [
            "&st"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_futimes(int fd, const struct p_timeval times[2])\n{\n\tHANDLE handle;\n\tFILETIME atime = {0}, mtime = {0};\n\n\tif (times == NULL) {\n\t\tSYSTEMTIME st;\n\n\t\tGetSystemTime(&st);\n\t\tSystemTimeToFileTime(&st, &atime);\n\t\tSystemTimeToFileTime(&st, &mtime);\n\t} else {\n\t\tgit_win32__timeval_to_filetime(&atime, times[0]);\n\t\tgit_win32__timeval_to_filetime(&mtime, times[1]);\n\t}\n\n\tif ((handle = (HANDLE)_get_osfhandle(fd)) == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\tif (SetFileTime(handle, NULL, &atime, &mtime) == 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "p_utimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "213-224",
    "snippet": "int p_utimes(const char *filename, const struct p_timeval times[2])\n{\n\tint fd, error;\n\n\tif ((fd = p_open(filename, O_RDWR)) < 0)\n\t\treturn fd;\n\n\terror = p_futimes(fd, times);\n\n\tclose(fd);\n\treturn error;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git__closedir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/dir.c",
          "lines": "106-118",
          "snippet": "int git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n\nint git__closedir(git__DIR *d)\n{\n\tif (!d)\n\t\treturn 0;\n\n\tif (d->h != INVALID_HANDLE_VALUE) {\n\t\tFindClose(d->h);\n\t\td->h = INVALID_HANDLE_VALUE;\n\t}\n\n\tgit__free(d);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_futimes",
          "args": [
            "fd",
            "times"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "p_futimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "226-249",
          "snippet": "int p_futimes(int fd, const struct p_timeval times[2])\n{\n\tHANDLE handle;\n\tFILETIME atime = {0}, mtime = {0};\n\n\tif (times == NULL) {\n\t\tSYSTEMTIME st;\n\n\t\tGetSystemTime(&st);\n\t\tSystemTimeToFileTime(&st, &atime);\n\t\tSystemTimeToFileTime(&st, &mtime);\n\t} else {\n\t\tgit_win32__timeval_to_filetime(&atime, times[0]);\n\t\tgit_win32__timeval_to_filetime(&mtime, times[1]);\n\t}\n\n\tif ((handle = (HANDLE)_get_osfhandle(fd)) == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\tif (SetFileTime(handle, NULL, &atime, &mtime) == 0)\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_futimes(int fd, const struct p_timeval times[2])\n{\n\tHANDLE handle;\n\tFILETIME atime = {0}, mtime = {0};\n\n\tif (times == NULL) {\n\t\tSYSTEMTIME st;\n\n\t\tGetSystemTime(&st);\n\t\tSystemTimeToFileTime(&st, &atime);\n\t\tSystemTimeToFileTime(&st, &mtime);\n\t} else {\n\t\tgit_win32__timeval_to_filetime(&atime, times[0]);\n\t\tgit_win32__timeval_to_filetime(&mtime, times[1]);\n\t}\n\n\tif ((handle = (HANDLE)_get_osfhandle(fd)) == INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\tif (SetFileTime(handle, NULL, &atime, &mtime) == 0)\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "filename",
            "O_RDWR"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "283-300",
          "snippet": "int p_open(const char *path, int flags, ...)\n{\n\tgit_win32_path buf;\n\tmode_t mode = 0;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn _wopen(buf, flags | STANDARD_OPEN_FLAGS, mode & WIN32_MODE_MASK);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [
            "#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)",
            "#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\n#define WIN32_MODE_MASK (_S_IREAD | _S_IWRITE)\n#define STANDARD_OPEN_FLAGS (_O_BINARY | _O_NOINHERIT)\n\nint p_open(const char *path, int flags, ...)\n{\n\tgit_win32_path buf;\n\tmode_t mode = 0;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn _wopen(buf, flags | STANDARD_OPEN_FLAGS, mode & WIN32_MODE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_utimes(const char *filename, const struct p_timeval times[2])\n{\n\tint fd, error;\n\n\tif ((fd = p_open(filename, O_RDWR)) < 0)\n\t\treturn fd;\n\n\terror = p_futimes(fd, times);\n\n\tclose(fd);\n\treturn error;\n}"
  },
  {
    "function_name": "p_lstat_posixly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "208-211",
    "snippet": "int p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lstat",
          "args": [
            "filename",
            "buf",
            "true"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "do_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "190-201",
          "snippet": "static int do_lstat(const char *path, struct stat *buf, bool posixly_correct)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0)\n\t\treturn -1;\n\n\tgit_win32__path_trim_end(path_w, len);\n\n\treturn lstat_w(path_w, buf, posixly_correct);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int do_lstat(const char *path, struct stat *buf, bool posixly_correct)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0)\n\t\treturn -1;\n\n\tgit_win32__path_trim_end(path_w, len);\n\n\treturn lstat_w(path_w, buf, posixly_correct);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat_posixly(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, true);\n}"
  },
  {
    "function_name": "p_lstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "203-206",
    "snippet": "int p_lstat(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, false);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_lstat",
          "args": [
            "filename",
            "buf",
            "false"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "do_lstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "190-201",
          "snippet": "static int do_lstat(const char *path, struct stat *buf, bool posixly_correct)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0)\n\t\treturn -1;\n\n\tgit_win32__path_trim_end(path_w, len);\n\n\treturn lstat_w(path_w, buf, posixly_correct);\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int do_lstat(const char *path, struct stat *buf, bool posixly_correct)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0)\n\t\treturn -1;\n\n\tgit_win32__path_trim_end(path_w, len);\n\n\treturn lstat_w(path_w, buf, posixly_correct);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_lstat(const char *filename, struct stat *buf)\n{\n\treturn do_lstat(filename, buf, false);\n}"
  },
  {
    "function_name": "do_lstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "190-201",
    "snippet": "static int do_lstat(const char *path, struct stat *buf, bool posixly_correct)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0)\n\t\treturn -1;\n\n\tgit_win32__path_trim_end(path_w, len);\n\n\treturn lstat_w(path_w, buf, posixly_correct);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lstat_w",
          "args": [
            "path_w",
            "buf",
            "posixly_correct"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "lstat_w",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "137-188",
          "snippet": "static int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32__path_trim_end",
          "args": [
            "path_w",
            "len"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__path_trim_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.c",
          "lines": "104-121",
          "snippet": "size_t git_win32__path_trim_end(wchar_t *str, size_t len)\n{\n\twhile (1) {\n\t\tif (!len || str[len - 1] != L'\\\\')\n\t\t\tbreak;\n\n\t\t/* Don't trim backslashes from drive letter paths, which\n\t\t * are 3 characters long and of the form C:\\, D:\\, etc. */\n\t\tif (len == 3 && git_win32__isalpha(str[0]) && str[1] == ':')\n\t\t\tbreak;\n\n\t\tlen--;\n\t}\n\n\tstr[len] = L'\\0';\n\n\treturn len;\n}",
          "includes": [
            "#include \"w32_util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"w32_util.h\"\n\nsize_t git_win32__path_trim_end(wchar_t *str, size_t len)\n{\n\twhile (1) {\n\t\tif (!len || str[len - 1] != L'\\\\')\n\t\t\tbreak;\n\n\t\t/* Don't trim backslashes from drive letter paths, which\n\t\t * are 3 characters long and of the form C:\\, D:\\, etc. */\n\t\tif (len == 3 && git_win32__isalpha(str[0]) && str[1] == ':')\n\t\t\tbreak;\n\n\t\tlen--;\n\t}\n\n\tstr[len] = L'\\0';\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "path_w",
            "path"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int do_lstat(const char *path, struct stat *buf, bool posixly_correct)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0)\n\t\treturn -1;\n\n\tgit_win32__path_trim_end(path_w, len);\n\n\treturn lstat_w(path_w, buf, posixly_correct);\n}"
  },
  {
    "function_name": "lstat_w",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "137-188",
    "snippet": "static int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetFileAttributesW",
          "args": [
            "path"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIN32_IS_WSEP",
          "args": [
            "path[path_len]"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wcslen",
          "args": [
            "path"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32__file_attribute_to_stat",
          "args": [
            "buf",
            "&fdata",
            "path"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32__file_attribute_to_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/w32_util.h",
          "lines": "155-184",
          "snippet": "GIT_INLINE(int) git_win32__file_attribute_to_stat(\n\tstruct stat *st,\n\tconst WIN32_FILE_ATTRIBUTE_DATA *attrdata,\n\tconst wchar_t *path)\n{\n\tgit_win32__stat_init(st,\n\t\tattrdata->dwFileAttributes,\n\t\tattrdata->nFileSizeHigh,\n\t\tattrdata->nFileSizeLow,\n\t\tattrdata->ftCreationTime,\n\t\tattrdata->ftLastAccessTime,\n\t\tattrdata->ftLastWriteTime);\n\n\tif (attrdata->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && path) {\n\t\tgit_win32_path target;\n\n\t\tif (git_win32_path_readlink_w(target, path) >= 0) {\n\t\t\tst->st_mode = (st->st_mode & ~S_IFMT) | S_IFLNK;\n\n\t\t\t/* st_size gets the UTF-8 length of the target name, in bytes,\n\t\t\t * not counting the NULL terminator */\n\t\t\tif ((st->st_size = git__utf16_to_8(NULL, 0, target)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Could not convert reparse point name for '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"path_w32.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"path_w32.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n\nGIT_INLINE(int) git_win32__file_attribute_to_stat(\n\tstruct stat *st,\n\tconst WIN32_FILE_ATTRIBUTE_DATA *attrdata,\n\tconst wchar_t *path)\n{\n\tgit_win32__stat_init(st,\n\t\tattrdata->dwFileAttributes,\n\t\tattrdata->nFileSizeHigh,\n\t\tattrdata->nFileSizeLow,\n\t\tattrdata->ftCreationTime,\n\t\tattrdata->ftLastAccessTime,\n\t\tattrdata->ftLastWriteTime);\n\n\tif (attrdata->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && path) {\n\t\tgit_win32_path target;\n\n\t\tif (git_win32_path_readlink_w(target, path) >= 0) {\n\t\t\tst->st_mode = (st->st_mode & ~S_IFMT) | S_IFLNK;\n\n\t\t\t/* st_size gets the UTF-8 length of the target name, in bytes,\n\t\t\t * not counting the NULL terminator */\n\t\t\tif ((st->st_size = git__utf16_to_8(NULL, 0, target)) < 0) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Could not convert reparse point name for '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetFileAttributesExW",
          "args": [
            "path",
            "GetFileExInfoStandard",
            "&fdata"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nstatic int lstat_w(\n\twchar_t *path,\n\tstruct stat *buf,\n\tbool posix_enotdir)\n{\n\tWIN32_FILE_ATTRIBUTE_DATA fdata;\n\n\tif (GetFileAttributesExW(path, GetFileExInfoStandard, &fdata)) {\n\t\tif (!buf)\n\t\t\treturn 0;\n\n\t\treturn git_win32__file_attribute_to_stat(buf, &fdata, path);\n\t}\n\n\tswitch (GetLastError()) {\n\tcase ERROR_ACCESS_DENIED:\n\t\terrno = EACCES;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tbreak;\n\t}\n\n\t/* To match POSIX behavior, set ENOTDIR when any of the folders in the\n\t * file path is a regular file, otherwise set ENOENT.\n\t */\n\tif (errno == ENOENT && posix_enotdir) {\n\t\tsize_t path_len = wcslen(path);\n\n\t\t/* scan up path until we find an existing item */\n\t\twhile (1) {\n\t\t\tDWORD attrs;\n\n\t\t\t/* remove last directory component */\n\t\t\tfor (path_len--; path_len > 0 && !WIN32_IS_WSEP(path[path_len]); path_len--);\n\n\t\t\tif (path_len <= 0)\n\t\t\t\tbreak;\n\n\t\t\tpath[path_len] = L'\\0';\n\t\t\tattrs = GetFileAttributesW(path);\n\n\t\t\tif (attrs != INVALID_FILE_ATTRIBUTES) {\n\t\t\t\tif (!(attrs & FILE_ATTRIBUTE_DIRECTORY))\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "p_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "112-133",
    "snippet": "int p_fsync(int fd)\n{\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (!FlushFileBuffers(fh)) {\n\t\tDWORD code = GetLastError();\n\n\t\tif (code == ERROR_INVALID_HANDLE)\n\t\t\terrno = EINVAL;\n\t\telse\n\t\t\terrno = EIO;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetLastError",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FlushFileBuffers",
          "args": [
            "fh"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_get_osfhandle",
          "args": [
            "fd"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_fsync(int fd)\n{\n\tHANDLE fh = (HANDLE)_get_osfhandle(fd);\n\n\tif (fh == INVALID_HANDLE_VALUE) {\n\t\terrno = EBADF;\n\t\treturn -1;\n\t}\n\n\tif (!FlushFileBuffers(fh)) {\n\t\tDWORD code = GetLastError();\n\n\t\tif (code == ERROR_INVALID_HANDLE)\n\t\t\terrno = EINVAL;\n\t\telse\n\t\t\terrno = EIO;\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "p_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "92-110",
    "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wunlink",
          "args": [
            "buf"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_wchmod",
          "args": [
            "buf",
            "0666"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_wunlink",
          "args": [
            "buf"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "p_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "84-90",
    "snippet": "int p_link(const char *old, const char *new)\n{\n\tGIT_UNUSED(old);\n\tGIT_UNUSED(new);\n\terrno = ENOSYS;\n\treturn -1;\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "new"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "old"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_link(const char *old, const char *new)\n{\n\tGIT_UNUSED(old);\n\tGIT_UNUSED(new);\n\terrno = ENOSYS;\n\treturn -1;\n}"
  },
  {
    "function_name": "p_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "72-82",
    "snippet": "int p_mkdir(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tGIT_UNUSED(mode);\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wmkdir(buf);\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_wmkdir",
          "args": [
            "buf"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_win32_path_from_utf8",
          "args": [
            "buf",
            "path"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "git_win32_path_from_utf8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/path_w32.c",
          "lines": "190-253",
          "snippet": "int git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"dir.h\"",
            "#include \"reparse.h\"",
            "#include \"posix.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define PATH__NT_NAMESPACE_LEN 4",
            "#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dir.h\"\n#include \"reparse.h\"\n#include \"posix.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"common.h\"\n\n#define PATH__NT_NAMESPACE_LEN 4\n#define PATH__NT_NAMESPACE     L\"\\\\\\\\?\\\\\"\n\nint git_win32_path_from_utf8(git_win32_path out, const char *src)\n{\n\twchar_t *dest = out;\n\n\t/* All win32 paths are in NT-prefixed format, beginning with \"\\\\?\\\". */\n\tmemcpy(dest, PATH__NT_NAMESPACE, sizeof(wchar_t) * PATH__NT_NAMESPACE_LEN);\n\tdest += PATH__NT_NAMESPACE_LEN;\n\n\t/* See if this is an absolute path (beginning with a drive letter) */\n\tif (path__is_absolute(src)) {\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* File-prefixed NT-style paths beginning with \\\\?\\ */\n\telse if (path__is_nt_namespace(src)) {\n\t\t/* Skip the NT prefix, the destination already contains it */\n\t\tif (git__utf8_to_16(dest, MAX_PATH, src + PATH__NT_NAMESPACE_LEN) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* UNC paths */\n\telse if (path__is_unc(src)) {\n\t\tmemcpy(dest, L\"UNC\\\\\", sizeof(wchar_t) * 4);\n\t\tdest += 4;\n\n\t\t/* Skip the leading \"\\\\\" */\n\t\tif (git__utf8_to_16(dest, MAX_PATH - 2, src + 2) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Absolute paths omitting the drive letter */\n\telse if (src[0] == '\\\\' || src[0] == '/') {\n\t\tif (path__cwd(dest, MAX_PATH) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (!path__is_absolute(dest)) {\n\t\t\terrno = ENOENT;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\t/* Skip the drive letter specification (\"C:\") */\t\n\t\tif (git__utf8_to_16(dest + 2, MAX_PATH - 2, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\t/* Relative paths */\n\telse {\n\t\tint cwd_len;\n\n\t\tif ((cwd_len = git_win32_path__cwd(dest, MAX_PATH)) < 0)\n\t\t\tgoto on_error;\n\n\t\tdest[cwd_len++] = L'\\\\';\n\n\t\tif (git__utf8_to_16(dest + cwd_len, MAX_PATH - cwd_len, src) < 0)\n\t\t\tgoto on_error;\n\t}\n\n\treturn git_win32_path_canonicalize(out);\n\non_error:\n\t/* set windows error code so we can use its error message */\n\tif (errno == ENAMETOOLONG)\n\t\tSetLastError(ERROR_FILENAME_EXCED_RANGE);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "mode"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_mkdir(const char *path, mode_t mode)\n{\n\tgit_win32_path buf;\n\n\tGIT_UNUSED(mode);\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\treturn _wmkdir(buf);\n}"
  },
  {
    "function_name": "p_ftruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
    "lines": "53-70",
    "snippet": "int p_ftruncate(int fd, git_off_t size)\n{\n\tif (size < 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n#if !defined(__MINGW32__) || defined(MINGW_HAS_SECURE_API)\n\treturn ((_chsize_s(fd, size) == 0) ? 0 : -1);\n#else\n\t/* TODO MINGW32 Find a replacement for _chsize() that handles big files. */\n\tif (size > INT32_MAX) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\treturn _chsize(fd, (long)size);\n#endif\n}",
    "includes": [
      "#include <ws2tcpip.h>",
      "#include <fcntl.h>",
      "#include <io.h>",
      "#include <errno.h>",
      "#include \"buffer.h\"",
      "#include \"global.h\"",
      "#include \"reparse.h\"",
      "#include \"repository.h\"",
      "#include \"utf-conv.h\"",
      "#include \"path_w32.h\"",
      "#include \"path.h\"",
      "#include \"../fileops.h\"",
      "#include \"../posix.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_chsize",
          "args": [
            "fd",
            "(long)size"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_chsize_s",
          "args": [
            "fd",
            "size"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_ftruncate(int fd, git_off_t size)\n{\n\tif (size < 0) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n#if !defined(__MINGW32__) || defined(MINGW_HAS_SECURE_API)\n\treturn ((_chsize_s(fd, size) == 0) ? 0 : -1);\n#else\n\t/* TODO MINGW32 Find a replacement for _chsize() that handles big files. */\n\tif (size > INT32_MAX) {\n\t\terrno = EFBIG;\n\t\treturn -1;\n\t}\n\treturn _chsize(fd, (long)size);\n#endif\n}"
  }
]