[
  {
    "function_name": "git_refdb_backend_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1918-1978",
    "snippet": "int git_refdb_backend_fs(\n\tgit_refdb_backend **backend_out,\n\tgit_repository *repository)\n{\n\tint t = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\trefdb_fs_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(refdb_fs_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->repo = repository;\n\n\tif (setup_namespace(&path, repository) < 0)\n\t\tgoto fail;\n\n\tbackend->path = git_buf_detach(&path);\n\n\tif (git_buf_joinpath(&path, backend->path, GIT_PACKEDREFS_FILE) < 0 ||\n\t\tgit_sortedcache_new(\n\t\t\t&backend->refcache, offsetof(struct packref, name),\n\t\t\tNULL, NULL, packref_cmp, git_buf_cstr(&path)) < 0)\n\t\tgoto fail;\n\n\tgit_buf_free(&path);\n\n\tif (!git_repository__cvar(&t, backend->repo, GIT_CVAR_IGNORECASE) && t) {\n\t\tbackend->iterator_flags |= GIT_ITERATOR_IGNORE_CASE;\n\t\tbackend->direach_flags  |= GIT_PATH_DIR_IGNORE_CASE;\n\t}\n\tif (!git_repository__cvar(&t, backend->repo, GIT_CVAR_PRECOMPOSE) && t) {\n\t\tbackend->iterator_flags |= GIT_ITERATOR_PRECOMPOSE_UNICODE;\n\t\tbackend->direach_flags  |= GIT_PATH_DIR_PRECOMPOSE_UNICODE;\n\t}\n\n\tbackend->parent.exists = &refdb_fs_backend__exists;\n\tbackend->parent.lookup = &refdb_fs_backend__lookup;\n\tbackend->parent.iterator = &refdb_fs_backend__iterator;\n\tbackend->parent.write = &refdb_fs_backend__write;\n\tbackend->parent.del = &refdb_fs_backend__delete;\n\tbackend->parent.rename = &refdb_fs_backend__rename;\n\tbackend->parent.compress = &refdb_fs_backend__compress;\n\tbackend->parent.lock = &refdb_fs_backend__lock;\n\tbackend->parent.unlock = &refdb_fs_backend__unlock;\n\tbackend->parent.has_log = &refdb_reflog_fs__has_log;\n\tbackend->parent.ensure_log = &refdb_reflog_fs__ensure_log;\n\tbackend->parent.free = &refdb_fs_backend__free;\n\tbackend->parent.reflog_read = &refdb_reflog_fs__read;\n\tbackend->parent.reflog_write = &refdb_reflog_fs__write;\n\tbackend->parent.reflog_rename = &refdb_reflog_fs__rename;\n\tbackend->parent.reflog_delete = &refdb_reflog_fs__delete;\n\n\t*backend_out = (git_refdb_backend *)backend;\n\treturn 0;\n\nfail:\n\tgit_buf_free(&path);\n\tgit__free(backend->path);\n\tgit__free(backend);\n\treturn -1;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&t",
            "backend->repo",
            "GIT_CVAR_PRECOMPOSE"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_new",
          "args": [
            "&backend->refcache",
            "offsetof(struct packref, name)",
            "NULL",
            "NULL",
            "packref_cmp",
            "git_buf_cstr(&path)"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "3-50",
          "snippet": "GIT__USE_STRMAP\n\nint git_sortedcache_new(\n\tgit_sortedcache **out,\n\tsize_t item_path_offset,\n\tgit_sortedcache_free_item_fn free_item,\n\tvoid *free_item_payload,\n\tgit_vector_cmp item_cmp,\n\tconst char *path)\n{\n\tgit_sortedcache *sc;\n\tsize_t pathlen, alloclen;\n\n\tpathlen = path ? strlen(path) : 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tsc = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(sc);\n\n\tgit_pool_init(&sc->pool, 1);\n\n\tif (git_vector_init(&sc->items, 4, item_cmp) < 0 ||\n\t\tgit_strmap_alloc(&sc->map) < 0)\n\t\tgoto fail;\n\n\tif (git_rwlock_init(&sc->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgoto fail;\n\t}\n\n\tsc->item_path_offset  = item_path_offset;\n\tsc->free_item         = free_item;\n\tsc->free_item_payload = free_item_payload;\n\tGIT_REFCOUNT_INC(sc);\n\tif (pathlen)\n\t\tmemcpy(sc->path, path, pathlen);\n\n\t*out = sc;\n\treturn 0;\n\nfail:\n\tgit_strmap_free(sc->map);\n\tgit_vector_free(&sc->items);\n\tgit_pool_clear(&sc->pool);\n\tgit__free(sc);\n\treturn -1;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nGIT__USE_STRMAP\n\nint git_sortedcache_new(\n\tgit_sortedcache **out,\n\tsize_t item_path_offset,\n\tgit_sortedcache_free_item_fn free_item,\n\tvoid *free_item_payload,\n\tgit_vector_cmp item_cmp,\n\tconst char *path)\n{\n\tgit_sortedcache *sc;\n\tsize_t pathlen, alloclen;\n\n\tpathlen = path ? strlen(path) : 0;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_sortedcache), pathlen);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tsc = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(sc);\n\n\tgit_pool_init(&sc->pool, 1);\n\n\tif (git_vector_init(&sc->items, 4, item_cmp) < 0 ||\n\t\tgit_strmap_alloc(&sc->map) < 0)\n\t\tgoto fail;\n\n\tif (git_rwlock_init(&sc->lock)) {\n\t\tgiterr_set(GITERR_OS, \"Failed to initialize lock\");\n\t\tgoto fail;\n\t}\n\n\tsc->item_path_offset  = item_path_offset;\n\tsc->free_item         = free_item;\n\tsc->free_item_payload = free_item_payload;\n\tGIT_REFCOUNT_INC(sc);\n\tif (pathlen)\n\t\tmemcpy(sc->path, path, pathlen);\n\n\t*out = sc;\n\treturn 0;\n\nfail:\n\tgit_strmap_free(sc->map);\n\tgit_vector_free(&sc->items);\n\tgit_pool_clear(&sc->pool);\n\tgit__free(sc);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "backend->path",
            "GIT_PACKEDREFS_FILE"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_detach",
          "args": [
            "&path"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "477-487",
          "snippet": "char *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nchar *git_buf_detach(git_buf *buf)\n{\n\tchar *data = buf->ptr;\n\n\tif (buf->asize == 0 || buf->ptr == git_buf__oom)\n\t\treturn NULL;\n\n\tgit_buf_init(buf, 0);\n\n\treturn data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_namespace",
          "args": [
            "&path",
            "repository"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "setup_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1388-1428",
          "snippet": "static int setup_namespace(git_buf *path, git_repository *repo)\n{\n\tchar *parts, *start, *end;\n\n\t/* Not all repositories have a path */\n\tif (repo->path_repository == NULL)\n\t\treturn 0;\n\n\t/* Load the path to the repo first */\n\tgit_buf_puts(path, repo->path_repository);\n\n\t/* if the repo is not namespaced, nothing else to do */\n\tif (repo->namespace == NULL)\n\t\treturn 0;\n\n\tparts = end = git__strdup(repo->namespace);\n\tif (parts == NULL)\n\t\treturn -1;\n\n\t/*\n\t * From `man gitnamespaces`:\n\t *  namespaces which include a / will expand to a hierarchy\n\t *  of namespaces; for example, GIT_NAMESPACE=foo/bar will store\n\t *  refs under refs/namespaces/foo/refs/namespaces/bar/\n\t */\n\twhile ((start = git__strsep(&end, \"/\")) != NULL) {\n\t\tgit_buf_printf(path, \"refs/namespaces/%s/\", start);\n\t}\n\n\tgit_buf_printf(path, \"refs/namespaces/%s/refs\", end);\n\tgit__free(parts);\n\n\t/* Make sure that the folder with the namespace exists */\n\tif (git_futils_mkdir_relative(git_buf_cstr(path), repo->path_repository,\n\t\t\t0777, GIT_MKDIR_PATH, NULL) < 0)\n\t\treturn -1;\n\n\t/* Return root of the namespaced path, i.e. without the trailing '/refs' */\n\tgit_buf_rtruncate_at_char(path, '/');\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int setup_namespace(git_buf *path, git_repository *repo)\n{\n\tchar *parts, *start, *end;\n\n\t/* Not all repositories have a path */\n\tif (repo->path_repository == NULL)\n\t\treturn 0;\n\n\t/* Load the path to the repo first */\n\tgit_buf_puts(path, repo->path_repository);\n\n\t/* if the repo is not namespaced, nothing else to do */\n\tif (repo->namespace == NULL)\n\t\treturn 0;\n\n\tparts = end = git__strdup(repo->namespace);\n\tif (parts == NULL)\n\t\treturn -1;\n\n\t/*\n\t * From `man gitnamespaces`:\n\t *  namespaces which include a / will expand to a hierarchy\n\t *  of namespaces; for example, GIT_NAMESPACE=foo/bar will store\n\t *  refs under refs/namespaces/foo/refs/namespaces/bar/\n\t */\n\twhile ((start = git__strsep(&end, \"/\")) != NULL) {\n\t\tgit_buf_printf(path, \"refs/namespaces/%s/\", start);\n\t}\n\n\tgit_buf_printf(path, \"refs/namespaces/%s/refs\", end);\n\tgit__free(parts);\n\n\t/* Make sure that the folder with the namespace exists */\n\tif (git_futils_mkdir_relative(git_buf_cstr(path), repo->path_repository,\n\t\t\t0777, GIT_MKDIR_PATH, NULL) < 0)\n\t\treturn -1;\n\n\t/* Return root of the namespaced path, i.e. without the trailing '/refs' */\n\tgit_buf_rtruncate_at_char(path, '/');\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "backend"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(refdb_fs_backend)"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nint git_refdb_backend_fs(\n\tgit_refdb_backend **backend_out,\n\tgit_repository *repository)\n{\n\tint t = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\trefdb_fs_backend *backend;\n\n\tbackend = git__calloc(1, sizeof(refdb_fs_backend));\n\tGITERR_CHECK_ALLOC(backend);\n\n\tbackend->repo = repository;\n\n\tif (setup_namespace(&path, repository) < 0)\n\t\tgoto fail;\n\n\tbackend->path = git_buf_detach(&path);\n\n\tif (git_buf_joinpath(&path, backend->path, GIT_PACKEDREFS_FILE) < 0 ||\n\t\tgit_sortedcache_new(\n\t\t\t&backend->refcache, offsetof(struct packref, name),\n\t\t\tNULL, NULL, packref_cmp, git_buf_cstr(&path)) < 0)\n\t\tgoto fail;\n\n\tgit_buf_free(&path);\n\n\tif (!git_repository__cvar(&t, backend->repo, GIT_CVAR_IGNORECASE) && t) {\n\t\tbackend->iterator_flags |= GIT_ITERATOR_IGNORE_CASE;\n\t\tbackend->direach_flags  |= GIT_PATH_DIR_IGNORE_CASE;\n\t}\n\tif (!git_repository__cvar(&t, backend->repo, GIT_CVAR_PRECOMPOSE) && t) {\n\t\tbackend->iterator_flags |= GIT_ITERATOR_PRECOMPOSE_UNICODE;\n\t\tbackend->direach_flags  |= GIT_PATH_DIR_PRECOMPOSE_UNICODE;\n\t}\n\n\tbackend->parent.exists = &refdb_fs_backend__exists;\n\tbackend->parent.lookup = &refdb_fs_backend__lookup;\n\tbackend->parent.iterator = &refdb_fs_backend__iterator;\n\tbackend->parent.write = &refdb_fs_backend__write;\n\tbackend->parent.del = &refdb_fs_backend__delete;\n\tbackend->parent.rename = &refdb_fs_backend__rename;\n\tbackend->parent.compress = &refdb_fs_backend__compress;\n\tbackend->parent.lock = &refdb_fs_backend__lock;\n\tbackend->parent.unlock = &refdb_fs_backend__unlock;\n\tbackend->parent.has_log = &refdb_reflog_fs__has_log;\n\tbackend->parent.ensure_log = &refdb_reflog_fs__ensure_log;\n\tbackend->parent.free = &refdb_fs_backend__free;\n\tbackend->parent.reflog_read = &refdb_reflog_fs__read;\n\tbackend->parent.reflog_write = &refdb_reflog_fs__write;\n\tbackend->parent.reflog_rename = &refdb_reflog_fs__rename;\n\tbackend->parent.reflog_delete = &refdb_reflog_fs__delete;\n\n\t*backend_out = (git_refdb_backend *)backend;\n\treturn 0;\n\nfail:\n\tgit_buf_free(&path);\n\tgit__free(backend->path);\n\tgit__free(backend);\n\treturn -1;\n}"
  },
  {
    "function_name": "refdb_reflog_fs__delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1894-1916",
    "snippet": "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\terror = retrieve_reflog_path(&path, repo, name);\n\n\tif (!error && git_path_exists(path.ptr))\n\t\terror = p_unlink(path.ptr);\n\n\tgit_buf_free(&path);\n\n\treturn error;\n\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "path.ptr"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "path.ptr"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_reflog_path",
          "args": [
            "&path",
            "repo",
            "name"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_reflog_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1536-1539",
          "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && name"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\terror = retrieve_reflog_path(&path, repo, name);\n\n\tif (!error && git_path_exists(path.ptr))\n\t\terror = p_unlink(path.ptr);\n\n\tgit_buf_free(&path);\n\n\treturn error;\n\n}"
  },
  {
    "function_name": "refdb_reflog_fs__rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1813-1892",
    "snippet": "static int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name)\n{\n\tint error = 0, fd;\n\tgit_buf old_path = GIT_BUF_INIT;\n\tgit_buf new_path = GIT_BUF_INIT;\n\tgit_buf temp_path = GIT_BUF_INIT;\n\tgit_buf normalized = GIT_BUF_INIT;\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && old_name && new_name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif ((error = git_reference__normalize_name(\n\t\t&normalized, new_name, GIT_REF_FORMAT_ALLOW_ONELEVEL)) < 0)\n\t\t\treturn error;\n\n\tif (git_buf_joinpath(&temp_path, repo->path_repository, GIT_REFLOG_DIR) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&old_path, git_buf_cstr(&temp_path), old_name) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&new_path, git_buf_cstr(&temp_path), git_buf_cstr(&normalized)) < 0)\n\t\treturn -1;\n\n\tif (!git_path_exists(git_buf_cstr(&old_path))) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Move the reflog to a temporary place. This two-phase renaming is required\n\t * in order to cope with funny renaming use cases when one tries to move a reference\n\t * to a partially colliding namespace:\n\t *  - a/b -> a/b/c\n\t *  - a/b/c/d -> a/b/c\n\t */\n\tif (git_buf_joinpath(&temp_path, git_buf_cstr(&temp_path), \"temp_reflog\") < 0)\n\t\treturn -1;\n\n\tif ((fd = git_futils_mktmp(&temp_path, git_buf_cstr(&temp_path), GIT_REFLOG_FILE_MODE)) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tp_close(fd);\n\n\tif (p_rename(git_buf_cstr(&old_path), git_buf_cstr(&temp_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_path_isdir(git_buf_cstr(&new_path)) && \n\t\t(git_futils_rmdir_r(git_buf_cstr(&new_path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_futils_mkpath2file(git_buf_cstr(&new_path), GIT_REFLOG_DIR_MODE) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (p_rename(git_buf_cstr(&temp_path), git_buf_cstr(&new_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_buf_free(&temp_path);\n\tgit_buf_free(&old_path);\n\tgit_buf_free(&new_path);\n\tgit_buf_free(&normalized);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&normalized"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"Failed to rename reflog for %s\"",
            "new_name"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_rename",
          "args": [
            "git_buf_cstr(&temp_path)",
            "git_buf_cstr(&new_path)"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "p_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "142-153",
          "snippet": "int p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_rename(const char *from, const char *to)\n{\n\tif (!link(from, to)) {\n\t\tp_unlink(from);\n\t\treturn 0;\n\t}\n\n\tif (!rename(from, to))\n\t\treturn 0;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&new_path"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkpath2file",
          "args": [
            "git_buf_cstr(&new_path)",
            "GIT_REFLOG_DIR_MODE"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkpath2file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "16-23",
          "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_rmdir_r",
          "args": [
            "git_buf_cstr(&new_path)",
            "NULL",
            "GIT_RMDIR_SKIP_NONEMPTY"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_rmdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "753-784",
          "snippet": "int git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "git_buf_cstr(&new_path)"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mktmp",
          "args": [
            "&temp_path",
            "git_buf_cstr(&temp_path)",
            "GIT_REFLOG_FILE_MODE"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mktmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "25-51",
          "snippet": "int git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mktmp(git_buf *path_out, const char *filename, mode_t mode)\n{\n\tint fd;\n\tmode_t mask;\n\n\tp_umask(mask = p_umask(0));\n\n\tgit_buf_sets(path_out, filename);\n\tgit_buf_puts(path_out, \"_git2_XXXXXX\");\n\n\tif (git_buf_oom(path_out))\n\t\treturn -1;\n\n\tif ((fd = p_mkstemp(path_out->ptr)) < 0) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to create temporary file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\tif (p_chmod(path_out->ptr, (mode & ~mask))) {\n\t\tgiterr_set(GITERR_OS,\n\t\t\t\"Failed to set permissions on file '%s'\", path_out->ptr);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&temp_path",
            "git_buf_cstr(&temp_path)",
            "\"temp_reflog\""
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "git_buf_cstr(&old_path)"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__normalize_name",
          "args": [
            "&normalized",
            "new_name",
            "GIT_REF_FORMAT_ALLOW_ONELEVEL"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__normalize_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "858-974",
          "snippet": "int git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference__normalize_name(\n\tgit_buf *buf,\n\tconst char *name,\n\tunsigned int flags)\n{\n\tconst char *current;\n\tint segment_len, segments_count = 0, error = GIT_EINVALIDSPEC;\n\tunsigned int process_flags;\n\tbool normalize = (buf != NULL);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tassert(name);\n\n\tprocess_flags = flags;\n\tcurrent = (char *)name;\n\n\tif (*current == '/')\n\t\tgoto cleanup;\n\n\tif (normalize)\n\t\tgit_buf_clear(buf);\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_REF_FORMAT__PRECOMPOSE_UNICODE) != 0) {\n\t\tsize_t namelen = strlen(current);\n\t\tif ((error = git_path_iconv_init_precompose(&ic)) < 0 ||\n\t\t\t(error = git_path_iconv(&ic, &current, &namelen)) < 0)\n\t\t\tgoto cleanup;\n\t\terror = GIT_EINVALIDSPEC;\n\t}\n#endif\n\n\twhile (true) {\n\t\tsegment_len = ensure_segment_validity(current);\n\t\tif (segment_len < 0) {\n\t\t\tif ((process_flags & GIT_REF_FORMAT_REFSPEC_PATTERN) &&\n\t\t\t\t\tcurrent[0] == '*' &&\n\t\t\t\t\t(current[1] == '\\0' || current[1] == '/')) {\n\t\t\t\t/* Accept one wildcard as a full refname component. */\n\t\t\t\tprocess_flags &= ~GIT_REF_FORMAT_REFSPEC_PATTERN;\n\t\t\t\tsegment_len = 1;\n\t\t\t} else\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (segment_len > 0) {\n\t\t\tif (normalize) {\n\t\t\t\tsize_t cur_len = git_buf_len(buf);\n\n\t\t\t\tgit_buf_joinpath(buf, git_buf_cstr(buf), current);\n\t\t\t\tgit_buf_truncate(buf,\n\t\t\t\t\tcur_len + segment_len + (segments_count ? 1 : 0));\n\n\t\t\t\tif (git_buf_oom(buf)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsegments_count++;\n\t\t}\n\n\t\t/* No empty segment is allowed when not normalizing */\n\t\tif (segment_len == 0 && !normalize)\n\t\t\tgoto cleanup;\n\n\t\tif (current[segment_len] == '\\0')\n\t\t\tbreak;\n\n\t\tcurrent += segment_len + 1;\n\t}\n\n\t/* A refname can not be empty */\n\tif (segment_len == 0 && segments_count == 0)\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \".\" */\n\tif (current[segment_len - 1] == '.')\n\t\tgoto cleanup;\n\n\t/* A refname can not end with \"/\" */\n\tif (current[segment_len - 1] == '/')\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) && !(flags & GIT_REF_FORMAT_ALLOW_ONELEVEL))\n\t\tgoto cleanup;\n\n\tif ((segments_count == 1 ) &&\n\t    !(flags & GIT_REF_FORMAT_REFSPEC_SHORTHAND) &&\n\t\t!(is_all_caps_and_underscore(name, (size_t)segment_len) ||\n\t\t\t((flags & GIT_REF_FORMAT_REFSPEC_PATTERN) && !strcmp(\"*\", name))))\n\t\t\tgoto cleanup;\n\n\tif ((segments_count > 1)\n\t\t&& (is_all_caps_and_underscore(name, strchr(name, '/') - name)))\n\t\t\tgoto cleanup;\n\n\terror = 0;\n\ncleanup:\n\tif (error == GIT_EINVALIDSPEC)\n\t\tgiterr_set(\n\t\t\tGITERR_REFERENCE,\n\t\t\t\"The given reference name '%s' is not valid\", name);\n\n\tif (error && normalize)\n\t\tgit_buf_free(buf);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && old_name && new_name"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name);\n\nstatic int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name)\n{\n\tint error = 0, fd;\n\tgit_buf old_path = GIT_BUF_INIT;\n\tgit_buf new_path = GIT_BUF_INIT;\n\tgit_buf temp_path = GIT_BUF_INIT;\n\tgit_buf normalized = GIT_BUF_INIT;\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && old_name && new_name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif ((error = git_reference__normalize_name(\n\t\t&normalized, new_name, GIT_REF_FORMAT_ALLOW_ONELEVEL)) < 0)\n\t\t\treturn error;\n\n\tif (git_buf_joinpath(&temp_path, repo->path_repository, GIT_REFLOG_DIR) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&old_path, git_buf_cstr(&temp_path), old_name) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&new_path, git_buf_cstr(&temp_path), git_buf_cstr(&normalized)) < 0)\n\t\treturn -1;\n\n\tif (!git_path_exists(git_buf_cstr(&old_path))) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Move the reflog to a temporary place. This two-phase renaming is required\n\t * in order to cope with funny renaming use cases when one tries to move a reference\n\t * to a partially colliding namespace:\n\t *  - a/b -> a/b/c\n\t *  - a/b/c/d -> a/b/c\n\t */\n\tif (git_buf_joinpath(&temp_path, git_buf_cstr(&temp_path), \"temp_reflog\") < 0)\n\t\treturn -1;\n\n\tif ((fd = git_futils_mktmp(&temp_path, git_buf_cstr(&temp_path), GIT_REFLOG_FILE_MODE)) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tp_close(fd);\n\n\tif (p_rename(git_buf_cstr(&old_path), git_buf_cstr(&temp_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_path_isdir(git_buf_cstr(&new_path)) && \n\t\t(git_futils_rmdir_r(git_buf_cstr(&new_path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_futils_mkpath2file(git_buf_cstr(&new_path), GIT_REFLOG_DIR_MODE) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (p_rename(git_buf_cstr(&temp_path), git_buf_cstr(&new_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_buf_free(&temp_path);\n\tgit_buf_free(&old_path);\n\tgit_buf_free(&new_path);\n\tgit_buf_free(&normalized);\n\n\treturn error;\n}"
  },
  {
    "function_name": "reflog_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1735-1811",
    "snippet": "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_writebuffer",
          "args": [
            "&buf",
            "git_buf_cstr(&path)",
            "O_WRONLY|O_CREAT|O_APPEND",
            "GIT_REFLOG_FILE_MODE"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_writebuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "229-254",
          "snippet": "int git_futils_writebuffer(\n\tconst git_buf *buf,\tconst char *path, int flags, mode_t mode)\n{\n\tint fd, error = 0;\n\n\tif (flags <= 0)\n\t\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tif (!mode)\n\t\tmode = GIT_FILEMODE_BLOB;\n\n\tif ((fd = p_open(path, flags, mode)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not open '%s' for writing\", path);\n\t\treturn fd;\n\t}\n\n\tif ((error = p_write(fd, git_buf_cstr(buf), git_buf_len(buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not write to '%s'\", path);\n\t\t(void)p_close(fd);\n\t\treturn error;\n\t}\n\n\tif ((error = p_close(fd)) < 0)\n\t\tgiterr_set(GITERR_OS, \"Error while closing '%s'\", path);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_writebuffer(\n\tconst git_buf *buf,\tconst char *path, int flags, mode_t mode)\n{\n\tint fd, error = 0;\n\n\tif (flags <= 0)\n\t\tflags = O_CREAT | O_TRUNC | O_WRONLY;\n\tif (!mode)\n\t\tmode = GIT_FILEMODE_BLOB;\n\n\tif ((fd = p_open(path, flags, mode)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not open '%s' for writing\", path);\n\t\treturn fd;\n\t}\n\n\tif ((error = p_write(fd, git_buf_cstr(buf), git_buf_len(buf))) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Could not write to '%s'\", path);\n\t\t(void)p_close(fd);\n\t\treturn error;\n\t}\n\n\tif ((error = p_close(fd)) < 0)\n\t\tgiterr_set(GITERR_OS, \"Error while closing '%s'\", path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"cannot create reflog at '%s', there are reflogs beneath that folder\"",
            "ref->name"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "git_buf_cstr(&path)"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_rmdir_r",
          "args": [
            "git_buf_cstr(&path)",
            "NULL",
            "GIT_RMDIR_SKIP_NONEMPTY"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_rmdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "753-784",
          "snippet": "int git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkpath2file",
          "args": [
            "git_buf_cstr(&path)",
            "0777"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkpath2file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "16-23",
          "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_reflog_path",
          "args": [
            "&path",
            "repo",
            "ref->name"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_reflog_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1536-1539",
          "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "serialize_reflog_entry",
          "args": [
            "&buf",
            "&old_id",
            "&new_id",
            "who",
            "message"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "serialize_reflog_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1633-1665",
          "snippet": "static int serialize_reflog_entry(\n\tgit_buf *buf,\n\tconst git_oid *oid_old,\n\tconst git_oid *oid_new,\n\tconst git_signature *committer,\n\tconst char *msg)\n{\n\tchar raw_old[GIT_OID_HEXSZ+1];\n\tchar raw_new[GIT_OID_HEXSZ+1];\n\n\tgit_oid_tostr(raw_old, GIT_OID_HEXSZ+1, oid_old);\n\tgit_oid_tostr(raw_new, GIT_OID_HEXSZ+1, oid_new);\n\n\tgit_buf_clear(buf);\n\n\tgit_buf_puts(buf, raw_old);\n\tgit_buf_putc(buf, ' ');\n\tgit_buf_puts(buf, raw_new);\n\n\tgit_signature__writebuf(buf, \" \", committer);\n\n\t/* drop trailing LF */\n\tgit_buf_rtrim(buf);\n\n\tif (msg) {\n\t\tgit_buf_putc(buf, '\\t');\n\t\tgit_buf_puts(buf, msg);\n\t}\n\n\tgit_buf_putc(buf, '\\n');\n\n\treturn git_buf_oom(buf);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int serialize_reflog_entry(\n\tgit_buf *buf,\n\tconst git_oid *oid_old,\n\tconst git_oid *oid_new,\n\tconst git_signature *committer,\n\tconst char *msg)\n{\n\tchar raw_old[GIT_OID_HEXSZ+1];\n\tchar raw_new[GIT_OID_HEXSZ+1];\n\n\tgit_oid_tostr(raw_old, GIT_OID_HEXSZ+1, oid_old);\n\tgit_oid_tostr(raw_new, GIT_OID_HEXSZ+1, oid_new);\n\n\tgit_buf_clear(buf);\n\n\tgit_buf_puts(buf, raw_old);\n\tgit_buf_putc(buf, ' ');\n\tgit_buf_puts(buf, raw_new);\n\n\tgit_signature__writebuf(buf, \" \", committer);\n\n\t/* drop trailing LF */\n\tgit_buf_rtrim(buf);\n\n\tif (msg) {\n\t\tgit_buf_putc(buf, '\\t');\n\t\tgit_buf_puts(buf, msg);\n\t}\n\n\tgit_buf_putc(buf, '\\n');\n\n\treturn git_buf_oom(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&new_id",
            "repo",
            "git_reference_symbolic_target(ref)"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_symbolic_target",
          "args": [
            "ref"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "341-349",
          "snippet": "const char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&new_id",
            "git_reference_target(ref)"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ref->name",
            "GIT_HEAD_FILE"
          ],
          "line": 1746
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "refdb_reflog_fs__write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1698-1732",
    "snippet": "static int refdb_reflog_fs__write(git_refdb_backend *_backend, git_reflog *reflog)\n{\n\tint error = -1;\n\tunsigned int i;\n\tgit_reflog_entry *entry;\n\trefdb_fs_backend *backend;\n\tgit_buf log = GIT_BUF_INIT;\n\tgit_filebuf fbuf = GIT_FILEBUF_INIT;\n\n\tassert(_backend && reflog);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\n\tif ((error = lock_reflog(&fbuf, backend, reflog->ref_name)) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&reflog->entries, i, entry) {\n\t\tif (serialize_reflog_entry(&log, &(entry->oid_old), &(entry->oid_cur), entry->committer, entry->msg) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_filebuf_write(&fbuf, log.ptr, log.size)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_commit(&fbuf);\n\tgoto success;\n\ncleanup:\n\tgit_filebuf_cleanup(&fbuf);\n\nsuccess:\n\tgit_buf_free(&log);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&fbuf"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&fbuf"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_write",
          "args": [
            "&fbuf",
            "log.ptr",
            "log.size"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "451-476",
          "snippet": "int git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_write(git_filebuf *file, const void *buff, size_t len)\n{\n\tconst unsigned char *buf = buff;\n\n\tENSURE_BUF_OK(file);\n\n\tif (file->do_not_buffer)\n\t\treturn file->write(file, (void *)buff, len);\n\n\tfor (;;) {\n\t\tsize_t space_left = file->buf_size - file->buf_pos;\n\n\t\t/* cache if it's small */\n\t\tif (space_left > len) {\n\t\t\tadd_to_cache(file, buf, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tadd_to_cache(file, buf, space_left);\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tlen -= space_left;\n\t\tbuf += space_left;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "serialize_reflog_entry",
          "args": [
            "&log",
            "&(entry->oid_old)",
            "&(entry->oid_cur)",
            "entry->committer",
            "entry->msg"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "serialize_reflog_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1633-1665",
          "snippet": "static int serialize_reflog_entry(\n\tgit_buf *buf,\n\tconst git_oid *oid_old,\n\tconst git_oid *oid_new,\n\tconst git_signature *committer,\n\tconst char *msg)\n{\n\tchar raw_old[GIT_OID_HEXSZ+1];\n\tchar raw_new[GIT_OID_HEXSZ+1];\n\n\tgit_oid_tostr(raw_old, GIT_OID_HEXSZ+1, oid_old);\n\tgit_oid_tostr(raw_new, GIT_OID_HEXSZ+1, oid_new);\n\n\tgit_buf_clear(buf);\n\n\tgit_buf_puts(buf, raw_old);\n\tgit_buf_putc(buf, ' ');\n\tgit_buf_puts(buf, raw_new);\n\n\tgit_signature__writebuf(buf, \" \", committer);\n\n\t/* drop trailing LF */\n\tgit_buf_rtrim(buf);\n\n\tif (msg) {\n\t\tgit_buf_putc(buf, '\\t');\n\t\tgit_buf_puts(buf, msg);\n\t}\n\n\tgit_buf_putc(buf, '\\n');\n\n\treturn git_buf_oom(buf);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int serialize_reflog_entry(\n\tgit_buf *buf,\n\tconst git_oid *oid_old,\n\tconst git_oid *oid_new,\n\tconst git_signature *committer,\n\tconst char *msg)\n{\n\tchar raw_old[GIT_OID_HEXSZ+1];\n\tchar raw_new[GIT_OID_HEXSZ+1];\n\n\tgit_oid_tostr(raw_old, GIT_OID_HEXSZ+1, oid_old);\n\tgit_oid_tostr(raw_new, GIT_OID_HEXSZ+1, oid_new);\n\n\tgit_buf_clear(buf);\n\n\tgit_buf_puts(buf, raw_old);\n\tgit_buf_putc(buf, ' ');\n\tgit_buf_puts(buf, raw_new);\n\n\tgit_signature__writebuf(buf, \" \", committer);\n\n\t/* drop trailing LF */\n\tgit_buf_rtrim(buf);\n\n\tif (msg) {\n\t\tgit_buf_putc(buf, '\\t');\n\t\tgit_buf_puts(buf, msg);\n\t}\n\n\tgit_buf_putc(buf, '\\n');\n\n\treturn git_buf_oom(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&reflog->entries",
            "i",
            "entry"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_reflog",
          "args": [
            "&fbuf",
            "backend",
            "reflog->ref_name"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "lock_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1667-1696",
          "snippet": "static int lock_reflog(git_filebuf *file, refdb_fs_backend *backend, const char *refname)\n{\n\tgit_repository *repo;\n\tgit_buf log_path = GIT_BUF_INIT;\n\tint error;\n\n\trepo = backend->repo;\n\n\tif (!git_path_isvalid(backend->repo, refname, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", refname);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (retrieve_reflog_path(&log_path, repo, refname) < 0)\n\t\treturn -1;\n\n\tif (!git_path_isfile(git_buf_cstr(&log_path))) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Log file for reference '%s' doesn't exist.\", refname);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_open(file, git_buf_cstr(&log_path), 0, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&log_path);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int lock_reflog(git_filebuf *file, refdb_fs_backend *backend, const char *refname)\n{\n\tgit_repository *repo;\n\tgit_buf log_path = GIT_BUF_INIT;\n\tint error;\n\n\trepo = backend->repo;\n\n\tif (!git_path_isvalid(backend->repo, refname, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", refname);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (retrieve_reflog_path(&log_path, repo, refname) < 0)\n\t\treturn -1;\n\n\tif (!git_path_isfile(git_buf_cstr(&log_path))) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Log file for reference '%s' doesn't exist.\", refname);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_open(file, git_buf_cstr(&log_path), 0, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&log_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && reflog"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__write(git_refdb_backend *_backend, git_reflog *reflog)\n{\n\tint error = -1;\n\tunsigned int i;\n\tgit_reflog_entry *entry;\n\trefdb_fs_backend *backend;\n\tgit_buf log = GIT_BUF_INIT;\n\tgit_filebuf fbuf = GIT_FILEBUF_INIT;\n\n\tassert(_backend && reflog);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\n\tif ((error = lock_reflog(&fbuf, backend, reflog->ref_name)) < 0)\n\t\treturn -1;\n\n\tgit_vector_foreach(&reflog->entries, i, entry) {\n\t\tif (serialize_reflog_entry(&log, &(entry->oid_old), &(entry->oid_cur), entry->committer, entry->msg) < 0)\n\t\t\tgoto cleanup;\n\n\t\tif ((error = git_filebuf_write(&fbuf, log.ptr, log.size)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_commit(&fbuf);\n\tgoto success;\n\ncleanup:\n\tgit_filebuf_cleanup(&fbuf);\n\nsuccess:\n\tgit_buf_free(&log);\n\n\treturn error;\n}"
  },
  {
    "function_name": "lock_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1667-1696",
    "snippet": "static int lock_reflog(git_filebuf *file, refdb_fs_backend *backend, const char *refname)\n{\n\tgit_repository *repo;\n\tgit_buf log_path = GIT_BUF_INIT;\n\tint error;\n\n\trepo = backend->repo;\n\n\tif (!git_path_isvalid(backend->repo, refname, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", refname);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (retrieve_reflog_path(&log_path, repo, refname) < 0)\n\t\treturn -1;\n\n\tif (!git_path_isfile(git_buf_cstr(&log_path))) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Log file for reference '%s' doesn't exist.\", refname);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_open(file, git_buf_cstr(&log_path), 0, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&log_path);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log_path"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "file",
            "git_buf_cstr(&log_path)",
            "0",
            "GIT_REFLOG_FILE_MODE"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&log_path"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Log file for reference '%s' doesn't exist.\"",
            "refname"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "git_buf_cstr(&log_path)"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_reflog_path",
          "args": [
            "&log_path",
            "repo",
            "refname"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_reflog_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1536-1539",
          "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isvalid",
          "args": [
            "backend->repo",
            "refname",
            "GIT_PATH_REJECT_FILESYSTEM_DEFAULTS"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1677-1701",
          "snippet": "bool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int lock_reflog(git_filebuf *file, refdb_fs_backend *backend, const char *refname)\n{\n\tgit_repository *repo;\n\tgit_buf log_path = GIT_BUF_INIT;\n\tint error;\n\n\trepo = backend->repo;\n\n\tif (!git_path_isvalid(backend->repo, refname, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", refname);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\tif (retrieve_reflog_path(&log_path, repo, refname) < 0)\n\t\treturn -1;\n\n\tif (!git_path_isfile(git_buf_cstr(&log_path))) {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Log file for reference '%s' doesn't exist.\", refname);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_filebuf_open(file, git_buf_cstr(&log_path), 0, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&log_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "serialize_reflog_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1633-1665",
    "snippet": "static int serialize_reflog_entry(\n\tgit_buf *buf,\n\tconst git_oid *oid_old,\n\tconst git_oid *oid_new,\n\tconst git_signature *committer,\n\tconst char *msg)\n{\n\tchar raw_old[GIT_OID_HEXSZ+1];\n\tchar raw_new[GIT_OID_HEXSZ+1];\n\n\tgit_oid_tostr(raw_old, GIT_OID_HEXSZ+1, oid_old);\n\tgit_oid_tostr(raw_new, GIT_OID_HEXSZ+1, oid_new);\n\n\tgit_buf_clear(buf);\n\n\tgit_buf_puts(buf, raw_old);\n\tgit_buf_putc(buf, ' ');\n\tgit_buf_puts(buf, raw_new);\n\n\tgit_signature__writebuf(buf, \" \", committer);\n\n\t/* drop trailing LF */\n\tgit_buf_rtrim(buf);\n\n\tif (msg) {\n\t\tgit_buf_putc(buf, '\\t');\n\t\tgit_buf_puts(buf, msg);\n\t}\n\n\tgit_buf_putc(buf, '\\n');\n\n\treturn git_buf_oom(buf);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_oom",
          "args": [
            "buf"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_oom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "94-97",
          "snippet": "GIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_buf_oom(const git_buf *buf)\n{\n\treturn (buf->ptr == git_buf__oom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "buf",
            "'\\n'"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "buf",
            "msg"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtrim",
          "args": [
            "buf"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "718-729",
          "snippet": "void git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_signature__writebuf",
          "args": [
            "buf",
            "\" \"",
            "committer"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__writebuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "265-284",
          "snippet": "void git_signature__writebuf(git_buf *buf, const char *header, const git_signature *sig)\n{\n\tint offset, hours, mins;\n\tchar sign;\n\n\tassert(buf && sig);\n\n\toffset = sig->when.offset;\n\tsign = (sig->when.offset < 0) ? '-' : '+';\n\n\tif (offset < 0)\n\t\toffset = -offset;\n\n\thours = offset / 60;\n\tmins = offset % 60;\n\n\tgit_buf_printf(buf, \"%s%s <%s> %u %c%02d%02d\\n\",\n\t\t\theader ? header : \"\", sig->name, sig->email,\n\t\t\t(unsigned)sig->when.time, sign, hours, mins);\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nvoid git_signature__writebuf(git_buf *buf, const char *header, const git_signature *sig)\n{\n\tint offset, hours, mins;\n\tchar sign;\n\n\tassert(buf && sig);\n\n\toffset = sig->when.offset;\n\tsign = (sig->when.offset < 0) ? '-' : '+';\n\n\tif (offset < 0)\n\t\toffset = -offset;\n\n\thours = offset / 60;\n\tmins = offset % 60;\n\n\tgit_buf_printf(buf, \"%s%s <%s> %u %c%02d%02d\\n\",\n\t\t\theader ? header : \"\", sig->name, sig->email,\n\t\t\t(unsigned)sig->when.time, sign, hours, mins);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "buf"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr",
          "args": [
            "raw_new",
            "GIT_OID_HEXSZ+1",
            "oid_new"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "119-131",
          "snippet": "char *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int serialize_reflog_entry(\n\tgit_buf *buf,\n\tconst git_oid *oid_old,\n\tconst git_oid *oid_new,\n\tconst git_signature *committer,\n\tconst char *msg)\n{\n\tchar raw_old[GIT_OID_HEXSZ+1];\n\tchar raw_new[GIT_OID_HEXSZ+1];\n\n\tgit_oid_tostr(raw_old, GIT_OID_HEXSZ+1, oid_old);\n\tgit_oid_tostr(raw_new, GIT_OID_HEXSZ+1, oid_new);\n\n\tgit_buf_clear(buf);\n\n\tgit_buf_puts(buf, raw_old);\n\tgit_buf_putc(buf, ' ');\n\tgit_buf_puts(buf, raw_new);\n\n\tgit_signature__writebuf(buf, \" \", committer);\n\n\t/* drop trailing LF */\n\tgit_buf_rtrim(buf);\n\n\tif (msg) {\n\t\tgit_buf_putc(buf, '\\t');\n\t\tgit_buf_puts(buf, msg);\n\t}\n\n\tgit_buf_putc(buf, '\\n');\n\n\treturn git_buf_oom(buf);\n}"
  },
  {
    "function_name": "refdb_reflog_fs__read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1588-1631",
    "snippet": "static int refdb_reflog_fs__read(git_reflog **out, git_refdb_backend *_backend, const char *name)\n{\n\tint error = -1;\n\tgit_buf log_path = GIT_BUF_INIT;\n\tgit_buf log_file = GIT_BUF_INIT;\n\tgit_reflog *log = NULL;\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(out && _backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif (reflog_alloc(&log, name) < 0)\n\t\treturn -1;\n\n\tif (retrieve_reflog_path(&log_path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\terror = git_futils_readbuffer(&log_file, git_buf_cstr(&log_path));\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\tif ((error == GIT_ENOTFOUND) &&\n\t\t((error = create_new_reflog_file(git_buf_cstr(&log_path))) < 0))\n\t\tgoto cleanup;\n \n\tif ((error = reflog_parse(log,\n\t\tgit_buf_cstr(&log_file), git_buf_len(&log_file))) < 0)\n\t\tgoto cleanup;\n\n\t*out = log;\n\tgoto success;\n\ncleanup:\n\tgit_reflog_free(log);\n\nsuccess:\n\tgit_buf_free(&log_file);\n\tgit_buf_free(&log_path);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&log_path"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reflog_free",
          "args": [
            "log"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "29-49",
          "snippet": "void git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_free(git_reflog *reflog)\n{\n\tsize_t i;\n\tgit_reflog_entry *entry;\n\n\tif (reflog == NULL)\n\t\treturn;\n\n\tif (reflog->db)\n\t\tGIT_REFCOUNT_DEC(reflog->db, git_refdb__free);\n\n\tfor (i=0; i < reflog->entries.length; i++) {\n\t\tentry = git_vector_get(&reflog->entries, i);\n\n\t\tgit_reflog_entry__free(entry);\n\t}\n\n\tgit_vector_free(&reflog->entries);\n\tgit__free(reflog->ref_name);\n\tgit__free(reflog);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reflog_parse",
          "args": [
            "log",
            "git_buf_cstr(&log_file)",
            "git_buf_len(&log_file)"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "reflog_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1453-1519",
          "snippet": "static int reflog_parse(git_reflog *log, const char *buf, size_t buf_size)\n{\n\tconst char *ptr;\n\tgit_reflog_entry *entry;\n\n#define seek_forward(_increase) do { \\\n\tif (_increase >= buf_size) { \\\n\t\tgiterr_set(GITERR_INVALID, \"Ran out of data while parsing reflog\"); \\\n\t\tgoto fail; \\\n\t} \\\n\tbuf += _increase; \\\n\tbuf_size -= _increase; \\\n\t} while (0)\n\n\twhile (buf_size > GIT_REFLOG_SIZE_MIN) {\n\t\tentry = git__calloc(1, sizeof(git_reflog_entry));\n\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\tentry->committer = git__calloc(1, sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(entry->committer);\n\n\t\tif (git_oid_fromstrn(&entry->oid_old, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tif (git_oid_fromstrn(&entry->oid_cur, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tptr = buf;\n\n\t\t/* Seek forward to the end of the signature. */\n\t\twhile (*buf && *buf != '\\t' && *buf != '\\n')\n\t\t\tseek_forward(1);\n\n\t\tif (git_signature__parse(entry->committer, &ptr, buf + 1, NULL, *buf) < 0)\n\t\t\tgoto fail;\n\n\t\tif (*buf == '\\t') {\n\t\t\t/* We got a message. Read everything till we reach LF. */\n\t\t\tseek_forward(1);\n\t\t\tptr = buf;\n\n\t\t\twhile (*buf && *buf != '\\n')\n\t\t\t\tseek_forward(1);\n\n\t\t\tentry->msg = git__strndup(ptr, buf - ptr);\n\t\t\tGITERR_CHECK_ALLOC(entry->msg);\n\t\t} else\n\t\t\tentry->msg = NULL;\n\n\t\twhile (*buf && *buf == '\\n' && buf_size > 1)\n\t\t\tseek_forward(1);\n\n\t\tif (git_vector_insert(&log->entries, entry) < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n#undef seek_forward\n\nfail:\n\tgit_reflog_entry__free(entry);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\n\nstatic int reflog_parse(git_reflog *log, const char *buf, size_t buf_size)\n{\n\tconst char *ptr;\n\tgit_reflog_entry *entry;\n\n#define seek_forward(_increase) do { \\\n\tif (_increase >= buf_size) { \\\n\t\tgiterr_set(GITERR_INVALID, \"Ran out of data while parsing reflog\"); \\\n\t\tgoto fail; \\\n\t} \\\n\tbuf += _increase; \\\n\tbuf_size -= _increase; \\\n\t} while (0)\n\n\twhile (buf_size > GIT_REFLOG_SIZE_MIN) {\n\t\tentry = git__calloc(1, sizeof(git_reflog_entry));\n\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\tentry->committer = git__calloc(1, sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(entry->committer);\n\n\t\tif (git_oid_fromstrn(&entry->oid_old, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tif (git_oid_fromstrn(&entry->oid_cur, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tptr = buf;\n\n\t\t/* Seek forward to the end of the signature. */\n\t\twhile (*buf && *buf != '\\t' && *buf != '\\n')\n\t\t\tseek_forward(1);\n\n\t\tif (git_signature__parse(entry->committer, &ptr, buf + 1, NULL, *buf) < 0)\n\t\t\tgoto fail;\n\n\t\tif (*buf == '\\t') {\n\t\t\t/* We got a message. Read everything till we reach LF. */\n\t\t\tseek_forward(1);\n\t\t\tptr = buf;\n\n\t\t\twhile (*buf && *buf != '\\n')\n\t\t\t\tseek_forward(1);\n\n\t\t\tentry->msg = git__strndup(ptr, buf - ptr);\n\t\t\tGITERR_CHECK_ALLOC(entry->msg);\n\t\t} else\n\t\t\tentry->msg = NULL;\n\n\t\twhile (*buf && *buf == '\\n' && buf_size > 1)\n\t\t\tseek_forward(1);\n\n\t\tif (git_vector_insert(&log->entries, entry) < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n#undef seek_forward\n\nfail:\n\tgit_reflog_entry__free(entry);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&log_file"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&log_file"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_reflog_file",
          "args": [
            "git_buf_cstr(&log_path)"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_reflog_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1521-1534",
          "snippet": "static int create_new_reflog_file(const char *filepath)\n{\n\tint fd, error;\n\n\tif ((error = git_futils_mkpath2file(filepath, GIT_REFLOG_DIR_MODE)) < 0)\n\t\treturn error;\n\n\tif ((fd = p_open(filepath,\n\t\t\tO_WRONLY | O_CREAT,\n\t\t\tGIT_REFLOG_FILE_MODE)) < 0)\n\t\treturn -1;\n\n\treturn p_close(fd);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int create_new_reflog_file(const char *filepath)\n{\n\tint fd, error;\n\n\tif ((error = git_futils_mkpath2file(filepath, GIT_REFLOG_DIR_MODE)) < 0)\n\t\treturn error;\n\n\tif ((fd = p_open(filepath,\n\t\t\tO_WRONLY | O_CREAT,\n\t\t\tGIT_REFLOG_FILE_MODE)) < 0)\n\t\treturn -1;\n\n\treturn p_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&log_file",
            "git_buf_cstr(&log_path)"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_reflog_path",
          "args": [
            "&log_path",
            "repo",
            "name"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_reflog_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1536-1539",
          "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reflog_alloc",
          "args": [
            "&log",
            "name"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "reflog_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1430-1451",
          "snippet": "static int reflog_alloc(git_reflog **reflog, const char *name)\n{\n\tgit_reflog *log;\n\n\t*reflog = NULL;\n\n\tlog = git__calloc(1, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(log);\n\n\tlog->ref_name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(log->ref_name);\n\n\tif (git_vector_init(&log->entries, 0, NULL) < 0) {\n\t\tgit__free(log->ref_name);\n\t\tgit__free(log);\n\t\treturn -1;\n\t}\n\n\t*reflog = log;\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reflog_alloc(git_reflog **reflog, const char *name)\n{\n\tgit_reflog *log;\n\n\t*reflog = NULL;\n\n\tlog = git__calloc(1, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(log);\n\n\tlog->ref_name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(log->ref_name);\n\n\tif (git_vector_init(&log->entries, 0, NULL) < 0) {\n\t\tgit__free(log->ref_name);\n\t\tgit__free(log);\n\t\treturn -1;\n\t}\n\n\t*reflog = log;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && _backend && name"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_reflog_fs__read(git_reflog **out, git_refdb_backend *_backend, const char *name)\n{\n\tint error = -1;\n\tgit_buf log_path = GIT_BUF_INIT;\n\tgit_buf log_file = GIT_BUF_INIT;\n\tgit_reflog *log = NULL;\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(out && _backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif (reflog_alloc(&log, name) < 0)\n\t\treturn -1;\n\n\tif (retrieve_reflog_path(&log_path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\terror = git_futils_readbuffer(&log_file, git_buf_cstr(&log_path));\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto cleanup;\n\n\tif ((error == GIT_ENOTFOUND) &&\n\t\t((error = create_new_reflog_file(git_buf_cstr(&log_path))) < 0))\n\t\tgoto cleanup;\n \n\tif ((error = reflog_parse(log,\n\t\tgit_buf_cstr(&log_file), git_buf_len(&log_file))) < 0)\n\t\tgoto cleanup;\n\n\t*out = log;\n\tgoto success;\n\ncleanup:\n\tgit_reflog_free(log);\n\nsuccess:\n\tgit_buf_free(&log_file);\n\tgit_buf_free(&log_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "refdb_reflog_fs__has_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1577-1586",
    "snippet": "static int refdb_reflog_fs__has_log(git_refdb_backend *_backend, const char *name)\n{\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\n\treturn has_reflog(backend->repo, name);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "has_reflog",
          "args": [
            "backend->repo",
            "name"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "has_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1562-1575",
          "snippet": "static int has_reflog(git_repository *repo, const char *name)\n{\n\tint ret = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (retrieve_reflog_path(&path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\tret = git_path_isfile(git_buf_cstr(&path));\n\ncleanup:\n\tgit_buf_free(&path);\n\treturn ret;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int has_reflog(git_repository *repo, const char *name)\n{\n\tint ret = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (retrieve_reflog_path(&path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\tret = git_path_isfile(git_buf_cstr(&path));\n\ncleanup:\n\tgit_buf_free(&path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && name"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_reflog_fs__has_log(git_refdb_backend *_backend, const char *name)\n{\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\n\treturn has_reflog(backend->repo, name);\n}"
  },
  {
    "function_name": "has_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1562-1575",
    "snippet": "static int has_reflog(git_repository *repo, const char *name)\n{\n\tint ret = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (retrieve_reflog_path(&path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\tret = git_path_isfile(git_buf_cstr(&path));\n\ncleanup:\n\tgit_buf_free(&path);\n\treturn ret;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "git_buf_cstr(&path)"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_reflog_path",
          "args": [
            "&path",
            "repo",
            "name"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_reflog_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1536-1539",
          "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int has_reflog(git_repository *repo, const char *name)\n{\n\tint ret = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (retrieve_reflog_path(&path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\tret = git_path_isfile(git_buf_cstr(&path));\n\ncleanup:\n\tgit_buf_free(&path);\n\treturn ret;\n}"
  },
  {
    "function_name": "refdb_reflog_fs__ensure_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1541-1560",
    "snippet": "static int refdb_reflog_fs__ensure_log(git_refdb_backend *_backend, const char *name)\n{\n\trefdb_fs_backend *backend;\n\tgit_repository *repo;\n\tgit_buf path = GIT_BUF_INIT;\n\tint error;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif ((error = retrieve_reflog_path(&path, repo, name)) < 0)\n\t\treturn error;\n\n\terror = create_new_reflog_file(git_buf_cstr(&path));\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_new_reflog_file",
          "args": [
            "git_buf_cstr(&path)"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "create_new_reflog_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1521-1534",
          "snippet": "static int create_new_reflog_file(const char *filepath)\n{\n\tint fd, error;\n\n\tif ((error = git_futils_mkpath2file(filepath, GIT_REFLOG_DIR_MODE)) < 0)\n\t\treturn error;\n\n\tif ((fd = p_open(filepath,\n\t\t\tO_WRONLY | O_CREAT,\n\t\t\tGIT_REFLOG_FILE_MODE)) < 0)\n\t\treturn -1;\n\n\treturn p_close(fd);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int create_new_reflog_file(const char *filepath)\n{\n\tint fd, error;\n\n\tif ((error = git_futils_mkpath2file(filepath, GIT_REFLOG_DIR_MODE)) < 0)\n\t\treturn error;\n\n\tif ((fd = p_open(filepath,\n\t\t\tO_WRONLY | O_CREAT,\n\t\t\tGIT_REFLOG_FILE_MODE)) < 0)\n\t\treturn -1;\n\n\treturn p_close(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "retrieve_reflog_path",
          "args": [
            "&path",
            "repo",
            "name"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "retrieve_reflog_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1536-1539",
          "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "_backend && name"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_reflog_fs__ensure_log(git_refdb_backend *_backend, const char *name)\n{\n\trefdb_fs_backend *backend;\n\tgit_repository *repo;\n\tgit_buf path = GIT_BUF_INIT;\n\tint error;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif ((error = retrieve_reflog_path(&path, repo, name)) < 0)\n\t\treturn error;\n\n\terror = create_new_reflog_file(git_buf_cstr(&path));\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "retrieve_reflog_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1536-1539",
    "snippet": "GIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_join3",
          "args": [
            "path",
            "'/'",
            "repo->path_repository",
            "GIT_REFLOG_DIR",
            "name"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "657-716",
          "snippet": "int git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join3(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b,\n\tconst char *str_c)\n{\n\tsize_t len_a = strlen(str_a),\n\t\tlen_b = strlen(str_b),\n\t\tlen_c = strlen(str_c),\n\t\tlen_total;\n\tint sep_a = 0, sep_b = 0;\n\tchar *tgt;\n\n\t/* for this function, disallow pointers into the existing buffer */\n\tassert(str_a < buf->ptr || str_a >= buf->ptr + buf->size);\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\tassert(str_c < buf->ptr || str_c >= buf->ptr + buf->size);\n\n\tif (separator) {\n\t\tif (len_a > 0) {\n\t\t\twhile (*str_b == separator) { str_b++; len_b--; }\n\t\t\tsep_a = (str_a[len_a - 1] != separator);\n\t\t}\n\t\tif (len_a > 0 || len_b > 0)\n\t\t\twhile (*str_c == separator) { str_c++; len_c--; }\n\t\tif (len_b > 0)\n\t\t\tsep_b = (str_b[len_b - 1] != separator);\n\t}\n\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_a, sep_a);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, sep_b);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, len_c);\n\tGITERR_CHECK_ALLOC_ADD(&len_total, len_total, 1);\n\tif (git_buf_grow(buf, len_total) < 0)\n\t\treturn -1;\n\n\ttgt = buf->ptr;\n\n\tif (len_a) {\n\t\tmemcpy(tgt, str_a, len_a);\n\t\ttgt += len_a;\n\t}\n\tif (sep_a)\n\t\t*tgt++ = separator;\n\tif (len_b) {\n\t\tmemcpy(tgt, str_b, len_b);\n\t\ttgt += len_b;\n\t}\n\tif (sep_b)\n\t\t*tgt++ = separator;\n\tif (len_c)\n\t\tmemcpy(tgt, str_c, len_c);\n\n\tbuf->size = len_a + sep_a + len_b + sep_b + len_c;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nGIT_INLINE(int) retrieve_reflog_path(git_buf *path, git_repository *repo, const char *name)\n{\n\treturn git_buf_join3(path, '/', repo->path_repository, GIT_REFLOG_DIR, name);\n}"
  },
  {
    "function_name": "create_new_reflog_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1521-1534",
    "snippet": "static int create_new_reflog_file(const char *filepath)\n{\n\tint fd, error;\n\n\tif ((error = git_futils_mkpath2file(filepath, GIT_REFLOG_DIR_MODE)) < 0)\n\t\treturn error;\n\n\tif ((fd = p_open(filepath,\n\t\t\tO_WRONLY | O_CREAT,\n\t\t\tGIT_REFLOG_FILE_MODE)) < 0)\n\t\treturn -1;\n\n\treturn p_close(fd);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_open",
          "args": [
            "filepath",
            "O_WRONLY | O_CREAT",
            "GIT_REFLOG_FILE_MODE"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "p_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "105-118",
          "snippet": "int p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nint p_open(const char *path, volatile int flags, ...)\n{\n\tmode_t mode = 0;\n\n\tif (flags & O_CREAT) {\n\t\tva_list arg_list;\n\n\t\tva_start(arg_list, flags);\n\t\tmode = (mode_t)va_arg(arg_list, int);\n\t\tva_end(arg_list);\n\t}\n\n\treturn open(path, flags | O_BINARY | O_CLOEXEC, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkpath2file",
          "args": [
            "filepath",
            "GIT_REFLOG_DIR_MODE"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkpath2file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "16-23",
          "snippet": "GIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nGIT__USE_STRMAP\n\nint git_futils_mkpath2file(const char *file_path, const mode_t mode)\n{\n\treturn git_futils_mkdir(\n\t\tfile_path, mode,\n\t\tGIT_MKDIR_PATH | GIT_MKDIR_SKIP_LAST | GIT_MKDIR_VERIFY_DIR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int create_new_reflog_file(const char *filepath)\n{\n\tint fd, error;\n\n\tif ((error = git_futils_mkpath2file(filepath, GIT_REFLOG_DIR_MODE)) < 0)\n\t\treturn error;\n\n\tif ((fd = p_open(filepath,\n\t\t\tO_WRONLY | O_CREAT,\n\t\t\tGIT_REFLOG_FILE_MODE)) < 0)\n\t\treturn -1;\n\n\treturn p_close(fd);\n}"
  },
  {
    "function_name": "reflog_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1453-1519",
    "snippet": "static int reflog_parse(git_reflog *log, const char *buf, size_t buf_size)\n{\n\tconst char *ptr;\n\tgit_reflog_entry *entry;\n\n#define seek_forward(_increase) do { \\\n\tif (_increase >= buf_size) { \\\n\t\tgiterr_set(GITERR_INVALID, \"Ran out of data while parsing reflog\"); \\\n\t\tgoto fail; \\\n\t} \\\n\tbuf += _increase; \\\n\tbuf_size -= _increase; \\\n\t} while (0)\n\n\twhile (buf_size > GIT_REFLOG_SIZE_MIN) {\n\t\tentry = git__calloc(1, sizeof(git_reflog_entry));\n\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\tentry->committer = git__calloc(1, sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(entry->committer);\n\n\t\tif (git_oid_fromstrn(&entry->oid_old, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tif (git_oid_fromstrn(&entry->oid_cur, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tptr = buf;\n\n\t\t/* Seek forward to the end of the signature. */\n\t\twhile (*buf && *buf != '\\t' && *buf != '\\n')\n\t\t\tseek_forward(1);\n\n\t\tif (git_signature__parse(entry->committer, &ptr, buf + 1, NULL, *buf) < 0)\n\t\t\tgoto fail;\n\n\t\tif (*buf == '\\t') {\n\t\t\t/* We got a message. Read everything till we reach LF. */\n\t\t\tseek_forward(1);\n\t\t\tptr = buf;\n\n\t\t\twhile (*buf && *buf != '\\n')\n\t\t\t\tseek_forward(1);\n\n\t\t\tentry->msg = git__strndup(ptr, buf - ptr);\n\t\t\tGITERR_CHECK_ALLOC(entry->msg);\n\t\t} else\n\t\t\tentry->msg = NULL;\n\n\t\twhile (*buf && *buf == '\\n' && buf_size > 1)\n\t\t\tseek_forward(1);\n\n\t\tif (git_vector_insert(&log->entries, entry) < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n#undef seek_forward\n\nfail:\n\tgit_reflog_entry__free(entry);\n\n\treturn -1;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reflog_entry__free",
          "args": [
            "entry"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "git_reflog_entry__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/reflog.c",
          "lines": "21-27",
          "snippet": "void git_reflog_entry__free(git_reflog_entry *entry)\n{\n\tgit_signature_free(entry->committer);\n\n\tgit__free(entry->msg);\n\tgit__free(entry);\n}",
          "includes": [
            "#include <git2/sys/refdb_backend.h>",
            "#include \"refdb.h\"",
            "#include \"signature.h\"",
            "#include \"filebuf.h\"",
            "#include \"repository.h\"",
            "#include \"reflog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/refdb_backend.h>\n#include \"refdb.h\"\n#include \"signature.h\"\n#include \"filebuf.h\"\n#include \"repository.h\"\n#include \"reflog.h\"\n\nvoid git_reflog_entry__free(git_reflog_entry *entry)\n{\n\tgit_signature_free(entry->committer);\n\n\tgit__free(entry->msg);\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&log->entries",
            "entry"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "1"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry->msg"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strndup",
          "args": [
            "ptr",
            "buf - ptr"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "git__strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "181-198",
          "snippet": "GIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strndup(const char *str, size_t n)\n{\n\tsize_t length = 0, alloclength;\n\tchar *ptr;\n\n\tlength = p_strnlen(str, n);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclength, length, 1) ||\n\t\t!(ptr = git__malloc(alloclength)))\n\t\treturn NULL;\n\n\tif (length)\n\t\tmemcpy(ptr, str, length);\n\n\tptr[length] = '\\0';\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "1"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "1"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_signature__parse",
          "args": [
            "entry->committer",
            "&ptr",
            "buf + 1",
            "NULL",
            "*buf"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "git_signature__parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/signature.c",
          "lines": "195-263",
          "snippet": "int git_signature__parse(git_signature *sig, const char **buffer_out,\n\t\tconst char *buffer_end, const char *header, char ender)\n{\n\tconst char *buffer = *buffer_out;\n\tconst char *email_start, *email_end;\n\n\tmemset(sig, 0, sizeof(git_signature));\n\n\tif ((buffer_end = memchr(buffer, ender, buffer_end - buffer)) == NULL)\n\t\treturn signature_error(\"no newline given\");\n\n\tif (header) {\n\t\tconst size_t header_len = strlen(header);\n\n\t\tif (buffer + header_len >= buffer_end || memcmp(buffer, header, header_len) != 0)\n\t\t\treturn signature_error(\"expected prefix doesn't match actual\");\n\n\t\tbuffer += header_len;\n\t}\n\n\temail_start = git__memrchr(buffer, '<', buffer_end - buffer);\n\temail_end = git__memrchr(buffer, '>', buffer_end - buffer);\n\n\tif (!email_start || !email_end || email_end <= email_start)\n\t\treturn signature_error(\"malformed e-mail\");\n\n\temail_start += 1;\n\tsig->name = extract_trimmed(buffer, email_start - buffer - 1);\n\tsig->email = extract_trimmed(email_start, email_end - email_start);\n\n\t/* Do we even have a time at the end of the signature? */\n\tif (email_end + 2 < buffer_end) {\n\t\tconst char *time_start = email_end + 2;\n\t\tconst char *time_end;\n\n\t\tif (git__strtol64(&sig->when.time, time_start, &time_end, 10) < 0)\n\t\t\treturn signature_error(\"invalid Unix timestamp\");\n\n\t\t/* do we have a timezone? */\n\t\tif (time_end + 1 < buffer_end) {\n\t\t\tint offset, hours, mins;\n\t\t\tconst char *tz_start, *tz_end;\n\n\t\t\ttz_start = time_end + 1;\n\n\t\t\tif ((tz_start[0] != '-' && tz_start[0] != '+') ||\n\t\t\t\tgit__strtol32(&offset, tz_start + 1, &tz_end, 10) < 0) {\n\t\t\t\t//malformed timezone, just assume it's zero\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\thours = offset / 100;\n\t\t\tmins = offset % 100;\n\n\t\t\t/*\n\t\t\t * only store timezone if it's not overflowing;\n\t\t\t * see http://www.worldtimezone.com/faq.html\n\t\t\t */\n\t\t\tif (hours < 14 && mins < 59) {\n\t\t\t\tsig->when.offset = (hours * 60) + mins;\n\t\t\t\tif (tz_start[0] == '-')\n\t\t\t\t\tsig->when.offset = -sig->when.offset;\n\t\t\t}\n\t\t}\n\t}\n\n\t*buffer_out = buffer_end + 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"posix.h\"",
            "#include \"git2/common.h\"",
            "#include \"repository.h\"",
            "#include \"signature.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix.h\"\n#include \"git2/common.h\"\n#include \"repository.h\"\n#include \"signature.h\"\n#include \"common.h\"\n\nint git_signature__parse(git_signature *sig, const char **buffer_out,\n\t\tconst char *buffer_end, const char *header, char ender)\n{\n\tconst char *buffer = *buffer_out;\n\tconst char *email_start, *email_end;\n\n\tmemset(sig, 0, sizeof(git_signature));\n\n\tif ((buffer_end = memchr(buffer, ender, buffer_end - buffer)) == NULL)\n\t\treturn signature_error(\"no newline given\");\n\n\tif (header) {\n\t\tconst size_t header_len = strlen(header);\n\n\t\tif (buffer + header_len >= buffer_end || memcmp(buffer, header, header_len) != 0)\n\t\t\treturn signature_error(\"expected prefix doesn't match actual\");\n\n\t\tbuffer += header_len;\n\t}\n\n\temail_start = git__memrchr(buffer, '<', buffer_end - buffer);\n\temail_end = git__memrchr(buffer, '>', buffer_end - buffer);\n\n\tif (!email_start || !email_end || email_end <= email_start)\n\t\treturn signature_error(\"malformed e-mail\");\n\n\temail_start += 1;\n\tsig->name = extract_trimmed(buffer, email_start - buffer - 1);\n\tsig->email = extract_trimmed(email_start, email_end - email_start);\n\n\t/* Do we even have a time at the end of the signature? */\n\tif (email_end + 2 < buffer_end) {\n\t\tconst char *time_start = email_end + 2;\n\t\tconst char *time_end;\n\n\t\tif (git__strtol64(&sig->when.time, time_start, &time_end, 10) < 0)\n\t\t\treturn signature_error(\"invalid Unix timestamp\");\n\n\t\t/* do we have a timezone? */\n\t\tif (time_end + 1 < buffer_end) {\n\t\t\tint offset, hours, mins;\n\t\t\tconst char *tz_start, *tz_end;\n\n\t\t\ttz_start = time_end + 1;\n\n\t\t\tif ((tz_start[0] != '-' && tz_start[0] != '+') ||\n\t\t\t\tgit__strtol32(&offset, tz_start + 1, &tz_end, 10) < 0) {\n\t\t\t\t//malformed timezone, just assume it's zero\n\t\t\t\toffset = 0;\n\t\t\t}\n\n\t\t\thours = offset / 100;\n\t\t\tmins = offset % 100;\n\n\t\t\t/*\n\t\t\t * only store timezone if it's not overflowing;\n\t\t\t * see http://www.worldtimezone.com/faq.html\n\t\t\t */\n\t\t\tif (hours < 14 && mins < 59) {\n\t\t\t\tsig->when.offset = (hours * 60) + mins;\n\t\t\t\tif (tz_start[0] == '-')\n\t\t\t\t\tsig->when.offset = -sig->when.offset;\n\t\t\t}\n\t\t}\n\t}\n\n\t*buffer_out = buffer_end + 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "1"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "GIT_OID_HEXSZ + 1"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_fromstrn",
          "args": [
            "&entry->oid_cur",
            "buf",
            "GIT_OID_HEXSZ"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstrn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "23-47",
          "snippet": "int git_oid_fromstrn(git_oid *out, const char *str, size_t length)\n{\n\tsize_t p;\n\tint v;\n\n\tassert(out && str);\n\n\tif (!length)\n\t\treturn oid_error_invalid(\"too short\");\n\n\tif (length > GIT_OID_HEXSZ)\n\t\treturn oid_error_invalid(\"too long\");\n\n\tmemset(out->id, 0, GIT_OID_RAWSZ);\n\n\tfor (p = 0; p < length; p++) {\n\t\tv = git__fromhex(str[p]);\n\t\tif (v < 0)\n\t\t\treturn oid_error_invalid(\"contains invalid characters\");\n\n\t\tout->id[p / 2] |= (unsigned char)(v << (p % 2 ? 0 : 4));\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstrn(git_oid *out, const char *str, size_t length)\n{\n\tsize_t p;\n\tint v;\n\n\tassert(out && str);\n\n\tif (!length)\n\t\treturn oid_error_invalid(\"too short\");\n\n\tif (length > GIT_OID_HEXSZ)\n\t\treturn oid_error_invalid(\"too long\");\n\n\tmemset(out->id, 0, GIT_OID_RAWSZ);\n\n\tfor (p = 0; p < length; p++) {\n\t\tv = git__fromhex(str[p]);\n\t\tif (v < 0)\n\t\t\treturn oid_error_invalid(\"contains invalid characters\");\n\n\t\tout->id[p / 2] |= (unsigned char)(v << (p % 2 ? 0 : 4));\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seek_forward",
          "args": [
            "GIT_OID_HEXSZ + 1"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry->committer"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_signature)"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\n\nstatic int reflog_parse(git_reflog *log, const char *buf, size_t buf_size)\n{\n\tconst char *ptr;\n\tgit_reflog_entry *entry;\n\n#define seek_forward(_increase) do { \\\n\tif (_increase >= buf_size) { \\\n\t\tgiterr_set(GITERR_INVALID, \"Ran out of data while parsing reflog\"); \\\n\t\tgoto fail; \\\n\t} \\\n\tbuf += _increase; \\\n\tbuf_size -= _increase; \\\n\t} while (0)\n\n\twhile (buf_size > GIT_REFLOG_SIZE_MIN) {\n\t\tentry = git__calloc(1, sizeof(git_reflog_entry));\n\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\tentry->committer = git__calloc(1, sizeof(git_signature));\n\t\tGITERR_CHECK_ALLOC(entry->committer);\n\n\t\tif (git_oid_fromstrn(&entry->oid_old, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tif (git_oid_fromstrn(&entry->oid_cur, buf, GIT_OID_HEXSZ) < 0)\n\t\t\tgoto fail;\n\t\tseek_forward(GIT_OID_HEXSZ + 1);\n\n\t\tptr = buf;\n\n\t\t/* Seek forward to the end of the signature. */\n\t\twhile (*buf && *buf != '\\t' && *buf != '\\n')\n\t\t\tseek_forward(1);\n\n\t\tif (git_signature__parse(entry->committer, &ptr, buf + 1, NULL, *buf) < 0)\n\t\t\tgoto fail;\n\n\t\tif (*buf == '\\t') {\n\t\t\t/* We got a message. Read everything till we reach LF. */\n\t\t\tseek_forward(1);\n\t\t\tptr = buf;\n\n\t\t\twhile (*buf && *buf != '\\n')\n\t\t\t\tseek_forward(1);\n\n\t\t\tentry->msg = git__strndup(ptr, buf - ptr);\n\t\t\tGITERR_CHECK_ALLOC(entry->msg);\n\t\t} else\n\t\t\tentry->msg = NULL;\n\n\t\twhile (*buf && *buf == '\\n' && buf_size > 1)\n\t\t\tseek_forward(1);\n\n\t\tif (git_vector_insert(&log->entries, entry) < 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n#undef seek_forward\n\nfail:\n\tgit_reflog_entry__free(entry);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "reflog_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1430-1451",
    "snippet": "static int reflog_alloc(git_reflog **reflog, const char *name)\n{\n\tgit_reflog *log;\n\n\t*reflog = NULL;\n\n\tlog = git__calloc(1, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(log);\n\n\tlog->ref_name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(log->ref_name);\n\n\tif (git_vector_init(&log->entries, 0, NULL) < 0) {\n\t\tgit__free(log->ref_name);\n\t\tgit__free(log);\n\t\treturn -1;\n\t}\n\n\t*reflog = log;\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "log"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&log->entries",
            "0",
            "NULL"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "log->ref_name"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "name"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "log"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_reflog)"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reflog_alloc(git_reflog **reflog, const char *name)\n{\n\tgit_reflog *log;\n\n\t*reflog = NULL;\n\n\tlog = git__calloc(1, sizeof(git_reflog));\n\tGITERR_CHECK_ALLOC(log);\n\n\tlog->ref_name = git__strdup(name);\n\tGITERR_CHECK_ALLOC(log->ref_name);\n\n\tif (git_vector_init(&log->entries, 0, NULL) < 0) {\n\t\tgit__free(log->ref_name);\n\t\tgit__free(log);\n\t\treturn -1;\n\t}\n\n\t*reflog = log;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1388-1428",
    "snippet": "static int setup_namespace(git_buf *path, git_repository *repo)\n{\n\tchar *parts, *start, *end;\n\n\t/* Not all repositories have a path */\n\tif (repo->path_repository == NULL)\n\t\treturn 0;\n\n\t/* Load the path to the repo first */\n\tgit_buf_puts(path, repo->path_repository);\n\n\t/* if the repo is not namespaced, nothing else to do */\n\tif (repo->namespace == NULL)\n\t\treturn 0;\n\n\tparts = end = git__strdup(repo->namespace);\n\tif (parts == NULL)\n\t\treturn -1;\n\n\t/*\n\t * From `man gitnamespaces`:\n\t *  namespaces which include a / will expand to a hierarchy\n\t *  of namespaces; for example, GIT_NAMESPACE=foo/bar will store\n\t *  refs under refs/namespaces/foo/refs/namespaces/bar/\n\t */\n\twhile ((start = git__strsep(&end, \"/\")) != NULL) {\n\t\tgit_buf_printf(path, \"refs/namespaces/%s/\", start);\n\t}\n\n\tgit_buf_printf(path, \"refs/namespaces/%s/refs\", end);\n\tgit__free(parts);\n\n\t/* Make sure that the folder with the namespace exists */\n\tif (git_futils_mkdir_relative(git_buf_cstr(path), repo->path_repository,\n\t\t\t0777, GIT_MKDIR_PATH, NULL) < 0)\n\t\treturn -1;\n\n\t/* Return root of the namespaced path, i.e. without the trailing '/refs' */\n\tgit_buf_rtruncate_at_char(path, '/');\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_rtruncate_at_char",
          "args": [
            "path",
            "'/'"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtruncate_at_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "464-468",
          "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_mkdir_relative",
          "args": [
            "git_buf_cstr(path)",
            "repo->path_repository",
            "0777",
            "GIT_MKDIR_PATH",
            "NULL"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_mkdir_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "498-625",
          "snippet": "int git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_mkdir_relative(\n\tconst char *relative_path,\n\tconst char *base,\n\tmode_t mode,\n\tuint32_t flags,\n\tstruct git_futils_mkdir_options *opts)\n{\n\tgit_buf make_path = GIT_BUF_INIT;\n\tssize_t root = 0, min_root_len;\n\tchar lastch = '/', *tail;\n\tstruct stat st;\n\tstruct git_futils_mkdir_options empty_opts = {0};\n\tint error;\n\n\tif (!opts)\n\t\topts = &empty_opts;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&make_path, relative_path, base, &root) < 0)\n\t\treturn -1;\n\n\tif ((error = mkdir_canonicalize(&make_path, flags)) < 0 ||\n\t\tmake_path.size == 0)\n\t\tgoto done;\n\n\t/* if we are not supposed to make the whole path, reset root */\n\tif ((flags & GIT_MKDIR_PATH) == 0)\n\t\troot = git_buf_rfind(&make_path, '/');\n\n\t/* advance root past drive name or network mount prefix */\n\tmin_root_len = git_path_root(make_path.ptr);\n\tif (root < min_root_len)\n\t\troot = min_root_len;\n\twhile (root >= 0 && make_path.ptr[root] == '/')\n\t\t++root;\n\n\t/* clip root to make_path length */\n\tif (root > (ssize_t)make_path.size)\n\t\troot = (ssize_t)make_path.size; /* i.e. NUL byte of string */\n\tif (root < 0)\n\t\troot = 0;\n\n\t/* walk down tail of path making each directory */\n\tfor (tail = &make_path.ptr[root]; *tail; *tail = lastch) {\n\t\tbool mkdir_attempted = false;\n\n\t\t/* advance tail to include next path component */\n\t\twhile (*tail == '/')\n\t\t\ttail++;\n\t\twhile (*tail && *tail != '/')\n\t\t\ttail++;\n\n\t\t/* truncate path at next component */\n\t\tlastch = *tail;\n\t\t*tail = '\\0';\n\t\tst.st_mode = 0;\n\n\t\tif (opts->dir_map && git_strmap_exists(opts->dir_map, make_path.ptr))\n\t\t\tcontinue;\n\n\t\t/* See what's going on with this path component */\n\t\topts->perfdata.stat_calls++;\n\nretry_lstat:\n\t\tif (p_lstat(make_path.ptr, &st) < 0) {\n\t\t\tif (mkdir_attempted || errno != ENOENT) {\n\t\t\t\tgiterr_set(GITERR_OS, \"Cannot access component in path '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tgiterr_clear();\n\t\t\topts->perfdata.mkdir_calls++;\n\t\t\tmkdir_attempted = true;\n\t\t\tif (p_mkdir(make_path.ptr, mode) < 0) {\n\t\t\t\tif (errno == EEXIST)\n\t\t\t\t\tgoto retry_lstat;\n\t\t\t\tgiterr_set(GITERR_OS, \"Failed to make directory '%s'\", make_path.ptr);\n\t\t\t\terror = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((error = mkdir_validate_dir(\n\t\t\t\tmake_path.ptr, &st, mode, flags, opts)) < 0)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\t/* chmod if requested and necessary */\n\t\tif ((error = mkdir_validate_mode(\n\t\t\tmake_path.ptr, &st, (lastch == '\\0'), mode, flags, opts)) < 0)\n\t\t\tgoto done;\n\n\t\tif (opts->dir_map && opts->pool) {\n\t\t\tchar *cache_path;\n\t\t\tsize_t alloc_size;\n\n\t\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, make_path.size, 1);\n\t\t\tif (!git__is_uint32(alloc_size))\n\t\t\t\treturn -1;\n\t\t\tcache_path = git_pool_malloc(opts->pool, (uint32_t)alloc_size);\n\t\t\tGITERR_CHECK_ALLOC(cache_path);\n\n\t\t\tmemcpy(cache_path, make_path.ptr, make_path.size + 1);\n\n\t\t\tgit_strmap_insert(opts->dir_map, cache_path, cache_path, error);\n\t\t\tif (error < 0)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\terror = 0;\n\n\t/* check that full path really is a directory if requested & needed */\n\tif ((flags & GIT_MKDIR_VERIFY_DIR) != 0 &&\n\t\tlastch != '\\0') {\n\t\topts->perfdata.stat_calls++;\n\n\t\tif (p_stat(make_path.ptr, &st) < 0 || !S_ISDIR(st.st_mode)) {\n\t\t\tgiterr_set(GITERR_OS, \"Path is not a directory '%s'\",\n\t\t\t\tmake_path.ptr);\n\t\t\terror = GIT_ENOTFOUND;\n\t\t}\n\t}\n\ndone:\n\tgit_buf_free(&make_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "path"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "parts"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "path",
            "\"refs/namespaces/%s/refs\"",
            "end"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strsep",
          "args": [
            "&end",
            "\"/\""
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "git__strsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "307-322",
          "snippet": "char *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nchar *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "repo->namespace"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "path",
            "repo->path_repository"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int setup_namespace(git_buf *path, git_repository *repo)\n{\n\tchar *parts, *start, *end;\n\n\t/* Not all repositories have a path */\n\tif (repo->path_repository == NULL)\n\t\treturn 0;\n\n\t/* Load the path to the repo first */\n\tgit_buf_puts(path, repo->path_repository);\n\n\t/* if the repo is not namespaced, nothing else to do */\n\tif (repo->namespace == NULL)\n\t\treturn 0;\n\n\tparts = end = git__strdup(repo->namespace);\n\tif (parts == NULL)\n\t\treturn -1;\n\n\t/*\n\t * From `man gitnamespaces`:\n\t *  namespaces which include a / will expand to a hierarchy\n\t *  of namespaces; for example, GIT_NAMESPACE=foo/bar will store\n\t *  refs under refs/namespaces/foo/refs/namespaces/bar/\n\t */\n\twhile ((start = git__strsep(&end, \"/\")) != NULL) {\n\t\tgit_buf_printf(path, \"refs/namespaces/%s/\", start);\n\t}\n\n\tgit_buf_printf(path, \"refs/namespaces/%s/refs\", end);\n\tgit__free(parts);\n\n\t/* Make sure that the folder with the namespace exists */\n\tif (git_futils_mkdir_relative(git_buf_cstr(path), repo->path_repository,\n\t\t\t0777, GIT_MKDIR_PATH, NULL) < 0)\n\t\treturn -1;\n\n\t/* Return root of the namespaced path, i.e. without the trailing '/refs' */\n\tgit_buf_rtruncate_at_char(path, '/');\n\treturn 0;\n}"
  },
  {
    "function_name": "refdb_fs_backend__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1377-1386",
    "snippet": "static void refdb_fs_backend__free(git_refdb_backend *_backend)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\n\tassert(backend);\n\n\tgit_sortedcache_free(backend->refcache);\n\tgit__free(backend->path);\n\tgit__free(backend);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "backend"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_free",
          "args": [
            "backend->refcache"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "96-101",
          "snippet": "void git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic void refdb_fs_backend__free(git_refdb_backend *_backend)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\n\tassert(backend);\n\n\tgit_sortedcache_free(backend->refcache);\n\tgit__free(backend->path);\n\tgit__free(backend);\n}"
  },
  {
    "function_name": "refdb_fs_backend__compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1363-1375",
    "snippet": "static int refdb_fs_backend__compress(git_refdb_backend *_backend)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0 || /* load the existing packfile */\n\t\tpacked_loadloose(backend) < 0 || /* add all the loose refs */\n\t\tpacked_write(backend) < 0) /* write back to disk */\n\t\treturn -1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packed_write",
          "args": [
            "backend"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "packed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "943-995",
          "snippet": "static int packed_write(refdb_fs_backend *backend)\n{\n\tgit_sortedcache *refcache = backend->refcache;\n\tgit_filebuf pack_file = GIT_FILEBUF_INIT;\n\tsize_t i;\n\n\t/* lock the cache to updates while we do this */\n\tif (git_sortedcache_wlock(refcache) < 0)\n\t\treturn -1;\n\n\t/* Open the file! */\n\tif (git_filebuf_open(&pack_file, git_sortedcache_path(refcache), 0, GIT_PACKEDREFS_FILE_MODE) < 0)\n\t\tgoto fail;\n\n\t/* Packfiles have a header... apparently\n\t * This is in fact not required, but we might as well print it\n\t * just for kicks */\n\tif (git_filebuf_printf(&pack_file, \"%s\\n\", GIT_PACKEDREFS_HEADER) < 0)\n\t\tgoto fail;\n\n\tfor (i = 0; i < git_sortedcache_entrycount(refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(refcache, i);\n\t\tassert(ref);\n\n\t\tif (packed_find_peel(backend, ref) < 0)\n\t\t\tgoto fail;\n\n\t\tif (packed_write_ref(ref, &pack_file) < 0)\n\t\t\tgoto fail;\n\t}\n\n\t/* if we've written all the references properly, we can commit\n\t * the packfile to make the changes effective */\n\tif (git_filebuf_commit(&pack_file) < 0)\n\t\tgoto fail;\n\n\t/* when and only when the packfile has been properly written,\n\t * we can go ahead and remove the loose refs */\n\tif (packed_remove_loose(backend) < 0)\n\t\tgoto fail;\n\n\tgit_sortedcache_updated(refcache);\n\tgit_sortedcache_wunlock(refcache);\n\n\t/* we're good now */\n\treturn 0;\n\nfail:\n\tgit_filebuf_cleanup(&pack_file);\n\tgit_sortedcache_wunlock(refcache);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_write(refdb_fs_backend *backend)\n{\n\tgit_sortedcache *refcache = backend->refcache;\n\tgit_filebuf pack_file = GIT_FILEBUF_INIT;\n\tsize_t i;\n\n\t/* lock the cache to updates while we do this */\n\tif (git_sortedcache_wlock(refcache) < 0)\n\t\treturn -1;\n\n\t/* Open the file! */\n\tif (git_filebuf_open(&pack_file, git_sortedcache_path(refcache), 0, GIT_PACKEDREFS_FILE_MODE) < 0)\n\t\tgoto fail;\n\n\t/* Packfiles have a header... apparently\n\t * This is in fact not required, but we might as well print it\n\t * just for kicks */\n\tif (git_filebuf_printf(&pack_file, \"%s\\n\", GIT_PACKEDREFS_HEADER) < 0)\n\t\tgoto fail;\n\n\tfor (i = 0; i < git_sortedcache_entrycount(refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(refcache, i);\n\t\tassert(ref);\n\n\t\tif (packed_find_peel(backend, ref) < 0)\n\t\t\tgoto fail;\n\n\t\tif (packed_write_ref(ref, &pack_file) < 0)\n\t\t\tgoto fail;\n\t}\n\n\t/* if we've written all the references properly, we can commit\n\t * the packfile to make the changes effective */\n\tif (git_filebuf_commit(&pack_file) < 0)\n\t\tgoto fail;\n\n\t/* when and only when the packfile has been properly written,\n\t * we can go ahead and remove the loose refs */\n\tif (packed_remove_loose(backend) < 0)\n\t\tgoto fail;\n\n\tgit_sortedcache_updated(refcache);\n\tgit_sortedcache_wunlock(refcache);\n\n\t/* we're good now */\n\treturn 0;\n\nfail:\n\tgit_filebuf_cleanup(&pack_file);\n\tgit_sortedcache_wunlock(refcache);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_loadloose",
          "args": [
            "backend"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "packed_loadloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "301-320",
          "snippet": "static int packed_loadloose(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf refs_path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&refs_path, backend->path, GIT_REFS_DIR) < 0)\n\t\treturn -1;\n\n\t/*\n\t * Load all the loose files from disk into the Packfile table.\n\t * This will overwrite any old packed entries with their\n\t * updated loose versions\n\t */\n\terror = git_path_direach(\n\t\t&refs_path, backend->direach_flags, _dirent_loose_load, backend);\n\n\tgit_buf_free(&refs_path);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_loadloose(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf refs_path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&refs_path, backend->path, GIT_REFS_DIR) < 0)\n\t\treturn -1;\n\n\t/*\n\t * Load all the loose files from disk into the Packfile table.\n\t * This will overwrite any old packed entries with their\n\t * updated loose versions\n\t */\n\terror = git_path_direach(\n\t\t&refs_path, backend->direach_flags, _dirent_loose_load, backend);\n\n\tgit_buf_free(&refs_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_reload",
          "args": [
            "backend"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "packed_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "74-195",
          "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__compress(git_refdb_backend *_backend)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0 || /* load the existing packfile */\n\t\tpacked_loadloose(backend) < 0 || /* add all the loose refs */\n\t\tpacked_write(backend) < 0) /* write back to disk */\n\t\treturn -1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "refdb_fs_backend__rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1301-1361",
    "snippet": "static int refdb_fs_backend__rename(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *old_name,\n\tconst char *new_name,\n\tint force,\n\tconst git_signature *who,\n\tconst char *message)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_reference *old, *new;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error;\n\n\tassert(backend);\n\n\tif ((error = reference_path_available(\n\t\t\tbackend, new_name, old_name, force)) < 0 ||\n\t\t(error = refdb_fs_backend__lookup(&old, _backend, old_name)) < 0)\n\t\treturn error;\n\n\tif ((error = refdb_fs_backend__delete(_backend, old_name, NULL, NULL)) < 0) {\n\t\tgit_reference_free(old);\n\t\treturn error;\n\t}\n\n\tnew = git_reference__set_name(old, new_name);\n\tif (!new) {\n\t\tgit_reference_free(old);\n\t\treturn -1;\n\t}\n\n\tif ((error = loose_lock(&file, backend, new->name)) < 0) {\n\t\tgit_reference_free(new);\n\t\treturn error;\n\t}\n\n\t/* Try to rename the refog; it's ok if the old doesn't exist */\n\terror = refdb_reflog_fs__rename(_backend, old_name, new_name);\n\tif (((error == 0) || (error == GIT_ENOTFOUND)) &&\n\t    ((error = reflog_append(backend, new, git_reference_target(new), NULL, who, message)) < 0)) {\n\t\tgit_reference_free(new);\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\tif (error < 0) {\n\t\tgit_reference_free(new);\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\n\tif ((error = loose_commit(&file, new)) < 0 || out == NULL) {\n\t\tgit_reference_free(new);\n\t\treturn error;\n\t}\n\n\t*out = new;\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
      "static int has_reflog(git_repository *repo, const char *name);",
      "static int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "new"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_commit",
          "args": [
            "&file",
            "new"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "loose_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "743-759",
          "snippet": "static int loose_commit(git_filebuf *file, const git_reference *ref)\n{\n\tassert(file && ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tchar oid[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(oid, sizeof(oid), &ref->target.oid);\n\n\t\tgit_filebuf_printf(file, \"%s\\n\", oid);\n\t} else if (ref->type == GIT_REF_SYMBOLIC) {\n\t\tgit_filebuf_printf(file, GIT_SYMREF \"%s\\n\", ref->target.symbolic);\n\t} else {\n\t\tassert(0); /* don't let this happen */\n\t}\n\n\treturn git_filebuf_commit(file);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_commit(git_filebuf *file, const git_reference *ref)\n{\n\tassert(file && ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tchar oid[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(oid, sizeof(oid), &ref->target.oid);\n\n\t\tgit_filebuf_printf(file, \"%s\\n\", oid);\n\t} else if (ref->type == GIT_REF_SYMBOLIC) {\n\t\tgit_filebuf_printf(file, GIT_SYMREF \"%s\\n\", ref->target.symbolic);\n\t} else {\n\t\tassert(0); /* don't let this happen */\n\t}\n\n\treturn git_filebuf_commit(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reflog_append",
          "args": [
            "backend",
            "new",
            "git_reference_target(new)",
            "NULL",
            "who",
            "message"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "reflog_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1735-1811",
          "snippet": "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "new"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_reflog_fs__rename",
          "args": [
            "_backend",
            "old_name",
            "new_name"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_reflog_fs__rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1813-1892",
          "snippet": "static int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name)\n{\n\tint error = 0, fd;\n\tgit_buf old_path = GIT_BUF_INIT;\n\tgit_buf new_path = GIT_BUF_INIT;\n\tgit_buf temp_path = GIT_BUF_INIT;\n\tgit_buf normalized = GIT_BUF_INIT;\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && old_name && new_name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif ((error = git_reference__normalize_name(\n\t\t&normalized, new_name, GIT_REF_FORMAT_ALLOW_ONELEVEL)) < 0)\n\t\t\treturn error;\n\n\tif (git_buf_joinpath(&temp_path, repo->path_repository, GIT_REFLOG_DIR) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&old_path, git_buf_cstr(&temp_path), old_name) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&new_path, git_buf_cstr(&temp_path), git_buf_cstr(&normalized)) < 0)\n\t\treturn -1;\n\n\tif (!git_path_exists(git_buf_cstr(&old_path))) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Move the reflog to a temporary place. This two-phase renaming is required\n\t * in order to cope with funny renaming use cases when one tries to move a reference\n\t * to a partially colliding namespace:\n\t *  - a/b -> a/b/c\n\t *  - a/b/c/d -> a/b/c\n\t */\n\tif (git_buf_joinpath(&temp_path, git_buf_cstr(&temp_path), \"temp_reflog\") < 0)\n\t\treturn -1;\n\n\tif ((fd = git_futils_mktmp(&temp_path, git_buf_cstr(&temp_path), GIT_REFLOG_FILE_MODE)) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tp_close(fd);\n\n\tif (p_rename(git_buf_cstr(&old_path), git_buf_cstr(&temp_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_path_isdir(git_buf_cstr(&new_path)) && \n\t\t(git_futils_rmdir_r(git_buf_cstr(&new_path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_futils_mkpath2file(git_buf_cstr(&new_path), GIT_REFLOG_DIR_MODE) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (p_rename(git_buf_cstr(&temp_path), git_buf_cstr(&new_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_buf_free(&temp_path);\n\tgit_buf_free(&old_path);\n\tgit_buf_free(&new_path);\n\tgit_buf_free(&normalized);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name);\n\nstatic int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name)\n{\n\tint error = 0, fd;\n\tgit_buf old_path = GIT_BUF_INIT;\n\tgit_buf new_path = GIT_BUF_INIT;\n\tgit_buf temp_path = GIT_BUF_INIT;\n\tgit_buf normalized = GIT_BUF_INIT;\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && old_name && new_name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\tif ((error = git_reference__normalize_name(\n\t\t&normalized, new_name, GIT_REF_FORMAT_ALLOW_ONELEVEL)) < 0)\n\t\t\treturn error;\n\n\tif (git_buf_joinpath(&temp_path, repo->path_repository, GIT_REFLOG_DIR) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&old_path, git_buf_cstr(&temp_path), old_name) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&new_path, git_buf_cstr(&temp_path), git_buf_cstr(&normalized)) < 0)\n\t\treturn -1;\n\n\tif (!git_path_exists(git_buf_cstr(&old_path))) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto cleanup;\n\t}\n\n\t/*\n\t * Move the reflog to a temporary place. This two-phase renaming is required\n\t * in order to cope with funny renaming use cases when one tries to move a reference\n\t * to a partially colliding namespace:\n\t *  - a/b -> a/b/c\n\t *  - a/b/c/d -> a/b/c\n\t */\n\tif (git_buf_joinpath(&temp_path, git_buf_cstr(&temp_path), \"temp_reflog\") < 0)\n\t\treturn -1;\n\n\tif ((fd = git_futils_mktmp(&temp_path, git_buf_cstr(&temp_path), GIT_REFLOG_FILE_MODE)) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tp_close(fd);\n\n\tif (p_rename(git_buf_cstr(&old_path), git_buf_cstr(&temp_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_path_isdir(git_buf_cstr(&new_path)) && \n\t\t(git_futils_rmdir_r(git_buf_cstr(&new_path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0)) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (git_futils_mkpath2file(git_buf_cstr(&new_path), GIT_REFLOG_DIR_MODE) < 0) {\n\t\terror = -1;\n\t\tgoto cleanup;\n\t}\n\n\tif (p_rename(git_buf_cstr(&temp_path), git_buf_cstr(&new_path)) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename reflog for %s\", new_name);\n\t\terror = -1;\n\t}\n\ncleanup:\n\tgit_buf_free(&temp_path);\n\tgit_buf_free(&old_path);\n\tgit_buf_free(&new_path);\n\tgit_buf_free(&normalized);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lock",
          "args": [
            "&file",
            "backend",
            "new->name"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "713-741",
          "snippet": "static int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__set_name",
          "args": [
            "old",
            "new_name"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__set_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "93-106",
          "snippet": "git_reference *git_reference__set_name(\n\tgit_reference *ref, const char *name)\n{\n\tsize_t namelen = strlen(name);\n\tsize_t reflen;\n\tgit_reference *rewrite = NULL;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(rewrite = git__realloc(ref, reflen)) != NULL)\n\t\tmemcpy(rewrite->name, name, namelen + 1);\n\n\treturn rewrite;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__set_name(\n\tgit_reference *ref, const char *name)\n{\n\tsize_t namelen = strlen(name);\n\tsize_t reflen;\n\tgit_reference *rewrite = NULL;\n\n\tif (!GIT_ADD_SIZET_OVERFLOW(&reflen, sizeof(git_reference), namelen) &&\n\t\t!GIT_ADD_SIZET_OVERFLOW(&reflen, reflen, 1) &&\n\t\t(rewrite = git__realloc(ref, reflen)) != NULL)\n\t\tmemcpy(rewrite->name, name, namelen + 1);\n\n\treturn rewrite;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_fs_backend__delete",
          "args": [
            "_backend",
            "old_name",
            "NULL",
            "NULL"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1215-1235",
          "snippet": "static int refdb_fs_backend__delete(\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error = 0;\n\n\tassert(backend && ref_name);\n\n\tif ((error = loose_lock(&file, backend, ref_name)) < 0)\n\t\treturn error;\n\n\tif ((error = refdb_reflog_fs__delete(_backend, ref_name)) < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\treturn refdb_fs_backend__delete_tail(_backend, &file, ref_name, old_id, old_target);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\n\nstatic int refdb_fs_backend__delete(\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error = 0;\n\n\tassert(backend && ref_name);\n\n\tif ((error = loose_lock(&file, backend, ref_name)) < 0)\n\t\treturn error;\n\n\tif ((error = refdb_reflog_fs__delete(_backend, ref_name)) < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\treturn refdb_fs_backend__delete_tail(_backend, &file, ref_name, old_id, old_target);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_fs_backend__lookup",
          "args": [
            "&old",
            "_backend",
            "old_name"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "432-453",
          "snippet": "static int refdb_fs_backend__lookup(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error;\n\n\tassert(backend);\n\n\tif (!(error = loose_lookup(out, backend, ref_name)))\n\t\treturn 0;\n\n\t/* only try to lookup this reference on the packfile if it\n\t * wasn't found on the loose refs; not if there was a critical error */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = packed_lookup(out, backend, ref_name);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__lookup(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error;\n\n\tassert(backend);\n\n\tif (!(error = loose_lookup(out, backend, ref_name)))\n\t\treturn 0;\n\n\t/* only try to lookup this reference on the packfile if it\n\t * wasn't found on the loose refs; not if there was a critical error */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = packed_lookup(out, backend, ref_name);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference_path_available",
          "args": [
            "backend",
            "new_name",
            "old_name",
            "force"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "reference_path_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "670-711",
          "snippet": "static int reference_path_available(\n\trefdb_fs_backend *backend,\n\tconst char *new_ref,\n\tconst char* old_ref,\n\tint force)\n{\n\tsize_t i;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (!force) {\n\t\tint exists;\n\n\t\tif (refdb_fs_backend__exists(\n\t\t\t\t&exists, (git_refdb_backend *)backend, new_ref) < 0)\n\t\t\treturn -1;\n\n\t\tif (exists) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to write reference '%s': a reference with \"\n\t\t\t\t\"that name already exists.\", new_ref);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\tgit_sortedcache_rlock(backend->refcache);\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (ref && !ref_is_available(old_ref, new_ref, ref->name)) {\n\t\t\tgit_sortedcache_runlock(backend->refcache);\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Path to reference '%s' collides with existing one\", new_ref);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reference_path_available(\n\trefdb_fs_backend *backend,\n\tconst char *new_ref,\n\tconst char* old_ref,\n\tint force)\n{\n\tsize_t i;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (!force) {\n\t\tint exists;\n\n\t\tif (refdb_fs_backend__exists(\n\t\t\t\t&exists, (git_refdb_backend *)backend, new_ref) < 0)\n\t\t\treturn -1;\n\n\t\tif (exists) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to write reference '%s': a reference with \"\n\t\t\t\t\"that name already exists.\", new_ref);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\tgit_sortedcache_rlock(backend->refcache);\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (ref && !ref_is_available(old_ref, new_ref, ref->name)) {\n\t\t\tgit_sortedcache_runlock(backend->refcache);\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Path to reference '%s' collides with existing one\", new_ref);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\nstatic int refdb_reflog_fs__rename(git_refdb_backend *_backend, const char *old_name, const char *new_name);\n\nstatic int refdb_fs_backend__rename(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *old_name,\n\tconst char *new_name,\n\tint force,\n\tconst git_signature *who,\n\tconst char *message)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_reference *old, *new;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error;\n\n\tassert(backend);\n\n\tif ((error = reference_path_available(\n\t\t\tbackend, new_name, old_name, force)) < 0 ||\n\t\t(error = refdb_fs_backend__lookup(&old, _backend, old_name)) < 0)\n\t\treturn error;\n\n\tif ((error = refdb_fs_backend__delete(_backend, old_name, NULL, NULL)) < 0) {\n\t\tgit_reference_free(old);\n\t\treturn error;\n\t}\n\n\tnew = git_reference__set_name(old, new_name);\n\tif (!new) {\n\t\tgit_reference_free(old);\n\t\treturn -1;\n\t}\n\n\tif ((error = loose_lock(&file, backend, new->name)) < 0) {\n\t\tgit_reference_free(new);\n\t\treturn error;\n\t}\n\n\t/* Try to rename the refog; it's ok if the old doesn't exist */\n\terror = refdb_reflog_fs__rename(_backend, old_name, new_name);\n\tif (((error == 0) || (error == GIT_ENOTFOUND)) &&\n\t    ((error = reflog_append(backend, new, git_reference_target(new), NULL, who, message)) < 0)) {\n\t\tgit_reference_free(new);\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\tif (error < 0) {\n\t\tgit_reference_free(new);\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\n\tif ((error = loose_commit(&file, new)) < 0 || out == NULL) {\n\t\tgit_reference_free(new);\n\t\treturn error;\n\t}\n\n\t*out = new;\n\treturn 0;\n}"
  },
  {
    "function_name": "refdb_fs_backend__delete_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1237-1297",
    "snippet": "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf loose_path = GIT_BUF_INIT;\n\tsize_t pack_pos;\n\tint error = 0, cmp = 0;\n\tbool loose_deleted = 0;\n\n\terror = cmp_old_ref(&cmp, _backend, ref_name, old_id, old_target);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a loose reference exists, remove it from the filesystem */\n\tif (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\tif (git_path_isfile(loose_path.ptr)) {\n\t\terror = p_unlink(loose_path.ptr);\n\t\tloose_deleted = 1;\n\t}\n\n\tgit_buf_free(&loose_path);\n\n\tif (error != 0)\n\t\tgoto cleanup;\n\n\tif ((error = packed_reload(backend)) < 0)\n\t\tgoto cleanup;\n\n\t/* If a packed reference exists, remove it from the packfile and repack */\n\tif ((error = git_sortedcache_wlock(backend->refcache)) < 0)\n\t\tgoto cleanup;\n\n\tif (!(error = git_sortedcache_lookup_index(\n\t\t\t&pack_pos, backend->refcache, ref_name)))\n\t\terror = git_sortedcache_remove(backend->refcache, pack_pos);\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = loose_deleted ? 0 : ref_error_notfound(ref_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = packed_write(backend);\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
      "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "file"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_write",
          "args": [
            "backend"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "packed_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "943-995",
          "snippet": "static int packed_write(refdb_fs_backend *backend)\n{\n\tgit_sortedcache *refcache = backend->refcache;\n\tgit_filebuf pack_file = GIT_FILEBUF_INIT;\n\tsize_t i;\n\n\t/* lock the cache to updates while we do this */\n\tif (git_sortedcache_wlock(refcache) < 0)\n\t\treturn -1;\n\n\t/* Open the file! */\n\tif (git_filebuf_open(&pack_file, git_sortedcache_path(refcache), 0, GIT_PACKEDREFS_FILE_MODE) < 0)\n\t\tgoto fail;\n\n\t/* Packfiles have a header... apparently\n\t * This is in fact not required, but we might as well print it\n\t * just for kicks */\n\tif (git_filebuf_printf(&pack_file, \"%s\\n\", GIT_PACKEDREFS_HEADER) < 0)\n\t\tgoto fail;\n\n\tfor (i = 0; i < git_sortedcache_entrycount(refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(refcache, i);\n\t\tassert(ref);\n\n\t\tif (packed_find_peel(backend, ref) < 0)\n\t\t\tgoto fail;\n\n\t\tif (packed_write_ref(ref, &pack_file) < 0)\n\t\t\tgoto fail;\n\t}\n\n\t/* if we've written all the references properly, we can commit\n\t * the packfile to make the changes effective */\n\tif (git_filebuf_commit(&pack_file) < 0)\n\t\tgoto fail;\n\n\t/* when and only when the packfile has been properly written,\n\t * we can go ahead and remove the loose refs */\n\tif (packed_remove_loose(backend) < 0)\n\t\tgoto fail;\n\n\tgit_sortedcache_updated(refcache);\n\tgit_sortedcache_wunlock(refcache);\n\n\t/* we're good now */\n\treturn 0;\n\nfail:\n\tgit_filebuf_cleanup(&pack_file);\n\tgit_sortedcache_wunlock(refcache);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_write(refdb_fs_backend *backend)\n{\n\tgit_sortedcache *refcache = backend->refcache;\n\tgit_filebuf pack_file = GIT_FILEBUF_INIT;\n\tsize_t i;\n\n\t/* lock the cache to updates while we do this */\n\tif (git_sortedcache_wlock(refcache) < 0)\n\t\treturn -1;\n\n\t/* Open the file! */\n\tif (git_filebuf_open(&pack_file, git_sortedcache_path(refcache), 0, GIT_PACKEDREFS_FILE_MODE) < 0)\n\t\tgoto fail;\n\n\t/* Packfiles have a header... apparently\n\t * This is in fact not required, but we might as well print it\n\t * just for kicks */\n\tif (git_filebuf_printf(&pack_file, \"%s\\n\", GIT_PACKEDREFS_HEADER) < 0)\n\t\tgoto fail;\n\n\tfor (i = 0; i < git_sortedcache_entrycount(refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(refcache, i);\n\t\tassert(ref);\n\n\t\tif (packed_find_peel(backend, ref) < 0)\n\t\t\tgoto fail;\n\n\t\tif (packed_write_ref(ref, &pack_file) < 0)\n\t\t\tgoto fail;\n\t}\n\n\t/* if we've written all the references properly, we can commit\n\t * the packfile to make the changes effective */\n\tif (git_filebuf_commit(&pack_file) < 0)\n\t\tgoto fail;\n\n\t/* when and only when the packfile has been properly written,\n\t * we can go ahead and remove the loose refs */\n\tif (packed_remove_loose(backend) < 0)\n\t\tgoto fail;\n\n\tgit_sortedcache_updated(refcache);\n\tgit_sortedcache_wunlock(refcache);\n\n\t/* we're good now */\n\treturn 0;\n\nfail:\n\tgit_filebuf_cleanup(&pack_file);\n\tgit_sortedcache_wunlock(refcache);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_error_notfound",
          "args": [
            "ref_name"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ref_error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "398-402",
          "snippet": "static int ref_error_notfound(const char *name)\n{\n\tgiterr_set(GITERR_REFERENCE, \"Reference '%s' not found\", name);\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int ref_error_notfound(const char *name)\n{\n\tgiterr_set(GITERR_REFERENCE, \"Reference '%s' not found\", name);\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "backend->refcache"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_remove",
          "args": [
            "backend->refcache",
            "pack_pos"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "357-380",
          "snippet": "int git_sortedcache_remove(git_sortedcache *sc, size_t pos)\n{\n\tchar *item;\n\tkhiter_t mappos;\n\n\t/* because of pool allocation, this can't actually remove the item,\n\t * but we can remove it from the items vector and the hash table.\n\t */\n\n\tif ((item = git_vector_get(&sc->items, pos)) == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Removing item out of range\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t(void)git_vector_remove(&sc->items, pos);\n\n\tmappos = git_strmap_lookup_index(sc->map, item + sc->item_path_offset);\n\tgit_strmap_delete_at(sc->map, mappos);\n\n\tif (sc->free_item)\n\t\tsc->free_item(sc->free_item_payload, item);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_remove(git_sortedcache *sc, size_t pos)\n{\n\tchar *item;\n\tkhiter_t mappos;\n\n\t/* because of pool allocation, this can't actually remove the item,\n\t * but we can remove it from the items vector and the hash table.\n\t */\n\n\tif ((item = git_vector_get(&sc->items, pos)) == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Removing item out of range\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\t(void)git_vector_remove(&sc->items, pos);\n\n\tmappos = git_strmap_lookup_index(sc->map, item + sc->item_path_offset);\n\tgit_strmap_delete_at(sc->map, mappos);\n\n\tif (sc->free_item)\n\t\tsc->free_item(sc->free_item_payload, item);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_lookup_index",
          "args": [
            "&pack_pos",
            "backend->refcache",
            "ref_name"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_lookup_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "345-354",
          "snippet": "int git_sortedcache_lookup_index(\n\tsize_t *out, git_sortedcache *sc, const char *key)\n{\n\tstruct sortedcache_magic_key magic;\n\n\tmagic.offset = sc->item_path_offset;\n\tmagic.key    = key;\n\n\treturn git_vector_bsearch2(out, &sc->items, sortedcache_magic_cmp, &magic);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_lookup_index(\n\tsize_t *out, git_sortedcache *sc, const char *key)\n{\n\tstruct sortedcache_magic_key magic;\n\n\tmagic.offset = sc->item_path_offset;\n\tmagic.key    = key;\n\n\treturn git_vector_bsearch2(out, &sc->items, sortedcache_magic_cmp, &magic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wlock",
          "args": [
            "backend->refcache"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "160-169",
          "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_reload",
          "args": [
            "backend"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "packed_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "74-195",
          "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&loose_path"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "loose_path.ptr"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "loose_path.ptr"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&loose_path",
            "backend->path",
            "ref_name"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"old reference value does not match\""
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmp_old_ref",
          "args": [
            "&cmp",
            "_backend",
            "ref_name",
            "old_id",
            "old_target"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_old_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1029-1063",
          "snippet": "static int cmp_old_ref(int *cmp, git_refdb_backend *backend, const char *name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\tint error = 0;\n\tgit_reference *old_ref = NULL;\n\n\t*cmp = 0;\n\t/* It \"matches\" if there is no old value to compare against */\n\tif (!old_id && !old_target)\n\t\treturn 0;\n\n\tif ((error = refdb_fs_backend__lookup(&old_ref, backend, name)) < 0)\n\t\tgoto out;\n\n\t/* If the types don't match, there's no way the values do */\n\tif (old_id && old_ref->type != GIT_REF_OID) {\n\t\t*cmp = -1;\n\t\tgoto out;\n\t}\n\tif (old_target && old_ref->type != GIT_REF_SYMBOLIC) {\n\t\t*cmp = 1;\n\t\tgoto out;\n\t}\n\n\tif (old_id && old_ref->type == GIT_REF_OID)\n\t\t*cmp = git_oid_cmp(old_id, &old_ref->target.oid);\n\n\tif (old_target && old_ref->type == GIT_REF_SYMBOLIC)\n\t\t*cmp = git__strcmp(old_target, old_ref->target.symbolic);\n\nout:\n\tgit_reference_free(old_ref);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int cmp_old_ref(int *cmp, git_refdb_backend *backend, const char *name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\tint error = 0;\n\tgit_reference *old_ref = NULL;\n\n\t*cmp = 0;\n\t/* It \"matches\" if there is no old value to compare against */\n\tif (!old_id && !old_target)\n\t\treturn 0;\n\n\tif ((error = refdb_fs_backend__lookup(&old_ref, backend, name)) < 0)\n\t\tgoto out;\n\n\t/* If the types don't match, there's no way the values do */\n\tif (old_id && old_ref->type != GIT_REF_OID) {\n\t\t*cmp = -1;\n\t\tgoto out;\n\t}\n\tif (old_target && old_ref->type != GIT_REF_SYMBOLIC) {\n\t\t*cmp = 1;\n\t\tgoto out;\n\t}\n\n\tif (old_id && old_ref->type == GIT_REF_OID)\n\t\t*cmp = git_oid_cmp(old_id, &old_ref->target.oid);\n\n\tif (old_target && old_ref->type == GIT_REF_SYMBOLIC)\n\t\t*cmp = git__strcmp(old_target, old_ref->target.symbolic);\n\nout:\n\tgit_reference_free(old_ref);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\n\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf loose_path = GIT_BUF_INIT;\n\tsize_t pack_pos;\n\tint error = 0, cmp = 0;\n\tbool loose_deleted = 0;\n\n\terror = cmp_old_ref(&cmp, _backend, ref_name, old_id, old_target);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a loose reference exists, remove it from the filesystem */\n\tif (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\tif (git_path_isfile(loose_path.ptr)) {\n\t\terror = p_unlink(loose_path.ptr);\n\t\tloose_deleted = 1;\n\t}\n\n\tgit_buf_free(&loose_path);\n\n\tif (error != 0)\n\t\tgoto cleanup;\n\n\tif ((error = packed_reload(backend)) < 0)\n\t\tgoto cleanup;\n\n\t/* If a packed reference exists, remove it from the packfile and repack */\n\tif ((error = git_sortedcache_wlock(backend->refcache)) < 0)\n\t\tgoto cleanup;\n\n\tif (!(error = git_sortedcache_lookup_index(\n\t\t\t&pack_pos, backend->refcache, ref_name)))\n\t\terror = git_sortedcache_remove(backend->refcache, pack_pos);\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = loose_deleted ? 0 : ref_error_notfound(ref_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = packed_write(backend);\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\n\treturn error;\n}"
  },
  {
    "function_name": "refdb_fs_backend__delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1215-1235",
    "snippet": "static int refdb_fs_backend__delete(\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error = 0;\n\n\tassert(backend && ref_name);\n\n\tif ((error = loose_lock(&file, backend, ref_name)) < 0)\n\t\treturn error;\n\n\tif ((error = refdb_reflog_fs__delete(_backend, ref_name)) < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\treturn refdb_fs_backend__delete_tail(_backend, &file, ref_name, old_id, old_target);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
      "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refdb_fs_backend__delete_tail",
          "args": [
            "_backend",
            "&file",
            "ref_name",
            "old_id",
            "old_target"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__delete_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1237-1297",
          "snippet": "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf loose_path = GIT_BUF_INIT;\n\tsize_t pack_pos;\n\tint error = 0, cmp = 0;\n\tbool loose_deleted = 0;\n\n\terror = cmp_old_ref(&cmp, _backend, ref_name, old_id, old_target);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a loose reference exists, remove it from the filesystem */\n\tif (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\tif (git_path_isfile(loose_path.ptr)) {\n\t\terror = p_unlink(loose_path.ptr);\n\t\tloose_deleted = 1;\n\t}\n\n\tgit_buf_free(&loose_path);\n\n\tif (error != 0)\n\t\tgoto cleanup;\n\n\tif ((error = packed_reload(backend)) < 0)\n\t\tgoto cleanup;\n\n\t/* If a packed reference exists, remove it from the packfile and repack */\n\tif ((error = git_sortedcache_wlock(backend->refcache)) < 0)\n\t\tgoto cleanup;\n\n\tif (!(error = git_sortedcache_lookup_index(\n\t\t\t&pack_pos, backend->refcache, ref_name)))\n\t\terror = git_sortedcache_remove(backend->refcache, pack_pos);\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = loose_deleted ? 0 : ref_error_notfound(ref_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = packed_write(backend);\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\n\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf loose_path = GIT_BUF_INIT;\n\tsize_t pack_pos;\n\tint error = 0, cmp = 0;\n\tbool loose_deleted = 0;\n\n\terror = cmp_old_ref(&cmp, _backend, ref_name, old_id, old_target);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a loose reference exists, remove it from the filesystem */\n\tif (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\tif (git_path_isfile(loose_path.ptr)) {\n\t\terror = p_unlink(loose_path.ptr);\n\t\tloose_deleted = 1;\n\t}\n\n\tgit_buf_free(&loose_path);\n\n\tif (error != 0)\n\t\tgoto cleanup;\n\n\tif ((error = packed_reload(backend)) < 0)\n\t\tgoto cleanup;\n\n\t/* If a packed reference exists, remove it from the packfile and repack */\n\tif ((error = git_sortedcache_wlock(backend->refcache)) < 0)\n\t\tgoto cleanup;\n\n\tif (!(error = git_sortedcache_lookup_index(\n\t\t\t&pack_pos, backend->refcache, ref_name)))\n\t\terror = git_sortedcache_remove(backend->refcache, pack_pos);\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = loose_deleted ? 0 : ref_error_notfound(ref_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = packed_write(backend);\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&file"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_reflog_fs__delete",
          "args": [
            "_backend",
            "ref_name"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_reflog_fs__delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1894-1916",
          "snippet": "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\terror = retrieve_reflog_path(&path, repo, name);\n\n\tif (!error && git_path_exists(path.ptr))\n\t\terror = p_unlink(path.ptr);\n\n\tgit_buf_free(&path);\n\n\treturn error;\n\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name)\n{\n\tint error;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tgit_repository *repo;\n\trefdb_fs_backend *backend;\n\n\tassert(_backend && name);\n\n\tbackend = (refdb_fs_backend *) _backend;\n\trepo = backend->repo;\n\n\terror = retrieve_reflog_path(&path, repo, name);\n\n\tif (!error && git_path_exists(path.ptr))\n\t\terror = p_unlink(path.ptr);\n\n\tgit_buf_free(&path);\n\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lock",
          "args": [
            "&file",
            "backend",
            "ref_name"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "713-741",
          "snippet": "static int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend && ref_name"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\n\nstatic int refdb_fs_backend__delete(\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error = 0;\n\n\tassert(backend && ref_name);\n\n\tif ((error = loose_lock(&file, backend, ref_name)) < 0)\n\t\treturn error;\n\n\tif ((error = refdb_reflog_fs__delete(_backend, ref_name)) < 0) {\n\t\tgit_filebuf_cleanup(&file);\n\t\treturn error;\n\t}\n\n\treturn refdb_fs_backend__delete_tail(_backend, &file, ref_name, old_id, old_target);\n}"
  },
  {
    "function_name": "refdb_fs_backend__write_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1157-1213",
    "snippet": "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error = 0, cmp = 0, should_write;\n\tconst char *new_target = NULL;\n\tconst git_oid *new_id = NULL;\n\n\tif ((error = cmp_old_ref(&cmp, _backend, ref->name, old_id, old_target)) < 0)\n\t\tgoto on_error;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto on_error;\n\t}\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\tnew_target = ref->target.symbolic;\n\telse\n\t\tnew_id = &ref->target.oid;\n\n\terror = cmp_old_ref(&cmp, _backend, ref->name, new_id, new_target);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* Don't update if we have the same value */\n\tif (!error && !cmp) {\n\t\terror = 0;\n\t\tgoto on_error; /* not really error */\n\t}\n\n\tif (update_reflog) {\n\t\tif ((error = should_write_reflog(&should_write, backend->repo, ref->name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (should_write) {\n\t\t\tif ((error = reflog_append(backend, ref, NULL, NULL, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t\tif ((error = maybe_append_head(backend, ref, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\treturn loose_commit(file, ref);\n\non_error:\n        git_filebuf_cleanup(file);\n        return error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
      "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "file"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_commit",
          "args": [
            "file",
            "ref"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "loose_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "743-759",
          "snippet": "static int loose_commit(git_filebuf *file, const git_reference *ref)\n{\n\tassert(file && ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tchar oid[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(oid, sizeof(oid), &ref->target.oid);\n\n\t\tgit_filebuf_printf(file, \"%s\\n\", oid);\n\t} else if (ref->type == GIT_REF_SYMBOLIC) {\n\t\tgit_filebuf_printf(file, GIT_SYMREF \"%s\\n\", ref->target.symbolic);\n\t} else {\n\t\tassert(0); /* don't let this happen */\n\t}\n\n\treturn git_filebuf_commit(file);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_commit(git_filebuf *file, const git_reference *ref)\n{\n\tassert(file && ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tchar oid[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(oid, sizeof(oid), &ref->target.oid);\n\n\t\tgit_filebuf_printf(file, \"%s\\n\", oid);\n\t} else if (ref->type == GIT_REF_SYMBOLIC) {\n\t\tgit_filebuf_printf(file, GIT_SYMREF \"%s\\n\", ref->target.symbolic);\n\t} else {\n\t\tassert(0); /* don't let this happen */\n\t}\n\n\treturn git_filebuf_commit(file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_append_head",
          "args": [
            "backend",
            "ref",
            "who",
            "message"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_append_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1079-1129",
          "snippet": "static int maybe_append_head(refdb_fs_backend *backend, const git_reference *ref, const git_signature *who, const char *message)\n{\n\tint error;\n\tgit_oid old_id = {{0}};\n\tgit_reference *tmp = NULL, *head = NULL, *peeled = NULL;\n\tconst char *name;\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\t/* if we can't resolve, we use {0}*40 as old id */\n\tgit_reference_name_to_id(&old_id, backend->repo, ref->name);\n\n\tif ((error = git_reference_lookup(&head, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\treturn error;\n\n\tif (git_reference_type(head) == GIT_REF_OID)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&tmp, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* Go down the symref chain until we find the branch */\n\twhile (git_reference_type(tmp) == GIT_REF_SYMBOLIC) {\n\t\terror = git_reference_lookup(&peeled, backend->repo, git_reference_symbolic_target(tmp));\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\tgit_reference_free(tmp);\n\t\ttmp = peeled;\n\t}\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = 0;\n\t\tname = git_reference_symbolic_target(tmp);\n\t} else if (error < 0) {\n\t\tgoto cleanup;\n\t} else {\n\t\tname = git_reference_name(tmp);\n\t}\n\n\tif (strcmp(name, ref->name))\n\t\tgoto cleanup;\n\n\terror = reflog_append(backend, head, &old_id, git_reference_target(ref), who, message);\n\ncleanup:\n\tgit_reference_free(tmp);\n\tgit_reference_free(head);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int maybe_append_head(refdb_fs_backend *backend, const git_reference *ref, const git_signature *who, const char *message)\n{\n\tint error;\n\tgit_oid old_id = {{0}};\n\tgit_reference *tmp = NULL, *head = NULL, *peeled = NULL;\n\tconst char *name;\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\t/* if we can't resolve, we use {0}*40 as old id */\n\tgit_reference_name_to_id(&old_id, backend->repo, ref->name);\n\n\tif ((error = git_reference_lookup(&head, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\treturn error;\n\n\tif (git_reference_type(head) == GIT_REF_OID)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&tmp, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* Go down the symref chain until we find the branch */\n\twhile (git_reference_type(tmp) == GIT_REF_SYMBOLIC) {\n\t\terror = git_reference_lookup(&peeled, backend->repo, git_reference_symbolic_target(tmp));\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\tgit_reference_free(tmp);\n\t\ttmp = peeled;\n\t}\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = 0;\n\t\tname = git_reference_symbolic_target(tmp);\n\t} else if (error < 0) {\n\t\tgoto cleanup;\n\t} else {\n\t\tname = git_reference_name(tmp);\n\t}\n\n\tif (strcmp(name, ref->name))\n\t\tgoto cleanup;\n\n\terror = reflog_append(backend, head, &old_id, git_reference_target(ref), who, message);\n\ncleanup:\n\tgit_reference_free(tmp);\n\tgit_reference_free(head);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reflog_append",
          "args": [
            "backend",
            "ref",
            "NULL",
            "NULL",
            "who",
            "message"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "reflog_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1735-1811",
          "snippet": "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_write_reflog",
          "args": [
            "&should_write",
            "backend->repo",
            "ref->name"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "should_write_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1001-1027",
          "snippet": "static int should_write_reflog(int *write, git_repository *repo, const char *name)\n{\n\tint error, logall;\n\n\terror = git_repository__cvar(&logall, repo, GIT_CVAR_LOGALLREFUPDATES);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* Defaults to the opposite of the repo being bare */\n\tif (logall == GIT_LOGALLREFUPDATES_UNSET)\n\t\tlogall = !git_repository_is_bare(repo);\n\n\tif (!logall) {\n\t\t*write = 0;\n\t} else if (has_reflog(repo, name)) {\n\t\t*write = 1;\n\t} else if (!git__prefixcmp(name, GIT_REFS_HEADS_DIR) ||\n\t\t   !git__strcmp(name, GIT_HEAD_FILE) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_REMOTES_DIR) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_NOTES_DIR)) {\n\t\t*write = 1;\n\t} else {\n\t\t*write = 0;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int should_write_reflog(int *write, git_repository *repo, const char *name)\n{\n\tint error, logall;\n\n\terror = git_repository__cvar(&logall, repo, GIT_CVAR_LOGALLREFUPDATES);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* Defaults to the opposite of the repo being bare */\n\tif (logall == GIT_LOGALLREFUPDATES_UNSET)\n\t\tlogall = !git_repository_is_bare(repo);\n\n\tif (!logall) {\n\t\t*write = 0;\n\t} else if (has_reflog(repo, name)) {\n\t\t*write = 1;\n\t} else if (!git__prefixcmp(name, GIT_REFS_HEADS_DIR) ||\n\t\t   !git__strcmp(name, GIT_HEAD_FILE) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_REMOTES_DIR) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_NOTES_DIR)) {\n\t\t*write = 1;\n\t} else {\n\t\t*write = 0;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmp_old_ref",
          "args": [
            "&cmp",
            "_backend",
            "ref->name",
            "new_id",
            "new_target"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_old_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1029-1063",
          "snippet": "static int cmp_old_ref(int *cmp, git_refdb_backend *backend, const char *name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\tint error = 0;\n\tgit_reference *old_ref = NULL;\n\n\t*cmp = 0;\n\t/* It \"matches\" if there is no old value to compare against */\n\tif (!old_id && !old_target)\n\t\treturn 0;\n\n\tif ((error = refdb_fs_backend__lookup(&old_ref, backend, name)) < 0)\n\t\tgoto out;\n\n\t/* If the types don't match, there's no way the values do */\n\tif (old_id && old_ref->type != GIT_REF_OID) {\n\t\t*cmp = -1;\n\t\tgoto out;\n\t}\n\tif (old_target && old_ref->type != GIT_REF_SYMBOLIC) {\n\t\t*cmp = 1;\n\t\tgoto out;\n\t}\n\n\tif (old_id && old_ref->type == GIT_REF_OID)\n\t\t*cmp = git_oid_cmp(old_id, &old_ref->target.oid);\n\n\tif (old_target && old_ref->type == GIT_REF_SYMBOLIC)\n\t\t*cmp = git__strcmp(old_target, old_ref->target.symbolic);\n\nout:\n\tgit_reference_free(old_ref);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int cmp_old_ref(int *cmp, git_refdb_backend *backend, const char *name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\tint error = 0;\n\tgit_reference *old_ref = NULL;\n\n\t*cmp = 0;\n\t/* It \"matches\" if there is no old value to compare against */\n\tif (!old_id && !old_target)\n\t\treturn 0;\n\n\tif ((error = refdb_fs_backend__lookup(&old_ref, backend, name)) < 0)\n\t\tgoto out;\n\n\t/* If the types don't match, there's no way the values do */\n\tif (old_id && old_ref->type != GIT_REF_OID) {\n\t\t*cmp = -1;\n\t\tgoto out;\n\t}\n\tif (old_target && old_ref->type != GIT_REF_SYMBOLIC) {\n\t\t*cmp = 1;\n\t\tgoto out;\n\t}\n\n\tif (old_id && old_ref->type == GIT_REF_OID)\n\t\t*cmp = git_oid_cmp(old_id, &old_ref->target.oid);\n\n\tif (old_target && old_ref->type == GIT_REF_SYMBOLIC)\n\t\t*cmp = git__strcmp(old_target, old_ref->target.symbolic);\n\nout:\n\tgit_reference_free(old_ref);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"old reference value does not match\""
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error = 0, cmp = 0, should_write;\n\tconst char *new_target = NULL;\n\tconst git_oid *new_id = NULL;\n\n\tif ((error = cmp_old_ref(&cmp, _backend, ref->name, old_id, old_target)) < 0)\n\t\tgoto on_error;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto on_error;\n\t}\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\tnew_target = ref->target.symbolic;\n\telse\n\t\tnew_id = &ref->target.oid;\n\n\terror = cmp_old_ref(&cmp, _backend, ref->name, new_id, new_target);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* Don't update if we have the same value */\n\tif (!error && !cmp) {\n\t\terror = 0;\n\t\tgoto on_error; /* not really error */\n\t}\n\n\tif (update_reflog) {\n\t\tif ((error = should_write_reflog(&should_write, backend->repo, ref->name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (should_write) {\n\t\t\tif ((error = reflog_append(backend, ref, NULL, NULL, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t\tif ((error = maybe_append_head(backend, ref, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\treturn loose_commit(file, ref);\n\non_error:\n        git_filebuf_cleanup(file);\n        return error;\n}"
  },
  {
    "function_name": "refdb_fs_backend__write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1131-1155",
    "snippet": "static int refdb_fs_backend__write(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tint force,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error = 0;\n\n\tassert(backend);\n\n\terror = reference_path_available(backend, ref->name, NULL, force);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* We need to perform the reflog append and old value check under the ref's lock */\n\tif ((error = loose_lock(&file, backend, ref->name)) < 0)\n\t\treturn error;\n\n\treturn refdb_fs_backend__write_tail(_backend, ref, &file, true, who, message, old_id, old_target);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
      "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "refdb_fs_backend__write_tail",
          "args": [
            "_backend",
            "ref",
            "&file",
            "true",
            "who",
            "message",
            "old_id",
            "old_target"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__write_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1157-1213",
          "snippet": "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error = 0, cmp = 0, should_write;\n\tconst char *new_target = NULL;\n\tconst git_oid *new_id = NULL;\n\n\tif ((error = cmp_old_ref(&cmp, _backend, ref->name, old_id, old_target)) < 0)\n\t\tgoto on_error;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto on_error;\n\t}\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\tnew_target = ref->target.symbolic;\n\telse\n\t\tnew_id = &ref->target.oid;\n\n\terror = cmp_old_ref(&cmp, _backend, ref->name, new_id, new_target);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* Don't update if we have the same value */\n\tif (!error && !cmp) {\n\t\terror = 0;\n\t\tgoto on_error; /* not really error */\n\t}\n\n\tif (update_reflog) {\n\t\tif ((error = should_write_reflog(&should_write, backend->repo, ref->name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (should_write) {\n\t\t\tif ((error = reflog_append(backend, ref, NULL, NULL, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t\tif ((error = maybe_append_head(backend, ref, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\treturn loose_commit(file, ref);\n\non_error:\n        git_filebuf_cleanup(file);\n        return error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error = 0, cmp = 0, should_write;\n\tconst char *new_target = NULL;\n\tconst git_oid *new_id = NULL;\n\n\tif ((error = cmp_old_ref(&cmp, _backend, ref->name, old_id, old_target)) < 0)\n\t\tgoto on_error;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto on_error;\n\t}\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\tnew_target = ref->target.symbolic;\n\telse\n\t\tnew_id = &ref->target.oid;\n\n\terror = cmp_old_ref(&cmp, _backend, ref->name, new_id, new_target);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* Don't update if we have the same value */\n\tif (!error && !cmp) {\n\t\terror = 0;\n\t\tgoto on_error; /* not really error */\n\t}\n\n\tif (update_reflog) {\n\t\tif ((error = should_write_reflog(&should_write, backend->repo, ref->name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (should_write) {\n\t\t\tif ((error = reflog_append(backend, ref, NULL, NULL, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t\tif ((error = maybe_append_head(backend, ref, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\treturn loose_commit(file, ref);\n\non_error:\n        git_filebuf_cleanup(file);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lock",
          "args": [
            "&file",
            "backend",
            "ref->name"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "713-741",
          "snippet": "static int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reference_path_available",
          "args": [
            "backend",
            "ref->name",
            "NULL",
            "force"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "reference_path_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "670-711",
          "snippet": "static int reference_path_available(\n\trefdb_fs_backend *backend,\n\tconst char *new_ref,\n\tconst char* old_ref,\n\tint force)\n{\n\tsize_t i;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (!force) {\n\t\tint exists;\n\n\t\tif (refdb_fs_backend__exists(\n\t\t\t\t&exists, (git_refdb_backend *)backend, new_ref) < 0)\n\t\t\treturn -1;\n\n\t\tif (exists) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to write reference '%s': a reference with \"\n\t\t\t\t\"that name already exists.\", new_ref);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\tgit_sortedcache_rlock(backend->refcache);\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (ref && !ref_is_available(old_ref, new_ref, ref->name)) {\n\t\t\tgit_sortedcache_runlock(backend->refcache);\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Path to reference '%s' collides with existing one\", new_ref);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reference_path_available(\n\trefdb_fs_backend *backend,\n\tconst char *new_ref,\n\tconst char* old_ref,\n\tint force)\n{\n\tsize_t i;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (!force) {\n\t\tint exists;\n\n\t\tif (refdb_fs_backend__exists(\n\t\t\t\t&exists, (git_refdb_backend *)backend, new_ref) < 0)\n\t\t\treturn -1;\n\n\t\tif (exists) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to write reference '%s': a reference with \"\n\t\t\t\t\"that name already exists.\", new_ref);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\tgit_sortedcache_rlock(backend->refcache);\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (ref && !ref_is_available(old_ref, new_ref, ref->name)) {\n\t\t\tgit_sortedcache_runlock(backend->refcache);\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Path to reference '%s' collides with existing one\", new_ref);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__write(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tint force,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tint error = 0;\n\n\tassert(backend);\n\n\terror = reference_path_available(backend, ref->name, NULL, force);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* We need to perform the reflog append and old value check under the ref's lock */\n\tif ((error = loose_lock(&file, backend, ref->name)) < 0)\n\t\treturn error;\n\n\treturn refdb_fs_backend__write_tail(_backend, ref, &file, true, who, message, old_id, old_target);\n}"
  },
  {
    "function_name": "maybe_append_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1079-1129",
    "snippet": "static int maybe_append_head(refdb_fs_backend *backend, const git_reference *ref, const git_signature *who, const char *message)\n{\n\tint error;\n\tgit_oid old_id = {{0}};\n\tgit_reference *tmp = NULL, *head = NULL, *peeled = NULL;\n\tconst char *name;\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\t/* if we can't resolve, we use {0}*40 as old id */\n\tgit_reference_name_to_id(&old_id, backend->repo, ref->name);\n\n\tif ((error = git_reference_lookup(&head, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\treturn error;\n\n\tif (git_reference_type(head) == GIT_REF_OID)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&tmp, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* Go down the symref chain until we find the branch */\n\twhile (git_reference_type(tmp) == GIT_REF_SYMBOLIC) {\n\t\terror = git_reference_lookup(&peeled, backend->repo, git_reference_symbolic_target(tmp));\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\tgit_reference_free(tmp);\n\t\ttmp = peeled;\n\t}\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = 0;\n\t\tname = git_reference_symbolic_target(tmp);\n\t} else if (error < 0) {\n\t\tgoto cleanup;\n\t} else {\n\t\tname = git_reference_name(tmp);\n\t}\n\n\tif (strcmp(name, ref->name))\n\t\tgoto cleanup;\n\n\terror = reflog_append(backend, head, &old_id, git_reference_target(ref), who, message);\n\ncleanup:\n\tgit_reference_free(tmp);\n\tgit_reference_free(head);\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "head"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reflog_append",
          "args": [
            "backend",
            "head",
            "&old_id",
            "git_reference_target(ref)",
            "who",
            "message"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "reflog_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1735-1811",
          "snippet": "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *who, const char *message)\n{\n\tint error, is_symbolic;\n\tgit_oid old_id = {{0}}, new_id = {{0}};\n\tgit_buf buf = GIT_BUF_INIT, path = GIT_BUF_INIT;\n\tgit_repository *repo = backend->repo;\n\n\tis_symbolic = ref->type == GIT_REF_SYMBOLIC;\n\n\t/* \"normal\" symbolic updates do not write */\n\tif (is_symbolic &&\n\t    strcmp(ref->name, GIT_HEAD_FILE) &&\n\t    !(old && new))\n\t\treturn 0;\n\n\t/* From here on is_symoblic also means that it's HEAD */\n\n\tif (old) {\n\t\tgit_oid_cpy(&old_id, old);\n\t} else {\n\t\terror = git_reference_name_to_id(&old_id, repo, ref->name);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t}\n\n\tif (new) {\n\t\tgit_oid_cpy(&new_id, new);\n\t} else {\n\t\tif (!is_symbolic) {\n\t\t\tgit_oid_cpy(&new_id, git_reference_target(ref));\n\t\t} else {\n\t\t\terror = git_reference_name_to_id(&new_id, repo, git_reference_symbolic_target(ref));\n\t\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\t/* detaching HEAD does not create an entry */\n\t\t\tif (error == GIT_ENOTFOUND)\n\t\t\t\treturn 0;\n\n\t\t\tgiterr_clear();\n\t\t}\n\t}\n\n\tif ((error = serialize_reflog_entry(&buf, &old_id, &new_id, who, message)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = retrieve_reflog_path(&path, repo, ref->name)) < 0)\n\t\tgoto cleanup;\n\n\tif (((error = git_futils_mkpath2file(git_buf_cstr(&path), 0777)) < 0) &&\n\t    (error != GIT_EEXISTS)) {\n\t\tgoto cleanup;\n\t}\n\n\t/* If the new branch matches part of the namespace of a previously deleted branch,\n\t * there maybe an obsolete/unused directory (or directory hierarchy) in the way.\n\t */\n\tif (git_path_isdir(git_buf_cstr(&path))) {\n\t\tif ((git_futils_rmdir_r(git_buf_cstr(&path), NULL, GIT_RMDIR_SKIP_NONEMPTY) < 0))\n\t\t\terror = -1;\n\t\telse if (git_path_isdir(git_buf_cstr(&path))) {\n\t\t\tgiterr_set(GITERR_REFERENCE, \"cannot create reflog at '%s', there are reflogs beneath that folder\",\n\t\t\t\tref->name);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t}\n\n\t\tif (error != 0)\n\t\t\tgoto cleanup;\n\t}\n\n\terror = git_futils_writebuffer(&buf, git_buf_cstr(&path), O_WRONLY|O_CREAT|O_APPEND, GIT_REFLOG_FILE_MODE);\n\ncleanup:\n\tgit_buf_free(&buf);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_target",
          "args": [
            "ref"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_target_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "331-339",
          "snippet": "const git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst git_oid *git_reference_target_peel(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_OID || git_oid_iszero(&ref->peel))\n\t\treturn NULL;\n\n\treturn &ref->peel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "ref->name"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name",
          "args": [
            "tmp"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "309-313",
          "snippet": "const char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_name(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_symbolic_target",
          "args": [
            "tmp"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_symbolic_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "341-349",
          "snippet": "const char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nconst char *git_reference_symbolic_target(const git_reference *ref)\n{\n\tassert(ref);\n\n\tif (ref->type != GIT_REF_SYMBOLIC)\n\t\treturn NULL;\n\n\treturn ref->target.symbolic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_lookup",
          "args": [
            "&peeled",
            "backend->repo",
            "git_reference_symbolic_target(tmp)"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "146-150",
          "snippet": "int git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_lookup(git_reference **ref_out,\n\tgit_repository *repo, const char *name)\n{\n\treturn git_reference_lookup_resolved(ref_out, repo, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_type",
          "args": [
            "tmp"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "303-307",
          "snippet": "git_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_ref_t git_reference_type(const git_reference *ref)\n{\n\tassert(ref);\n\treturn ref->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference_name_to_id",
          "args": [
            "&old_id",
            "backend->repo",
            "ref->name"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_name_to_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "152-164",
          "snippet": "int git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nint git_reference_name_to_id(\n\tgit_oid *out, git_repository *repo, const char *name)\n{\n\tint error;\n\tgit_reference *ref;\n\n\tif ((error = git_reference_lookup_resolved(&ref, repo, name, -1)) < 0)\n\t\treturn error;\n\n\tgit_oid_cpy(out, git_reference_target(ref));\n\tgit_reference_free(ref);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int maybe_append_head(refdb_fs_backend *backend, const git_reference *ref, const git_signature *who, const char *message)\n{\n\tint error;\n\tgit_oid old_id = {{0}};\n\tgit_reference *tmp = NULL, *head = NULL, *peeled = NULL;\n\tconst char *name;\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\treturn 0;\n\n\t/* if we can't resolve, we use {0}*40 as old id */\n\tgit_reference_name_to_id(&old_id, backend->repo, ref->name);\n\n\tif ((error = git_reference_lookup(&head, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\treturn error;\n\n\tif (git_reference_type(head) == GIT_REF_OID)\n\t\tgoto cleanup;\n\n\tif ((error = git_reference_lookup(&tmp, backend->repo, GIT_HEAD_FILE)) < 0)\n\t\tgoto cleanup;\n\n\t/* Go down the symref chain until we find the branch */\n\twhile (git_reference_type(tmp) == GIT_REF_SYMBOLIC) {\n\t\terror = git_reference_lookup(&peeled, backend->repo, git_reference_symbolic_target(tmp));\n\t\tif (error < 0)\n\t\t\tbreak;\n\n\t\tgit_reference_free(tmp);\n\t\ttmp = peeled;\n\t}\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = 0;\n\t\tname = git_reference_symbolic_target(tmp);\n\t} else if (error < 0) {\n\t\tgoto cleanup;\n\t} else {\n\t\tname = git_reference_name(tmp);\n\t}\n\n\tif (strcmp(name, ref->name))\n\t\tgoto cleanup;\n\n\terror = reflog_append(backend, head, &old_id, git_reference_target(ref), who, message);\n\ncleanup:\n\tgit_reference_free(tmp);\n\tgit_reference_free(head);\n\treturn error;\n}"
  },
  {
    "function_name": "cmp_old_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1029-1063",
    "snippet": "static int cmp_old_ref(int *cmp, git_refdb_backend *backend, const char *name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\tint error = 0;\n\tgit_reference *old_ref = NULL;\n\n\t*cmp = 0;\n\t/* It \"matches\" if there is no old value to compare against */\n\tif (!old_id && !old_target)\n\t\treturn 0;\n\n\tif ((error = refdb_fs_backend__lookup(&old_ref, backend, name)) < 0)\n\t\tgoto out;\n\n\t/* If the types don't match, there's no way the values do */\n\tif (old_id && old_ref->type != GIT_REF_OID) {\n\t\t*cmp = -1;\n\t\tgoto out;\n\t}\n\tif (old_target && old_ref->type != GIT_REF_SYMBOLIC) {\n\t\t*cmp = 1;\n\t\tgoto out;\n\t}\n\n\tif (old_id && old_ref->type == GIT_REF_OID)\n\t\t*cmp = git_oid_cmp(old_id, &old_ref->target.oid);\n\n\tif (old_target && old_ref->type == GIT_REF_SYMBOLIC)\n\t\t*cmp = git__strcmp(old_target, old_ref->target.symbolic);\n\nout:\n\tgit_reference_free(old_ref);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
      "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference_free",
          "args": [
            "old_ref"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "108-120",
          "snippet": "void git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nvoid git_reference_free(git_reference *reference)\n{\n\tif (reference == NULL)\n\t\treturn;\n\n\tif (reference->type == GIT_REF_SYMBOLIC)\n\t\tgit__free(reference->target.symbolic);\n\n\tif (reference->db)\n\t\tGIT_REFCOUNT_DEC(reference->db, git_refdb__free);\n\n\tgit__free(reference);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "old_target",
            "old_ref->target.symbolic"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cmp",
          "args": [
            "old_id",
            "&old_ref->target.oid"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "179-182",
          "snippet": "int git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__cmp(a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_fs_backend__lookup",
          "args": [
            "&old_ref",
            "backend",
            "name"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "432-453",
          "snippet": "static int refdb_fs_backend__lookup(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error;\n\n\tassert(backend);\n\n\tif (!(error = loose_lookup(out, backend, ref_name)))\n\t\treturn 0;\n\n\t/* only try to lookup this reference on the packfile if it\n\t * wasn't found on the loose refs; not if there was a critical error */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = packed_lookup(out, backend, ref_name);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__lookup(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error;\n\n\tassert(backend);\n\n\tif (!(error = loose_lookup(out, backend, ref_name)))\n\t\treturn 0;\n\n\t/* only try to lookup this reference on the packfile if it\n\t * wasn't found on the loose refs; not if there was a critical error */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = packed_lookup(out, backend, ref_name);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int cmp_old_ref(int *cmp, git_refdb_backend *backend, const char *name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\tint error = 0;\n\tgit_reference *old_ref = NULL;\n\n\t*cmp = 0;\n\t/* It \"matches\" if there is no old value to compare against */\n\tif (!old_id && !old_target)\n\t\treturn 0;\n\n\tif ((error = refdb_fs_backend__lookup(&old_ref, backend, name)) < 0)\n\t\tgoto out;\n\n\t/* If the types don't match, there's no way the values do */\n\tif (old_id && old_ref->type != GIT_REF_OID) {\n\t\t*cmp = -1;\n\t\tgoto out;\n\t}\n\tif (old_target && old_ref->type != GIT_REF_SYMBOLIC) {\n\t\t*cmp = 1;\n\t\tgoto out;\n\t}\n\n\tif (old_id && old_ref->type == GIT_REF_OID)\n\t\t*cmp = git_oid_cmp(old_id, &old_ref->target.oid);\n\n\tif (old_target && old_ref->type == GIT_REF_SYMBOLIC)\n\t\t*cmp = git__strcmp(old_target, old_ref->target.symbolic);\n\nout:\n\tgit_reference_free(old_ref);\n\n\treturn error;\n}"
  },
  {
    "function_name": "should_write_reflog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "1001-1027",
    "snippet": "static int should_write_reflog(int *write, git_repository *repo, const char *name)\n{\n\tint error, logall;\n\n\terror = git_repository__cvar(&logall, repo, GIT_CVAR_LOGALLREFUPDATES);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* Defaults to the opposite of the repo being bare */\n\tif (logall == GIT_LOGALLREFUPDATES_UNSET)\n\t\tlogall = !git_repository_is_bare(repo);\n\n\tif (!logall) {\n\t\t*write = 0;\n\t} else if (has_reflog(repo, name)) {\n\t\t*write = 1;\n\t} else if (!git__prefixcmp(name, GIT_REFS_HEADS_DIR) ||\n\t\t   !git__strcmp(name, GIT_HEAD_FILE) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_REMOTES_DIR) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_NOTES_DIR)) {\n\t\t*write = 1;\n\t} else {\n\t\t*write = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "name",
            "GIT_REFS_NOTES_DIR"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "name",
            "GIT_HEAD_FILE"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_reflog",
          "args": [
            "repo",
            "name"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "has_reflog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1562-1575",
          "snippet": "static int has_reflog(git_repository *repo, const char *name)\n{\n\tint ret = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (retrieve_reflog_path(&path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\tret = git_path_isfile(git_buf_cstr(&path));\n\ncleanup:\n\tgit_buf_free(&path);\n\treturn ret;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int has_reflog(git_repository *repo, const char *name)\n{\n\tint ret = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\n\tif (retrieve_reflog_path(&path, repo, name) < 0)\n\t\tgoto cleanup;\n\n\tret = git_path_isfile(git_buf_cstr(&path));\n\ncleanup:\n\tgit_buf_free(&path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_is_bare",
          "args": [
            "repo"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_is_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1882-1886",
          "snippet": "int git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_is_bare(git_repository *repo)\n{\n\tassert(repo);\n\treturn repo->is_bare;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&logall",
            "repo",
            "GIT_CVAR_LOGALLREFUPDATES"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int should_write_reflog(int *write, git_repository *repo, const char *name)\n{\n\tint error, logall;\n\n\terror = git_repository__cvar(&logall, repo, GIT_CVAR_LOGALLREFUPDATES);\n\tif (error < 0)\n\t\treturn error;\n\n\t/* Defaults to the opposite of the repo being bare */\n\tif (logall == GIT_LOGALLREFUPDATES_UNSET)\n\t\tlogall = !git_repository_is_bare(repo);\n\n\tif (!logall) {\n\t\t*write = 0;\n\t} else if (has_reflog(repo, name)) {\n\t\t*write = 1;\n\t} else if (!git__prefixcmp(name, GIT_REFS_HEADS_DIR) ||\n\t\t   !git__strcmp(name, GIT_HEAD_FILE) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_REMOTES_DIR) ||\n\t\t   !git__prefixcmp(name, GIT_REFS_NOTES_DIR)) {\n\t\t*write = 1;\n\t} else {\n\t\t*write = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "packed_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "943-995",
    "snippet": "static int packed_write(refdb_fs_backend *backend)\n{\n\tgit_sortedcache *refcache = backend->refcache;\n\tgit_filebuf pack_file = GIT_FILEBUF_INIT;\n\tsize_t i;\n\n\t/* lock the cache to updates while we do this */\n\tif (git_sortedcache_wlock(refcache) < 0)\n\t\treturn -1;\n\n\t/* Open the file! */\n\tif (git_filebuf_open(&pack_file, git_sortedcache_path(refcache), 0, GIT_PACKEDREFS_FILE_MODE) < 0)\n\t\tgoto fail;\n\n\t/* Packfiles have a header... apparently\n\t * This is in fact not required, but we might as well print it\n\t * just for kicks */\n\tif (git_filebuf_printf(&pack_file, \"%s\\n\", GIT_PACKEDREFS_HEADER) < 0)\n\t\tgoto fail;\n\n\tfor (i = 0; i < git_sortedcache_entrycount(refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(refcache, i);\n\t\tassert(ref);\n\n\t\tif (packed_find_peel(backend, ref) < 0)\n\t\t\tgoto fail;\n\n\t\tif (packed_write_ref(ref, &pack_file) < 0)\n\t\t\tgoto fail;\n\t}\n\n\t/* if we've written all the references properly, we can commit\n\t * the packfile to make the changes effective */\n\tif (git_filebuf_commit(&pack_file) < 0)\n\t\tgoto fail;\n\n\t/* when and only when the packfile has been properly written,\n\t * we can go ahead and remove the loose refs */\n\tif (packed_remove_loose(backend) < 0)\n\t\tgoto fail;\n\n\tgit_sortedcache_updated(refcache);\n\tgit_sortedcache_wunlock(refcache);\n\n\t/* we're good now */\n\treturn 0;\n\nfail:\n\tgit_filebuf_cleanup(&pack_file);\n\tgit_sortedcache_wunlock(refcache);\n\n\treturn -1;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "refcache"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "&pack_file"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_updated",
          "args": [
            "refcache"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_updated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "236-240",
          "snippet": "void git_sortedcache_updated(git_sortedcache *sc)\n{\n\t/* update filestamp to latest value */\n\tgit_futils_filestamp_check(&sc->stamp, sc->path);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_updated(git_sortedcache *sc)\n{\n\t/* update filestamp to latest value */\n\tgit_futils_filestamp_check(&sc->stamp, sc->path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_remove_loose",
          "args": [
            "backend"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "packed_remove_loose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "901-938",
          "snippet": "static int packed_remove_loose(refdb_fs_backend *backend)\n{\n\tsize_t i;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tint failed = 0;\n\n\t/* backend->refcache is already locked when this is called */\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (!ref || !(ref->flags & PACKREF_WAS_LOOSE))\n\t\t\tcontinue;\n\n\t\tif (git_buf_joinpath(&full_path, backend->path, ref->name) < 0)\n\t\t\treturn -1; /* critical; do not try to recover on oom */\n\n\t\tif (git_path_exists(full_path.ptr) && p_unlink(full_path.ptr) < 0) {\n\t\t\tif (failed)\n\t\t\t\tcontinue;\n\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to remove loose reference '%s' after packing: %s\",\n\t\t\t\tfull_path.ptr, strerror(errno));\n\t\t\tfailed = 1;\n\t\t}\n\n\t\t/*\n\t\t * if we fail to remove a single file, this is *not* good,\n\t\t * but we should keep going and remove as many as possible.\n\t\t * After we've removed as many files as possible, we return\n\t\t * the error code anyway.\n\t\t */\n\t}\n\n\tgit_buf_free(&full_path);\n\treturn failed ? -1 : 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_remove_loose(refdb_fs_backend *backend)\n{\n\tsize_t i;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tint failed = 0;\n\n\t/* backend->refcache is already locked when this is called */\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (!ref || !(ref->flags & PACKREF_WAS_LOOSE))\n\t\t\tcontinue;\n\n\t\tif (git_buf_joinpath(&full_path, backend->path, ref->name) < 0)\n\t\t\treturn -1; /* critical; do not try to recover on oom */\n\n\t\tif (git_path_exists(full_path.ptr) && p_unlink(full_path.ptr) < 0) {\n\t\t\tif (failed)\n\t\t\t\tcontinue;\n\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to remove loose reference '%s' after packing: %s\",\n\t\t\t\tfull_path.ptr, strerror(errno));\n\t\t\tfailed = 1;\n\t\t}\n\n\t\t/*\n\t\t * if we fail to remove a single file, this is *not* good,\n\t\t * but we should keep going and remove as many as possible.\n\t\t * After we've removed as many files as possible, we return\n\t\t * the error code anyway.\n\t\t */\n\t}\n\n\tgit_buf_free(&full_path);\n\treturn failed ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&pack_file"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_write_ref",
          "args": [
            "ref",
            "&pack_file"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "packed_write_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "861-888",
          "snippet": "static int packed_write_ref(struct packref *ref, git_filebuf *file)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tgit_oid_nfmt(oid, sizeof(oid), &ref->oid);\n\n\t/*\n\t * For references that peel to an object in the repo, we must\n\t * write the resulting peel on a separate line, e.g.\n\t *\n\t *\t6fa8a902cc1d18527e1355773c86721945475d37 refs/tags/libgit2-0.4\n\t *\t^2ec0cb7959b0bf965d54f95453f5b4b34e8d3100\n\t *\n\t * This obviously only applies to tags.\n\t * The required peels have already been loaded into `ref->peel_target`.\n\t */\n\tif (ref->flags & PACKREF_HAS_PEEL) {\n\t\tchar peel[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(peel, sizeof(peel), &ref->peel);\n\n\t\tif (git_filebuf_printf(file, \"%s %s\\n^%s\\n\", oid, ref->name, peel) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\tif (git_filebuf_printf(file, \"%s %s\\n\", oid, ref->name) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_write_ref(struct packref *ref, git_filebuf *file)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tgit_oid_nfmt(oid, sizeof(oid), &ref->oid);\n\n\t/*\n\t * For references that peel to an object in the repo, we must\n\t * write the resulting peel on a separate line, e.g.\n\t *\n\t *\t6fa8a902cc1d18527e1355773c86721945475d37 refs/tags/libgit2-0.4\n\t *\t^2ec0cb7959b0bf965d54f95453f5b4b34e8d3100\n\t *\n\t * This obviously only applies to tags.\n\t * The required peels have already been loaded into `ref->peel_target`.\n\t */\n\tif (ref->flags & PACKREF_HAS_PEEL) {\n\t\tchar peel[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(peel, sizeof(peel), &ref->peel);\n\n\t\tif (git_filebuf_printf(file, \"%s %s\\n^%s\\n\", oid, ref->name, peel) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\tif (git_filebuf_printf(file, \"%s %s\\n\", oid, ref->name) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_find_peel",
          "args": [
            "backend",
            "ref"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "packed_find_peel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "820-856",
          "snippet": "static int packed_find_peel(refdb_fs_backend *backend, struct packref *ref)\n{\n\tgit_object *object;\n\n\tif (ref->flags & PACKREF_HAS_PEEL || ref->flags & PACKREF_CANNOT_PEEL)\n\t\treturn 0;\n\n\t/*\n\t * Find the tagged object in the repository\n\t */\n\tif (git_object_lookup(&object, backend->repo, &ref->oid, GIT_OBJ_ANY) < 0)\n\t\treturn -1;\n\n\t/*\n\t * If the tagged object is a Tag object, we need to resolve it;\n\t * if the ref is actually a 'weak' ref, we don't need to resolve\n\t * anything.\n\t */\n\tif (git_object_type(object) == GIT_OBJ_TAG) {\n\t\tgit_tag *tag = (git_tag *)object;\n\n\t\t/*\n\t\t * Find the object pointed at by this tag\n\t\t */\n\t\tgit_oid_cpy(&ref->peel, git_tag_target_id(tag));\n\t\tref->flags |= PACKREF_HAS_PEEL;\n\n\t\t/*\n\t\t * The reference has now cached the resolved OID, and is\n\t\t * marked at such. When written to the packfile, it'll be\n\t\t * accompanied by this resolved oid\n\t\t */\n\t}\n\n\tgit_object_free(object);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_find_peel(refdb_fs_backend *backend, struct packref *ref)\n{\n\tgit_object *object;\n\n\tif (ref->flags & PACKREF_HAS_PEEL || ref->flags & PACKREF_CANNOT_PEEL)\n\t\treturn 0;\n\n\t/*\n\t * Find the tagged object in the repository\n\t */\n\tif (git_object_lookup(&object, backend->repo, &ref->oid, GIT_OBJ_ANY) < 0)\n\t\treturn -1;\n\n\t/*\n\t * If the tagged object is a Tag object, we need to resolve it;\n\t * if the ref is actually a 'weak' ref, we don't need to resolve\n\t * anything.\n\t */\n\tif (git_object_type(object) == GIT_OBJ_TAG) {\n\t\tgit_tag *tag = (git_tag *)object;\n\n\t\t/*\n\t\t * Find the object pointed at by this tag\n\t\t */\n\t\tgit_oid_cpy(&ref->peel, git_tag_target_id(tag));\n\t\tref->flags |= PACKREF_HAS_PEEL;\n\n\t\t/*\n\t\t * The reference has now cached the resolved OID, and is\n\t\t * marked at such. When written to the packfile, it'll be\n\t\t * accompanied by this resolved oid\n\t\t */\n\t}\n\n\tgit_object_free(object);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ref"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entry",
          "args": [
            "refcache",
            "i"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "322-329",
          "snippet": "void *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entrycount",
          "args": [
            "refcache"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "316-319",
          "snippet": "size_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nsize_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "&pack_file",
            "\"%s\\n\"",
            "GIT_PACKEDREFS_HEADER"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&pack_file",
            "git_sortedcache_path(refcache)",
            "0",
            "GIT_PACKEDREFS_FILE_MODE"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_path",
          "args": [
            "refcache"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "57-60",
          "snippet": "const char *git_sortedcache_path(git_sortedcache *sc)\n{\n\treturn sc->path;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nconst char *git_sortedcache_path(git_sortedcache *sc)\n{\n\treturn sc->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wlock",
          "args": [
            "refcache"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "160-169",
          "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_write(refdb_fs_backend *backend)\n{\n\tgit_sortedcache *refcache = backend->refcache;\n\tgit_filebuf pack_file = GIT_FILEBUF_INIT;\n\tsize_t i;\n\n\t/* lock the cache to updates while we do this */\n\tif (git_sortedcache_wlock(refcache) < 0)\n\t\treturn -1;\n\n\t/* Open the file! */\n\tif (git_filebuf_open(&pack_file, git_sortedcache_path(refcache), 0, GIT_PACKEDREFS_FILE_MODE) < 0)\n\t\tgoto fail;\n\n\t/* Packfiles have a header... apparently\n\t * This is in fact not required, but we might as well print it\n\t * just for kicks */\n\tif (git_filebuf_printf(&pack_file, \"%s\\n\", GIT_PACKEDREFS_HEADER) < 0)\n\t\tgoto fail;\n\n\tfor (i = 0; i < git_sortedcache_entrycount(refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(refcache, i);\n\t\tassert(ref);\n\n\t\tif (packed_find_peel(backend, ref) < 0)\n\t\t\tgoto fail;\n\n\t\tif (packed_write_ref(ref, &pack_file) < 0)\n\t\t\tgoto fail;\n\t}\n\n\t/* if we've written all the references properly, we can commit\n\t * the packfile to make the changes effective */\n\tif (git_filebuf_commit(&pack_file) < 0)\n\t\tgoto fail;\n\n\t/* when and only when the packfile has been properly written,\n\t * we can go ahead and remove the loose refs */\n\tif (packed_remove_loose(backend) < 0)\n\t\tgoto fail;\n\n\tgit_sortedcache_updated(refcache);\n\tgit_sortedcache_wunlock(refcache);\n\n\t/* we're good now */\n\treturn 0;\n\nfail:\n\tgit_filebuf_cleanup(&pack_file);\n\tgit_sortedcache_wunlock(refcache);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "packed_remove_loose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "901-938",
    "snippet": "static int packed_remove_loose(refdb_fs_backend *backend)\n{\n\tsize_t i;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tint failed = 0;\n\n\t/* backend->refcache is already locked when this is called */\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (!ref || !(ref->flags & PACKREF_WAS_LOOSE))\n\t\t\tcontinue;\n\n\t\tif (git_buf_joinpath(&full_path, backend->path, ref->name) < 0)\n\t\t\treturn -1; /* critical; do not try to recover on oom */\n\n\t\tif (git_path_exists(full_path.ptr) && p_unlink(full_path.ptr) < 0) {\n\t\t\tif (failed)\n\t\t\t\tcontinue;\n\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to remove loose reference '%s' after packing: %s\",\n\t\t\t\tfull_path.ptr, strerror(errno));\n\t\t\tfailed = 1;\n\t\t}\n\n\t\t/*\n\t\t * if we fail to remove a single file, this is *not* good,\n\t\t * but we should keep going and remove as many as possible.\n\t\t * After we've removed as many files as possible, we return\n\t\t * the error code anyway.\n\t\t */\n\t}\n\n\tgit_buf_free(&full_path);\n\treturn failed ? -1 : 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&full_path"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Failed to remove loose reference '%s' after packing: %s\"",
            "full_path.ptr",
            "strerror(errno)"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "p_gai_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/posix.c",
          "lines": "94-101",
          "snippet": "const char *p_gai_strerror(int ret)\n{\n\tswitch(ret) {\n\tcase -1: return \"Out of memory\"; break;\n\tcase -2: return \"Address lookup failed\"; break;\n\tdefault: return \"Unknown error\"; break;\n\t}\n}",
          "includes": [
            "#include \"map.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"path.h\"",
            "#include \"posix.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"path.h\"\n#include \"posix.h\"\n#include \"common.h\"\n\nconst char *p_gai_strerror(int ret)\n{\n\tswitch(ret) {\n\tcase -1: return \"Out of memory\"; break;\n\tcase -2: return \"Address lookup failed\"; break;\n\tdefault: return \"Unknown error\"; break;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_unlink",
          "args": [
            "full_path.ptr"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "p_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "92-110",
          "snippet": "int p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_unlink(const char *path)\n{\n\tgit_win32_path buf;\n\tint error;\n\n\tif (git_win32_path_from_utf8(buf, path) < 0)\n\t\treturn -1;\n\n\terror = _wunlink(buf);\n\n\t/* If the file could not be deleted because it was\n\t * read-only, clear the bit and try again */\n\tif (error == -1 && errno == EACCES) {\n\t\t_wchmod(buf, 0666);\n\t\terror = _wunlink(buf);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_exists",
          "args": [
            "full_path.ptr"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "503-507",
          "snippet": "bool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_exists(const char *path)\n{\n\tassert(path);\n\treturn p_access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&full_path",
            "backend->path",
            "ref->name"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entry",
          "args": [
            "backend->refcache",
            "i"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "322-329",
          "snippet": "void *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entrycount",
          "args": [
            "backend->refcache"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "316-319",
          "snippet": "size_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nsize_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_remove_loose(refdb_fs_backend *backend)\n{\n\tsize_t i;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tint failed = 0;\n\n\t/* backend->refcache is already locked when this is called */\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (!ref || !(ref->flags & PACKREF_WAS_LOOSE))\n\t\t\tcontinue;\n\n\t\tif (git_buf_joinpath(&full_path, backend->path, ref->name) < 0)\n\t\t\treturn -1; /* critical; do not try to recover on oom */\n\n\t\tif (git_path_exists(full_path.ptr) && p_unlink(full_path.ptr) < 0) {\n\t\t\tif (failed)\n\t\t\t\tcontinue;\n\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to remove loose reference '%s' after packing: %s\",\n\t\t\t\tfull_path.ptr, strerror(errno));\n\t\t\tfailed = 1;\n\t\t}\n\n\t\t/*\n\t\t * if we fail to remove a single file, this is *not* good,\n\t\t * but we should keep going and remove as many as possible.\n\t\t * After we've removed as many files as possible, we return\n\t\t * the error code anyway.\n\t\t */\n\t}\n\n\tgit_buf_free(&full_path);\n\treturn failed ? -1 : 0;\n}"
  },
  {
    "function_name": "packed_write_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "861-888",
    "snippet": "static int packed_write_ref(struct packref *ref, git_filebuf *file)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tgit_oid_nfmt(oid, sizeof(oid), &ref->oid);\n\n\t/*\n\t * For references that peel to an object in the repo, we must\n\t * write the resulting peel on a separate line, e.g.\n\t *\n\t *\t6fa8a902cc1d18527e1355773c86721945475d37 refs/tags/libgit2-0.4\n\t *\t^2ec0cb7959b0bf965d54f95453f5b4b34e8d3100\n\t *\n\t * This obviously only applies to tags.\n\t * The required peels have already been loaded into `ref->peel_target`.\n\t */\n\tif (ref->flags & PACKREF_HAS_PEEL) {\n\t\tchar peel[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(peel, sizeof(peel), &ref->peel);\n\n\t\tif (git_filebuf_printf(file, \"%s %s\\n^%s\\n\", oid, ref->name, peel) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\tif (git_filebuf_printf(file, \"%s %s\\n\", oid, ref->name) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "file",
            "\"%s %s\\n\"",
            "oid",
            "ref->name"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_nfmt",
          "args": [
            "peel",
            "sizeof(peel)",
            "&ref->peel"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_nfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "66-86",
          "snippet": "void git_oid_nfmt(char *str, size_t n, const git_oid *oid)\n{\n\tsize_t i, max_i;\n\n\tif (!oid) {\n\t\tmemset(str, 0, n);\n\t\treturn;\n\t}\n\tif (n > GIT_OID_HEXSZ) {\n\t\tmemset(&str[GIT_OID_HEXSZ], 0, n - GIT_OID_HEXSZ);\n\t\tn = GIT_OID_HEXSZ;\n\t}\n\n\tmax_i = n / 2;\n\n\tfor (i = 0; i < max_i; i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n\n\tif (n & 1)\n\t\t*str++ = to_hex[oid->id[i] >> 4];\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char to_hex[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nstatic char to_hex[] = \"0123456789abcdef\";\n\nvoid git_oid_nfmt(char *str, size_t n, const git_oid *oid)\n{\n\tsize_t i, max_i;\n\n\tif (!oid) {\n\t\tmemset(str, 0, n);\n\t\treturn;\n\t}\n\tif (n > GIT_OID_HEXSZ) {\n\t\tmemset(&str[GIT_OID_HEXSZ], 0, n - GIT_OID_HEXSZ);\n\t\tn = GIT_OID_HEXSZ;\n\t}\n\n\tmax_i = n / 2;\n\n\tfor (i = 0; i < max_i; i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n\n\tif (n & 1)\n\t\t*str++ = to_hex[oid->id[i] >> 4];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_write_ref(struct packref *ref, git_filebuf *file)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tgit_oid_nfmt(oid, sizeof(oid), &ref->oid);\n\n\t/*\n\t * For references that peel to an object in the repo, we must\n\t * write the resulting peel on a separate line, e.g.\n\t *\n\t *\t6fa8a902cc1d18527e1355773c86721945475d37 refs/tags/libgit2-0.4\n\t *\t^2ec0cb7959b0bf965d54f95453f5b4b34e8d3100\n\t *\n\t * This obviously only applies to tags.\n\t * The required peels have already been loaded into `ref->peel_target`.\n\t */\n\tif (ref->flags & PACKREF_HAS_PEEL) {\n\t\tchar peel[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(peel, sizeof(peel), &ref->peel);\n\n\t\tif (git_filebuf_printf(file, \"%s %s\\n^%s\\n\", oid, ref->name, peel) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\tif (git_filebuf_printf(file, \"%s %s\\n\", oid, ref->name) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "packed_find_peel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "820-856",
    "snippet": "static int packed_find_peel(refdb_fs_backend *backend, struct packref *ref)\n{\n\tgit_object *object;\n\n\tif (ref->flags & PACKREF_HAS_PEEL || ref->flags & PACKREF_CANNOT_PEEL)\n\t\treturn 0;\n\n\t/*\n\t * Find the tagged object in the repository\n\t */\n\tif (git_object_lookup(&object, backend->repo, &ref->oid, GIT_OBJ_ANY) < 0)\n\t\treturn -1;\n\n\t/*\n\t * If the tagged object is a Tag object, we need to resolve it;\n\t * if the ref is actually a 'weak' ref, we don't need to resolve\n\t * anything.\n\t */\n\tif (git_object_type(object) == GIT_OBJ_TAG) {\n\t\tgit_tag *tag = (git_tag *)object;\n\n\t\t/*\n\t\t * Find the object pointed at by this tag\n\t\t */\n\t\tgit_oid_cpy(&ref->peel, git_tag_target_id(tag));\n\t\tref->flags |= PACKREF_HAS_PEEL;\n\n\t\t/*\n\t\t * The reference has now cached the resolved OID, and is\n\t\t * marked at such. When written to the packfile, it'll be\n\t\t * accompanied by this resolved oid\n\t\t */\n\t}\n\n\tgit_object_free(object);\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_object_free",
          "args": [
            "object"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "201-207",
          "snippet": "void git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_object_free(git_object *object)\n{\n\tif (object == NULL)\n\t\treturn;\n\n\tgit_cached_obj_decref(object);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ref->peel",
            "git_tag_target_id(tag)"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tag_target_id",
          "args": [
            "tag"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "git_tag_target_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tag.c",
          "lines": "33-37",
          "snippet": "const git_oid *git_tag_target_id(const git_tag *t)\n{\n\tassert(t);\n\treturn &t->target;\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_oid *git_tag_target_id(const git_tag *t)\n{\n\tassert(t);\n\treturn &t->target;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_type",
          "args": [
            "object"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_typeisloose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "249-255",
          "snippet": "int git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nstatic git_object_def git_objects_table[] = {\n\t/* 0 = GIT_OBJ__EXT1 */\n\t{ \"\", 0, NULL, NULL },\n\n\t/* 1 = GIT_OBJ_COMMIT */\n\t{ \"commit\", sizeof(git_commit), git_commit__parse, git_commit__free },\n\n\t/* 2 = GIT_OBJ_TREE */\n\t{ \"tree\", sizeof(git_tree), git_tree__parse, git_tree__free },\n\n\t/* 3 = GIT_OBJ_BLOB */\n\t{ \"blob\", sizeof(git_blob), git_blob__parse, git_blob__free },\n\n\t/* 4 = GIT_OBJ_TAG */\n\t{ \"tag\", sizeof(git_tag), git_tag__parse, git_tag__free },\n\n\t/* 5 = GIT_OBJ__EXT2 */\n\t{ \"\", 0, NULL, NULL },\n\t/* 6 = GIT_OBJ_OFS_DELTA */\n\t{ \"OFS_DELTA\", 0, NULL, NULL },\n\t/* 7 = GIT_OBJ_REF_DELTA */\n\t{ \"REF_DELTA\", 0, NULL, NULL },\n};\n\nint git_object_typeisloose(git_otype type)\n{\n\tif (type < 0 || ((size_t) type) >= ARRAY_SIZE(git_objects_table))\n\t\treturn 0;\n\n\treturn (git_objects_table[type].size > 0) ? 1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_lookup",
          "args": [
            "&object",
            "backend->repo",
            "&ref->oid",
            "GIT_OBJ_ANY"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_lookup_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "390-423",
          "snippet": "int git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_lookup_bypath(\n\t\tgit_object **out,\n\t\tconst git_object *treeish,\n\t\tconst char *path,\n\t\tgit_otype type)\n{\n\tint error = -1;\n\tgit_tree *tree = NULL;\n\tgit_tree_entry *entry = NULL;\n\n\tassert(out && treeish && path);\n\n\tif ((error = git_object_peel((git_object**)&tree, treeish, GIT_OBJ_TREE)) < 0 ||\n\t\t (error = git_tree_entry_bypath(&entry, tree, path)) < 0)\n\t{\n\t\tgoto cleanup;\n\t}\n\n\tif (type != GIT_OBJ_ANY && git_tree_entry_type(entry) != type)\n\t{\n\t\tgiterr_set(GITERR_OBJECT,\n\t\t\t\t\"object at path '%s' is not of the asked-for type %d\",\n\t\t\t\tpath, type);\n\t\terror = GIT_EINVALIDSPEC;\n\t\tgoto cleanup;\n\t}\n\n\terror = git_tree_entry_to_object(out, git_object_owner(treeish), entry);\n\ncleanup:\n\tgit_tree_entry_free(entry);\n\tgit_tree_free(tree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_find_peel(refdb_fs_backend *backend, struct packref *ref)\n{\n\tgit_object *object;\n\n\tif (ref->flags & PACKREF_HAS_PEEL || ref->flags & PACKREF_CANNOT_PEEL)\n\t\treturn 0;\n\n\t/*\n\t * Find the tagged object in the repository\n\t */\n\tif (git_object_lookup(&object, backend->repo, &ref->oid, GIT_OBJ_ANY) < 0)\n\t\treturn -1;\n\n\t/*\n\t * If the tagged object is a Tag object, we need to resolve it;\n\t * if the ref is actually a 'weak' ref, we don't need to resolve\n\t * anything.\n\t */\n\tif (git_object_type(object) == GIT_OBJ_TAG) {\n\t\tgit_tag *tag = (git_tag *)object;\n\n\t\t/*\n\t\t * Find the object pointed at by this tag\n\t\t */\n\t\tgit_oid_cpy(&ref->peel, git_tag_target_id(tag));\n\t\tref->flags |= PACKREF_HAS_PEEL;\n\n\t\t/*\n\t\t * The reference has now cached the resolved OID, and is\n\t\t * marked at such. When written to the packfile, it'll be\n\t\t * accompanied by this resolved oid\n\t\t */\n\t}\n\n\tgit_object_free(object);\n\treturn 0;\n}"
  },
  {
    "function_name": "refdb_fs_backend__unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "795-810",
    "snippet": "static int refdb_fs_backend__unlock(git_refdb_backend *backend, void *payload, int success, int update_reflog,\n\t\t\t\t    const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tgit_filebuf *lock = (git_filebuf *) payload;\n\tint error = 0;\n\n\tif (success == 2)\n\t\terror = refdb_fs_backend__delete_tail(backend, lock, ref->name, NULL, NULL);\n\telse if (success)\n\t\terror = refdb_fs_backend__write_tail(backend, ref, lock, update_reflog, sig, message, NULL, NULL);\n\telse\n\t\tgit_filebuf_cleanup(lock);\n\n\tgit__free(lock);\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "lock"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_cleanup",
          "args": [
            "lock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "104-133",
          "snippet": "void git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nvoid git_filebuf_cleanup(git_filebuf *file)\n{\n\tif (file->fd_is_open && file->fd >= 0)\n\t\tp_close(file->fd);\n\n\tif (file->created_lock && !file->did_rename && file->path_lock && git_path_exists(file->path_lock))\n\t\tp_unlink(file->path_lock);\n\n\tif (file->compute_digest) {\n\t\tgit_hash_ctx_cleanup(&file->digest);\n\t\tfile->compute_digest = 0;\n\t}\n\n\tif (file->buffer)\n\t\tgit__free(file->buffer);\n\n\t/* use the presence of z_buf to decide if we need to deflateEnd */\n\tif (file->z_buf) {\n\t\tgit__free(file->z_buf);\n\t\tdeflateEnd(&file->zs);\n\t}\n\n\tif (file->path_original)\n\t\tgit__free(file->path_original);\n\tif (file->path_lock)\n\t\tgit__free(file->path_lock);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\tfile->fd = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_fs_backend__write_tail",
          "args": [
            "backend",
            "ref",
            "lock",
            "update_reflog",
            "sig",
            "message",
            "NULL",
            "NULL"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__write_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1157-1213",
          "snippet": "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error = 0, cmp = 0, should_write;\n\tconst char *new_target = NULL;\n\tconst git_oid *new_id = NULL;\n\n\tif ((error = cmp_old_ref(&cmp, _backend, ref->name, old_id, old_target)) < 0)\n\t\tgoto on_error;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto on_error;\n\t}\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\tnew_target = ref->target.symbolic;\n\telse\n\t\tnew_id = &ref->target.oid;\n\n\terror = cmp_old_ref(&cmp, _backend, ref->name, new_id, new_target);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* Don't update if we have the same value */\n\tif (!error && !cmp) {\n\t\terror = 0;\n\t\tgoto on_error; /* not really error */\n\t}\n\n\tif (update_reflog) {\n\t\tif ((error = should_write_reflog(&should_write, backend->repo, ref->name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (should_write) {\n\t\t\tif ((error = reflog_append(backend, ref, NULL, NULL, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t\tif ((error = maybe_append_head(backend, ref, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\treturn loose_commit(file, ref);\n\non_error:\n        git_filebuf_cleanup(file);\n        return error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);",
            "static int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error = 0, cmp = 0, should_write;\n\tconst char *new_target = NULL;\n\tconst git_oid *new_id = NULL;\n\n\tif ((error = cmp_old_ref(&cmp, _backend, ref->name, old_id, old_target)) < 0)\n\t\tgoto on_error;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto on_error;\n\t}\n\n\tif (ref->type == GIT_REF_SYMBOLIC)\n\t\tnew_target = ref->target.symbolic;\n\telse\n\t\tnew_id = &ref->target.oid;\n\n\terror = cmp_old_ref(&cmp, _backend, ref->name, new_id, new_target);\n\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\tgoto on_error;\n\n\t/* Don't update if we have the same value */\n\tif (!error && !cmp) {\n\t\terror = 0;\n\t\tgoto on_error; /* not really error */\n\t}\n\n\tif (update_reflog) {\n\t\tif ((error = should_write_reflog(&should_write, backend->repo, ref->name)) < 0)\n\t\t\tgoto on_error;\n\n\t\tif (should_write) {\n\t\t\tif ((error = reflog_append(backend, ref, NULL, NULL, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t\tif ((error = maybe_append_head(backend, ref, who, message)) < 0)\n\t\t\t\tgoto on_error;\n\t\t}\n\t}\n\n\treturn loose_commit(file, ref);\n\non_error:\n        git_filebuf_cleanup(file);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_fs_backend__delete_tail",
          "args": [
            "backend",
            "lock",
            "ref->name",
            "NULL",
            "NULL"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__delete_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "1237-1297",
          "snippet": "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf loose_path = GIT_BUF_INIT;\n\tsize_t pack_pos;\n\tint error = 0, cmp = 0;\n\tbool loose_deleted = 0;\n\n\terror = cmp_old_ref(&cmp, _backend, ref_name, old_id, old_target);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a loose reference exists, remove it from the filesystem */\n\tif (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\tif (git_path_isfile(loose_path.ptr)) {\n\t\terror = p_unlink(loose_path.ptr);\n\t\tloose_deleted = 1;\n\t}\n\n\tgit_buf_free(&loose_path);\n\n\tif (error != 0)\n\t\tgoto cleanup;\n\n\tif ((error = packed_reload(backend)) < 0)\n\t\tgoto cleanup;\n\n\t/* If a packed reference exists, remove it from the packfile and repack */\n\tif ((error = git_sortedcache_wlock(backend->refcache)) < 0)\n\t\tgoto cleanup;\n\n\tif (!(error = git_sortedcache_lookup_index(\n\t\t\t&pack_pos, backend->refcache, ref_name)))\n\t\terror = git_sortedcache_remove(backend->refcache, pack_pos);\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = loose_deleted ? 0 : ref_error_notfound(ref_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = packed_write(backend);\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);",
            "static int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__write_tail(\n\tgit_refdb_backend *_backend,\n\tconst git_reference *ref,\n\tgit_filebuf *file,\n\tint update_reflog,\n\tconst git_signature *who,\n\tconst char *message,\n\tconst git_oid *old_id,\n\tconst char *old_target);\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target);\n\nstatic int refdb_fs_backend__delete_tail(\n\tgit_refdb_backend *_backend,\n\tgit_filebuf *file,\n\tconst char *ref_name,\n\tconst git_oid *old_id, const char *old_target)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf loose_path = GIT_BUF_INIT;\n\tsize_t pack_pos;\n\tint error = 0, cmp = 0;\n\tbool loose_deleted = 0;\n\n\terror = cmp_old_ref(&cmp, _backend, ref_name, old_id, old_target);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (cmp) {\n\t\tgiterr_set(GITERR_REFERENCE, \"old reference value does not match\");\n\t\terror = GIT_EMODIFIED;\n\t\tgoto cleanup;\n\t}\n\n\t/* If a loose reference exists, remove it from the filesystem */\n\tif (git_buf_joinpath(&loose_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\tif (git_path_isfile(loose_path.ptr)) {\n\t\terror = p_unlink(loose_path.ptr);\n\t\tloose_deleted = 1;\n\t}\n\n\tgit_buf_free(&loose_path);\n\n\tif (error != 0)\n\t\tgoto cleanup;\n\n\tif ((error = packed_reload(backend)) < 0)\n\t\tgoto cleanup;\n\n\t/* If a packed reference exists, remove it from the packfile and repack */\n\tif ((error = git_sortedcache_wlock(backend->refcache)) < 0)\n\t\tgoto cleanup;\n\n\tif (!(error = git_sortedcache_lookup_index(\n\t\t\t&pack_pos, backend->refcache, ref_name)))\n\t\terror = git_sortedcache_remove(backend->refcache, pack_pos);\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\n\tif (error == GIT_ENOTFOUND) {\n\t\terror = loose_deleted ? 0 : ref_error_notfound(ref_name);\n\t\tgoto cleanup;\n\t}\n\n\terror = packed_write(backend);\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int reflog_append(refdb_fs_backend *backend, const git_reference *ref, const git_oid *old, const git_oid *new, const git_signature *author, const char *message);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__unlock(git_refdb_backend *backend, void *payload, int success, int update_reflog,\n\t\t\t\t    const git_reference *ref, const git_signature *sig, const char *message)\n{\n\tgit_filebuf *lock = (git_filebuf *) payload;\n\tint error = 0;\n\n\tif (success == 2)\n\t\terror = refdb_fs_backend__delete_tail(backend, lock, ref->name, NULL, NULL);\n\telse if (success)\n\t\terror = refdb_fs_backend__write_tail(backend, ref, lock, update_reflog, sig, message, NULL, NULL);\n\telse\n\t\tgit_filebuf_cleanup(lock);\n\n\tgit__free(lock);\n\treturn error;\n}"
  },
  {
    "function_name": "refdb_fs_backend__lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "761-777",
    "snippet": "static int refdb_fs_backend__lock(void **out, git_refdb_backend *_backend, const char *refname)\n{\n\tint error;\n\tgit_filebuf *lock;\n\trefdb_fs_backend *backend = (refdb_fs_backend *) _backend;\n\n\tlock = git__calloc(1, sizeof(git_filebuf));\n\tGITERR_CHECK_ALLOC(lock);\n\n\tif ((error = loose_lock(lock, backend, refname)) < 0) {\n\t\tgit__free(lock);\n\t\treturn error;\n\t}\n\n\t*out = lock;\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "lock"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lock",
          "args": [
            "lock",
            "backend",
            "refname"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "713-741",
          "snippet": "static int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "lock"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_filebuf)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__lock(void **out, git_refdb_backend *_backend, const char *refname)\n{\n\tint error;\n\tgit_filebuf *lock;\n\trefdb_fs_backend *backend = (refdb_fs_backend *) _backend;\n\n\tlock = git__calloc(1, sizeof(git_filebuf));\n\tGITERR_CHECK_ALLOC(lock);\n\n\tif ((error = loose_lock(lock, backend, refname)) < 0) {\n\t\tgit__free(lock);\n\t\treturn error;\n\t}\n\n\t*out = lock;\n\treturn 0;\n}"
  },
  {
    "function_name": "loose_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "743-759",
    "snippet": "static int loose_commit(git_filebuf *file, const git_reference *ref)\n{\n\tassert(file && ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tchar oid[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(oid, sizeof(oid), &ref->target.oid);\n\n\t\tgit_filebuf_printf(file, \"%s\\n\", oid);\n\t} else if (ref->type == GIT_REF_SYMBOLIC) {\n\t\tgit_filebuf_printf(file, GIT_SYMREF \"%s\\n\", ref->target.symbolic);\n\t} else {\n\t\tassert(0); /* don't let this happen */\n\t}\n\n\treturn git_filebuf_commit(file);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "file"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "file",
            "GIT_SYMREF \"%s\\n\"",
            "ref->target.symbolic"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_nfmt",
          "args": [
            "oid",
            "sizeof(oid)",
            "&ref->target.oid"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_nfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "66-86",
          "snippet": "void git_oid_nfmt(char *str, size_t n, const git_oid *oid)\n{\n\tsize_t i, max_i;\n\n\tif (!oid) {\n\t\tmemset(str, 0, n);\n\t\treturn;\n\t}\n\tif (n > GIT_OID_HEXSZ) {\n\t\tmemset(&str[GIT_OID_HEXSZ], 0, n - GIT_OID_HEXSZ);\n\t\tn = GIT_OID_HEXSZ;\n\t}\n\n\tmax_i = n / 2;\n\n\tfor (i = 0; i < max_i; i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n\n\tif (n & 1)\n\t\t*str++ = to_hex[oid->id[i] >> 4];\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char to_hex[] = \"0123456789abcdef\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nstatic char to_hex[] = \"0123456789abcdef\";\n\nvoid git_oid_nfmt(char *str, size_t n, const git_oid *oid)\n{\n\tsize_t i, max_i;\n\n\tif (!oid) {\n\t\tmemset(str, 0, n);\n\t\treturn;\n\t}\n\tif (n > GIT_OID_HEXSZ) {\n\t\tmemset(&str[GIT_OID_HEXSZ], 0, n - GIT_OID_HEXSZ);\n\t\tn = GIT_OID_HEXSZ;\n\t}\n\n\tmax_i = n / 2;\n\n\tfor (i = 0; i < max_i; i++)\n\t\tstr = fmt_one(str, oid->id[i]);\n\n\tif (n & 1)\n\t\t*str++ = to_hex[oid->id[i] >> 4];\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "file && ref"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_commit(git_filebuf *file, const git_reference *ref)\n{\n\tassert(file && ref);\n\n\tif (ref->type == GIT_REF_OID) {\n\t\tchar oid[GIT_OID_HEXSZ + 1];\n\t\tgit_oid_nfmt(oid, sizeof(oid), &ref->target.oid);\n\n\t\tgit_filebuf_printf(file, \"%s\\n\", oid);\n\t} else if (ref->type == GIT_REF_SYMBOLIC) {\n\t\tgit_filebuf_printf(file, GIT_SYMREF \"%s\\n\", ref->target.symbolic);\n\t} else {\n\t\tassert(0); /* don't let this happen */\n\t}\n\n\treturn git_filebuf_commit(file);\n}"
  },
  {
    "function_name": "loose_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "713-741",
    "snippet": "static int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_path"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"cannot lock ref '%s', there are refs beneath that folder\"",
            "name"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "file",
            "ref_path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_REFS_FILE_MODE"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&ref_path",
            "backend->path",
            "name"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_rmdir_r",
          "args": [
            "name",
            "backend->path",
            "GIT_RMDIR_SKIP_NONEMPTY"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_rmdir_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "753-784",
          "snippet": "int git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_rmdir_r(\n\tconst char *path, const char *base, uint32_t flags)\n{\n\tint error;\n\tgit_buf fullpath = GIT_BUF_INIT;\n\tfutils__rmdir_data data;\n\n\t/* build path and find \"root\" where we should start calling mkdir */\n\tif (git_path_join_unrooted(&fullpath, path, base, NULL) < 0)\n\t\treturn -1;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.base    = base ? base : \"\";\n\tdata.baselen = base ? strlen(base) : 0;\n\tdata.flags   = flags;\n\n\terror = futils__rmdir_recurs_foreach(&data, &fullpath);\n\n\t/* remove now-empty parents if requested */\n\tif (!error && (flags & GIT_RMDIR_EMPTY_PARENTS) != 0)\n\t\terror = git_path_walk_up(\n\t\t\t&fullpath, base, futils__rmdir_empty_parent, &data);\n\n\tif (error == GIT_ITEROVER) {\n\t\tgiterr_clear();\n\t\terror = 0;\n\t}\n\n\tgit_buf_free(&fullpath);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isvalid",
          "args": [
            "backend->repo",
            "name",
            "GIT_PATH_REJECT_FILESYSTEM_DEFAULTS"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1677-1701",
          "snippet": "bool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isvalid(\n\tgit_repository *repo,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tconst char *start, *c;\n\n\t/* Upgrade the \".git\" checks based on platform */\n\tif ((flags & GIT_PATH_REJECT_DOT_GIT))\n\t\tflags = dotgit_flags(repo, flags);\n\n\tfor (start = c = path; *c; c++) {\n\t\tif (!verify_char(*c, flags))\n\t\t\treturn false;\n\n\t\tif (*c == '/') {\n\t\t\tif (!verify_component(repo, start, (c - start), flags))\n\t\t\t\treturn false;\n\n\t\t\tstart = c+1;\n\t\t}\n\t}\n\n\treturn verify_component(repo, start, (c - start), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "file && backend && name"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lock(git_filebuf *file, refdb_fs_backend *backend, const char *name)\n{\n\tint error;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(file && backend && name);\n\n\tif (!git_path_isvalid(backend->repo, name, GIT_PATH_REJECT_FILESYSTEM_DEFAULTS)) {\n\t\tgiterr_set(GITERR_INVALID, \"Invalid reference name '%s'.\", name);\n\t\treturn GIT_EINVALIDSPEC;\n\t}\n\n\t/* Remove a possibly existing empty directory hierarchy\n\t * which name would collide with the reference name\n\t */\n\tif (git_futils_rmdir_r(name, backend->path, GIT_RMDIR_SKIP_NONEMPTY) < 0)\n\t\treturn -1;\n\n\tif (git_buf_joinpath(&ref_path, backend->path, name) < 0)\n\t\treturn -1;\n\n\terror = git_filebuf_open(file, ref_path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE);\n\n\tif (error == GIT_EDIRECTORY)\n\t\tgiterr_set(GITERR_REFERENCE, \"cannot lock ref '%s', there are refs beneath that folder\", name);\n\n\tgit_buf_free(&ref_path);\n\treturn error;\n}"
  },
  {
    "function_name": "reference_path_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "670-711",
    "snippet": "static int reference_path_available(\n\trefdb_fs_backend *backend,\n\tconst char *new_ref,\n\tconst char* old_ref,\n\tint force)\n{\n\tsize_t i;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (!force) {\n\t\tint exists;\n\n\t\tif (refdb_fs_backend__exists(\n\t\t\t\t&exists, (git_refdb_backend *)backend, new_ref) < 0)\n\t\t\treturn -1;\n\n\t\tif (exists) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to write reference '%s': a reference with \"\n\t\t\t\t\"that name already exists.\", new_ref);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\tgit_sortedcache_rlock(backend->refcache);\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (ref && !ref_is_available(old_ref, new_ref, ref->name)) {\n\t\t\tgit_sortedcache_runlock(backend->refcache);\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Path to reference '%s' collides with existing one\", new_ref);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_sortedcache_runlock",
          "args": [
            "backend->refcache"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_runlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "191-195",
          "snippet": "void git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Path to reference '%s' collides with existing one\"",
            "new_ref"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_is_available",
          "args": [
            "old_ref",
            "new_ref",
            "ref->name"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "ref_is_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "653-668",
          "snippet": "static bool ref_is_available(\n\tconst char *old_ref, const char *new_ref, const char *this_ref)\n{\n\tif (old_ref == NULL || strcmp(old_ref, this_ref)) {\n\t\tsize_t reflen = strlen(this_ref);\n\t\tsize_t newlen = strlen(new_ref);\n\t\tsize_t cmplen = reflen < newlen ? reflen : newlen;\n\t\tconst char *lead = reflen < newlen ? new_ref : this_ref;\n\n\t\tif (!strncmp(new_ref, this_ref, cmplen) && lead[cmplen] == '/') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic bool ref_is_available(\n\tconst char *old_ref, const char *new_ref, const char *this_ref)\n{\n\tif (old_ref == NULL || strcmp(old_ref, this_ref)) {\n\t\tsize_t reflen = strlen(this_ref);\n\t\tsize_t newlen = strlen(new_ref);\n\t\tsize_t cmplen = reflen < newlen ? reflen : newlen;\n\t\tconst char *lead = reflen < newlen ? new_ref : this_ref;\n\n\t\tif (!strncmp(new_ref, this_ref, cmplen) && lead[cmplen] == '/') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entry",
          "args": [
            "backend->refcache",
            "i"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "322-329",
          "snippet": "void *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entrycount",
          "args": [
            "backend->refcache"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "316-319",
          "snippet": "size_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nsize_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_rlock",
          "args": [
            "backend->refcache"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_rlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "179-188",
          "snippet": "int git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "refdb_fs_backend__exists",
          "args": [
            "&exists",
            "(git_refdb_backend *)backend",
            "new_ref"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "322-341",
          "snippet": "static int refdb_fs_backend__exists(\n\tint *exists,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0 ||\n\t\tgit_buf_joinpath(&ref_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\t*exists = git_path_isfile(ref_path.ptr) ||\n\t\t(git_sortedcache_lookup(backend->refcache, ref_name) != NULL);\n\n\tgit_buf_free(&ref_path);\n\treturn 0;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__exists(\n\tint *exists,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0 ||\n\t\tgit_buf_joinpath(&ref_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\t*exists = git_path_isfile(ref_path.ptr) ||\n\t\t(git_sortedcache_lookup(backend->refcache, ref_name) != NULL);\n\n\tgit_buf_free(&ref_path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_reload",
          "args": [
            "backend"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "packed_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "74-195",
          "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int reference_path_available(\n\trefdb_fs_backend *backend,\n\tconst char *new_ref,\n\tconst char* old_ref,\n\tint force)\n{\n\tsize_t i;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (!force) {\n\t\tint exists;\n\n\t\tif (refdb_fs_backend__exists(\n\t\t\t\t&exists, (git_refdb_backend *)backend, new_ref) < 0)\n\t\t\treturn -1;\n\n\t\tif (exists) {\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Failed to write reference '%s': a reference with \"\n\t\t\t\t\"that name already exists.\", new_ref);\n\t\t\treturn GIT_EEXISTS;\n\t\t}\n\t}\n\n\tgit_sortedcache_rlock(backend->refcache);\n\n\tfor (i = 0; i < git_sortedcache_entrycount(backend->refcache); ++i) {\n\t\tstruct packref *ref = git_sortedcache_entry(backend->refcache, i);\n\n\t\tif (ref && !ref_is_available(old_ref, new_ref, ref->name)) {\n\t\t\tgit_sortedcache_runlock(backend->refcache);\n\t\t\tgiterr_set(GITERR_REFERENCE,\n\t\t\t\t\"Path to reference '%s' collides with existing one\", new_ref);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\treturn 0;\n}"
  },
  {
    "function_name": "ref_is_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "653-668",
    "snippet": "static bool ref_is_available(\n\tconst char *old_ref, const char *new_ref, const char *this_ref)\n{\n\tif (old_ref == NULL || strcmp(old_ref, this_ref)) {\n\t\tsize_t reflen = strlen(this_ref);\n\t\tsize_t newlen = strlen(new_ref);\n\t\tsize_t cmplen = reflen < newlen ? reflen : newlen;\n\t\tconst char *lead = reflen < newlen ? new_ref : this_ref;\n\n\t\tif (!strncmp(new_ref, this_ref, cmplen) && lead[cmplen] == '/') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_ref",
            "this_ref",
            "cmplen"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "git__strncmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "205-212",
          "snippet": "int git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strncmp(const char *a, const char *b, size_t sz)\n{\n\twhile (sz && *a && *b && *a == *b)\n\t\t--sz, ++a, ++b;\n\tif (!sz)\n\t\treturn 0;\n\treturn (int)(*(const unsigned char *)a) - (int)(*(const unsigned char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "new_ref"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "this_ref"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "old_ref",
            "this_ref"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic bool ref_is_available(\n\tconst char *old_ref, const char *new_ref, const char *this_ref)\n{\n\tif (old_ref == NULL || strcmp(old_ref, this_ref)) {\n\t\tsize_t reflen = strlen(this_ref);\n\t\tsize_t newlen = strlen(new_ref);\n\t\tsize_t cmplen = reflen < newlen ? reflen : newlen;\n\t\tconst char *lead = reflen < newlen ? new_ref : this_ref;\n\n\t\tif (!strncmp(new_ref, this_ref, cmplen) && lead[cmplen] == '/') {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "refdb_fs_backend__iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "615-651",
    "snippet": "static int refdb_fs_backend__iterator(\n\tgit_reference_iterator **out, git_refdb_backend *_backend, const char *glob)\n{\n\trefdb_fs_iter *iter;\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\titer = git__calloc(1, sizeof(refdb_fs_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tgit_pool_init(&iter->pool, 1);\n\n\tif (git_vector_init(&iter->loose, 8, NULL) < 0)\n\t\tgoto fail;\n\n\tif (glob != NULL &&\n\t\t(iter->glob = git_pool_strdup(&iter->pool, glob)) == NULL)\n\t\tgoto fail;\n\n\titer->parent.next = refdb_fs_backend__iterator_next;\n\titer->parent.next_name = refdb_fs_backend__iterator_next_name;\n\titer->parent.free = refdb_fs_backend__iterator_free;\n\n\tif (iter_load_loose_paths(backend, iter) < 0)\n\t\tgoto fail;\n\n\t*out = (git_reference_iterator *)iter;\n\treturn 0;\n\nfail:\n\trefdb_fs_backend__iterator_free((git_reference_iterator *)iter);\n\treturn -1;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "refdb_fs_backend__iterator_free",
          "args": [
            "(git_reference_iterator *)iter"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "refdb_fs_backend__iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "468-476",
          "snippet": "static void refdb_fs_backend__iterator_free(git_reference_iterator *_iter)\n{\n\trefdb_fs_iter *iter = (refdb_fs_iter *) _iter;\n\n\tgit_vector_free(&iter->loose);\n\tgit_pool_clear(&iter->pool);\n\tgit_sortedcache_free(iter->cache);\n\tgit__free(iter);\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic void refdb_fs_backend__iterator_free(git_reference_iterator *_iter)\n{\n\trefdb_fs_iter *iter = (refdb_fs_iter *) _iter;\n\n\tgit_vector_free(&iter->loose);\n\tgit_pool_clear(&iter->pool);\n\tgit_sortedcache_free(iter->cache);\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_load_loose_paths",
          "args": [
            "backend",
            "iter"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "iter_load_loose_paths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "478-529",
          "snippet": "static int iter_load_loose_paths(refdb_fs_backend *backend, refdb_fs_iter *iter)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_iterator *fsit = NULL;\n\tgit_iterator_options fsit_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *entry = NULL;\n\n\tif (!backend->path) /* do nothing if no path for loose refs */\n\t\treturn 0;\n\n\tfsit_opts.flags = backend->iterator_flags;\n\n\tif ((error = git_buf_printf(&path, \"%s/refs\", backend->path)) < 0 ||\n\t\t(error = git_iterator_for_filesystem(&fsit, path.ptr, &fsit_opts)) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn error;\n\t}\n\n\terror = git_buf_sets(&path, GIT_REFS_DIR);\n\n\twhile (!error && !git_iterator_advance(&entry, fsit)) {\n\t\tconst char *ref_name;\n\t\tstruct packref *ref;\n\t\tchar *ref_dup;\n\n\t\tgit_buf_truncate(&path, strlen(GIT_REFS_DIR));\n\t\tgit_buf_puts(&path, entry->path);\n\t\tref_name = git_buf_cstr(&path);\n\n\t\tif (git__suffixcmp(ref_name, \".lock\") == 0 ||\n\t\t\t(iter->glob && p_fnmatch(iter->glob, ref_name, 0) != 0))\n\t\t\tcontinue;\n\n\t\tgit_sortedcache_rlock(backend->refcache);\n\t\tref = git_sortedcache_lookup(backend->refcache, ref_name);\n\t\tif (ref)\n\t\t\tref->flags |= PACKREF_SHADOWED;\n\t\tgit_sortedcache_runlock(backend->refcache);\n\n\t\tref_dup = git_pool_strdup(&iter->pool, ref_name);\n\t\tif (!ref_dup)\n\t\t\terror = -1;\n\t\telse\n\t\t\terror = git_vector_insert(&iter->loose, ref_dup);\n\t}\n\n\tgit_iterator_free(fsit);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int iter_load_loose_paths(refdb_fs_backend *backend, refdb_fs_iter *iter)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_iterator *fsit = NULL;\n\tgit_iterator_options fsit_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *entry = NULL;\n\n\tif (!backend->path) /* do nothing if no path for loose refs */\n\t\treturn 0;\n\n\tfsit_opts.flags = backend->iterator_flags;\n\n\tif ((error = git_buf_printf(&path, \"%s/refs\", backend->path)) < 0 ||\n\t\t(error = git_iterator_for_filesystem(&fsit, path.ptr, &fsit_opts)) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn error;\n\t}\n\n\terror = git_buf_sets(&path, GIT_REFS_DIR);\n\n\twhile (!error && !git_iterator_advance(&entry, fsit)) {\n\t\tconst char *ref_name;\n\t\tstruct packref *ref;\n\t\tchar *ref_dup;\n\n\t\tgit_buf_truncate(&path, strlen(GIT_REFS_DIR));\n\t\tgit_buf_puts(&path, entry->path);\n\t\tref_name = git_buf_cstr(&path);\n\n\t\tif (git__suffixcmp(ref_name, \".lock\") == 0 ||\n\t\t\t(iter->glob && p_fnmatch(iter->glob, ref_name, 0) != 0))\n\t\t\tcontinue;\n\n\t\tgit_sortedcache_rlock(backend->refcache);\n\t\tref = git_sortedcache_lookup(backend->refcache, ref_name);\n\t\tif (ref)\n\t\t\tref->flags |= PACKREF_SHADOWED;\n\t\tgit_sortedcache_runlock(backend->refcache);\n\n\t\tref_dup = git_pool_strdup(&iter->pool, ref_name);\n\t\tif (!ref_dup)\n\t\t\terror = -1;\n\t\telse\n\t\t\terror = git_vector_insert(&iter->loose, ref_dup);\n\t}\n\n\tgit_iterator_free(fsit);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&iter->pool",
            "glob"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&iter->loose",
            "8",
            "NULL"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&iter->pool",
            "1"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "iter"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(refdb_fs_iter)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_reload",
          "args": [
            "backend"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "packed_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "74-195",
          "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__iterator(\n\tgit_reference_iterator **out, git_refdb_backend *_backend, const char *glob)\n{\n\trefdb_fs_iter *iter;\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\titer = git__calloc(1, sizeof(refdb_fs_iter));\n\tGITERR_CHECK_ALLOC(iter);\n\n\tgit_pool_init(&iter->pool, 1);\n\n\tif (git_vector_init(&iter->loose, 8, NULL) < 0)\n\t\tgoto fail;\n\n\tif (glob != NULL &&\n\t\t(iter->glob = git_pool_strdup(&iter->pool, glob)) == NULL)\n\t\tgoto fail;\n\n\titer->parent.next = refdb_fs_backend__iterator_next;\n\titer->parent.next_name = refdb_fs_backend__iterator_next_name;\n\titer->parent.free = refdb_fs_backend__iterator_free;\n\n\tif (iter_load_loose_paths(backend, iter) < 0)\n\t\tgoto fail;\n\n\t*out = (git_reference_iterator *)iter;\n\treturn 0;\n\nfail:\n\trefdb_fs_backend__iterator_free((git_reference_iterator *)iter);\n\treturn -1;\n}"
  },
  {
    "function_name": "refdb_fs_backend__iterator_next_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "572-613",
    "snippet": "static int refdb_fs_backend__iterator_next_name(\n\tconst char **out, git_reference_iterator *_iter)\n{\n\tint error = GIT_ITEROVER;\n\trefdb_fs_iter *iter = (refdb_fs_iter *)_iter;\n\trefdb_fs_backend *backend = (refdb_fs_backend *)iter->parent.db->backend;\n\tstruct packref *ref;\n\n\twhile (iter->loose_pos < iter->loose.length) {\n\t\tconst char *path = git_vector_get(&iter->loose, iter->loose_pos++);\n\n\t\tif (loose_lookup(NULL, backend, path) == 0) {\n\t\t\t*out = path;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgiterr_clear();\n\t}\n\n\tif (!iter->cache) {\n\t\tif ((error = git_sortedcache_copy(&iter->cache, backend->refcache, 1, NULL, NULL)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = GIT_ITEROVER;\n\twhile (iter->packed_pos < git_sortedcache_entrycount(iter->cache)) {\n\t\tref = git_sortedcache_entry(iter->cache, iter->packed_pos++);\n\t\tif (!ref) /* stop now if another thread deleted refs and we past end */\n\t\t\tbreak;\n\n\t\tif (ref->flags & PACKREF_SHADOWED)\n\t\t\tcontinue;\n\t\tif (iter->glob && p_fnmatch(iter->glob, ref->name, 0) != 0)\n\t\t\tcontinue;\n\n\t\t*out = ref->name;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "iter->glob",
            "ref->name",
            "0"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entry",
          "args": [
            "iter->cache",
            "iter->packed_pos++"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "322-329",
          "snippet": "void *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entrycount",
          "args": [
            "iter->cache"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "316-319",
          "snippet": "size_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nsize_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_copy",
          "args": [
            "&iter->cache",
            "backend->refcache",
            "1",
            "NULL",
            "NULL"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "112-157",
          "snippet": "int git_sortedcache_copy(\n\tgit_sortedcache **out,\n\tgit_sortedcache *src,\n\tbool lock,\n\tint (*copy_item)(void *payload, void *tgt_item, void *src_item),\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_sortedcache *tgt;\n\tsize_t i;\n\tvoid *src_item, *tgt_item;\n\n\t/* just use memcpy if no special copy fn is passed in */\n\tif (!copy_item) {\n\t\tcopy_item = sortedcache_copy_item;\n\t\tpayload   = src;\n\t}\n\n\tif ((error = git_sortedcache_new(\n\t\t\t&tgt, src->item_path_offset,\n\t\t\tsrc->free_item, src->free_item_payload,\n\t\t\tsrc->items._cmp, src->path)) < 0)\n\t\treturn error;\n\n\tif (lock && git_sortedcache_rlock(src) < 0) {\n\t\tgit_sortedcache_free(tgt);\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&src->items, i, src_item) {\n\t\tchar *path = ((char *)src_item) + src->item_path_offset;\n\n\t\tif ((error = git_sortedcache_upsert(&tgt_item, tgt, path)) < 0 ||\n\t\t\t(error = copy_item(payload, tgt_item, src_item)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (lock)\n\t\tgit_sortedcache_runlock(src);\n\tif (error)\n\t\tgit_sortedcache_free(tgt);\n\n\t*out = !error ? tgt : NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_copy(\n\tgit_sortedcache **out,\n\tgit_sortedcache *src,\n\tbool lock,\n\tint (*copy_item)(void *payload, void *tgt_item, void *src_item),\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_sortedcache *tgt;\n\tsize_t i;\n\tvoid *src_item, *tgt_item;\n\n\t/* just use memcpy if no special copy fn is passed in */\n\tif (!copy_item) {\n\t\tcopy_item = sortedcache_copy_item;\n\t\tpayload   = src;\n\t}\n\n\tif ((error = git_sortedcache_new(\n\t\t\t&tgt, src->item_path_offset,\n\t\t\tsrc->free_item, src->free_item_payload,\n\t\t\tsrc->items._cmp, src->path)) < 0)\n\t\treturn error;\n\n\tif (lock && git_sortedcache_rlock(src) < 0) {\n\t\tgit_sortedcache_free(tgt);\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&src->items, i, src_item) {\n\t\tchar *path = ((char *)src_item) + src->item_path_offset;\n\n\t\tif ((error = git_sortedcache_upsert(&tgt_item, tgt, path)) < 0 ||\n\t\t\t(error = copy_item(payload, tgt_item, src_item)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (lock)\n\t\tgit_sortedcache_runlock(src);\n\tif (error)\n\t\tgit_sortedcache_free(tgt);\n\n\t*out = !error ? tgt : NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lookup",
          "args": [
            "NULL",
            "backend",
            "path"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "364-396",
          "snippet": "static int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&iter->loose",
            "iter->loose_pos++"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__iterator_next_name(\n\tconst char **out, git_reference_iterator *_iter)\n{\n\tint error = GIT_ITEROVER;\n\trefdb_fs_iter *iter = (refdb_fs_iter *)_iter;\n\trefdb_fs_backend *backend = (refdb_fs_backend *)iter->parent.db->backend;\n\tstruct packref *ref;\n\n\twhile (iter->loose_pos < iter->loose.length) {\n\t\tconst char *path = git_vector_get(&iter->loose, iter->loose_pos++);\n\n\t\tif (loose_lookup(NULL, backend, path) == 0) {\n\t\t\t*out = path;\n\t\t\treturn 0;\n\t\t}\n\n\t\tgiterr_clear();\n\t}\n\n\tif (!iter->cache) {\n\t\tif ((error = git_sortedcache_copy(&iter->cache, backend->refcache, 1, NULL, NULL)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = GIT_ITEROVER;\n\twhile (iter->packed_pos < git_sortedcache_entrycount(iter->cache)) {\n\t\tref = git_sortedcache_entry(iter->cache, iter->packed_pos++);\n\t\tif (!ref) /* stop now if another thread deleted refs and we past end */\n\t\t\tbreak;\n\n\t\tif (ref->flags & PACKREF_SHADOWED)\n\t\t\tcontinue;\n\t\tif (iter->glob && p_fnmatch(iter->glob, ref->name, 0) != 0)\n\t\t\tcontinue;\n\n\t\t*out = ref->name;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "refdb_fs_backend__iterator_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "531-570",
    "snippet": "static int refdb_fs_backend__iterator_next(\n\tgit_reference **out, git_reference_iterator *_iter)\n{\n\tint error = GIT_ITEROVER;\n\trefdb_fs_iter *iter = (refdb_fs_iter *)_iter;\n\trefdb_fs_backend *backend = (refdb_fs_backend *)iter->parent.db->backend;\n\tstruct packref *ref;\n\n\twhile (iter->loose_pos < iter->loose.length) {\n\t\tconst char *path = git_vector_get(&iter->loose, iter->loose_pos++);\n\n\t\tif (loose_lookup(out, backend, path) == 0)\n\t\t\treturn 0;\n\n\t\tgiterr_clear();\n\t}\n\n\tif (!iter->cache) {\n\t\tif ((error = git_sortedcache_copy(&iter->cache, backend->refcache, 1, NULL, NULL)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = GIT_ITEROVER;\n\twhile (iter->packed_pos < git_sortedcache_entrycount(iter->cache)) {\n\t\tref = git_sortedcache_entry(iter->cache, iter->packed_pos++);\n\t\tif (!ref) /* stop now if another thread deleted refs and we past end */\n\t\t\tbreak;\n\n\t\tif (ref->flags & PACKREF_SHADOWED)\n\t\t\tcontinue;\n\t\tif (iter->glob && p_fnmatch(iter->glob, ref->name, 0) != 0)\n\t\t\tcontinue;\n\n\t\t*out = git_reference__alloc(ref->name, &ref->oid, &ref->peel);\n\t\terror = (*out != NULL) ? 0 : -1;\n\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_reference__alloc",
          "args": [
            "ref->name",
            "&ref->oid",
            "&ref->peel"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "71-91",
          "snippet": "git_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "iter->glob",
            "ref->name",
            "0"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entry",
          "args": [
            "iter->cache",
            "iter->packed_pos++"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "322-329",
          "snippet": "void *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_entry(git_sortedcache *sc, size_t pos)\n{\n\t/* make sure the items are sorted so this gets the correct item */\n\tif (!git_vector_is_sorted(&sc->items))\n\t\tgit_vector_sort(&sc->items);\n\n\treturn git_vector_get(&sc->items, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_entrycount",
          "args": [
            "iter->cache"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "316-319",
          "snippet": "size_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nsize_t git_sortedcache_entrycount(const git_sortedcache *sc)\n{\n\treturn git_vector_length(&sc->items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_copy",
          "args": [
            "&iter->cache",
            "backend->refcache",
            "1",
            "NULL",
            "NULL"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "112-157",
          "snippet": "int git_sortedcache_copy(\n\tgit_sortedcache **out,\n\tgit_sortedcache *src,\n\tbool lock,\n\tint (*copy_item)(void *payload, void *tgt_item, void *src_item),\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_sortedcache *tgt;\n\tsize_t i;\n\tvoid *src_item, *tgt_item;\n\n\t/* just use memcpy if no special copy fn is passed in */\n\tif (!copy_item) {\n\t\tcopy_item = sortedcache_copy_item;\n\t\tpayload   = src;\n\t}\n\n\tif ((error = git_sortedcache_new(\n\t\t\t&tgt, src->item_path_offset,\n\t\t\tsrc->free_item, src->free_item_payload,\n\t\t\tsrc->items._cmp, src->path)) < 0)\n\t\treturn error;\n\n\tif (lock && git_sortedcache_rlock(src) < 0) {\n\t\tgit_sortedcache_free(tgt);\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&src->items, i, src_item) {\n\t\tchar *path = ((char *)src_item) + src->item_path_offset;\n\n\t\tif ((error = git_sortedcache_upsert(&tgt_item, tgt, path)) < 0 ||\n\t\t\t(error = copy_item(payload, tgt_item, src_item)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (lock)\n\t\tgit_sortedcache_runlock(src);\n\tif (error)\n\t\tgit_sortedcache_free(tgt);\n\n\t*out = !error ? tgt : NULL;\n\n\treturn error;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_copy(\n\tgit_sortedcache **out,\n\tgit_sortedcache *src,\n\tbool lock,\n\tint (*copy_item)(void *payload, void *tgt_item, void *src_item),\n\tvoid *payload)\n{\n\tint error = 0;\n\tgit_sortedcache *tgt;\n\tsize_t i;\n\tvoid *src_item, *tgt_item;\n\n\t/* just use memcpy if no special copy fn is passed in */\n\tif (!copy_item) {\n\t\tcopy_item = sortedcache_copy_item;\n\t\tpayload   = src;\n\t}\n\n\tif ((error = git_sortedcache_new(\n\t\t\t&tgt, src->item_path_offset,\n\t\t\tsrc->free_item, src->free_item_payload,\n\t\t\tsrc->items._cmp, src->path)) < 0)\n\t\treturn error;\n\n\tif (lock && git_sortedcache_rlock(src) < 0) {\n\t\tgit_sortedcache_free(tgt);\n\t\treturn -1;\n\t}\n\n\tgit_vector_foreach(&src->items, i, src_item) {\n\t\tchar *path = ((char *)src_item) + src->item_path_offset;\n\n\t\tif ((error = git_sortedcache_upsert(&tgt_item, tgt, path)) < 0 ||\n\t\t\t(error = copy_item(payload, tgt_item, src_item)) < 0)\n\t\t\tbreak;\n\t}\n\n\tif (lock)\n\t\tgit_sortedcache_runlock(src);\n\tif (error)\n\t\tgit_sortedcache_free(tgt);\n\n\t*out = !error ? tgt : NULL;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lookup",
          "args": [
            "out",
            "backend",
            "path"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "364-396",
          "snippet": "static int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&iter->loose",
            "iter->loose_pos++"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int refdb_fs_backend__iterator_next(\n\tgit_reference **out, git_reference_iterator *_iter)\n{\n\tint error = GIT_ITEROVER;\n\trefdb_fs_iter *iter = (refdb_fs_iter *)_iter;\n\trefdb_fs_backend *backend = (refdb_fs_backend *)iter->parent.db->backend;\n\tstruct packref *ref;\n\n\twhile (iter->loose_pos < iter->loose.length) {\n\t\tconst char *path = git_vector_get(&iter->loose, iter->loose_pos++);\n\n\t\tif (loose_lookup(out, backend, path) == 0)\n\t\t\treturn 0;\n\n\t\tgiterr_clear();\n\t}\n\n\tif (!iter->cache) {\n\t\tif ((error = git_sortedcache_copy(&iter->cache, backend->refcache, 1, NULL, NULL)) < 0)\n\t\t\treturn error;\n\t}\n\n\terror = GIT_ITEROVER;\n\twhile (iter->packed_pos < git_sortedcache_entrycount(iter->cache)) {\n\t\tref = git_sortedcache_entry(iter->cache, iter->packed_pos++);\n\t\tif (!ref) /* stop now if another thread deleted refs and we past end */\n\t\t\tbreak;\n\n\t\tif (ref->flags & PACKREF_SHADOWED)\n\t\t\tcontinue;\n\t\tif (iter->glob && p_fnmatch(iter->glob, ref->name, 0) != 0)\n\t\t\tcontinue;\n\n\t\t*out = git_reference__alloc(ref->name, &ref->oid, &ref->peel);\n\t\terror = (*out != NULL) ? 0 : -1;\n\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "iter_load_loose_paths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "478-529",
    "snippet": "static int iter_load_loose_paths(refdb_fs_backend *backend, refdb_fs_iter *iter)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_iterator *fsit = NULL;\n\tgit_iterator_options fsit_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *entry = NULL;\n\n\tif (!backend->path) /* do nothing if no path for loose refs */\n\t\treturn 0;\n\n\tfsit_opts.flags = backend->iterator_flags;\n\n\tif ((error = git_buf_printf(&path, \"%s/refs\", backend->path)) < 0 ||\n\t\t(error = git_iterator_for_filesystem(&fsit, path.ptr, &fsit_opts)) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn error;\n\t}\n\n\terror = git_buf_sets(&path, GIT_REFS_DIR);\n\n\twhile (!error && !git_iterator_advance(&entry, fsit)) {\n\t\tconst char *ref_name;\n\t\tstruct packref *ref;\n\t\tchar *ref_dup;\n\n\t\tgit_buf_truncate(&path, strlen(GIT_REFS_DIR));\n\t\tgit_buf_puts(&path, entry->path);\n\t\tref_name = git_buf_cstr(&path);\n\n\t\tif (git__suffixcmp(ref_name, \".lock\") == 0 ||\n\t\t\t(iter->glob && p_fnmatch(iter->glob, ref_name, 0) != 0))\n\t\t\tcontinue;\n\n\t\tgit_sortedcache_rlock(backend->refcache);\n\t\tref = git_sortedcache_lookup(backend->refcache, ref_name);\n\t\tif (ref)\n\t\t\tref->flags |= PACKREF_SHADOWED;\n\t\tgit_sortedcache_runlock(backend->refcache);\n\n\t\tref_dup = git_pool_strdup(&iter->pool, ref_name);\n\t\tif (!ref_dup)\n\t\t\terror = -1;\n\t\telse\n\t\t\terror = git_vector_insert(&iter->loose, ref_dup);\n\t}\n\n\tgit_iterator_free(fsit);\n\tgit_buf_free(&path);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "fsit"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&iter->loose",
            "ref_dup"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&iter->pool",
            "ref_name"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_runlock",
          "args": [
            "backend->refcache"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_runlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "191-195",
          "snippet": "void git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_lookup",
          "args": [
            "backend->refcache",
            "ref_name"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "307-313",
          "snippet": "void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_rlock",
          "args": [
            "backend->refcache"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_rlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "179-188",
          "snippet": "int git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_fnmatch",
          "args": [
            "iter->glob",
            "ref_name",
            "0"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "p_fnmatch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fnmatch.c",
          "lines": "230-234",
          "snippet": "int\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include <string.h>\n#include <stdio.h>\n#include <ctype.h>\n\nint\np_fnmatch(const char *pattern, const char *string, int flags)\n{\n\t\treturn p_fnmatchx(pattern, string, flags, 64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__suffixcmp",
          "args": [
            "ref_name",
            "\".lock\""
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "git__suffixcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "272-279",
          "snippet": "int git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&path"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "&path",
            "entry->path"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "&path",
            "strlen(GIT_REFS_DIR)"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_DIR"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "&entry",
            "fsit"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&path",
            "GIT_REFS_DIR"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_filesystem",
          "args": [
            "&fsit",
            "path.ptr",
            "&fsit_opts"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1627-1641",
          "snippet": "int git_iterator_for_filesystem(\n\tgit_iterator **out,\n\tconst char *root,\n\tgit_iterator_options *options)\n{\n\tfs_iterator *fi = git__calloc(1, sizeof(fs_iterator));\n\tGITERR_CHECK_ALLOC(fi);\n\n\tITERATOR_BASE_INIT(fi, fs, FS, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tfi->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\treturn fs_iterator__initialize(out, fi, root);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_for_filesystem(\n\tgit_iterator **out,\n\tconst char *root,\n\tgit_iterator_options *options)\n{\n\tfs_iterator *fi = git__calloc(1, sizeof(fs_iterator));\n\tGITERR_CHECK_ALLOC(fi);\n\n\tITERATOR_BASE_INIT(fi, fs, FS, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tfi->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\treturn fs_iterator__initialize(out, fi, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "&path",
            "\"%s/refs\"",
            "backend->path"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int iter_load_loose_paths(refdb_fs_backend *backend, refdb_fs_iter *iter)\n{\n\tint error = 0;\n\tgit_buf path = GIT_BUF_INIT;\n\tgit_iterator *fsit = NULL;\n\tgit_iterator_options fsit_opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *entry = NULL;\n\n\tif (!backend->path) /* do nothing if no path for loose refs */\n\t\treturn 0;\n\n\tfsit_opts.flags = backend->iterator_flags;\n\n\tif ((error = git_buf_printf(&path, \"%s/refs\", backend->path)) < 0 ||\n\t\t(error = git_iterator_for_filesystem(&fsit, path.ptr, &fsit_opts)) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn error;\n\t}\n\n\terror = git_buf_sets(&path, GIT_REFS_DIR);\n\n\twhile (!error && !git_iterator_advance(&entry, fsit)) {\n\t\tconst char *ref_name;\n\t\tstruct packref *ref;\n\t\tchar *ref_dup;\n\n\t\tgit_buf_truncate(&path, strlen(GIT_REFS_DIR));\n\t\tgit_buf_puts(&path, entry->path);\n\t\tref_name = git_buf_cstr(&path);\n\n\t\tif (git__suffixcmp(ref_name, \".lock\") == 0 ||\n\t\t\t(iter->glob && p_fnmatch(iter->glob, ref_name, 0) != 0))\n\t\t\tcontinue;\n\n\t\tgit_sortedcache_rlock(backend->refcache);\n\t\tref = git_sortedcache_lookup(backend->refcache, ref_name);\n\t\tif (ref)\n\t\t\tref->flags |= PACKREF_SHADOWED;\n\t\tgit_sortedcache_runlock(backend->refcache);\n\n\t\tref_dup = git_pool_strdup(&iter->pool, ref_name);\n\t\tif (!ref_dup)\n\t\t\terror = -1;\n\t\telse\n\t\t\terror = git_vector_insert(&iter->loose, ref_dup);\n\t}\n\n\tgit_iterator_free(fsit);\n\tgit_buf_free(&path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "refdb_fs_backend__iterator_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "468-476",
    "snippet": "static void refdb_fs_backend__iterator_free(git_reference_iterator *_iter)\n{\n\trefdb_fs_iter *iter = (refdb_fs_iter *) _iter;\n\n\tgit_vector_free(&iter->loose);\n\tgit_pool_clear(&iter->pool);\n\tgit_sortedcache_free(iter->cache);\n\tgit__free(iter);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iter"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_free",
          "args": [
            "iter->cache"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "96-101",
          "snippet": "void git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_free(git_sortedcache *sc)\n{\n\tif (!sc)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sc, sortedcache_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&iter->pool"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&iter->loose"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic void refdb_fs_backend__iterator_free(git_reference_iterator *_iter)\n{\n\trefdb_fs_iter *iter = (refdb_fs_iter *) _iter;\n\n\tgit_vector_free(&iter->loose);\n\tgit_pool_clear(&iter->pool);\n\tgit_sortedcache_free(iter->cache);\n\tgit__free(iter);\n}"
  },
  {
    "function_name": "refdb_fs_backend__lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "432-453",
    "snippet": "static int refdb_fs_backend__lookup(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error;\n\n\tassert(backend);\n\n\tif (!(error = loose_lookup(out, backend, ref_name)))\n\t\treturn 0;\n\n\t/* only try to lookup this reference on the packfile if it\n\t * wasn't found on the loose refs; not if there was a critical error */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = packed_lookup(out, backend, ref_name);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "packed_lookup",
          "args": [
            "out",
            "backend",
            "ref_name"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "packed_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "404-430",
          "snippet": "static int packed_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tint error = 0;\n\tstruct packref *entry;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (git_sortedcache_rlock(backend->refcache) < 0)\n\t\treturn -1;\n\n\tentry = git_sortedcache_lookup(backend->refcache, ref_name);\n\tif (!entry) {\n\t\terror = ref_error_notfound(ref_name);\n\t} else {\n\t\t*out = git_reference__alloc(ref_name, &entry->oid, &entry->peel);\n\t\tif (!*out)\n\t\t\terror = -1;\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tint error = 0;\n\tstruct packref *entry;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (git_sortedcache_rlock(backend->refcache) < 0)\n\t\treturn -1;\n\n\tentry = git_sortedcache_lookup(backend->refcache, ref_name);\n\tif (!entry) {\n\t\terror = ref_error_notfound(ref_name);\n\t} else {\n\t\t*out = git_reference__alloc(ref_name, &entry->oid, &entry->peel);\n\t\tif (!*out)\n\t\t\terror = -1;\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_lookup",
          "args": [
            "out",
            "backend",
            "ref_name"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "364-396",
          "snippet": "static int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__lookup(\n\tgit_reference **out,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tint error;\n\n\tassert(backend);\n\n\tif (!(error = loose_lookup(out, backend, ref_name)))\n\t\treturn 0;\n\n\t/* only try to lookup this reference on the packfile if it\n\t * wasn't found on the loose refs; not if there was a critical error */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = packed_lookup(out, backend, ref_name);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "packed_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "404-430",
    "snippet": "static int packed_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tint error = 0;\n\tstruct packref *entry;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (git_sortedcache_rlock(backend->refcache) < 0)\n\t\treturn -1;\n\n\tentry = git_sortedcache_lookup(backend->refcache, ref_name);\n\tif (!entry) {\n\t\terror = ref_error_notfound(ref_name);\n\t} else {\n\t\t*out = git_reference__alloc(ref_name, &entry->oid, &entry->peel);\n\t\tif (!*out)\n\t\t\terror = -1;\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_sortedcache_runlock",
          "args": [
            "backend->refcache"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_runlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "191-195",
          "snippet": "void git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_runlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\tgit_rwlock_rdunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__alloc",
          "args": [
            "ref_name",
            "&entry->oid",
            "&entry->peel"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "71-91",
          "snippet": "git_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_error_notfound",
          "args": [
            "ref_name"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ref_error_notfound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "398-402",
          "snippet": "static int ref_error_notfound(const char *name)\n{\n\tgiterr_set(GITERR_REFERENCE, \"Reference '%s' not found\", name);\n\treturn GIT_ENOTFOUND;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int ref_error_notfound(const char *name)\n{\n\tgiterr_set(GITERR_REFERENCE, \"Reference '%s' not found\", name);\n\treturn GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_lookup",
          "args": [
            "backend->refcache",
            "ref_name"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "307-313",
          "snippet": "void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_rlock",
          "args": [
            "backend->refcache"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_rlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "179-188",
          "snippet": "int git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_rlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_rdlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire read lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_reload",
          "args": [
            "backend"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "packed_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "74-195",
          "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tint error = 0;\n\tstruct packref *entry;\n\n\tif (packed_reload(backend) < 0)\n\t\treturn -1;\n\n\tif (git_sortedcache_rlock(backend->refcache) < 0)\n\t\treturn -1;\n\n\tentry = git_sortedcache_lookup(backend->refcache, ref_name);\n\tif (!entry) {\n\t\terror = ref_error_notfound(ref_name);\n\t} else {\n\t\t*out = git_reference__alloc(ref_name, &entry->oid, &entry->peel);\n\t\tif (!*out)\n\t\t\terror = -1;\n\t}\n\n\tgit_sortedcache_runlock(backend->refcache);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ref_error_notfound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "398-402",
    "snippet": "static int ref_error_notfound(const char *name)\n{\n\tgiterr_set(GITERR_REFERENCE, \"Reference '%s' not found\", name);\n\treturn GIT_ENOTFOUND;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Reference '%s' not found\"",
            "name"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int ref_error_notfound(const char *name)\n{\n\tgiterr_set(GITERR_REFERENCE, \"Reference '%s' not found\", name);\n\treturn GIT_ENOTFOUND;\n}"
  },
  {
    "function_name": "loose_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "364-396",
    "snippet": "static int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_file"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__alloc",
          "args": [
            "ref_name",
            "&oid",
            "NULL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "71-91",
          "snippet": "git_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc(\n\tconst char *name,\n\tconst git_oid *oid,\n\tconst git_oid *peel)\n{\n\tgit_reference *ref;\n\n\tassert(name && oid);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_OID;\n\tgit_oid_cpy(&ref->target.oid, oid);\n\n\tif (peel != NULL)\n\t\tgit_oid_cpy(&ref->peel, peel);\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_parse_oid",
          "args": [
            "&oid",
            "ref_name",
            "&ref_file"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "loose_parse_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "197-217",
          "snippet": "static int loose_parse_oid(\n\tgit_oid *oid, const char *filename, git_buf *file_content)\n{\n\tconst char *str = git_buf_cstr(file_content);\n\n\tif (git_buf_len(file_content) < GIT_OID_HEXSZ)\n\t\tgoto corrupted;\n\n\t/* we need to get 40 OID characters from the file */\n\tif (git_oid_fromstr(oid, str) < 0)\n\t\tgoto corrupted;\n\n\t/* If the file is longer than 40 chars, the 41st must be a space */\n\tstr += GIT_OID_HEXSZ;\n\tif (*str == '\\0' || git__isspace(*str))\n\t\treturn 0;\n\ncorrupted:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file: %s\", filename);\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_parse_oid(\n\tgit_oid *oid, const char *filename, git_buf *file_content)\n{\n\tconst char *str = git_buf_cstr(file_content);\n\n\tif (git_buf_len(file_content) < GIT_OID_HEXSZ)\n\t\tgoto corrupted;\n\n\t/* we need to get 40 OID characters from the file */\n\tif (git_oid_fromstr(oid, str) < 0)\n\t\tgoto corrupted;\n\n\t/* If the file is longer than 40 chars, the 41st must be a space */\n\tstr += GIT_OID_HEXSZ;\n\tif (*str == '\\0' || git__isspace(*str))\n\t\treturn 0;\n\ncorrupted:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file: %s\", filename);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_reference__alloc_symbolic",
          "args": [
            "ref_name",
            "target"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "git_reference__alloc_symbolic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refs.c",
          "lines": "50-69",
          "snippet": "git_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}",
          "includes": [
            "#include <git2/commit.h>",
            "#include <git2/signature.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/refdb.h>",
            "#include <git2/refs.h>",
            "#include <git2/branch.h>",
            "#include <git2/oid.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/commit.h>\n#include <git2/signature.h>\n#include <git2/sys/refs.h>\n#include <git2/refdb.h>\n#include <git2/refs.h>\n#include <git2/branch.h>\n#include <git2/oid.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\ngit_reference *git_reference__alloc_symbolic(\n\tconst char *name, const char *target)\n{\n\tgit_reference *ref;\n\n\tassert(name && target);\n\n\tref = alloc_ref(name);\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->type = GIT_REF_SYMBOLIC;\n\n\tif ((ref->target.symbolic = git__strdup(target)) == NULL) {\n\t\tgit__free(ref);\n\t\treturn NULL;\n\t}\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_parse_symbolic",
          "args": [
            "&ref_file"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "loose_parse_symbolic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "343-362",
          "snippet": "static const char *loose_parse_symbolic(git_buf *file_content)\n{\n\tconst unsigned int header_len = (unsigned int)strlen(GIT_SYMREF);\n\tconst char *refname_start;\n\n\trefname_start = (const char *)file_content->ptr;\n\n\tif (git_buf_len(file_content) < header_len + 1) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Assume we have already checked for the header\n\t * before calling this function\n\t */\n\trefname_start += header_len;\n\n\treturn refname_start;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic const char *loose_parse_symbolic(git_buf *file_content)\n{\n\tconst unsigned int header_len = (unsigned int)strlen(GIT_SYMREF);\n\tconst char *refname_start;\n\n\trefname_start = (const char *)file_content->ptr;\n\n\tif (git_buf_len(file_content) < header_len + 1) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Assume we have already checked for the header\n\t * before calling this function\n\t */\n\trefname_start += header_len;\n\n\treturn refname_start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtrim",
          "args": [
            "&ref_file"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "718-729",
          "snippet": "void git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtrim(git_buf *buf)\n{\n\twhile (buf->size > 0) {\n\t\tif (!git__isspace(buf->ptr[buf->size - 1]))\n\t\t\tbreak;\n\n\t\tbuf->size--;\n\t}\n\n\tif (buf->asize > buf->size)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "git_buf_cstr(&ref_file)",
            "GIT_SYMREF"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&ref_file"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_readbuffer",
          "args": [
            "&ref_file",
            "backend->path",
            "ref_name"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "loose_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "219-229",
          "snippet": "static int loose_readbuffer(git_buf *buf, const char *base, const char *path)\n{\n\tint error;\n\n\t/* build full path to file */\n\tif ((error = git_buf_joinpath(buf, base, path)) < 0 ||\n\t\t(error = git_futils_readbuffer(buf, buf->ptr)) < 0)\n\t\tgit_buf_free(buf);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_readbuffer(git_buf *buf, const char *base, const char *path)\n{\n\tint error;\n\n\t/* build full path to file */\n\tif ((error = git_buf_joinpath(buf, base, path)) < 0 ||\n\t\t(error = git_futils_readbuffer(buf, buf->ptr)) < 0)\n\t\tgit_buf_free(buf);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_lookup(\n\tgit_reference **out,\n\trefdb_fs_backend *backend,\n\tconst char *ref_name)\n{\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tint error = 0;\n\n\tif (out)\n\t\t*out = NULL;\n\n\tif ((error = loose_readbuffer(&ref_file, backend->path, ref_name)) < 0)\n\t\t/* cannot read loose ref file - gah */;\n\telse if (git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF) == 0) {\n\t\tconst char *target;\n\n\t\tgit_buf_rtrim(&ref_file);\n\n\t\tif (!(target = loose_parse_symbolic(&ref_file)))\n\t\t\terror = -1;\n\t\telse if (out != NULL)\n\t\t\t*out = git_reference__alloc_symbolic(ref_name, target);\n\t} else {\n\t\tgit_oid oid;\n\n\t\tif (!(error = loose_parse_oid(&oid, ref_name, &ref_file)) &&\n\t\t\tout != NULL)\n\t\t\t*out = git_reference__alloc(ref_name, &oid, NULL);\n\t}\n\n\tgit_buf_free(&ref_file);\n\treturn error;\n}"
  },
  {
    "function_name": "loose_parse_symbolic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "343-362",
    "snippet": "static const char *loose_parse_symbolic(git_buf *file_content)\n{\n\tconst unsigned int header_len = (unsigned int)strlen(GIT_SYMREF);\n\tconst char *refname_start;\n\n\trefname_start = (const char *)file_content->ptr;\n\n\tif (git_buf_len(file_content) < header_len + 1) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Assume we have already checked for the header\n\t * before calling this function\n\t */\n\trefname_start += header_len;\n\n\treturn refname_start;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Corrupted loose reference file\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "file_content"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_SYMREF"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic const char *loose_parse_symbolic(git_buf *file_content)\n{\n\tconst unsigned int header_len = (unsigned int)strlen(GIT_SYMREF);\n\tconst char *refname_start;\n\n\trefname_start = (const char *)file_content->ptr;\n\n\tif (git_buf_len(file_content) < header_len + 1) {\n\t\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file\");\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * Assume we have already checked for the header\n\t * before calling this function\n\t */\n\trefname_start += header_len;\n\n\treturn refname_start;\n}"
  },
  {
    "function_name": "refdb_fs_backend__exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "322-341",
    "snippet": "static int refdb_fs_backend__exists(\n\tint *exists,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0 ||\n\t\tgit_buf_joinpath(&ref_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\t*exists = git_path_isfile(ref_path.ptr) ||\n\t\t(git_sortedcache_lookup(backend->refcache, ref_name) != NULL);\n\n\tgit_buf_free(&ref_path);\n\treturn 0;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_path"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_lookup",
          "args": [
            "backend->refcache",
            "ref_name"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "307-313",
          "snippet": "void *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid *git_sortedcache_lookup(const git_sortedcache *sc, const char *key)\n{\n\tkhiter_t pos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos))\n\t\treturn git_strmap_value_at(sc->map, pos);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isfile",
          "args": [
            "ref_path.ptr"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "518-527",
          "snippet": "bool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isfile(const char *path)\n{\n\tstruct stat st;\n\n\tassert(path);\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISREG(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&ref_path",
            "backend->path",
            "ref_name"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "packed_reload",
          "args": [
            "backend"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "packed_reload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "74-195",
          "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "backend"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_fs_backend__exists(\n\tint *exists,\n\tgit_refdb_backend *_backend,\n\tconst char *ref_name)\n{\n\trefdb_fs_backend *backend = (refdb_fs_backend *)_backend;\n\tgit_buf ref_path = GIT_BUF_INIT;\n\n\tassert(backend);\n\n\tif (packed_reload(backend) < 0 ||\n\t\tgit_buf_joinpath(&ref_path, backend->path, ref_name) < 0)\n\t\treturn -1;\n\n\t*exists = git_path_isfile(ref_path.ptr) ||\n\t\t(git_sortedcache_lookup(backend->refcache, ref_name) != NULL);\n\n\tgit_buf_free(&ref_path);\n\treturn 0;\n}"
  },
  {
    "function_name": "packed_loadloose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "301-320",
    "snippet": "static int packed_loadloose(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf refs_path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&refs_path, backend->path, GIT_REFS_DIR) < 0)\n\t\treturn -1;\n\n\t/*\n\t * Load all the loose files from disk into the Packfile table.\n\t * This will overwrite any old packed entries with their\n\t * updated loose versions\n\t */\n\terror = git_path_direach(\n\t\t&refs_path, backend->direach_flags, _dirent_loose_load, backend);\n\n\tgit_buf_free(&refs_path);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&refs_path"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "&refs_path",
            "backend->direach_flags",
            "_dirent_loose_load",
            "backend"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&refs_path",
            "backend->path",
            "GIT_REFS_DIR"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int packed_loadloose(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf refs_path = GIT_BUF_INIT;\n\n\tif (git_buf_joinpath(&refs_path, backend->path, GIT_REFS_DIR) < 0)\n\t\treturn -1;\n\n\t/*\n\t * Load all the loose files from disk into the Packfile table.\n\t * This will overwrite any old packed entries with their\n\t * updated loose versions\n\t */\n\terror = git_path_direach(\n\t\t&refs_path, backend->direach_flags, _dirent_loose_load, backend);\n\n\tgit_buf_free(&refs_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "_dirent_loose_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "270-293",
    "snippet": "static int _dirent_loose_load(void *payload, git_buf *full_path)\n{\n\trefdb_fs_backend *backend = payload;\n\tconst char *file_path;\n\n\tif (git__suffixcmp(full_path->ptr, \".lock\") == 0)\n\t\treturn 0;\n\n\tif (git_path_isdir(full_path->ptr)) {\n\t\tint error = git_path_direach(\n\t\t\tfull_path, backend->direach_flags, _dirent_loose_load, backend);\n\t\t/* Race with the filesystem, ignore it */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\tfile_path = full_path->ptr + strlen(backend->path);\n\n\treturn loose_lookup_to_packfile(backend, file_path);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "loose_lookup_to_packfile",
          "args": [
            "backend",
            "file_path"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "loose_lookup_to_packfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "231-268",
          "snippet": "static int loose_lookup_to_packfile(refdb_fs_backend *backend, const char *name)\n{\n\tint error = 0;\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tstruct packref *ref = NULL;\n\tgit_oid oid;\n\n\t/* if we fail to load the loose reference, assume someone changed\n\t * the filesystem under us and skip it...\n\t */\n\tif (loose_readbuffer(&ref_file, backend->path, name) < 0) {\n\t\tgiterr_clear();\n\t\tgoto done;\n\t}\n\n\t/* skip symbolic refs */\n\tif (!git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF))\n\t\tgoto done;\n\n\t/* parse OID from file */\n\tif ((error = loose_parse_oid(&oid, name, &ref_file)) < 0)\n\t\tgoto done;\n\n\tgit_sortedcache_wlock(backend->refcache);\n\n\tif (!(error = git_sortedcache_upsert(\n\t\t\t(void **)&ref, backend->refcache, name))) {\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\t\tref->flags = PACKREF_WAS_LOOSE;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\ndone:\n\tgit_buf_free(&ref_file);\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
            "static int has_reflog(git_repository *repo, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lookup_to_packfile(refdb_fs_backend *backend, const char *name)\n{\n\tint error = 0;\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tstruct packref *ref = NULL;\n\tgit_oid oid;\n\n\t/* if we fail to load the loose reference, assume someone changed\n\t * the filesystem under us and skip it...\n\t */\n\tif (loose_readbuffer(&ref_file, backend->path, name) < 0) {\n\t\tgiterr_clear();\n\t\tgoto done;\n\t}\n\n\t/* skip symbolic refs */\n\tif (!git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF))\n\t\tgoto done;\n\n\t/* parse OID from file */\n\tif ((error = loose_parse_oid(&oid, name, &ref_file)) < 0)\n\t\tgoto done;\n\n\tgit_sortedcache_wlock(backend->refcache);\n\n\tif (!(error = git_sortedcache_upsert(\n\t\t\t(void **)&ref, backend->refcache, name))) {\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\t\tref->flags = PACKREF_WAS_LOOSE;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\ndone:\n\tgit_buf_free(&ref_file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "backend->path"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_direach",
          "args": [
            "full_path",
            "backend->direach_flags",
            "_dirent_loose_load",
            "backend"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_direach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1023-1094",
          "snippet": "int git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_direach(\n\tgit_buf *path,\n\tuint32_t flags,\n\tint (*fn)(void *, git_buf *),\n\tvoid *arg)\n{\n\tint error = 0;\n\tssize_t wd_len;\n\tDIR *dir;\n\tstruct dirent *de;\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_t ic = GIT_PATH_ICONV_INIT;\n#endif\n\n\tGIT_UNUSED(flags);\n\n\tif (git_path_to_dir(path) < 0)\n\t\treturn -1;\n\n\twd_len = git_buf_len(path);\n\n\tif ((dir = opendir(path->ptr)) == NULL) {\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path->ptr);\n\t\tif (errno == ENOENT)\n\t\t\treturn GIT_ENOTFOUND;\n\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&ic);\n#endif\n\n\twhile ((de = readdir(dir)) != NULL) {\n\t\tconst char *de_path = de->d_name;\n\t\tsize_t de_len = strlen(de_path);\n\n\t\tif (git_path_is_dot_or_dotdot(de_path))\n\t\t\tcontinue;\n\n#ifdef GIT_USE_ICONV\n\t\tif ((error = git_path_iconv(&ic, &de_path, &de_len)) < 0)\n\t\t\tbreak;\n#endif\n\n\t\tif ((error = git_buf_put(path, de_path, de_len)) < 0)\n\t\t\tbreak;\n\n\t\tgiterr_clear();\n\t\terror = fn(arg, path);\n\n\t\tgit_buf_truncate(path, wd_len); /* restore path */\n\n\t\t/* Only set our own error if the callback did not set one already */\n\t\tif (error != 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set_after_callback(error);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dir);\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&ic);\n#endif\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_isdir",
          "args": [
            "full_path->ptr"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_isdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "509-516",
          "snippet": "bool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_isdir(const char *path)\n{\n\tstruct stat st;\n\tif (p_stat(path, &st) < 0)\n\t\treturn false;\n\n\treturn S_ISDIR(st.st_mode) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__suffixcmp",
          "args": [
            "full_path->ptr",
            "\".lock\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "git__suffixcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "272-279",
          "snippet": "int git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__suffixcmp(const char *str, const char *suffix)\n{\n\tsize_t a = strlen(str);\n\tsize_t b = strlen(suffix);\n\tif (a < b)\n\t\treturn -1;\n\treturn strcmp(str + (a - b), suffix);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int _dirent_loose_load(void *payload, git_buf *full_path)\n{\n\trefdb_fs_backend *backend = payload;\n\tconst char *file_path;\n\n\tif (git__suffixcmp(full_path->ptr, \".lock\") == 0)\n\t\treturn 0;\n\n\tif (git_path_isdir(full_path->ptr)) {\n\t\tint error = git_path_direach(\n\t\t\tfull_path, backend->direach_flags, _dirent_loose_load, backend);\n\t\t/* Race with the filesystem, ignore it */\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\tfile_path = full_path->ptr + strlen(backend->path);\n\n\treturn loose_lookup_to_packfile(backend, file_path);\n}"
  },
  {
    "function_name": "loose_lookup_to_packfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "231-268",
    "snippet": "static int loose_lookup_to_packfile(refdb_fs_backend *backend, const char *name)\n{\n\tint error = 0;\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tstruct packref *ref = NULL;\n\tgit_oid oid;\n\n\t/* if we fail to load the loose reference, assume someone changed\n\t * the filesystem under us and skip it...\n\t */\n\tif (loose_readbuffer(&ref_file, backend->path, name) < 0) {\n\t\tgiterr_clear();\n\t\tgoto done;\n\t}\n\n\t/* skip symbolic refs */\n\tif (!git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF))\n\t\tgoto done;\n\n\t/* parse OID from file */\n\tif ((error = loose_parse_oid(&oid, name, &ref_file)) < 0)\n\t\tgoto done;\n\n\tgit_sortedcache_wlock(backend->refcache);\n\n\tif (!(error = git_sortedcache_upsert(\n\t\t\t(void **)&ref, backend->refcache, name))) {\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\t\tref->flags = PACKREF_WAS_LOOSE;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\ndone:\n\tgit_buf_free(&ref_file);\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ref_file"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "backend->refcache"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ref->oid",
            "&oid"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_upsert",
          "args": [
            "(void **)&ref",
            "backend->refcache",
            "name"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_upsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "257-304",
          "snippet": "int git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wlock",
          "args": [
            "backend->refcache"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "160-169",
          "snippet": "int git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_wlock(git_sortedcache *sc)\n{\n\tGIT_UNUSED(sc); /* prevent warning when compiled w/o threads */\n\n\tif (git_rwlock_wrlock(&sc->lock) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Unable to acquire write lock on cache\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_parse_oid",
          "args": [
            "&oid",
            "name",
            "&ref_file"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "loose_parse_oid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "197-217",
          "snippet": "static int loose_parse_oid(\n\tgit_oid *oid, const char *filename, git_buf *file_content)\n{\n\tconst char *str = git_buf_cstr(file_content);\n\n\tif (git_buf_len(file_content) < GIT_OID_HEXSZ)\n\t\tgoto corrupted;\n\n\t/* we need to get 40 OID characters from the file */\n\tif (git_oid_fromstr(oid, str) < 0)\n\t\tgoto corrupted;\n\n\t/* If the file is longer than 40 chars, the 41st must be a space */\n\tstr += GIT_OID_HEXSZ;\n\tif (*str == '\\0' || git__isspace(*str))\n\t\treturn 0;\n\ncorrupted:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file: %s\", filename);\n\treturn -1;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_parse_oid(\n\tgit_oid *oid, const char *filename, git_buf *file_content)\n{\n\tconst char *str = git_buf_cstr(file_content);\n\n\tif (git_buf_len(file_content) < GIT_OID_HEXSZ)\n\t\tgoto corrupted;\n\n\t/* we need to get 40 OID characters from the file */\n\tif (git_oid_fromstr(oid, str) < 0)\n\t\tgoto corrupted;\n\n\t/* If the file is longer than 40 chars, the 41st must be a space */\n\tstr += GIT_OID_HEXSZ;\n\tif (*str == '\\0' || git__isspace(*str))\n\t\treturn 0;\n\ncorrupted:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file: %s\", filename);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "git_buf_cstr(&ref_file)",
            "GIT_SYMREF"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&ref_file"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "loose_readbuffer",
          "args": [
            "&ref_file",
            "backend->path",
            "name"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "loose_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
          "lines": "219-229",
          "snippet": "static int loose_readbuffer(git_buf *buf, const char *base, const char *path)\n{\n\tint error;\n\n\t/* build full path to file */\n\tif ((error = git_buf_joinpath(buf, base, path)) < 0 ||\n\t\t(error = git_futils_readbuffer(buf, buf->ptr)) < 0)\n\t\tgit_buf_free(buf);\n\n\treturn error;\n}",
          "includes": [
            "#include <git2/sys/reflog.h>",
            "#include <git2/sys/refs.h>",
            "#include <git2/sys/refdb_backend.h>",
            "#include <git2/branch.h>",
            "#include <git2/refdb.h>",
            "#include <git2/object.h>",
            "#include <git2/tag.h>",
            "#include \"signature.h\"",
            "#include \"sortedcache.h\"",
            "#include \"iterator.h\"",
            "#include \"refdb_fs.h\"",
            "#include \"refdb.h\"",
            "#include \"reflog.h\"",
            "#include \"pack.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"repository.h\"",
            "#include \"hash.h\"",
            "#include \"refs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_readbuffer(git_buf *buf, const char *base, const char *path)\n{\n\tint error;\n\n\t/* build full path to file */\n\tif ((error = git_buf_joinpath(buf, base, path)) < 0 ||\n\t\t(error = git_futils_readbuffer(buf, buf->ptr)) < 0)\n\t\tgit_buf_free(buf);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int loose_lookup_to_packfile(refdb_fs_backend *backend, const char *name)\n{\n\tint error = 0;\n\tgit_buf ref_file = GIT_BUF_INIT;\n\tstruct packref *ref = NULL;\n\tgit_oid oid;\n\n\t/* if we fail to load the loose reference, assume someone changed\n\t * the filesystem under us and skip it...\n\t */\n\tif (loose_readbuffer(&ref_file, backend->path, name) < 0) {\n\t\tgiterr_clear();\n\t\tgoto done;\n\t}\n\n\t/* skip symbolic refs */\n\tif (!git__prefixcmp(git_buf_cstr(&ref_file), GIT_SYMREF))\n\t\tgoto done;\n\n\t/* parse OID from file */\n\tif ((error = loose_parse_oid(&oid, name, &ref_file)) < 0)\n\t\tgoto done;\n\n\tgit_sortedcache_wlock(backend->refcache);\n\n\tif (!(error = git_sortedcache_upsert(\n\t\t\t(void **)&ref, backend->refcache, name))) {\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\t\tref->flags = PACKREF_WAS_LOOSE;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\ndone:\n\tgit_buf_free(&ref_file);\n\treturn error;\n}"
  },
  {
    "function_name": "loose_readbuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "219-229",
    "snippet": "static int loose_readbuffer(git_buf *buf, const char *base, const char *path)\n{\n\tint error;\n\n\t/* build full path to file */\n\tif ((error = git_buf_joinpath(buf, base, path)) < 0 ||\n\t\t(error = git_futils_readbuffer(buf, buf->ptr)) < 0)\n\t\tgit_buf_free(buf);\n\n\treturn error;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "buf"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "buf",
            "buf->ptr"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "buf",
            "base",
            "path"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_readbuffer(git_buf *buf, const char *base, const char *path)\n{\n\tint error;\n\n\t/* build full path to file */\n\tif ((error = git_buf_joinpath(buf, base, path)) < 0 ||\n\t\t(error = git_futils_readbuffer(buf, buf->ptr)) < 0)\n\t\tgit_buf_free(buf);\n\n\treturn error;\n}"
  },
  {
    "function_name": "loose_parse_oid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "197-217",
    "snippet": "static int loose_parse_oid(\n\tgit_oid *oid, const char *filename, git_buf *file_content)\n{\n\tconst char *str = git_buf_cstr(file_content);\n\n\tif (git_buf_len(file_content) < GIT_OID_HEXSZ)\n\t\tgoto corrupted;\n\n\t/* we need to get 40 OID characters from the file */\n\tif (git_oid_fromstr(oid, str) < 0)\n\t\tgoto corrupted;\n\n\t/* If the file is longer than 40 chars, the 41st must be a space */\n\tstr += GIT_OID_HEXSZ;\n\tif (*str == '\\0' || git__isspace(*str))\n\t\treturn 0;\n\ncorrupted:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file: %s\", filename);\n\treturn -1;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Corrupted loose reference file: %s\"",
            "filename"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__isspace",
          "args": [
            "*str"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "git__isspace_nonlf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "459-462",
          "snippet": "GIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(bool) git__isspace_nonlf(int c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\f' || c == '\\r' || c == '\\v');\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromstr",
          "args": [
            "oid",
            "str"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "54-57",
          "snippet": "int git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "file_content"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "file_content"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int loose_parse_oid(\n\tgit_oid *oid, const char *filename, git_buf *file_content)\n{\n\tconst char *str = git_buf_cstr(file_content);\n\n\tif (git_buf_len(file_content) < GIT_OID_HEXSZ)\n\t\tgoto corrupted;\n\n\t/* we need to get 40 OID characters from the file */\n\tif (git_oid_fromstr(oid, str) < 0)\n\t\tgoto corrupted;\n\n\t/* If the file is longer than 40 chars, the 41st must be a space */\n\tstr += GIT_OID_HEXSZ;\n\tif (*str == '\\0' || git__isspace(*str))\n\t\treturn 0;\n\ncorrupted:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted loose reference file: %s\", filename);\n\treturn -1;\n}"
  },
  {
    "function_name": "packed_reload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "74-195",
    "snippet": "static int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&packedrefs"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_wunlock",
          "args": [
            "backend->refcache"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_wunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "172-176",
          "snippet": "void git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nvoid git_sortedcache_wunlock(git_sortedcache *sc)\n{\n\tgit_vector_sort(&sc->items);\n\tgit_rwlock_wrunlock(&sc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_clear",
          "args": [
            "backend->refcache",
            "false"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "243-254",
          "snippet": "int git_sortedcache_clear(git_sortedcache *sc, bool wlock)\n{\n\tif (wlock && git_sortedcache_wlock(sc) < 0)\n\t\treturn -1;\n\n\tsortedcache_clear(sc);\n\n\tif (wlock)\n\t\tgit_sortedcache_wunlock(sc);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_clear(git_sortedcache *sc, bool wlock)\n{\n\tif (wlock && git_sortedcache_wlock(sc) < 0)\n\t\treturn -1;\n\n\tsortedcache_clear(sc);\n\n\tif (wlock)\n\t\tgit_sortedcache_wunlock(sc);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REFERENCE",
            "\"Corrupted packed references file\""
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "ref->name",
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ref->peel",
            "&oid"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "scan",
            "'\\n'"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_fromstr",
          "args": [
            "&oid",
            "scan + 1"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "54-57",
          "snippet": "int git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_upsert",
          "args": [
            "(void **)&ref",
            "backend->refcache",
            "scan"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_upsert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "257-304",
          "snippet": "int git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_upsert(void **out, git_sortedcache *sc, const char *key)\n{\n\tint error = 0;\n\tkhiter_t pos;\n\tvoid *item;\n\tsize_t keylen, itemlen;\n\tchar *item_key;\n\n\tpos = git_strmap_lookup_index(sc->map, key);\n\tif (git_strmap_valid_index(sc->map, pos)) {\n\t\titem = git_strmap_value_at(sc->map, pos);\n\t\tgoto done;\n\t}\n\n\tkeylen  = strlen(key);\n\titemlen = sc->item_path_offset + keylen + 1;\n\titemlen = (itemlen + 7) & ~7;\n\n\tif ((item = git_pool_mallocz(&sc->pool, (uint32_t)itemlen)) == NULL) {\n\t\t/* don't use GITERR_CHECK_ALLOC b/c of lock */\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\n\t/* one strange thing is that even if the vector or hash table insert\n\t * fail, there is no way to free the pool item so we just abandon it\n\t */\n\n\titem_key = ((char *)item) + sc->item_path_offset;\n\tmemcpy(item_key, key, keylen);\n\n\tpos = kh_put(str, sc->map, item_key, &error);\n\tif (error < 0)\n\t\tgoto done;\n\n\tif (!error)\n\t\tkh_key(sc->map, pos) = item_key;\n\tkh_val(sc->map, pos) = item;\n\n\terror = git_vector_insert(&sc->items, item);\n\tif (error < 0)\n\t\tgit_strmap_delete_at(sc->map, pos);\n\ndone:\n\tif (out)\n\t\t*out = !error ? item : NULL;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "scan",
            "'\\n'"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "scan",
            "'\\n'"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "scan",
            "\" peeled \""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "scan",
            "\" fully-peeled \""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "scan",
            "'\\n'"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "traits_header"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_sortedcache_lockandload",
          "args": [
            "backend->refcache",
            "&packedrefs"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "git_sortedcache_lockandload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/sortedcache.c",
          "lines": "200-234",
          "snippet": "int git_sortedcache_lockandload(git_sortedcache *sc, git_buf *buf)\n{\n\tint error, fd;\n\n\tif ((error = git_sortedcache_wlock(sc)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(&sc->stamp, sc->path)) <= 0)\n\t\tgoto unlock;\n\n\tif (!git__is_sizet(sc->stamp.size)) {\n\t\tgiterr_set(GITERR_INVALID, \"Unable to load file larger than size_t\");\n\t\terror = -1;\n\t\tgoto unlock;\n\t}\n\n\tif ((fd = git_futils_open_ro(sc->path)) < 0) {\n\t\terror = fd;\n\t\tgoto unlock;\n\t}\n\n\tif (buf)\n\t\terror = git_futils_readbuffer_fd(buf, fd, (size_t)sc->stamp.size);\n\n\t(void)p_close(fd);\n\n\tif (error < 0)\n\t\tgoto unlock;\n\n\treturn 1; /* return 1 -> file needs reload and was successfully loaded */\n\nunlock:\n\tgit_sortedcache_wunlock(sc);\n\treturn error;\n}",
          "includes": [
            "#include \"sortedcache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sortedcache.h\"\n\nint git_sortedcache_lockandload(git_sortedcache *sc, git_buf *buf)\n{\n\tint error, fd;\n\n\tif ((error = git_sortedcache_wlock(sc)) < 0)\n\t\treturn error;\n\n\tif ((error = git_futils_filestamp_check(&sc->stamp, sc->path)) <= 0)\n\t\tgoto unlock;\n\n\tif (!git__is_sizet(sc->stamp.size)) {\n\t\tgiterr_set(GITERR_INVALID, \"Unable to load file larger than size_t\");\n\t\terror = -1;\n\t\tgoto unlock;\n\t}\n\n\tif ((fd = git_futils_open_ro(sc->path)) < 0) {\n\t\terror = fd;\n\t\tgoto unlock;\n\t}\n\n\tif (buf)\n\t\terror = git_futils_readbuffer_fd(buf, fd, (size_t)sc->stamp.size);\n\n\t(void)p_close(fd);\n\n\tif (error < 0)\n\t\tgoto unlock;\n\n\treturn 1; /* return 1 -> file needs reload and was successfully loaded */\n\nunlock:\n\tgit_sortedcache_wunlock(sc);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packed_reload(refdb_fs_backend *backend)\n{\n\tint error;\n\tgit_buf packedrefs = GIT_BUF_INIT;\n\tchar *scan, *eof, *eol;\n\n\tif (!backend->path)\n\t\treturn 0;\n\n\terror = git_sortedcache_lockandload(backend->refcache, &packedrefs);\n\n\t/*\n\t * If we can't find the packed-refs, clear table and return.\n\t * Any other error just gets passed through.\n\t * If no error, and file wasn't changed, just return.\n\t * Anything else means we need to refresh the packed refs.\n\t */\n\tif (error <= 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgit_sortedcache_clear(backend->refcache, true);\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\t/* At this point, refresh the packed refs from the loaded buffer. */\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\n\tscan = (char *)packedrefs.ptr;\n\teof  = scan + packedrefs.size;\n\n\tbackend->peeling_mode = PEELING_NONE;\n\n\tif (*scan == '#') {\n\t\tstatic const char *traits_header = \"# pack-refs with: \";\n\n\t\tif (git__prefixcmp(scan, traits_header) == 0) {\n\t\t\tscan += strlen(traits_header);\n\t\t\teol = strchr(scan, '\\n');\n\n\t\t\tif (!eol)\n\t\t\t\tgoto parse_failed;\n\t\t\t*eol = '\\0';\n\n\t\t\tif (strstr(scan, \" fully-peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_FULL;\n\t\t\t} else if (strstr(scan, \" peeled \") != NULL) {\n\t\t\t\tbackend->peeling_mode = PEELING_STANDARD;\n\t\t\t}\n\n\t\t\tscan = eol + 1;\n\t\t}\n\t}\n\n\twhile (scan < eof && *scan == '#') {\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\t}\n\n\twhile (scan < eof) {\n\t\tstruct packref *ref;\n\t\tgit_oid oid;\n\n\t\t/* parse \"<OID> <refname>\\n\" */\n\n\t\tif (git_oid_fromstr(&oid, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan += GIT_OID_HEXSZ;\n\n\t\tif (*scan++ != ' ')\n\t\t\tgoto parse_failed;\n\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\tgoto parse_failed;\n\t\t*eol = '\\0';\n\t\tif (eol[-1] == '\\r')\n\t\t\teol[-1] = '\\0';\n\n\t\tif (git_sortedcache_upsert((void **)&ref, backend->refcache, scan) < 0)\n\t\t\tgoto parse_failed;\n\t\tscan = eol + 1;\n\n\t\tgit_oid_cpy(&ref->oid, &oid);\n\n\t\t/* look for optional \"^<OID>\\n\" */\n\n\t\tif (*scan == '^') {\n\t\t\tif (git_oid_fromstr(&oid, scan + 1) < 0)\n\t\t\t\tgoto parse_failed;\n\t\t\tscan += GIT_OID_HEXSZ + 1;\n\n\t\t\tif (scan < eof) {\n\t\t\t\tif (!(eol = strchr(scan, '\\n')))\n\t\t\t\t\tgoto parse_failed;\n\t\t\t\tscan = eol + 1;\n\t\t\t}\n\n\t\t\tgit_oid_cpy(&ref->peel, &oid);\n\t\t\tref->flags |= PACKREF_HAS_PEEL;\n\t\t}\n\t\telse if (backend->peeling_mode == PEELING_FULL ||\n\t\t\t\t(backend->peeling_mode == PEELING_STANDARD &&\n\t\t\t\t git__prefixcmp(ref->name, GIT_REFS_TAGS_DIR) == 0))\n\t\t\tref->flags |= PACKREF_CANNOT_PEEL;\n\t}\n\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn 0;\n\nparse_failed:\n\tgiterr_set(GITERR_REFERENCE, \"Corrupted packed references file\");\n\n\tgit_sortedcache_clear(backend->refcache, false);\n\tgit_sortedcache_wunlock(backend->refcache);\n\tgit_buf_free(&packedrefs);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "packref_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/refdb_fs.c",
    "lines": "68-72",
    "snippet": "static int packref_cmp(const void *a_, const void *b_)\n{\n\tconst struct packref *a = a_, *b = b_;\n\treturn strcmp(a->name, b->name);\n}",
    "includes": [
      "#include <git2/sys/reflog.h>",
      "#include <git2/sys/refs.h>",
      "#include <git2/sys/refdb_backend.h>",
      "#include <git2/branch.h>",
      "#include <git2/refdb.h>",
      "#include <git2/object.h>",
      "#include <git2/tag.h>",
      "#include \"signature.h\"",
      "#include \"sortedcache.h\"",
      "#include \"iterator.h\"",
      "#include \"refdb_fs.h\"",
      "#include \"refdb.h\"",
      "#include \"reflog.h\"",
      "#include \"pack.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"repository.h\"",
      "#include \"hash.h\"",
      "#include \"refs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);",
      "static int has_reflog(git_repository *repo, const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "a->name",
            "b->name"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <git2/sys/reflog.h>\n#include <git2/sys/refs.h>\n#include <git2/sys/refdb_backend.h>\n#include <git2/branch.h>\n#include <git2/refdb.h>\n#include <git2/object.h>\n#include <git2/tag.h>\n#include \"signature.h\"\n#include \"sortedcache.h\"\n#include \"iterator.h\"\n#include \"refdb_fs.h\"\n#include \"refdb.h\"\n#include \"reflog.h\"\n#include \"pack.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"repository.h\"\n#include \"hash.h\"\n#include \"refs.h\"\n\nstatic int refdb_reflog_fs__delete(git_refdb_backend *_backend, const char *name);\nstatic int has_reflog(git_repository *repo, const char *name);\n\nstatic int packref_cmp(const void *a_, const void *b_)\n{\n\tconst struct packref *a = a_, *b = b_;\n\treturn strcmp(a->name, b->name);\n}"
  }
]