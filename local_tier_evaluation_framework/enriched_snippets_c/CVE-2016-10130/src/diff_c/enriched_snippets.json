[
  {
    "function_name": "git_diff_format_email_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1856-1863",
    "snippet": "int git_diff_format_email_init_options(\n\tgit_diff_format_email_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_diff_format_email_options,\n\t\tGIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_diff_format_email_options",
            "GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email_init_options(\n\tgit_diff_format_email_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_diff_format_email_options,\n\t\tGIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_find_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1848-1854",
    "snippet": "int git_diff_find_init_options(\n\tgit_diff_find_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_diff_find_options, GIT_DIFF_FIND_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_diff_find_options",
            "GIT_DIFF_FIND_OPTIONS_INIT"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_find_init_options(\n\tgit_diff_find_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_diff_find_options, GIT_DIFF_FIND_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_init_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1841-1846",
    "snippet": "int git_diff_init_options(git_diff_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_diff_options, GIT_DIFF_OPTIONS_INIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_INIT_STRUCTURE_FROM_TEMPLATE",
          "args": [
            "opts",
            "version",
            "git_diff_options",
            "GIT_DIFF_OPTIONS_INIT"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_init_options(git_diff_options *opts, unsigned int version)\n{\n\tGIT_INIT_STRUCTURE_FROM_TEMPLATE(\n\t\topts, version, git_diff_options, GIT_DIFF_OPTIONS_INIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_commit_as_email",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1809-1839",
    "snippet": "int git_diff_commit_as_email(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tsize_t patch_no,\n\tsize_t total_patches,\n\tgit_diff_format_email_flags_t flags,\n\tconst git_diff_options *diff_opts)\n{\n\tgit_diff *diff = NULL;\n\tgit_diff_format_email_options opts = GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT;\n\tint error;\n\n\tassert (out && repo && commit);\n\n\topts.flags = flags;\n\topts.patch_no = patch_no;\n\topts.total_patches = total_patches;\n\topts.id = git_commit_id(commit);\n\topts.summary = git_commit_summary(commit);\n\topts.body = git_commit_body(commit);\n\topts.author = git_commit_author(commit);\n\n\tif ((error = git_diff__commit(&diff, repo, commit, diff_opts)) < 0)\n\t\treturn error;\n\n\terror = git_diff_format_email(out, diff, &opts);\n\n\tgit_diff_free(diff);\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_format_email",
          "args": [
            "out",
            "diff",
            "&opts"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_format_email",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1736-1807",
          "snippet": "int git_diff_format_email(\n\tgit_buf *out,\n\tgit_diff *diff,\n\tconst git_diff_format_email_options *opts)\n{\n\tgit_diff_stats *stats = NULL;\n\tchar *summary = NULL, *loc = NULL;\n\tbool ignore_marker;\n\tunsigned int format_flags = 0;\n\tsize_t allocsize;\n\tint error;\n\n\tassert(out && diff && opts);\n\tassert(opts->summary && opts->id && opts->author);\n\n\tGITERR_CHECK_VERSION(opts, GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION, \"git_format_email_options\");\n\n\tif ((ignore_marker = opts->flags & GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER) == false) {\n\t\tif (opts->patch_no > opts->total_patches) {\n\t\t\tgiterr_set(GITERR_INVALID, \"patch %\"PRIuZ\" out of range. max %\"PRIuZ, opts->patch_no, opts->total_patches);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (opts->patch_no == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"invalid patch no %\"PRIuZ\". should be >0\", opts->patch_no);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* the summary we receive may not be clean.\n\t * it could potentially contain new line characters\n\t * or not be set, sanitize, */\n\tif ((loc = strpbrk(opts->summary, \"\\r\\n\")) != NULL) {\n\t\tsize_t offset = 0;\n\n\t\tif ((offset = (loc - opts->summary)) == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"summary is empty\");\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&allocsize, offset, 1);\n\t\tsummary = git__calloc(allocsize, sizeof(char));\n\t\tGITERR_CHECK_ALLOC(summary);\n\n\t\tstrncpy(summary, opts->summary, offset);\n\t}\n\n\terror = git_diff_format_email__append_header_tobuf(out,\n\t\t\t\topts->id, opts->author, summary == NULL ? opts->summary : summary,\n\t\t\t\topts->body, opts->patch_no, opts->total_patches, ignore_marker);\n\n\tif (error < 0)\n\t\tgoto on_error;\n\n\tformat_flags = GIT_DIFF_STATS_FULL | GIT_DIFF_STATS_INCLUDE_SUMMARY;\n\n\tif ((error = git_buf_puts(out, \"---\\n\")) < 0 ||\n\t\t(error = git_diff_get_stats(&stats, diff)) < 0 ||\n\t\t(error = git_diff_stats_to_buf(out, stats, format_flags, 0)) < 0 ||\n\t\t(error = git_buf_putc(out, '\\n')) < 0 ||\n\t\t(error = git_diff_format_email__append_patches_tobuf(out, diff)) < 0)\n\t\t\tgoto on_error;\n\n\terror = git_buf_puts(out, \"--\\nlibgit2 \" LIBGIT2_VERSION \"\\n\\n\");\n\non_error:\n\tgit__free(summary);\n\tgit_diff_stats_free(stats);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email(\n\tgit_buf *out,\n\tgit_diff *diff,\n\tconst git_diff_format_email_options *opts)\n{\n\tgit_diff_stats *stats = NULL;\n\tchar *summary = NULL, *loc = NULL;\n\tbool ignore_marker;\n\tunsigned int format_flags = 0;\n\tsize_t allocsize;\n\tint error;\n\n\tassert(out && diff && opts);\n\tassert(opts->summary && opts->id && opts->author);\n\n\tGITERR_CHECK_VERSION(opts, GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION, \"git_format_email_options\");\n\n\tif ((ignore_marker = opts->flags & GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER) == false) {\n\t\tif (opts->patch_no > opts->total_patches) {\n\t\t\tgiterr_set(GITERR_INVALID, \"patch %\"PRIuZ\" out of range. max %\"PRIuZ, opts->patch_no, opts->total_patches);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (opts->patch_no == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"invalid patch no %\"PRIuZ\". should be >0\", opts->patch_no);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* the summary we receive may not be clean.\n\t * it could potentially contain new line characters\n\t * or not be set, sanitize, */\n\tif ((loc = strpbrk(opts->summary, \"\\r\\n\")) != NULL) {\n\t\tsize_t offset = 0;\n\n\t\tif ((offset = (loc - opts->summary)) == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"summary is empty\");\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&allocsize, offset, 1);\n\t\tsummary = git__calloc(allocsize, sizeof(char));\n\t\tGITERR_CHECK_ALLOC(summary);\n\n\t\tstrncpy(summary, opts->summary, offset);\n\t}\n\n\terror = git_diff_format_email__append_header_tobuf(out,\n\t\t\t\topts->id, opts->author, summary == NULL ? opts->summary : summary,\n\t\t\t\topts->body, opts->patch_no, opts->total_patches, ignore_marker);\n\n\tif (error < 0)\n\t\tgoto on_error;\n\n\tformat_flags = GIT_DIFF_STATS_FULL | GIT_DIFF_STATS_INCLUDE_SUMMARY;\n\n\tif ((error = git_buf_puts(out, \"---\\n\")) < 0 ||\n\t\t(error = git_diff_get_stats(&stats, diff)) < 0 ||\n\t\t(error = git_diff_stats_to_buf(out, stats, format_flags, 0)) < 0 ||\n\t\t(error = git_buf_putc(out, '\\n')) < 0 ||\n\t\t(error = git_diff_format_email__append_patches_tobuf(out, diff)) < 0)\n\t\t\tgoto on_error;\n\n\terror = git_buf_puts(out, \"--\\nlibgit2 \" LIBGIT2_VERSION \"\\n\\n\");\n\non_error:\n\tgit__free(summary);\n\tgit_diff_stats_free(stats);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff__commit",
          "args": [
            "&diff",
            "repo",
            "commit",
            "diff_opts"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1617-1655",
          "snippet": "int git_diff__commit(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tconst git_commit *commit,\n\tconst git_diff_options *opts)\n{\n\tgit_commit *parent = NULL;\n\tgit_diff *commit_diff = NULL;\n\tgit_tree *old_tree = NULL, *new_tree = NULL;\n\tsize_t parents;\n\tint error = 0;\n\n\tif ((parents = git_commit_parentcount(commit)) > 1) {\n\t\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\t\terror = -1;\n\t\tgiterr_set(GITERR_INVALID, \"Commit %s is a merge commit\",\n\t\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\t\tgoto on_error;\n\t}\n\n\tif (parents > 0)\n\t\tif ((error = git_commit_parent(&parent, commit, 0)) < 0 ||\n\t\t\t(error = git_commit_tree(&old_tree, parent)) < 0)\n\t\t\t\tgoto on_error;\n\n\tif ((error = git_commit_tree(&new_tree, commit)) < 0 ||\n\t\t(error = git_diff_tree_to_tree(&commit_diff, repo, old_tree, new_tree, opts)) < 0)\n\t\t\tgoto on_error;\n\n\t*diff = commit_diff;\n\non_error:\n\tgit_tree_free(new_tree);\n\tgit_tree_free(old_tree);\n\tgit_commit_free(parent);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__commit(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tconst git_commit *commit,\n\tconst git_diff_options *opts)\n{\n\tgit_commit *parent = NULL;\n\tgit_diff *commit_diff = NULL;\n\tgit_tree *old_tree = NULL, *new_tree = NULL;\n\tsize_t parents;\n\tint error = 0;\n\n\tif ((parents = git_commit_parentcount(commit)) > 1) {\n\t\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\t\terror = -1;\n\t\tgiterr_set(GITERR_INVALID, \"Commit %s is a merge commit\",\n\t\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\t\tgoto on_error;\n\t}\n\n\tif (parents > 0)\n\t\tif ((error = git_commit_parent(&parent, commit, 0)) < 0 ||\n\t\t\t(error = git_commit_tree(&old_tree, parent)) < 0)\n\t\t\t\tgoto on_error;\n\n\tif ((error = git_commit_tree(&new_tree, commit)) < 0 ||\n\t\t(error = git_diff_tree_to_tree(&commit_diff, repo, old_tree, new_tree, opts)) < 0)\n\t\t\tgoto on_error;\n\n\t*diff = commit_diff;\n\non_error:\n\tgit_tree_free(new_tree);\n\tgit_tree_free(old_tree);\n\tgit_commit_free(parent);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_author",
          "args": [
            "commit"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_commit_body",
          "args": [
            "commit"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_body",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "503-528",
          "snippet": "const char *git_commit_body(git_commit *commit)\n{\n\tconst char *msg, *end;\n\n\tassert(commit);\n\n\tif (!commit->body) {\n\t\t/* search for end of summary */\n\t\tfor (msg = git_commit_message(commit); *msg; ++msg)\n\t\t\tif (msg[0] == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\n\t\t/* trim leading and trailing whitespace */\n\t\tfor (; *msg; ++msg)\n\t\t\tif (!git__isspace(*msg))\n\t\t\t\tbreak;\n\t\tfor (end = msg + strlen(msg) - 1; msg <= end; --end)\n\t\t\tif (!git__isspace(*end))\n\t\t\t\tbreak;\n\n\t\tif (*msg)\n\t\t\t    commit->body = git__strndup(msg, end - msg + 1);\n\t}\n\n\treturn commit->body;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_body(git_commit *commit)\n{\n\tconst char *msg, *end;\n\n\tassert(commit);\n\n\tif (!commit->body) {\n\t\t/* search for end of summary */\n\t\tfor (msg = git_commit_message(commit); *msg; ++msg)\n\t\t\tif (msg[0] == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\n\t\t/* trim leading and trailing whitespace */\n\t\tfor (; *msg; ++msg)\n\t\t\tif (!git__isspace(*msg))\n\t\t\t\tbreak;\n\t\tfor (end = msg + strlen(msg) - 1; msg <= end; --end)\n\t\t\tif (!git__isspace(*end))\n\t\t\t\tbreak;\n\n\t\tif (*msg)\n\t\t\t    commit->body = git__strndup(msg, end - msg + 1);\n\t}\n\n\treturn commit->body;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_summary",
          "args": [
            "commit"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_summary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "458-501",
          "snippet": "const char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nconst char *git_commit_summary(git_commit *commit)\n{\n\tgit_buf summary = GIT_BUF_INIT;\n\tconst char *msg, *space;\n\tbool space_contains_newline = false;\n\n\tassert(commit);\n\n\tif (!commit->summary) {\n\t\tfor (msg = git_commit_message(commit), space = NULL; *msg; ++msg) {\n\t\t\tchar next_character = msg[0];\n\t\t\t/* stop processing at the end of the first paragraph */\n\t\t\tif (next_character == '\\n' && (!msg[1] || msg[1] == '\\n'))\n\t\t\t\tbreak;\n\t\t\t/* record the beginning of contiguous whitespace runs */\n\t\t\telse if (git__isspace(next_character)) {\n\t\t\t\tif(space == NULL) {\n\t\t\t\t\tspace = msg;\n\t\t\t\t\tspace_contains_newline = false;\n\t\t\t\t}\n\t\t\t\tspace_contains_newline |= next_character == '\\n';\n\t\t\t}\n\t\t\t/* the next character is non-space */\n\t\t\telse {\n\t\t\t\t/* process any recorded whitespace */\n\t\t\t\tif (space) {\n\t\t\t\t\tif(space_contains_newline)\n\t\t\t\t\t\tgit_buf_putc(&summary, ' '); /* if the space contains a newline, collapse to ' ' */\n\t\t\t\t\telse\n\t\t\t\t\t\tgit_buf_put(&summary, space, (msg - space)); /* otherwise copy it */\n\t\t\t\t\tspace = NULL;\n\t\t\t\t}\n\t\t\t\t/* copy the next character */\n\t\t\t\tgit_buf_putc(&summary, next_character);\n\t\t\t}\n\t\t}\n\n\t\tcommit->summary = git_buf_detach(&summary);\n\t\tif (!commit->summary)\n\t\t\tcommit->summary = git__strdup(\"\");\n\t}\n\n\treturn commit->summary;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && repo && commit"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_commit_as_email(\n\tgit_buf *out,\n\tgit_repository *repo,\n\tgit_commit *commit,\n\tsize_t patch_no,\n\tsize_t total_patches,\n\tgit_diff_format_email_flags_t flags,\n\tconst git_diff_options *diff_opts)\n{\n\tgit_diff *diff = NULL;\n\tgit_diff_format_email_options opts = GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT;\n\tint error;\n\n\tassert (out && repo && commit);\n\n\topts.flags = flags;\n\topts.patch_no = patch_no;\n\topts.total_patches = total_patches;\n\topts.id = git_commit_id(commit);\n\topts.summary = git_commit_summary(commit);\n\topts.body = git_commit_body(commit);\n\topts.author = git_commit_author(commit);\n\n\tif ((error = git_diff__commit(&diff, repo, commit, diff_opts)) < 0)\n\t\treturn error;\n\n\terror = git_diff_format_email(out, diff, &opts);\n\n\tgit_diff_free(diff);\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_format_email",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1736-1807",
    "snippet": "int git_diff_format_email(\n\tgit_buf *out,\n\tgit_diff *diff,\n\tconst git_diff_format_email_options *opts)\n{\n\tgit_diff_stats *stats = NULL;\n\tchar *summary = NULL, *loc = NULL;\n\tbool ignore_marker;\n\tunsigned int format_flags = 0;\n\tsize_t allocsize;\n\tint error;\n\n\tassert(out && diff && opts);\n\tassert(opts->summary && opts->id && opts->author);\n\n\tGITERR_CHECK_VERSION(opts, GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION, \"git_format_email_options\");\n\n\tif ((ignore_marker = opts->flags & GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER) == false) {\n\t\tif (opts->patch_no > opts->total_patches) {\n\t\t\tgiterr_set(GITERR_INVALID, \"patch %\"PRIuZ\" out of range. max %\"PRIuZ, opts->patch_no, opts->total_patches);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (opts->patch_no == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"invalid patch no %\"PRIuZ\". should be >0\", opts->patch_no);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* the summary we receive may not be clean.\n\t * it could potentially contain new line characters\n\t * or not be set, sanitize, */\n\tif ((loc = strpbrk(opts->summary, \"\\r\\n\")) != NULL) {\n\t\tsize_t offset = 0;\n\n\t\tif ((offset = (loc - opts->summary)) == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"summary is empty\");\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&allocsize, offset, 1);\n\t\tsummary = git__calloc(allocsize, sizeof(char));\n\t\tGITERR_CHECK_ALLOC(summary);\n\n\t\tstrncpy(summary, opts->summary, offset);\n\t}\n\n\terror = git_diff_format_email__append_header_tobuf(out,\n\t\t\t\topts->id, opts->author, summary == NULL ? opts->summary : summary,\n\t\t\t\topts->body, opts->patch_no, opts->total_patches, ignore_marker);\n\n\tif (error < 0)\n\t\tgoto on_error;\n\n\tformat_flags = GIT_DIFF_STATS_FULL | GIT_DIFF_STATS_INCLUDE_SUMMARY;\n\n\tif ((error = git_buf_puts(out, \"---\\n\")) < 0 ||\n\t\t(error = git_diff_get_stats(&stats, diff)) < 0 ||\n\t\t(error = git_diff_stats_to_buf(out, stats, format_flags, 0)) < 0 ||\n\t\t(error = git_buf_putc(out, '\\n')) < 0 ||\n\t\t(error = git_diff_format_email__append_patches_tobuf(out, diff)) < 0)\n\t\t\tgoto on_error;\n\n\terror = git_buf_puts(out, \"--\\nlibgit2 \" LIBGIT2_VERSION \"\\n\\n\");\n\non_error:\n\tgit__free(summary);\n\tgit_diff_stats_free(stats);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_stats_free",
          "args": [
            "stats"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_stats_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_stats.c",
          "lines": "327-335",
          "snippet": "void git_diff_stats_free(git_diff_stats *stats)\n{\n\tif (stats == NULL)\n\t\treturn;\n\n\tgit_diff_free(stats->diff); /* bumped refcount in constructor */\n\tgit__free(stats->filestats);\n\tgit__free(stats);\n}",
          "includes": [
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_diff_stats_free(git_diff_stats *stats)\n{\n\tif (stats == NULL)\n\t\treturn;\n\n\tgit_diff_free(stats->diff); /* bumped refcount in constructor */\n\tgit__free(stats->filestats);\n\tgit__free(stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "summary"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "\"--\\nlibgit2 \" LIBGIT2_VERSION \"\\n\\n\""
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_format_email__append_patches_tobuf",
          "args": [
            "out",
            "diff"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_format_email__append_patches_tobuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1712-1734",
          "snippet": "int git_diff_format_email__append_patches_tobuf(\n\tgit_buf *out,\n\tgit_diff *diff)\n{\n\tsize_t i, deltas;\n\tint error = 0;\n\n\tdeltas = git_diff_num_deltas(diff);\n\n\tfor (i = 0; i < deltas; ++i) {\n\t\tgit_patch *patch = NULL;\n\n\t\tif ((error = git_patch_from_diff(&patch, diff, i)) >= 0)\n\t\t\terror = git_patch_to_buf(out, patch);\n\n\t\tgit_patch_free(patch);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email__append_patches_tobuf(\n\tgit_buf *out,\n\tgit_diff *diff)\n{\n\tsize_t i, deltas;\n\tint error = 0;\n\n\tdeltas = git_diff_num_deltas(diff);\n\n\tfor (i = 0; i < deltas; ++i) {\n\t\tgit_patch *patch = NULL;\n\n\t\tif ((error = git_patch_from_diff(&patch, diff, i)) >= 0)\n\t\t\terror = git_patch_to_buf(out, patch);\n\n\t\tgit_patch_free(patch);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "out",
            "'\\n'"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_stats_to_buf",
          "args": [
            "out",
            "stats",
            "format_flags",
            "0"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_stats_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_stats.c",
          "lines": "256-325",
          "snippet": "int git_diff_stats_to_buf(\n\tgit_buf *out,\n\tconst git_diff_stats *stats,\n\tgit_diff_stats_format_t format,\n\tsize_t width)\n{\n\tint error = 0;\n\tsize_t i;\n\tconst git_diff_delta *delta;\n\n\tassert(out && stats);\n\n\tif (format & GIT_DIFF_STATS_NUMBER) {\n\t\tfor (i = 0; i < stats->files_changed; ++i) {\n\t\t\tif ((delta = git_diff_get_delta(stats->diff, i)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_diff_file_stats__number_to_buf(\n\t\t\t\tout, delta, &stats->filestats[i]);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (format & GIT_DIFF_STATS_FULL) {\n\t\tif (width > 0) {\n\t\t\tif (width > stats->max_name + stats->max_digits + 5)\n\t\t\t\twidth -= (stats->max_name + stats->max_digits + 5);\n\t\t\tif (width < STATS_FULL_MIN_SCALE)\n\t\t\t\twidth = STATS_FULL_MIN_SCALE;\n\t\t}\n\t\tif (width > stats->max_filestat)\n\t\t\twidth = 0;\n\n\t\tfor (i = 0; i < stats->files_changed; ++i) {\n\t\t\tif ((delta = git_diff_get_delta(stats->diff, i)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_diff_file_stats__full_to_buf(\n\t\t\t\tout, delta, &stats->filestats[i], stats, width);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (format & GIT_DIFF_STATS_FULL || format & GIT_DIFF_STATS_SHORT) {\n\t\terror = git_buf_printf(\n\t\t\tout, \" %\" PRIuZ \" file%s changed, %\" PRIuZ\n\t\t\t\" insertion%s(+), %\" PRIuZ \" deletion%s(-)\\n\",\n\t\t\tstats->files_changed, stats->files_changed != 1 ? \"s\" : \"\",\n\t\t\tstats->insertions, stats->insertions != 1 ? \"s\" : \"\",\n\t\t\tstats->deletions, stats->deletions != 1 ? \"s\" : \"\");\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (format & GIT_DIFF_STATS_INCLUDE_SUMMARY) {\n\t\tfor (i = 0; i < stats->files_changed; ++i) {\n\t\t\tif ((delta = git_diff_get_delta(stats->diff, i)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_diff_file_stats__summary_to_buf(out, delta);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define STATS_FULL_MIN_SCALE 7"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"vector.h\"\n#include \"common.h\"\n\n#define STATS_FULL_MIN_SCALE 7\n\nint git_diff_stats_to_buf(\n\tgit_buf *out,\n\tconst git_diff_stats *stats,\n\tgit_diff_stats_format_t format,\n\tsize_t width)\n{\n\tint error = 0;\n\tsize_t i;\n\tconst git_diff_delta *delta;\n\n\tassert(out && stats);\n\n\tif (format & GIT_DIFF_STATS_NUMBER) {\n\t\tfor (i = 0; i < stats->files_changed; ++i) {\n\t\t\tif ((delta = git_diff_get_delta(stats->diff, i)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_diff_file_stats__number_to_buf(\n\t\t\t\tout, delta, &stats->filestats[i]);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (format & GIT_DIFF_STATS_FULL) {\n\t\tif (width > 0) {\n\t\t\tif (width > stats->max_name + stats->max_digits + 5)\n\t\t\t\twidth -= (stats->max_name + stats->max_digits + 5);\n\t\t\tif (width < STATS_FULL_MIN_SCALE)\n\t\t\t\twidth = STATS_FULL_MIN_SCALE;\n\t\t}\n\t\tif (width > stats->max_filestat)\n\t\t\twidth = 0;\n\n\t\tfor (i = 0; i < stats->files_changed; ++i) {\n\t\t\tif ((delta = git_diff_get_delta(stats->diff, i)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_diff_file_stats__full_to_buf(\n\t\t\t\tout, delta, &stats->filestats[i], stats, width);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif (format & GIT_DIFF_STATS_FULL || format & GIT_DIFF_STATS_SHORT) {\n\t\terror = git_buf_printf(\n\t\t\tout, \" %\" PRIuZ \" file%s changed, %\" PRIuZ\n\t\t\t\" insertion%s(+), %\" PRIuZ \" deletion%s(-)\\n\",\n\t\t\tstats->files_changed, stats->files_changed != 1 ? \"s\" : \"\",\n\t\t\tstats->insertions, stats->insertions != 1 ? \"s\" : \"\",\n\t\t\tstats->deletions, stats->deletions != 1 ? \"s\" : \"\");\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\tif (format & GIT_DIFF_STATS_INCLUDE_SUMMARY) {\n\t\tfor (i = 0; i < stats->files_changed; ++i) {\n\t\t\tif ((delta = git_diff_get_delta(stats->diff, i)) == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_diff_file_stats__summary_to_buf(out, delta);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_get_stats",
          "args": [
            "&stats",
            "diff"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_get_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_stats.c",
          "lines": "159-230",
          "snippet": "int git_diff_get_stats(\n\tgit_diff_stats **out,\n\tgit_diff *diff)\n{\n\tsize_t i, deltas;\n\tsize_t total_insertions = 0, total_deletions = 0;\n\tgit_diff_stats *stats = NULL;\n\tint error = 0;\n\n\tassert(out && diff);\n\n\tstats = git__calloc(1, sizeof(git_diff_stats));\n\tGITERR_CHECK_ALLOC(stats);\n\n\tdeltas = git_diff_num_deltas(diff);\n\n\tstats->filestats = git__calloc(deltas, sizeof(diff_file_stats));\n\tif (!stats->filestats) {\n\t\tgit__free(stats);\n\t\treturn -1;\n\t}\n\n\tstats->diff = diff;\n\tGIT_REFCOUNT_INC(diff);\n\n\tfor (i = 0; i < deltas && !error; ++i) {\n\t\tgit_patch *patch = NULL;\n\t\tsize_t add = 0, remove = 0, namelen;\n\t\tconst git_diff_delta *delta;\n\n\t\tif ((error = git_patch_from_diff(&patch, diff, i)) < 0)\n\t\t\tbreak;\n\n\t\t/* keep a count of renames because it will affect formatting */\n\t\tdelta = git_patch_get_delta(patch);\n\n\t\tnamelen = strlen(delta->new_file.path);\n\t\tif (strcmp(delta->old_file.path, delta->new_file.path) != 0) {\n\t\t\tnamelen += strlen(delta->old_file.path);\n\t\t\tstats->renames++;\n\t\t}\n\n\t\t/* and, of course, count the line stats */\n\t\terror = git_patch_line_stats(NULL, &add, &remove, patch);\n\n\t\tgit_patch_free(patch);\n\n\t\tstats->filestats[i].insertions = add;\n\t\tstats->filestats[i].deletions = remove;\n\n\t\ttotal_insertions += add;\n\t\ttotal_deletions += remove;\n\n\t\tif (stats->max_name < namelen)\n\t\t\tstats->max_name = namelen;\n\t\tif (stats->max_filestat < add + remove)\n\t\t\tstats->max_filestat = add + remove;\n\t}\n\n\tstats->files_changed = deltas;\n\tstats->insertions = total_insertions;\n\tstats->deletions = total_deletions;\n\tstats->max_digits = digits_for_value(stats->max_filestat + 1);\n\n\tif (error < 0) {\n\t\tgit_diff_stats_free(stats);\n\t\tstats = NULL;\n\t}\n\n\t*out = stats;\n\treturn error;\n}",
          "includes": [
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"vector.h\"\n#include \"common.h\"\n\nint git_diff_get_stats(\n\tgit_diff_stats **out,\n\tgit_diff *diff)\n{\n\tsize_t i, deltas;\n\tsize_t total_insertions = 0, total_deletions = 0;\n\tgit_diff_stats *stats = NULL;\n\tint error = 0;\n\n\tassert(out && diff);\n\n\tstats = git__calloc(1, sizeof(git_diff_stats));\n\tGITERR_CHECK_ALLOC(stats);\n\n\tdeltas = git_diff_num_deltas(diff);\n\n\tstats->filestats = git__calloc(deltas, sizeof(diff_file_stats));\n\tif (!stats->filestats) {\n\t\tgit__free(stats);\n\t\treturn -1;\n\t}\n\n\tstats->diff = diff;\n\tGIT_REFCOUNT_INC(diff);\n\n\tfor (i = 0; i < deltas && !error; ++i) {\n\t\tgit_patch *patch = NULL;\n\t\tsize_t add = 0, remove = 0, namelen;\n\t\tconst git_diff_delta *delta;\n\n\t\tif ((error = git_patch_from_diff(&patch, diff, i)) < 0)\n\t\t\tbreak;\n\n\t\t/* keep a count of renames because it will affect formatting */\n\t\tdelta = git_patch_get_delta(patch);\n\n\t\tnamelen = strlen(delta->new_file.path);\n\t\tif (strcmp(delta->old_file.path, delta->new_file.path) != 0) {\n\t\t\tnamelen += strlen(delta->old_file.path);\n\t\t\tstats->renames++;\n\t\t}\n\n\t\t/* and, of course, count the line stats */\n\t\terror = git_patch_line_stats(NULL, &add, &remove, patch);\n\n\t\tgit_patch_free(patch);\n\n\t\tstats->filestats[i].insertions = add;\n\t\tstats->filestats[i].deletions = remove;\n\n\t\ttotal_insertions += add;\n\t\ttotal_deletions += remove;\n\n\t\tif (stats->max_name < namelen)\n\t\t\tstats->max_name = namelen;\n\t\tif (stats->max_filestat < add + remove)\n\t\t\tstats->max_filestat = add + remove;\n\t}\n\n\tstats->files_changed = deltas;\n\tstats->insertions = total_insertions;\n\tstats->deletions = total_deletions;\n\tstats->max_digits = digits_for_value(stats->max_filestat + 1);\n\n\tif (error < 0) {\n\t\tgit_diff_stats_free(stats);\n\t\tstats = NULL;\n\t}\n\n\t*out = stats;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_format_email__append_header_tobuf",
          "args": [
            "out",
            "opts->id",
            "opts->author",
            "summary == NULL ? opts->summary : summary",
            "opts->body",
            "opts->patch_no",
            "opts->total_patches",
            "ignore_marker"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_format_email__append_header_tobuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1657-1710",
          "snippet": "int git_diff_format_email__append_header_tobuf(\n\tgit_buf *out,\n\tconst git_oid *id,\n\tconst git_signature *author,\n\tconst char *summary,\n\tconst char *body,\n\tsize_t patch_no,\n\tsize_t total_patches,\n\tbool exclude_patchno_marker)\n{\n\tchar idstr[GIT_OID_HEXSZ + 1];\n\tchar date_str[GIT_DATE_RFC2822_SZ];\n\tint error = 0;\n\n\tgit_oid_fmt(idstr, id);\n\tidstr[GIT_OID_HEXSZ] = '\\0';\n\n\tif ((error = git__date_rfc2822_fmt(date_str, sizeof(date_str), &author->when)) < 0)\n\t\treturn error;\n\n\terror = git_buf_printf(out,\n\t\t\t\t\"From %s Mon Sep 17 00:00:00 2001\\n\" \\\n\t\t\t\t\"From: %s <%s>\\n\" \\\n\t\t\t\t\"Date: %s\\n\" \\\n\t\t\t\t\"Subject: \",\n\t\t\t\tidstr,\n\t\t\t\tauthor->name, author->email,\n\t\t\t\tdate_str);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!exclude_patchno_marker) {\n\t\tif (total_patches == 1) {\n\t\t\terror = git_buf_puts(out, \"[PATCH] \");\n\t\t} else {\n\t\t\terror = git_buf_printf(out, \"[PATCH %\"PRIuZ\"/%\"PRIuZ\"] \", patch_no, total_patches);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_buf_printf(out, \"%s\\n\\n\", summary);\n\n\tif (body) {\n\t\tgit_buf_puts(out, body);\n\n\t\tif (out->ptr[out->size - 1] != '\\n')\n\t\t\tgit_buf_putc(out, '\\n');\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email__append_header_tobuf(\n\tgit_buf *out,\n\tconst git_oid *id,\n\tconst git_signature *author,\n\tconst char *summary,\n\tconst char *body,\n\tsize_t patch_no,\n\tsize_t total_patches,\n\tbool exclude_patchno_marker)\n{\n\tchar idstr[GIT_OID_HEXSZ + 1];\n\tchar date_str[GIT_DATE_RFC2822_SZ];\n\tint error = 0;\n\n\tgit_oid_fmt(idstr, id);\n\tidstr[GIT_OID_HEXSZ] = '\\0';\n\n\tif ((error = git__date_rfc2822_fmt(date_str, sizeof(date_str), &author->when)) < 0)\n\t\treturn error;\n\n\terror = git_buf_printf(out,\n\t\t\t\t\"From %s Mon Sep 17 00:00:00 2001\\n\" \\\n\t\t\t\t\"From: %s <%s>\\n\" \\\n\t\t\t\t\"Date: %s\\n\" \\\n\t\t\t\t\"Subject: \",\n\t\t\t\tidstr,\n\t\t\t\tauthor->name, author->email,\n\t\t\t\tdate_str);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!exclude_patchno_marker) {\n\t\tif (total_patches == 1) {\n\t\t\terror = git_buf_puts(out, \"[PATCH] \");\n\t\t} else {\n\t\t\terror = git_buf_printf(out, \"[PATCH %\"PRIuZ\"/%\"PRIuZ\"] \", patch_no, total_patches);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_buf_printf(out, \"%s\\n\\n\", summary);\n\n\tif (body) {\n\t\tgit_buf_puts(out, body);\n\n\t\tif (out->ptr[out->size - 1] != '\\n')\n\t\t\tgit_buf_putc(out, '\\n');\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "summary",
            "opts->summary",
            "offset"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "summary"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "allocsize",
            "sizeof(char)"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&allocsize",
            "offset",
            "1"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"summary is empty\""
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "opts->summary",
            "\"\\r\\n\""
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"invalid patch no %\"PRIuZ\". should be >0\"",
            "opts->patch_no"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "opts",
            "GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION",
            "\"git_format_email_options\""
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "opts->summary && opts->id && opts->author"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && diff && opts"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email(\n\tgit_buf *out,\n\tgit_diff *diff,\n\tconst git_diff_format_email_options *opts)\n{\n\tgit_diff_stats *stats = NULL;\n\tchar *summary = NULL, *loc = NULL;\n\tbool ignore_marker;\n\tunsigned int format_flags = 0;\n\tsize_t allocsize;\n\tint error;\n\n\tassert(out && diff && opts);\n\tassert(opts->summary && opts->id && opts->author);\n\n\tGITERR_CHECK_VERSION(opts, GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION, \"git_format_email_options\");\n\n\tif ((ignore_marker = opts->flags & GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER) == false) {\n\t\tif (opts->patch_no > opts->total_patches) {\n\t\t\tgiterr_set(GITERR_INVALID, \"patch %\"PRIuZ\" out of range. max %\"PRIuZ, opts->patch_no, opts->total_patches);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (opts->patch_no == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"invalid patch no %\"PRIuZ\". should be >0\", opts->patch_no);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* the summary we receive may not be clean.\n\t * it could potentially contain new line characters\n\t * or not be set, sanitize, */\n\tif ((loc = strpbrk(opts->summary, \"\\r\\n\")) != NULL) {\n\t\tsize_t offset = 0;\n\n\t\tif ((offset = (loc - opts->summary)) == 0) {\n\t\t\tgiterr_set(GITERR_INVALID, \"summary is empty\");\n\t\t\terror = -1;\n\t\t\tgoto on_error;\n\t\t}\n\n\t\tGITERR_CHECK_ALLOC_ADD(&allocsize, offset, 1);\n\t\tsummary = git__calloc(allocsize, sizeof(char));\n\t\tGITERR_CHECK_ALLOC(summary);\n\n\t\tstrncpy(summary, opts->summary, offset);\n\t}\n\n\terror = git_diff_format_email__append_header_tobuf(out,\n\t\t\t\topts->id, opts->author, summary == NULL ? opts->summary : summary,\n\t\t\t\topts->body, opts->patch_no, opts->total_patches, ignore_marker);\n\n\tif (error < 0)\n\t\tgoto on_error;\n\n\tformat_flags = GIT_DIFF_STATS_FULL | GIT_DIFF_STATS_INCLUDE_SUMMARY;\n\n\tif ((error = git_buf_puts(out, \"---\\n\")) < 0 ||\n\t\t(error = git_diff_get_stats(&stats, diff)) < 0 ||\n\t\t(error = git_diff_stats_to_buf(out, stats, format_flags, 0)) < 0 ||\n\t\t(error = git_buf_putc(out, '\\n')) < 0 ||\n\t\t(error = git_diff_format_email__append_patches_tobuf(out, diff)) < 0)\n\t\t\tgoto on_error;\n\n\terror = git_buf_puts(out, \"--\\nlibgit2 \" LIBGIT2_VERSION \"\\n\\n\");\n\non_error:\n\tgit__free(summary);\n\tgit_diff_stats_free(stats);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_format_email__append_patches_tobuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1712-1734",
    "snippet": "int git_diff_format_email__append_patches_tobuf(\n\tgit_buf *out,\n\tgit_diff *diff)\n{\n\tsize_t i, deltas;\n\tint error = 0;\n\n\tdeltas = git_diff_num_deltas(diff);\n\n\tfor (i = 0; i < deltas; ++i) {\n\t\tgit_patch *patch = NULL;\n\n\t\tif ((error = git_patch_from_diff(&patch, diff, i)) >= 0)\n\t\t\terror = git_patch_to_buf(out, patch);\n\n\t\tgit_patch_free(patch);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_patch_free",
          "args": [
            "patch"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "git_patch_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_patch.c",
          "lines": "788-792",
          "snippet": "void git_patch_free(git_patch *patch)\n{\n\tif (patch)\n\t\tGIT_REFCOUNT_DEC(patch, diff_patch_free);\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"zstream.h\"",
            "#include \"delta.h\"",
            "#include \"diff_xdiff.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void diff_output_to_patch(git_diff_output *, git_patch *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"zstream.h\"\n#include \"delta.h\"\n#include \"diff_xdiff.h\"\n#include \"diff_patch.h\"\n#include \"diff_driver.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic void diff_output_to_patch(git_diff_output *, git_patch *);\n\nvoid git_patch_free(git_patch *patch)\n{\n\tif (patch)\n\t\tGIT_REFCOUNT_DEC(patch, diff_patch_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_patch_to_buf",
          "args": [
            "out",
            "patch"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "git_patch_to_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_print.c",
          "lines": "663-668",
          "snippet": "int git_patch_to_buf(git_buf *out, git_patch *patch)\n{\n\tassert(out && patch);\n\tgit_buf_sanitize(out);\n\treturn git_patch_print(patch, git_diff_print_callback__to_buf, out);\n}",
          "includes": [
            "#include \"git2/sys/diff.h\"",
            "#include \"delta.h\"",
            "#include \"blob.h\"",
            "#include \"zstream.h\"",
            "#include \"fileops.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/diff.h\"\n#include \"delta.h\"\n#include \"blob.h\"\n#include \"zstream.h\"\n#include \"fileops.h\"\n#include \"diff_patch.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_patch_to_buf(git_buf *out, git_patch *patch)\n{\n\tassert(out && patch);\n\tgit_buf_sanitize(out);\n\treturn git_patch_print(patch, git_diff_print_callback__to_buf, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_patch_from_diff",
          "args": [
            "&patch",
            "diff",
            "i"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "git_patch_from_diff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_patch.c",
          "lines": "735-786",
          "snippet": "int git_patch_from_diff(\n\tgit_patch **patch_ptr, git_diff *diff, size_t idx)\n{\n\tint error = 0;\n\tgit_xdiff_output xo;\n\tgit_diff_delta *delta = NULL;\n\tgit_patch *patch = NULL;\n\n\tif (patch_ptr) *patch_ptr = NULL;\n\n\tif (diff_required(diff, \"git_patch_from_diff\") < 0)\n\t\treturn -1;\n\n\tdelta = git_vector_get(&diff->deltas, idx);\n\tif (!delta) {\n\t\tgiterr_set(GITERR_INVALID, \"Index out of range for delta in diff\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (git_diff_delta__should_skip(&diff->opts, delta))\n\t\treturn 0;\n\n\t/* don't load the patch data unless we need it for binary check */\n\tif (!patch_ptr &&\n\t\t((delta->flags & DIFF_FLAGS_KNOWN_BINARY) != 0 ||\n\t\t (diff->opts.flags & GIT_DIFF_SKIP_BINARY_CHECK) != 0))\n\t\treturn 0;\n\n\tif ((error = diff_patch_alloc_from_diff(&patch, diff, idx)) < 0)\n\t\treturn error;\n\n\tmemset(&xo, 0, sizeof(xo));\n\tdiff_output_to_patch(&xo.output, patch);\n\tgit_xdiff_init(&xo, &diff->opts);\n\n\terror = diff_patch_invoke_file_callback(patch, &xo.output);\n\n\tif (!error)\n\t\terror = diff_patch_generate(patch, &xo.output);\n\n\tif (!error) {\n\t\t/* TODO: if cumulative diff size is < 0.5 total size, flatten patch */\n\t\t/* TODO: and unload the file content */\n\t}\n\n\tif (error || !patch_ptr)\n\t\tgit_patch_free(patch);\n\telse\n\t\t*patch_ptr = patch;\n\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"zstream.h\"",
            "#include \"delta.h\"",
            "#include \"diff_xdiff.h\"",
            "#include \"diff_patch.h\"",
            "#include \"diff_driver.h\"",
            "#include \"diff_file.h\"",
            "#include \"diff.h\"",
            "#include \"git2/blob.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void diff_output_to_patch(git_diff_output *, git_patch *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"zstream.h\"\n#include \"delta.h\"\n#include \"diff_xdiff.h\"\n#include \"diff_patch.h\"\n#include \"diff_driver.h\"\n#include \"diff_file.h\"\n#include \"diff.h\"\n#include \"git2/blob.h\"\n#include \"common.h\"\n\nstatic void diff_output_to_patch(git_diff_output *, git_patch *);\n\nint git_patch_from_diff(\n\tgit_patch **patch_ptr, git_diff *diff, size_t idx)\n{\n\tint error = 0;\n\tgit_xdiff_output xo;\n\tgit_diff_delta *delta = NULL;\n\tgit_patch *patch = NULL;\n\n\tif (patch_ptr) *patch_ptr = NULL;\n\n\tif (diff_required(diff, \"git_patch_from_diff\") < 0)\n\t\treturn -1;\n\n\tdelta = git_vector_get(&diff->deltas, idx);\n\tif (!delta) {\n\t\tgiterr_set(GITERR_INVALID, \"Index out of range for delta in diff\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tif (git_diff_delta__should_skip(&diff->opts, delta))\n\t\treturn 0;\n\n\t/* don't load the patch data unless we need it for binary check */\n\tif (!patch_ptr &&\n\t\t((delta->flags & DIFF_FLAGS_KNOWN_BINARY) != 0 ||\n\t\t (diff->opts.flags & GIT_DIFF_SKIP_BINARY_CHECK) != 0))\n\t\treturn 0;\n\n\tif ((error = diff_patch_alloc_from_diff(&patch, diff, idx)) < 0)\n\t\treturn error;\n\n\tmemset(&xo, 0, sizeof(xo));\n\tdiff_output_to_patch(&xo.output, patch);\n\tgit_xdiff_init(&xo, &diff->opts);\n\n\terror = diff_patch_invoke_file_callback(patch, &xo.output);\n\n\tif (!error)\n\t\terror = diff_patch_generate(patch, &xo.output);\n\n\tif (!error) {\n\t\t/* TODO: if cumulative diff size is < 0.5 total size, flatten patch */\n\t\t/* TODO: and unload the file content */\n\t}\n\n\tif (error || !patch_ptr)\n\t\tgit_patch_free(patch);\n\telse\n\t\t*patch_ptr = patch;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_num_deltas",
          "args": [
            "diff"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_num_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1486-1490",
          "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email__append_patches_tobuf(\n\tgit_buf *out,\n\tgit_diff *diff)\n{\n\tsize_t i, deltas;\n\tint error = 0;\n\n\tdeltas = git_diff_num_deltas(diff);\n\n\tfor (i = 0; i < deltas; ++i) {\n\t\tgit_patch *patch = NULL;\n\n\t\tif ((error = git_patch_from_diff(&patch, diff, i)) >= 0)\n\t\t\terror = git_patch_to_buf(out, patch);\n\n\t\tgit_patch_free(patch);\n\n\t\tif (error < 0)\n\t\t\tbreak;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_format_email__append_header_tobuf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1657-1710",
    "snippet": "int git_diff_format_email__append_header_tobuf(\n\tgit_buf *out,\n\tconst git_oid *id,\n\tconst git_signature *author,\n\tconst char *summary,\n\tconst char *body,\n\tsize_t patch_no,\n\tsize_t total_patches,\n\tbool exclude_patchno_marker)\n{\n\tchar idstr[GIT_OID_HEXSZ + 1];\n\tchar date_str[GIT_DATE_RFC2822_SZ];\n\tint error = 0;\n\n\tgit_oid_fmt(idstr, id);\n\tidstr[GIT_OID_HEXSZ] = '\\0';\n\n\tif ((error = git__date_rfc2822_fmt(date_str, sizeof(date_str), &author->when)) < 0)\n\t\treturn error;\n\n\terror = git_buf_printf(out,\n\t\t\t\t\"From %s Mon Sep 17 00:00:00 2001\\n\" \\\n\t\t\t\t\"From: %s <%s>\\n\" \\\n\t\t\t\t\"Date: %s\\n\" \\\n\t\t\t\t\"Subject: \",\n\t\t\t\tidstr,\n\t\t\t\tauthor->name, author->email,\n\t\t\t\tdate_str);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!exclude_patchno_marker) {\n\t\tif (total_patches == 1) {\n\t\t\terror = git_buf_puts(out, \"[PATCH] \");\n\t\t} else {\n\t\t\terror = git_buf_printf(out, \"[PATCH %\"PRIuZ\"/%\"PRIuZ\"] \", patch_no, total_patches);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_buf_printf(out, \"%s\\n\\n\", summary);\n\n\tif (body) {\n\t\tgit_buf_puts(out, body);\n\n\t\tif (out->ptr[out->size - 1] != '\\n')\n\t\t\tgit_buf_putc(out, '\\n');\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "out",
            "'\\n'"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "out",
            "body"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_printf",
          "args": [
            "out",
            "\"%s\\n\\n\"",
            "summary"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "406-416",
          "snippet": "int git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_printf(git_buf *buf, const char *format, ...)\n{\n\tint r;\n\tva_list ap;\n\n\tva_start(ap, format);\n\tr = git_buf_vprintf(buf, format, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__date_rfc2822_fmt",
          "args": [
            "date_str",
            "sizeof(date_str)",
            "&author->when"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "git__date_rfc2822_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/date.c",
          "lines": "878-903",
          "snippet": "int git__date_rfc2822_fmt(char *out, size_t len, const git_time *date)\n{\n\tint written;\n\tstruct tm gmt;\n\ttime_t t;\n\n\tassert(out && date);\n\n\tt = (time_t) (date->time + date->offset * 60);\n\n\tif (p_gmtime_r (&t, &gmt) == NULL)\n\t\treturn -1;\n\n\twritten = p_snprintf(out, len, \"%.3s, %u %.3s %.4u %02u:%02u:%02u %+03d%02d\",\n\t\tweekday_names[gmt.tm_wday],\n\t\tgmt.tm_mday,\n\t\tmonth_names[gmt.tm_mon],\n\t\tgmt.tm_year + 1900,\n\t\tgmt.tm_hour, gmt.tm_min, gmt.tm_sec,\n\t\tdate->offset / 60, date->offset % 60);\n\n\tif (written < 0 || (written > (int) len - 1))\n\t\treturn -1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <time.h>",
            "#include <ctype.h>",
            "#include \"posix.h\"",
            "#include \"cache.h\"",
            "#include \"util.h\"",
            "#include <sys/time.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *month_names[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n\t\"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};",
            "static const char *weekday_names[] = {\n\t\"Sundays\", \"Mondays\", \"Tuesdays\", \"Wednesdays\", \"Thursdays\", \"Fridays\", \"Saturdays\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <ctype.h>\n#include \"posix.h\"\n#include \"cache.h\"\n#include \"util.h\"\n#include <sys/time.h>\n#include \"common.h\"\n\nstatic const char *month_names[] = {\n\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n\t\"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n};\nstatic const char *weekday_names[] = {\n\t\"Sundays\", \"Mondays\", \"Tuesdays\", \"Wednesdays\", \"Thursdays\", \"Fridays\", \"Saturdays\"\n};\n\nint git__date_rfc2822_fmt(char *out, size_t len, const git_time *date)\n{\n\tint written;\n\tstruct tm gmt;\n\ttime_t t;\n\n\tassert(out && date);\n\n\tt = (time_t) (date->time + date->offset * 60);\n\n\tif (p_gmtime_r (&t, &gmt) == NULL)\n\t\treturn -1;\n\n\twritten = p_snprintf(out, len, \"%.3s, %u %.3s %.4u %02u:%02u:%02u %+03d%02d\",\n\t\tweekday_names[gmt.tm_wday],\n\t\tgmt.tm_mday,\n\t\tmonth_names[gmt.tm_mon],\n\t\tgmt.tm_year + 1900,\n\t\tgmt.tm_hour, gmt.tm_min, gmt.tm_sec,\n\t\tdate->offset / 60, date->offset % 60);\n\n\tif (written < 0 || (written > (int) len - 1))\n\t\treturn -1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "idstr",
            "id"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_format_email__append_header_tobuf(\n\tgit_buf *out,\n\tconst git_oid *id,\n\tconst git_signature *author,\n\tconst char *summary,\n\tconst char *body,\n\tsize_t patch_no,\n\tsize_t total_patches,\n\tbool exclude_patchno_marker)\n{\n\tchar idstr[GIT_OID_HEXSZ + 1];\n\tchar date_str[GIT_DATE_RFC2822_SZ];\n\tint error = 0;\n\n\tgit_oid_fmt(idstr, id);\n\tidstr[GIT_OID_HEXSZ] = '\\0';\n\n\tif ((error = git__date_rfc2822_fmt(date_str, sizeof(date_str), &author->when)) < 0)\n\t\treturn error;\n\n\terror = git_buf_printf(out,\n\t\t\t\t\"From %s Mon Sep 17 00:00:00 2001\\n\" \\\n\t\t\t\t\"From: %s <%s>\\n\" \\\n\t\t\t\t\"Date: %s\\n\" \\\n\t\t\t\t\"Subject: \",\n\t\t\t\tidstr,\n\t\t\t\tauthor->name, author->email,\n\t\t\t\tdate_str);\n\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!exclude_patchno_marker) {\n\t\tif (total_patches == 1) {\n\t\t\terror = git_buf_puts(out, \"[PATCH] \");\n\t\t} else {\n\t\t\terror = git_buf_printf(out, \"[PATCH %\"PRIuZ\"/%\"PRIuZ\"] \", patch_no, total_patches);\n\t\t}\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_buf_printf(out, \"%s\\n\\n\", summary);\n\n\tif (body) {\n\t\tgit_buf_puts(out, body);\n\n\t\tif (out->ptr[out->size - 1] != '\\n')\n\t\t\tgit_buf_putc(out, '\\n');\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff__commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1617-1655",
    "snippet": "int git_diff__commit(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tconst git_commit *commit,\n\tconst git_diff_options *opts)\n{\n\tgit_commit *parent = NULL;\n\tgit_diff *commit_diff = NULL;\n\tgit_tree *old_tree = NULL, *new_tree = NULL;\n\tsize_t parents;\n\tint error = 0;\n\n\tif ((parents = git_commit_parentcount(commit)) > 1) {\n\t\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\t\terror = -1;\n\t\tgiterr_set(GITERR_INVALID, \"Commit %s is a merge commit\",\n\t\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\t\tgoto on_error;\n\t}\n\n\tif (parents > 0)\n\t\tif ((error = git_commit_parent(&parent, commit, 0)) < 0 ||\n\t\t\t(error = git_commit_tree(&old_tree, parent)) < 0)\n\t\t\t\tgoto on_error;\n\n\tif ((error = git_commit_tree(&new_tree, commit)) < 0 ||\n\t\t(error = git_diff_tree_to_tree(&commit_diff, repo, old_tree, new_tree, opts)) < 0)\n\t\t\tgoto on_error;\n\n\t*diff = commit_diff;\n\non_error:\n\tgit_tree_free(new_tree);\n\tgit_tree_free(old_tree);\n\tgit_commit_free(parent);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_commit_free",
          "args": [
            "parent"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "30-33",
          "snippet": "void git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_commit_free(git_commit *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "old_tree"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_tree",
          "args": [
            "&commit_diff",
            "repo",
            "old_tree",
            "new_tree",
            "opts"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1315-1340",
          "snippet": "int git_diff_tree_to_tree(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_tree *new_tree,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\t/* for tree to tree diff, be case sensitive even if the index is\n\t * currently case insensitive, unless the user explicitly asked\n\t * for case insensitivity\n\t */\n\tif (opts && (opts->flags & GIT_DIFF_IGNORE_CASE) != 0)\n\t\tiflag = GIT_ITERATOR_IGNORE_CASE;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_tree(&b, new_tree, &b_opts), iflag\n\t);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_tree(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_tree *new_tree,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\t/* for tree to tree diff, be case sensitive even if the index is\n\t * currently case insensitive, unless the user explicitly asked\n\t * for case insensitivity\n\t */\n\tif (opts && (opts->flags & GIT_DIFF_IGNORE_CASE) != 0)\n\t\tiflag = GIT_ITERATOR_IGNORE_CASE;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_tree(&b, new_tree, &b_opts), iflag\n\t);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_tree",
          "args": [
            "&new_tree",
            "commit"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "530-534",
          "snippet": "int git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_tree(git_tree **tree_out, const git_commit *commit)\n{\n\tassert(commit);\n\treturn git_tree_lookup(tree_out, commit->object.repo, &commit->tree_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parent",
          "args": [
            "&parent",
            "commit",
            "0"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/commit.c",
          "lines": "544-557",
          "snippet": "int git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}",
          "includes": [
            "#include \"object.h\"",
            "#include \"refs.h\"",
            "#include \"message.h\"",
            "#include \"signature.h\"",
            "#include \"commit.h\"",
            "#include \"odb.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/commit.h\"",
            "#include \"git2/signature.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"object.h\"\n#include \"refs.h\"\n#include \"message.h\"\n#include \"signature.h\"\n#include \"commit.h\"\n#include \"odb.h\"\n#include \"common.h\"\n#include \"git2/sys/commit.h\"\n#include \"git2/signature.h\"\n#include \"git2/repository.h\"\n#include \"git2/object.h\"\n#include \"git2/common.h\"\n\nint git_commit_parent(\n\tgit_commit **parent, const git_commit *commit, unsigned int n)\n{\n\tconst git_oid *parent_id;\n\tassert(commit);\n\n\tparent_id = git_commit_parent_id(commit, n);\n\tif (parent_id == NULL) {\n\t\tgiterr_set(GITERR_INVALID, \"Parent %u does not exist\", n);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\treturn git_commit_lookup(parent, commit->object.repo, parent_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Commit %s is a merge commit\"",
            "git_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit))"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_tostr",
          "args": [
            "commit_oidstr",
            "GIT_OID_HEXSZ + 1",
            "git_commit_id(commit)"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_tostr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "119-131",
          "snippet": "char *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nchar *git_oid_tostr(char *out, size_t n, const git_oid *oid)\n{\n\tif (!out || n == 0)\n\t\treturn \"\";\n\n\tif (n > GIT_OID_HEXSZ + 1)\n\t\tn = GIT_OID_HEXSZ + 1;\n\n\tgit_oid_nfmt(out, n - 1, oid); /* allow room for terminating NUL */\n\tout[n - 1] = '\\0';\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_id",
          "args": [
            "commit"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "git_commit_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "35-38",
          "snippet": "const git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nconst git_oid *git_commit_id(const git_commit *obj)\n{\n\treturn git_object_id((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_commit_parentcount",
          "args": [
            "commit"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__commit(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tconst git_commit *commit,\n\tconst git_diff_options *opts)\n{\n\tgit_commit *parent = NULL;\n\tgit_diff *commit_diff = NULL;\n\tgit_tree *old_tree = NULL, *new_tree = NULL;\n\tsize_t parents;\n\tint error = 0;\n\n\tif ((parents = git_commit_parentcount(commit)) > 1) {\n\t\tchar commit_oidstr[GIT_OID_HEXSZ + 1];\n\n\t\terror = -1;\n\t\tgiterr_set(GITERR_INVALID, \"Commit %s is a merge commit\",\n\t\t\tgit_oid_tostr(commit_oidstr, GIT_OID_HEXSZ + 1, git_commit_id(commit)));\n\t\tgoto on_error;\n\t}\n\n\tif (parents > 0)\n\t\tif ((error = git_commit_parent(&parent, commit, 0)) < 0 ||\n\t\t\t(error = git_commit_tree(&old_tree, parent)) < 0)\n\t\t\t\tgoto on_error;\n\n\tif ((error = git_commit_tree(&new_tree, commit)) < 0 ||\n\t\t(error = git_diff_tree_to_tree(&commit_diff, repo, old_tree, new_tree, opts)) < 0)\n\t\t\tgoto on_error;\n\n\t*diff = commit_diff;\n\non_error:\n\tgit_tree_free(new_tree);\n\tgit_tree_free(old_tree);\n\tgit_commit_free(parent);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff__paired_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1526-1615",
    "snippet": "int git_diff__paired_foreach(\n\tgit_diff *head2idx,\n\tgit_diff *idx2wd,\n\tint (*cb)(git_diff_delta *h2i, git_diff_delta *i2w, void *payload),\n\tvoid *payload)\n{\n\tint cmp, error = 0;\n\tgit_diff_delta *h2i, *i2w;\n\tsize_t i, j, i_max, j_max;\n\tint (*strcomp)(const char *, const char *) = git__strcmp;\n\tbool h2i_icase, i2w_icase, icase_mismatch;\n\n\ti_max = head2idx ? head2idx->deltas.length : 0;\n\tj_max = idx2wd ? idx2wd->deltas.length : 0;\n\tif (!i_max && !j_max)\n\t\treturn 0;\n\n\t/* At some point, tree-to-index diffs will probably never ignore case,\n\t * even if that isn't true now.  Index-to-workdir diffs may or may not\n\t * ignore case, but the index filename for the idx2wd diff should\n\t * still be using the canonical case-preserving name.\n\t *\n\t * Therefore the main thing we need to do here is make sure the diffs\n\t * are traversed in a compatible order.  To do this, we temporarily\n\t * resort a mismatched diff to get the order correct.\n\t *\n\t * In order to traverse renames in the index->workdir, we need to\n\t * ensure that we compare the index name on both sides, so we\n\t * always sort by the old name in the i2w list.\n\t */\n\th2i_icase = head2idx != NULL &&\n\t\t(head2idx->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ti2w_icase = idx2wd != NULL &&\n\t\t(idx2wd->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ticase_mismatch =\n\t\t(head2idx != NULL && idx2wd != NULL && h2i_icase != i2w_icase);\n\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__cmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\tif (i2w_icase && !icase_mismatch) {\n\t\tstrcomp = git__strcasecmp;\n\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_casecmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t} else if (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\tfor (i = 0, j = 0; i < i_max || j < j_max; ) {\n\t\th2i = head2idx ? GIT_VECTOR_GET(&head2idx->deltas, i) : NULL;\n\t\ti2w = idx2wd ? GIT_VECTOR_GET(&idx2wd->deltas, j) : NULL;\n\n\t\tcmp = !i2w ? -1 : !h2i ? 1 :\n\t\t\tstrcomp(h2i->new_file.path, i2w->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\ti++; i2w = NULL;\n\t\t} else if (cmp > 0) {\n\t\t\tj++; h2i = NULL;\n\t\t} else {\n\t\t\ti++; j++;\n\t\t}\n\n\t\tif ((error = cb(h2i, i2w, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* restore case-insensitive delta sort */\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__casecmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\t/* restore idx2wd sort by new path */\n\tif (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas,\n\t\t\ti2w_icase ? git_diff_delta__casecmp : git_diff_delta__cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&idx2wd->deltas"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&idx2wd->deltas",
            "i2w_icase ? git_diff_delta__casecmp : git_diff_delta__cmp"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "h2i",
            "i2w",
            "payload"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "is_dirty_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/stash.c",
          "lines": "447-454",
          "snippet": "static int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"merge.h\"",
            "#include \"iterator.h\"",
            "#include \"signature.h\"",
            "#include \"index.h\"",
            "#include \"git2/merge.h\"",
            "#include \"git2/transaction.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/checkout.h\"",
            "#include \"git2/status.h\"",
            "#include \"git2/stash.h\"",
            "#include \"git2/diff.h\"",
            "#include \"reflog.h\"",
            "#include \"tree.h\"",
            "#include \"message.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"merge.h\"\n#include \"iterator.h\"\n#include \"signature.h\"\n#include \"index.h\"\n#include \"git2/merge.h\"\n#include \"git2/transaction.h\"\n#include \"git2/index.h\"\n#include \"git2/checkout.h\"\n#include \"git2/status.h\"\n#include \"git2/stash.h\"\n#include \"git2/diff.h\"\n#include \"reflog.h\"\n#include \"tree.h\"\n#include \"message.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n\nstatic int is_dirty_cb(const char *path, unsigned int status, void *payload)\n{\n\tGIT_UNUSED(path);\n\tGIT_UNUSED(status);\n\tGIT_UNUSED(payload);\n\n\treturn GIT_PASSTHROUGH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcomp",
          "args": [
            "h2i->new_file.path",
            "i2w->old_file.path"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&idx2wd->deltas",
            "j"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_VECTOR_GET",
          "args": [
            "&head2idx->deltas",
            "i"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__paired_foreach(\n\tgit_diff *head2idx,\n\tgit_diff *idx2wd,\n\tint (*cb)(git_diff_delta *h2i, git_diff_delta *i2w, void *payload),\n\tvoid *payload)\n{\n\tint cmp, error = 0;\n\tgit_diff_delta *h2i, *i2w;\n\tsize_t i, j, i_max, j_max;\n\tint (*strcomp)(const char *, const char *) = git__strcmp;\n\tbool h2i_icase, i2w_icase, icase_mismatch;\n\n\ti_max = head2idx ? head2idx->deltas.length : 0;\n\tj_max = idx2wd ? idx2wd->deltas.length : 0;\n\tif (!i_max && !j_max)\n\t\treturn 0;\n\n\t/* At some point, tree-to-index diffs will probably never ignore case,\n\t * even if that isn't true now.  Index-to-workdir diffs may or may not\n\t * ignore case, but the index filename for the idx2wd diff should\n\t * still be using the canonical case-preserving name.\n\t *\n\t * Therefore the main thing we need to do here is make sure the diffs\n\t * are traversed in a compatible order.  To do this, we temporarily\n\t * resort a mismatched diff to get the order correct.\n\t *\n\t * In order to traverse renames in the index->workdir, we need to\n\t * ensure that we compare the index name on both sides, so we\n\t * always sort by the old name in the i2w list.\n\t */\n\th2i_icase = head2idx != NULL &&\n\t\t(head2idx->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ti2w_icase = idx2wd != NULL &&\n\t\t(idx2wd->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n\n\ticase_mismatch =\n\t\t(head2idx != NULL && idx2wd != NULL && h2i_icase != i2w_icase);\n\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__cmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\tif (i2w_icase && !icase_mismatch) {\n\t\tstrcomp = git__strcasecmp;\n\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_casecmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t} else if (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas, git_diff_delta__i2w_cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\tfor (i = 0, j = 0; i < i_max || j < j_max; ) {\n\t\th2i = head2idx ? GIT_VECTOR_GET(&head2idx->deltas, i) : NULL;\n\t\ti2w = idx2wd ? GIT_VECTOR_GET(&idx2wd->deltas, j) : NULL;\n\n\t\tcmp = !i2w ? -1 : !h2i ? 1 :\n\t\t\tstrcomp(h2i->new_file.path, i2w->old_file.path);\n\n\t\tif (cmp < 0) {\n\t\t\ti++; i2w = NULL;\n\t\t} else if (cmp > 0) {\n\t\t\tj++; h2i = NULL;\n\t\t} else {\n\t\t\ti++; j++;\n\t\t}\n\n\t\tif ((error = cb(h2i, i2w, payload)) != 0) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* restore case-insensitive delta sort */\n\tif (icase_mismatch && h2i_icase) {\n\t\tgit_vector_set_cmp(&head2idx->deltas, git_diff_delta__casecmp);\n\t\tgit_vector_sort(&head2idx->deltas);\n\t}\n\n\t/* restore idx2wd sort by new path */\n\tif (idx2wd != NULL) {\n\t\tgit_vector_set_cmp(&idx2wd->deltas,\n\t\t\ti2w_icase ? git_diff_delta__casecmp : git_diff_delta__cmp);\n\t\tgit_vector_sort(&idx2wd->deltas);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_get_perfdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1517-1524",
    "snippet": "int git_diff_get_perfdata(git_diff_perfdata *out, const git_diff *diff)\n{\n\tassert(out);\n\tGITERR_CHECK_VERSION(out, GIT_DIFF_PERFDATA_VERSION, \"git_diff_perfdata\");\n\tout->stat_calls = diff->perf.stat_calls;\n\tout->oid_calculations = diff->perf.oid_calculations;\n\treturn 0;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_VERSION",
          "args": [
            "out",
            "GIT_DIFF_PERFDATA_VERSION",
            "\"git_diff_perfdata\""
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_get_perfdata(git_diff_perfdata *out, const git_diff *diff)\n{\n\tassert(out);\n\tGITERR_CHECK_VERSION(out, GIT_DIFF_PERFDATA_VERSION, \"git_diff_perfdata\");\n\tout->stat_calls = diff->perf.stat_calls;\n\tout->oid_calculations = diff->perf.oid_calculations;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_diff_is_sorted_icase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1512-1515",
    "snippet": "int git_diff_is_sorted_icase(const git_diff *diff)\n{\n\treturn (diff->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_is_sorted_icase(const git_diff *diff)\n{\n\treturn (diff->opts.flags & GIT_DIFF_IGNORE_CASE) != 0;\n}"
  },
  {
    "function_name": "git_diff_get_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1506-1510",
    "snippet": "const git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&diff->deltas",
            "idx"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst git_diff_delta *git_diff_get_delta(const git_diff *diff, size_t idx)\n{\n\tassert(diff);\n\treturn git_vector_get(&diff->deltas, idx);\n}"
  },
  {
    "function_name": "git_diff_num_deltas_of_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1492-1504",
    "snippet": "size_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)\n{\n\tsize_t i, count = 0;\n\tconst git_diff_delta *delta;\n\n\tassert(diff);\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tcount += (delta->status == type);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&diff->deltas",
            "i",
            "delta"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas_of_type(const git_diff *diff, git_delta_t type)\n{\n\tsize_t i, count = 0;\n\tconst git_diff_delta *delta;\n\n\tassert(diff);\n\n\tgit_vector_foreach(&diff->deltas, i, delta) {\n\t\tcount += (delta->status == type);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "git_diff_num_deltas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1486-1490",
    "snippet": "size_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nsize_t git_diff_num_deltas(const git_diff *diff)\n{\n\tassert(diff);\n\treturn diff->deltas.length;\n}"
  },
  {
    "function_name": "git_diff_index_to_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1463-1484",
    "snippet": "int git_diff_index_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *old_index,\n\tgit_index *new_index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && old_index && new_index);\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, old_index, &a_opts), GIT_ITERATOR_DONT_IGNORE_CASE,\n\t\tgit_iterator_for_index(&b, repo, new_index, &b_opts), GIT_ITERATOR_DONT_IGNORE_CASE\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && (old_index->ignore_case || new_index->ignore_case))\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_set_ignore_case",
          "args": [
            "*diff",
            "true"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "diff_set_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "390-413",
          "snippet": "static void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FROM_ITERATORS",
          "args": [
            "git_iterator_for_index(&a, repo, old_index, &a_opts)",
            "GIT_ITERATOR_DONT_IGNORE_CASE",
            "git_iterator_for_index(&b, repo, new_index, &b_opts)",
            "GIT_ITERATOR_DONT_IGNORE_CASE"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&b",
            "repo",
            "new_index",
            "&b_opts"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff && old_index && new_index"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *old_index,\n\tgit_index *new_index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && old_index && new_index);\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, old_index, &a_opts), GIT_ITERATOR_DONT_IGNORE_CASE,\n\t\tgit_iterator_for_index(&b, repo, new_index, &b_opts), GIT_ITERATOR_DONT_IGNORE_CASE\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && (old_index->ignore_case || new_index->ignore_case))\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_tree_to_workdir_with_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1433-1461",
    "snippet": "int git_diff_tree_to_workdir_with_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tgit_diff *d1 = NULL, *d2 = NULL;\n\tgit_index *index = NULL;\n\n\tassert(diff && repo);\n\n\tif ((error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_diff_tree_to_index(&d1, repo, old_tree, index, opts)) &&\n\t\t!(error = git_diff_index_to_workdir(&d2, repo, index, opts)))\n\t\terror = git_diff_merge(d1, d2);\n\n\tgit_diff_free(d2);\n\n\tif (error) {\n\t\tgit_diff_free(d1);\n\t\td1 = NULL;\n\t}\n\n\t*diff = d1;\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "d1"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_merge",
          "args": [
            "d1",
            "d2"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff_tform.c",
          "lines": "197-200",
          "snippet": "int git_diff_merge(git_diff *onto, const git_diff *from)\n{\n\treturn git_diff__merge(onto, from, git_diff__merge_like_cgit);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"path.h\"",
            "#include \"diff.h\"",
            "#include \"git2/sys/hashsig.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"fileops.h\"\n#include \"path.h\"\n#include \"diff.h\"\n#include \"git2/sys/hashsig.h\"\n#include \"git2/blob.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nint git_diff_merge(git_diff *onto, const git_diff *from)\n{\n\treturn git_diff__merge(onto, from, git_diff__merge_like_cgit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_index_to_workdir",
          "args": [
            "&d2",
            "repo",
            "index",
            "opts"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_index_to_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1384-1409",
          "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_tree_to_index",
          "args": [
            "&d1",
            "repo",
            "old_tree",
            "index",
            "opts"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_tree_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1353-1382",
          "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_load_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "diff_load_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1342-1351",
          "snippet": "static int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff && repo"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_workdir_with_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tgit_diff *d1 = NULL, *d2 = NULL;\n\tgit_index *index = NULL;\n\n\tassert(diff && repo);\n\n\tif ((error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tif (!(error = git_diff_tree_to_index(&d1, repo, old_tree, index, opts)) &&\n\t\t!(error = git_diff_index_to_workdir(&d2, repo, index, opts)))\n\t\terror = git_diff_merge(d1, d2);\n\n\tgit_diff_free(d2);\n\n\tif (error) {\n\t\tgit_diff_free(d1);\n\t\td1 = NULL;\n\t}\n\n\t*diff = d1;\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_tree_to_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1411-1431",
    "snippet": "int git_diff_tree_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tgit_index *index;\n\n\tassert(diff && repo);\n\n\tif ((error = git_repository_index__weakptr(&index, repo)))\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), 0,\n\t\tgit_iterator_for_workdir(&b, repo, index, old_tree, &b_opts), GIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIFF_FROM_ITERATORS",
          "args": [
            "git_iterator_for_tree(&a, old_tree, &a_opts)",
            "0",
            "git_iterator_for_workdir(&b, repo, index, old_tree, &b_opts)",
            "GIT_ITERATOR_DONT_AUTOEXPAND"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_for_workdir",
          "args": [
            "&b",
            "repo",
            "index",
            "old_tree",
            "&b_opts"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "113-121",
          "snippet": "GIT_INLINE(int) git_iterator_for_workdir(\n\tgit_iterator **out,\n\tgit_repository *repo,\n\tgit_index *index,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\treturn git_iterator_for_workdir_ext(out, repo, NULL, index, tree, options);\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_for_workdir(\n\tgit_iterator **out,\n\tgit_repository *repo,\n\tgit_index *index,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\treturn git_iterator_for_workdir_ext(out, repo, NULL, index, tree, options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&a",
            "old_tree",
            "&a_opts"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "repo"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff && repo"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tgit_index *index;\n\n\tassert(diff && repo);\n\n\tif ((error = git_repository_index__weakptr(&index, repo)))\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), 0,\n\t\tgit_iterator_for_workdir(&b, repo, index, old_tree, &b_opts), GIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_index_to_workdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1384-1409",
    "snippet": "int git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_index_write",
          "args": [
            "index"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "750-763",
          "snippet": "int git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_write(git_index *index)\n{\n\tgit_indexwriter writer = GIT_INDEXWRITER_INIT;\n\tint error;\n\n\ttruncate_racily_clean(index);\n\n\tif ((error = git_indexwriter_init(&writer, index)) == 0)\n\t\terror = git_indexwriter_commit(&writer);\n\n\tgit_indexwriter_cleanup(&writer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "*diff",
            "GIT_DIFF_UPDATE_INDEX"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FROM_ITERATORS",
          "args": [
            "git_iterator_for_index(&a, repo, index, &a_opts)",
            "GIT_ITERATOR_INCLUDE_CONFLICTS",
            "git_iterator_for_workdir(&b, repo, index, NULL, &b_opts)",
            "GIT_ITERATOR_DONT_AUTOEXPAND"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_for_workdir",
          "args": [
            "&b",
            "repo",
            "index",
            "NULL",
            "&b_opts"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "113-121",
          "snippet": "GIT_INLINE(int) git_iterator_for_workdir(\n\tgit_iterator **out,\n\tgit_repository *repo,\n\tgit_index *index,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\treturn git_iterator_for_workdir_ext(out, repo, NULL, index, tree, options);\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_for_workdir(\n\tgit_iterator **out,\n\tgit_repository *repo,\n\tgit_index *index,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\treturn git_iterator_for_workdir_ext(out, repo, NULL, index, tree, options);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&a",
            "repo",
            "index",
            "&a_opts"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_load_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "diff_load_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1342-1351",
          "snippet": "static int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff && repo"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_index_to_workdir(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_index(&a, repo, index, &a_opts),\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS,\n\n\t\tgit_iterator_for_workdir(&b, repo, index, NULL, &b_opts),\n\t\tGIT_ITERATOR_DONT_AUTOEXPAND\n\t);\n\n\tif (!error && DIFF_FLAG_IS_SET(*diff, GIT_DIFF_UPDATE_INDEX) && (*diff)->index_updated)\n\t\terror = git_index_write(index);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_tree_to_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1353-1382",
    "snippet": "int git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_set_ignore_case",
          "args": [
            "*diff",
            "true"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "diff_set_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "390-413",
          "snippet": "static void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FROM_ITERATORS",
          "args": [
            "git_iterator_for_tree(&a, old_tree, &a_opts)",
            "iflag",
            "git_iterator_for_index(&b, repo, index, &b_opts)",
            "iflag"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_for_index",
          "args": [
            "&b",
            "repo",
            "index",
            "&b_opts"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1087-1124",
          "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&a",
            "old_tree",
            "&a_opts"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_load_index",
          "args": [
            "&index",
            "repo"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "diff_load_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1342-1351",
          "snippet": "static int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff && repo"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_index(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_index *index,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE |\n\t\tGIT_ITERATOR_INCLUDE_CONFLICTS;\n\tbool index_ignore_case = false;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\tif (!index && (error = diff_load_index(&index, repo)) < 0)\n\t\treturn error;\n\n\tindex_ignore_case = index->ignore_case;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_index(&b, repo, index, &b_opts), iflag\n\t);\n\n\t/* if index is in case-insensitive order, re-sort deltas to match */\n\tif (!error && index_ignore_case)\n\t\tdiff_set_ignore_case(*diff, true);\n\n\treturn error;\n}"
  },
  {
    "function_name": "diff_load_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1342-1351",
    "snippet": "static int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_read",
          "args": [
            "*index",
            "false"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_read_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2928-3062",
          "snippet": "int git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_read_index(\n\tgit_index *index,\n\tconst git_index *new_index)\n{\n\tgit_vector new_entries = GIT_VECTOR_INIT,\n\t\tremove_entries = GIT_VECTOR_INIT;\n\tgit_idxmap *new_entries_map = NULL;\n\tgit_iterator *index_iterator = NULL;\n\tgit_iterator *new_iterator = NULL;\n\tgit_iterator_options opts = GIT_ITERATOR_OPTIONS_INIT;\n\tconst git_index_entry *old_entry, *new_entry;\n\tgit_index_entry *entry;\n\tsize_t i;\n\tint error;\n\n\tif ((error = git_vector_init(&new_entries, new_index->entries.length, index->entries._cmp)) < 0 ||\n\t\t(error = git_vector_init(&remove_entries, index->entries.length, NULL)) < 0 ||\n\t\t(error = git_idxmap_alloc(&new_entries_map)) < 0)\n\t\tgoto done;\n\n\tif (index->ignore_case)\n\t\tkh_resize(idxicase, (khash_t(idxicase) *) new_entries_map, new_index->entries.length);\n\telse\n\t\tkh_resize(idx, new_entries_map, new_index->entries.length);\n\n\topts.flags = GIT_ITERATOR_DONT_IGNORE_CASE;\n\n\tif ((error = git_iterator_for_index(&index_iterator, git_index_owner(index), index, &opts)) < 0 ||\n\t\t(error = git_iterator_for_index(&new_iterator, git_index_owner(new_index), (git_index *)new_index, &opts)) < 0)\n\t\tgoto done;\n\n\tif (((error = git_iterator_current(&old_entry, index_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER) ||\n\t\t((error = git_iterator_current(&new_entry, new_iterator)) < 0 &&\n\t\t\terror != GIT_ITEROVER))\n\t\tgoto done;\n\n\twhile (true) {\n\t\tgit_index_entry\n\t\t\t*dup_entry = NULL,\n\t\t\t*add_entry = NULL,\n\t\t\t*remove_entry = NULL;\n\t\tint diff;\n\n\t\terror = 0;\n\n\t\tif (old_entry && new_entry)\n\t\t\tdiff = git_index_entry_cmp(old_entry, new_entry);\n\t\telse if (!old_entry && new_entry)\n\t\t\tdiff = 1;\n\t\telse if (old_entry && !new_entry)\n\t\t\tdiff = -1;\n\t\telse\n\t\t\tbreak;\n\n\t\tif (diff < 0) {\n\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t} else if (diff > 0) {\n\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t} else {\n\t\t\t/* Path and stage are equal, if the OID is equal, keep it to\n\t\t\t * keep the stat cache data.\n\t\t\t */\n\t\t\tif (git_oid_equal(&old_entry->id, &new_entry->id) &&\n\t\t\t\told_entry->mode == new_entry->mode) {\n\t\t\t\tadd_entry = (git_index_entry *)old_entry;\n\t\t\t} else {\n\t\t\t\tdup_entry = (git_index_entry *)new_entry;\n\t\t\t\tremove_entry = (git_index_entry *)old_entry;\n\t\t\t}\n\t\t}\n\n\t\tif (dup_entry) {\n\t\t\tif ((error = index_entry_dup_nocache(&add_entry, index, dup_entry)) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tindex_entry_adjust_namemask(add_entry,\n\t\t\t\t((struct entry_internal *)add_entry)->pathlen);\n\t\t}\n\n\t\t/* invalidate this path in the tree cache if this is new (to\n\t\t * invalidate the parent trees)\n\t\t */\n\t\tif (dup_entry && !remove_entry && index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, dup_entry->path);\n\n\t\tif (add_entry) {\n\t\t\tif ((error = git_vector_insert(&new_entries, add_entry)) == 0)\n\t\t\t\tINSERT_IN_MAP_EX(index, new_entries_map, add_entry, error);\n\t\t}\n\n\t\tif (remove_entry && error >= 0)\n\t\t\terror = git_vector_insert(&remove_entries, remove_entry);\n\n\t\tif (error < 0) {\n\t\t\tgiterr_set(GITERR_INDEX, \"failed to insert entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff <= 0) {\n\t\t\tif ((error = git_iterator_advance(&old_entry, index_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tif (diff >= 0) {\n\t\t\tif ((error = git_iterator_advance(&new_entry, new_iterator)) < 0 &&\n\t\t\t\terror != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\n\tgit_index_name_clear(index);\n\tgit_index_reuc_clear(index);\n\n\tgit_vector_swap(&new_entries, &index->entries);\n\tnew_entries_map = git__swap(index->entries_map, new_entries_map);\n\n\tgit_vector_foreach(&remove_entries, i, entry) {\n\t\tif (index->tree)\n\t\t\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\n\t\tindex_entry_free(entry);\n\t}\n\n\terror = 0;\n\ndone:\n\tgit_idxmap_free(new_entries_map);\n\tgit_vector_free(&new_entries);\n\tgit_vector_free(&remove_entries);\n\tgit_iterator_free(index_iterator);\n\tgit_iterator_free(new_iterator);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "index",
            "repo"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_load_index(git_index **index, git_repository *repo)\n{\n\tint error = git_repository_index__weakptr(index, repo);\n\n\t/* reload the repository index when user did not pass one in */\n\tif (!error && git_index_read(*index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff_tree_to_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1315-1340",
    "snippet": "int git_diff_tree_to_tree(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_tree *new_tree,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\t/* for tree to tree diff, be case sensitive even if the index is\n\t * currently case insensitive, unless the user explicitly asked\n\t * for case insensitivity\n\t */\n\tif (opts && (opts->flags & GIT_DIFF_IGNORE_CASE) != 0)\n\t\tiflag = GIT_ITERATOR_IGNORE_CASE;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_tree(&b, new_tree, &b_opts), iflag\n\t);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIFF_FROM_ITERATORS",
          "args": [
            "git_iterator_for_tree(&a, old_tree, &a_opts)",
            "iflag",
            "git_iterator_for_tree(&b, new_tree, &b_opts)",
            "iflag"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_for_tree",
          "args": [
            "&b",
            "new_tree",
            "&b_opts"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "809-843",
          "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "diff && repo"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_tree_to_tree(\n\tgit_diff **diff,\n\tgit_repository *repo,\n\tgit_tree *old_tree,\n\tgit_tree *new_tree,\n\tconst git_diff_options *opts)\n{\n\tgit_iterator_flag_t iflag = GIT_ITERATOR_DONT_IGNORE_CASE;\n\tint error = 0;\n\n\tassert(diff && repo);\n\n\t/* for tree to tree diff, be case sensitive even if the index is\n\t * currently case insensitive, unless the user explicitly asked\n\t * for case insensitivity\n\t */\n\tif (opts && (opts->flags & GIT_DIFF_IGNORE_CASE) != 0)\n\t\tiflag = GIT_ITERATOR_IGNORE_CASE;\n\n\tDIFF_FROM_ITERATORS(\n\t\tgit_iterator_for_tree(&a, old_tree, &a_opts), iflag,\n\t\tgit_iterator_for_tree(&b, new_tree, &b_opts), iflag\n\t);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff__from_iterators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1212-1289",
    "snippet": "int git_diff__from_iterators(\n\tgit_diff **diff_ptr,\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tdiff_in_progress info;\n\tgit_diff *diff;\n\n\t*diff_ptr = NULL;\n\n\tdiff = diff_list_alloc(repo, old_iter, new_iter);\n\tGITERR_CHECK_ALLOC(diff);\n\n\tinfo.repo = repo;\n\tinfo.old_iter = old_iter;\n\tinfo.new_iter = new_iter;\n\n\t/* make iterators have matching icase behavior */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)) {\n\t\tif ((error = git_iterator_set_ignore_case(old_iter, true)) < 0 ||\n\t\t\t(error = git_iterator_set_ignore_case(new_iter, true)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* finish initialization */\n\tif ((error = diff_list_apply_options(diff, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = iterator_current(&info.oitem, old_iter)) < 0 ||\n\t\t(error = iterator_current(&info.nitem, new_iter)) < 0)\n\t\tgoto cleanup;\n\n\t/* run iterators building diffs */\n\twhile (!error && (info.oitem || info.nitem)) {\n\t\tint cmp;\n\n\t\t/* report progress */\n\t\tif (opts && opts->progress_cb) {\n\t\t\tif ((error = opts->progress_cb(diff,\n\t\t\t\t\tinfo.oitem ? info.oitem->path : NULL,\n\t\t\t\t\tinfo.nitem ? info.nitem->path : NULL,\n\t\t\t\t\topts->payload)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcmp = info.oitem ?\n\t\t\t(info.nitem ? diff->entrycomp(info.oitem, info.nitem) : -1) : 1;\n\n\t\t/* create DELETED records for old items not matched in new */\n\t\tif (cmp < 0)\n\t\t\terror = handle_unmatched_old_item(diff, &info);\n\n\t\t/* create ADDED, TRACKED, or IGNORED records for new items not\n\t\t * matched in old (and/or descend into directories as needed)\n\t\t */\n\t\telse if (cmp > 0)\n\t\t\terror = handle_unmatched_new_item(diff, &info);\n\n\t\t/* otherwise item paths match, so create MODIFIED record\n\t\t * (or ADDED and DELETED pair if type changed)\n\t\t */\n\t\telse\n\t\t\terror = handle_matched_item(diff, &info);\n\t}\n\n\tdiff->perf.stat_calls += old_iter->stat_calls + new_iter->stat_calls;\n\ncleanup:\n\tif (!error)\n\t\t*diff_ptr = diff;\n\telse\n\t\tgit_diff_free(diff);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_matched_item",
          "args": [
            "diff",
            "&info"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "handle_matched_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1198-1210",
          "snippet": "static int handle_matched_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\n\tif ((error = maybe_modified(diff, info)) < 0)\n\t\treturn error;\n\n\tif (!(error = iterator_advance(&info->oitem, info->old_iter)))\n\t\terror = iterator_advance(&info->nitem, info->new_iter);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int handle_matched_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\n\tif ((error = maybe_modified(diff, info)) < 0)\n\t\treturn error;\n\n\tif (!(error = iterator_advance(&info->oitem, info->old_iter)))\n\t\terror = iterator_advance(&info->nitem, info->new_iter);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_unmatched_new_item",
          "args": [
            "diff",
            "&info"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "handle_unmatched_new_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "999-1158",
          "snippet": "static int handle_unmatched_new_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\tconst git_index_entry *nitem = info->nitem;\n\tgit_delta_t delta_type = GIT_DELTA_UNTRACKED;\n\tbool contains_oitem;\n\n\t/* check if this is a prefix of the other side */\n\tcontains_oitem = entry_is_prefixed(diff, info->oitem, nitem);\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(nitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\t/* update delta_type if this item is ignored */\n\telse if (git_iterator_current_is_ignored(info->new_iter))\n\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\tif (nitem->mode == GIT_FILEMODE_TREE) {\n\t\tbool recurse_into_dir = contains_oitem;\n\n\t\t/* check if user requests recursion into this type of dir */\n\t\trecurse_into_dir = contains_oitem ||\n\t\t\t(delta_type == GIT_DELTA_UNTRACKED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS)) ||\n\t\t\t(delta_type == GIT_DELTA_IGNORED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS));\n\n\t\t/* do not advance into directories that contain a .git file */\n\t\tif (recurse_into_dir && !contains_oitem) {\n\t\t\tgit_buf *full = NULL;\n\t\t\tif (git_iterator_current_workdir_path(&full, info->new_iter) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (full && git_path_contains(full, DOT_GIT)) {\n\t\t\t\t/* TODO: warning if not a valid git repository */\n\t\t\t\trecurse_into_dir = false;\n\t\t\t}\n\t\t}\n\n\t\t/* still have to look into untracked directories to match core git -\n\t\t * with no untracked files, directory is treated as ignored\n\t\t */\n\t\tif (!recurse_into_dir &&\n\t\t\tdelta_type == GIT_DELTA_UNTRACKED &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS))\n\t\t{\n\t\t\tgit_diff_delta *last;\n\t\t\tgit_iterator_status_t untracked_state;\n\n\t\t\t/* attempt to insert record for this directory */\n\t\t\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if delta wasn't created (because of rules), just skip ahead */\n\t\t\tlast = diff_delta__last_for_item(diff, nitem);\n\t\t\tif (!last)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\t\t\t/* iterate into dir looking for an actual untracked file */\n\t\t\tif ((error = iterator_advance_over_with_status(\n\t\t\t\t\t&info->nitem, &untracked_state, info->new_iter)) < 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if we found nothing that matched our pathlist filter, exclude */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_FILTERED) {\n\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\tgit__free(last);\n\t\t\t}\n\n\t\t\t/* if we found nothing or just ignored items, update the record */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_IGNORED ||\n\t\t\t\tuntracked_state == GIT_ITERATOR_STATUS_EMPTY) {\n\t\t\t\tlast->status = GIT_DELTA_IGNORED;\n\n\t\t\t\t/* remove the record if we don't want ignored records */\n\t\t\t\tif (DIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED)) {\n\t\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\t\tgit__free(last);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* try to advance into directory if necessary */\n\t\tif (recurse_into_dir) {\n\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\n\t\t\t/* if real error or no error, proceed with iteration */\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\tgiterr_clear();\n\n\t\t\t/* if directory is empty, can't advance into it, so either skip\n\t\t\t * it or ignore it\n\t\t\t */\n\t\t\tif (contains_oitem)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\t\t}\n\t}\n\n\telse if (delta_type == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS) &&\n\t\tgit_iterator_current_tree_is_ignored(info->new_iter))\n\t\t/* item contained in ignored directory, so skip over it */\n\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\telse if (info->new_iter->type != GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif (delta_type != GIT_DELTA_CONFLICTED)\n\t\t\tdelta_type = GIT_DELTA_ADDED;\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_COMMIT) {\n\t\t/* ignore things that are not actual submodules */\n\t\tif (git_submodule_lookup(NULL, info->repo, nitem->path) != 0) {\n\t\t\tgiterr_clear();\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\t\t\t/* if this contains a tracked item, treat as normal TREE */\n\t\t\tif (contains_oitem) {\n\t\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\t\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\t\treturn error;\n\n\t\t\t\tgiterr_clear();\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_UNREADABLE) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED))\n\t\t\tdelta_type = GIT_DELTA_UNTRACKED;\n\t\telse\n\t\t\tdelta_type = GIT_DELTA_UNREADABLE;\n\t}\n\n\t/* Actually create the record for this item if necessary */\n\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\treturn error;\n\n\t/* If user requested TYPECHANGE records, then check for that instead of\n\t * just generating an ADDED/UNTRACKED record\n\t */\n\tif (delta_type != GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tcontains_oitem)\n\t{\n\t\t/* this entry was prefixed with a tree - make TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, nitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->old_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\t}\n\n\treturn iterator_advance(&info->nitem, info->new_iter);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int handle_unmatched_new_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\tconst git_index_entry *nitem = info->nitem;\n\tgit_delta_t delta_type = GIT_DELTA_UNTRACKED;\n\tbool contains_oitem;\n\n\t/* check if this is a prefix of the other side */\n\tcontains_oitem = entry_is_prefixed(diff, info->oitem, nitem);\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(nitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\t/* update delta_type if this item is ignored */\n\telse if (git_iterator_current_is_ignored(info->new_iter))\n\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\tif (nitem->mode == GIT_FILEMODE_TREE) {\n\t\tbool recurse_into_dir = contains_oitem;\n\n\t\t/* check if user requests recursion into this type of dir */\n\t\trecurse_into_dir = contains_oitem ||\n\t\t\t(delta_type == GIT_DELTA_UNTRACKED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS)) ||\n\t\t\t(delta_type == GIT_DELTA_IGNORED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS));\n\n\t\t/* do not advance into directories that contain a .git file */\n\t\tif (recurse_into_dir && !contains_oitem) {\n\t\t\tgit_buf *full = NULL;\n\t\t\tif (git_iterator_current_workdir_path(&full, info->new_iter) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (full && git_path_contains(full, DOT_GIT)) {\n\t\t\t\t/* TODO: warning if not a valid git repository */\n\t\t\t\trecurse_into_dir = false;\n\t\t\t}\n\t\t}\n\n\t\t/* still have to look into untracked directories to match core git -\n\t\t * with no untracked files, directory is treated as ignored\n\t\t */\n\t\tif (!recurse_into_dir &&\n\t\t\tdelta_type == GIT_DELTA_UNTRACKED &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS))\n\t\t{\n\t\t\tgit_diff_delta *last;\n\t\t\tgit_iterator_status_t untracked_state;\n\n\t\t\t/* attempt to insert record for this directory */\n\t\t\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if delta wasn't created (because of rules), just skip ahead */\n\t\t\tlast = diff_delta__last_for_item(diff, nitem);\n\t\t\tif (!last)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\t\t\t/* iterate into dir looking for an actual untracked file */\n\t\t\tif ((error = iterator_advance_over_with_status(\n\t\t\t\t\t&info->nitem, &untracked_state, info->new_iter)) < 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if we found nothing that matched our pathlist filter, exclude */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_FILTERED) {\n\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\tgit__free(last);\n\t\t\t}\n\n\t\t\t/* if we found nothing or just ignored items, update the record */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_IGNORED ||\n\t\t\t\tuntracked_state == GIT_ITERATOR_STATUS_EMPTY) {\n\t\t\t\tlast->status = GIT_DELTA_IGNORED;\n\n\t\t\t\t/* remove the record if we don't want ignored records */\n\t\t\t\tif (DIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED)) {\n\t\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\t\tgit__free(last);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* try to advance into directory if necessary */\n\t\tif (recurse_into_dir) {\n\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\n\t\t\t/* if real error or no error, proceed with iteration */\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\tgiterr_clear();\n\n\t\t\t/* if directory is empty, can't advance into it, so either skip\n\t\t\t * it or ignore it\n\t\t\t */\n\t\t\tif (contains_oitem)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\t\t}\n\t}\n\n\telse if (delta_type == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS) &&\n\t\tgit_iterator_current_tree_is_ignored(info->new_iter))\n\t\t/* item contained in ignored directory, so skip over it */\n\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\telse if (info->new_iter->type != GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif (delta_type != GIT_DELTA_CONFLICTED)\n\t\t\tdelta_type = GIT_DELTA_ADDED;\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_COMMIT) {\n\t\t/* ignore things that are not actual submodules */\n\t\tif (git_submodule_lookup(NULL, info->repo, nitem->path) != 0) {\n\t\t\tgiterr_clear();\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\t\t\t/* if this contains a tracked item, treat as normal TREE */\n\t\t\tif (contains_oitem) {\n\t\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\t\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\t\treturn error;\n\n\t\t\t\tgiterr_clear();\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_UNREADABLE) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED))\n\t\t\tdelta_type = GIT_DELTA_UNTRACKED;\n\t\telse\n\t\t\tdelta_type = GIT_DELTA_UNREADABLE;\n\t}\n\n\t/* Actually create the record for this item if necessary */\n\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\treturn error;\n\n\t/* If user requested TYPECHANGE records, then check for that instead of\n\t * just generating an ADDED/UNTRACKED record\n\t */\n\tif (delta_type != GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tcontains_oitem)\n\t{\n\t\t/* this entry was prefixed with a tree - make TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, nitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->old_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\t}\n\n\treturn iterator_advance(&info->nitem, info->new_iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_unmatched_old_item",
          "args": [
            "diff",
            "&info"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "handle_unmatched_old_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "1160-1196",
          "snippet": "static int handle_unmatched_old_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tgit_delta_t delta_type = GIT_DELTA_DELETED;\n\tint error;\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(info->oitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\tif ((error = diff_delta__from_one(diff, delta_type, info->oitem, NULL)) < 0)\n\t\treturn error;\n\n\t/* if we are generating TYPECHANGE records then check for that\n\t * instead of just generating a DELETE record\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tentry_is_prefixed(diff, info->nitem, info->oitem))\n\t{\n\t\t/* this entry has become a tree! convert to TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, info->oitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->new_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\n\t\t/* If new_iter is a workdir iterator, then this situation\n\t\t * will certainly be followed by a series of untracked items.\n\t\t * Unless RECURSE_UNTRACKED_DIRS is set, skip over them...\n\t\t */\n\t\tif (S_ISDIR(info->nitem->mode) &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS))\n\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t}\n\n\treturn iterator_advance(&info->oitem, info->old_iter);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int handle_unmatched_old_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tgit_delta_t delta_type = GIT_DELTA_DELETED;\n\tint error;\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(info->oitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\tif ((error = diff_delta__from_one(diff, delta_type, info->oitem, NULL)) < 0)\n\t\treturn error;\n\n\t/* if we are generating TYPECHANGE records then check for that\n\t * instead of just generating a DELETE record\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tentry_is_prefixed(diff, info->nitem, info->oitem))\n\t{\n\t\t/* this entry has become a tree! convert to TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, info->oitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->new_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\n\t\t/* If new_iter is a workdir iterator, then this situation\n\t\t * will certainly be followed by a series of untracked items.\n\t\t * Unless RECURSE_UNTRACKED_DIRS is set, skip over them...\n\t\t */\n\t\tif (S_ISDIR(info->nitem->mode) &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS))\n\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t}\n\n\treturn iterator_advance(&info->oitem, info->old_iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff->entrycomp",
          "args": [
            "info.oitem",
            "info.nitem"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opts->progress_cb",
          "args": [
            "diff",
            "info.oitem ? info.oitem->path : NULL",
            "info.nitem ? info.nitem->path : NULL",
            "opts->payload"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator_current",
          "args": [
            "&info.nitem",
            "new_iter"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "921-933",
          "snippet": "static int iterator_current(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_current(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_current(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_current(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_list_apply_options",
          "args": [
            "diff",
            "opts"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "diff_list_apply_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "450-563",
          "snippet": "static int diff_list_apply_options(\n\tgit_diff *diff,\n\tconst git_diff_options *opts)\n{\n\tgit_config *cfg = NULL;\n\tgit_repository *repo = diff->repo;\n\tgit_pool *pool = &diff->pool;\n\tint val;\n\n\tif (opts) {\n\t\t/* copy user options (except case sensitivity info from iterators) */\n\t\tbool icase = DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE);\n\t\tmemcpy(&diff->opts, opts, sizeof(diff->opts));\n\t\tDIFF_FLAG_SET(diff, GIT_DIFF_IGNORE_CASE, icase);\n\n\t\t/* initialize pathspec from options */\n\t\tif (git_pathspec__vinit(&diff->pathspec, &opts->pathspec, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* flag INCLUDE_TYPECHANGE_TREES implies INCLUDE_TYPECHANGE */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE;\n\n\t/* flag INCLUDE_UNTRACKED_CONTENT implies INCLUDE_UNTRACKED */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_SHOW_UNTRACKED_CONTENT))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* load config values that affect diff behavior */\n\tif ((val = git_repository_config_snapshot(&cfg, repo)) < 0)\n\t\treturn val;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_SYMLINKS) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_HAS_SYMLINKS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_IGNORESTAT) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_IGNORE_STAT;\n\n\tif ((diff->opts.flags & GIT_DIFF_IGNORE_FILEMODE) == 0 &&\n\t\t!git_config__cvar(&val, cfg, GIT_CVAR_FILEMODE) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_MODE_BITS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_TRUSTCTIME) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_CTIME;\n\n\t/* Don't set GIT_DIFFCAPS_USE_DEV - compile time option in core git */\n\n\t/* If not given explicit `opts`, check `diff.xyz` configs */\n\tif (!opts) {\n\t\tint context = git_config__get_int_force(cfg, \"diff.context\", 3);\n\t\tdiff->opts.context_lines = context >= 0 ? (uint32_t)context : 3;\n\n\t\t/* add other defaults here */\n\t}\n\n\t/* Reverse src info if diff is reversed */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tgit_iterator_type_t tmp_src = diff->old_src;\n\t\tdiff->old_src = diff->new_src;\n\t\tdiff->new_src = tmp_src;\n\t}\n\n\t/* Unset UPDATE_INDEX unless diffing workdir and index */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) &&\n\t\t(!(diff->old_src == GIT_ITERATOR_TYPE_WORKDIR ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ||\n\t\t !(diff->old_src == GIT_ITERATOR_TYPE_INDEX ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_INDEX)))\n\t\tdiff->opts.flags &= ~GIT_DIFF_UPDATE_INDEX;\n\n\t/* if ignore_submodules not explicitly set, check diff config */\n\tif (diff->opts.ignore_submodules <= 0) {\n\t\t git_config_entry *entry;\n\t\tgit_config__lookup_entry(&entry, cfg, \"diff.ignoresubmodules\", true);\n\n\t\tif (entry && git_submodule_parse_ignore(\n\t\t\t\t&diff->opts.ignore_submodules, entry->value) < 0)\n\t\t\tgiterr_clear();\n\t\tgit_config_entry_free(entry);\n\t}\n\n\t/* if either prefix is not set, figure out appropriate value */\n\tif (!diff->opts.old_prefix || !diff->opts.new_prefix) {\n\t\tconst char *use_old = DIFF_OLD_PREFIX_DEFAULT;\n\t\tconst char *use_new = DIFF_NEW_PREFIX_DEFAULT;\n\n\t\tif (git_config__get_bool_force(cfg, \"diff.noprefix\", 0))\n\t\t\tuse_old = use_new = \"\";\n\t\telse if (git_config__get_bool_force(cfg, \"diff.mnemonicprefix\", 0)) {\n\t\t\tuse_old = diff_mnemonic_prefix(diff->old_src, true);\n\t\t\tuse_new = diff_mnemonic_prefix(diff->new_src, false);\n\t\t}\n\n\t\tif (!diff->opts.old_prefix)\n\t\t\tdiff->opts.old_prefix = use_old;\n\t\tif (!diff->opts.new_prefix)\n\t\t\tdiff->opts.new_prefix = use_new;\n\t}\n\n\t/* strdup prefix from pool so we're not dependent on external data */\n\tdiff->opts.old_prefix = diff_strdup_prefix(pool, diff->opts.old_prefix);\n\tdiff->opts.new_prefix = diff_strdup_prefix(pool, diff->opts.new_prefix);\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tconst char *tmp_prefix = diff->opts.old_prefix;\n\t\tdiff->opts.old_prefix  = diff->opts.new_prefix;\n\t\tdiff->opts.new_prefix  = tmp_prefix;\n\t}\n\n\tgit_config_free(cfg);\n\n\t/* check strdup results for error */\n\treturn (!diff->opts.old_prefix || !diff->opts.new_prefix) ? -1 : 0;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_list_apply_options(\n\tgit_diff *diff,\n\tconst git_diff_options *opts)\n{\n\tgit_config *cfg = NULL;\n\tgit_repository *repo = diff->repo;\n\tgit_pool *pool = &diff->pool;\n\tint val;\n\n\tif (opts) {\n\t\t/* copy user options (except case sensitivity info from iterators) */\n\t\tbool icase = DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE);\n\t\tmemcpy(&diff->opts, opts, sizeof(diff->opts));\n\t\tDIFF_FLAG_SET(diff, GIT_DIFF_IGNORE_CASE, icase);\n\n\t\t/* initialize pathspec from options */\n\t\tif (git_pathspec__vinit(&diff->pathspec, &opts->pathspec, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* flag INCLUDE_TYPECHANGE_TREES implies INCLUDE_TYPECHANGE */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE;\n\n\t/* flag INCLUDE_UNTRACKED_CONTENT implies INCLUDE_UNTRACKED */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_SHOW_UNTRACKED_CONTENT))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* load config values that affect diff behavior */\n\tif ((val = git_repository_config_snapshot(&cfg, repo)) < 0)\n\t\treturn val;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_SYMLINKS) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_HAS_SYMLINKS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_IGNORESTAT) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_IGNORE_STAT;\n\n\tif ((diff->opts.flags & GIT_DIFF_IGNORE_FILEMODE) == 0 &&\n\t\t!git_config__cvar(&val, cfg, GIT_CVAR_FILEMODE) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_MODE_BITS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_TRUSTCTIME) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_CTIME;\n\n\t/* Don't set GIT_DIFFCAPS_USE_DEV - compile time option in core git */\n\n\t/* If not given explicit `opts`, check `diff.xyz` configs */\n\tif (!opts) {\n\t\tint context = git_config__get_int_force(cfg, \"diff.context\", 3);\n\t\tdiff->opts.context_lines = context >= 0 ? (uint32_t)context : 3;\n\n\t\t/* add other defaults here */\n\t}\n\n\t/* Reverse src info if diff is reversed */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tgit_iterator_type_t tmp_src = diff->old_src;\n\t\tdiff->old_src = diff->new_src;\n\t\tdiff->new_src = tmp_src;\n\t}\n\n\t/* Unset UPDATE_INDEX unless diffing workdir and index */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) &&\n\t\t(!(diff->old_src == GIT_ITERATOR_TYPE_WORKDIR ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ||\n\t\t !(diff->old_src == GIT_ITERATOR_TYPE_INDEX ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_INDEX)))\n\t\tdiff->opts.flags &= ~GIT_DIFF_UPDATE_INDEX;\n\n\t/* if ignore_submodules not explicitly set, check diff config */\n\tif (diff->opts.ignore_submodules <= 0) {\n\t\t git_config_entry *entry;\n\t\tgit_config__lookup_entry(&entry, cfg, \"diff.ignoresubmodules\", true);\n\n\t\tif (entry && git_submodule_parse_ignore(\n\t\t\t\t&diff->opts.ignore_submodules, entry->value) < 0)\n\t\t\tgiterr_clear();\n\t\tgit_config_entry_free(entry);\n\t}\n\n\t/* if either prefix is not set, figure out appropriate value */\n\tif (!diff->opts.old_prefix || !diff->opts.new_prefix) {\n\t\tconst char *use_old = DIFF_OLD_PREFIX_DEFAULT;\n\t\tconst char *use_new = DIFF_NEW_PREFIX_DEFAULT;\n\n\t\tif (git_config__get_bool_force(cfg, \"diff.noprefix\", 0))\n\t\t\tuse_old = use_new = \"\";\n\t\telse if (git_config__get_bool_force(cfg, \"diff.mnemonicprefix\", 0)) {\n\t\t\tuse_old = diff_mnemonic_prefix(diff->old_src, true);\n\t\t\tuse_new = diff_mnemonic_prefix(diff->new_src, false);\n\t\t}\n\n\t\tif (!diff->opts.old_prefix)\n\t\t\tdiff->opts.old_prefix = use_old;\n\t\tif (!diff->opts.new_prefix)\n\t\t\tdiff->opts.new_prefix = use_new;\n\t}\n\n\t/* strdup prefix from pool so we're not dependent on external data */\n\tdiff->opts.old_prefix = diff_strdup_prefix(pool, diff->opts.old_prefix);\n\tdiff->opts.new_prefix = diff_strdup_prefix(pool, diff->opts.new_prefix);\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tconst char *tmp_prefix = diff->opts.old_prefix;\n\t\tdiff->opts.old_prefix  = diff->opts.new_prefix;\n\t\tdiff->opts.new_prefix  = tmp_prefix;\n\t}\n\n\tgit_config_free(cfg);\n\n\t/* check strdup results for error */\n\treturn (!diff->opts.old_prefix || !diff->opts.new_prefix) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_set_ignore_case",
          "args": [
            "new_iter",
            "true"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_set_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1887-1906",
          "snippet": "int git_iterator_set_ignore_case(git_iterator *iter, bool ignore_case)\n{\n\tbool desire_ignore_case  = (ignore_case != 0);\n\n\tif (iterator__ignore_case(iter) == desire_ignore_case)\n\t\treturn 0;\n\n\tif (iter->type == GIT_ITERATOR_TYPE_EMPTY) {\n\t\tif (desire_ignore_case)\n\t\t\titer->flags |= GIT_ITERATOR_IGNORE_CASE;\n\t\telse\n\t\t\titer->flags &= ~GIT_ITERATOR_IGNORE_CASE;\n\t} else {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Cannot currently set ignore case on non-empty iterators\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_set_ignore_case(git_iterator *iter, bool ignore_case)\n{\n\tbool desire_ignore_case  = (ignore_case != 0);\n\n\tif (iterator__ignore_case(iter) == desire_ignore_case)\n\t\treturn 0;\n\n\tif (iter->type == GIT_ITERATOR_TYPE_EMPTY) {\n\t\tif (desire_ignore_case)\n\t\t\titer->flags |= GIT_ITERATOR_IGNORE_CASE;\n\t\telse\n\t\t\titer->flags &= ~GIT_ITERATOR_IGNORE_CASE;\n\t} else {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Cannot currently set ignore case on non-empty iterators\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_CASE"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "diff"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_list_alloc",
          "args": [
            "repo",
            "old_iter",
            "new_iter"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "diff_list_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "415-448",
          "snippet": "static git_diff *diff_list_alloc(\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter)\n{\n\tgit_diff_options dflt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = git__calloc(1, sizeof(git_diff));\n\tif (!diff)\n\t\treturn NULL;\n\n\tassert(repo && old_iter && new_iter);\n\n\tGIT_REFCOUNT_INC(diff);\n\tdiff->repo = repo;\n\tdiff->old_src = old_iter->type;\n\tdiff->new_src = new_iter->type;\n\tmemcpy(&diff->opts, &dflt, sizeof(diff->opts));\n\n\tgit_pool_init(&diff->pool, 1);\n\n\tif (git_vector_init(&diff->deltas, 0, git_diff_delta__cmp) < 0) {\n\t\tgit_diff_free(diff);\n\t\treturn NULL;\n\t}\n\n\t/* Use case-insensitive compare if either iterator has\n\t * the ignore_case bit set */\n\tdiff_set_ignore_case(\n\t\tdiff,\n\t\tgit_iterator_ignore_case(old_iter) ||\n\t\tgit_iterator_ignore_case(new_iter));\n\n\treturn diff;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff *diff_list_alloc(\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter)\n{\n\tgit_diff_options dflt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = git__calloc(1, sizeof(git_diff));\n\tif (!diff)\n\t\treturn NULL;\n\n\tassert(repo && old_iter && new_iter);\n\n\tGIT_REFCOUNT_INC(diff);\n\tdiff->repo = repo;\n\tdiff->old_src = old_iter->type;\n\tdiff->new_src = new_iter->type;\n\tmemcpy(&diff->opts, &dflt, sizeof(diff->opts));\n\n\tgit_pool_init(&diff->pool, 1);\n\n\tif (git_vector_init(&diff->deltas, 0, git_diff_delta__cmp) < 0) {\n\t\tgit_diff_free(diff);\n\t\treturn NULL;\n\t}\n\n\t/* Use case-insensitive compare if either iterator has\n\t * the ignore_case bit set */\n\tdiff_set_ignore_case(\n\t\tdiff,\n\t\tgit_iterator_ignore_case(old_iter) ||\n\t\tgit_iterator_ignore_case(new_iter));\n\n\treturn diff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__from_iterators(\n\tgit_diff **diff_ptr,\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter,\n\tconst git_diff_options *opts)\n{\n\tint error = 0;\n\tdiff_in_progress info;\n\tgit_diff *diff;\n\n\t*diff_ptr = NULL;\n\n\tdiff = diff_list_alloc(repo, old_iter, new_iter);\n\tGITERR_CHECK_ALLOC(diff);\n\n\tinfo.repo = repo;\n\tinfo.old_iter = old_iter;\n\tinfo.new_iter = new_iter;\n\n\t/* make iterators have matching icase behavior */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)) {\n\t\tif ((error = git_iterator_set_ignore_case(old_iter, true)) < 0 ||\n\t\t\t(error = git_iterator_set_ignore_case(new_iter, true)) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* finish initialization */\n\tif ((error = diff_list_apply_options(diff, opts)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = iterator_current(&info.oitem, old_iter)) < 0 ||\n\t\t(error = iterator_current(&info.nitem, new_iter)) < 0)\n\t\tgoto cleanup;\n\n\t/* run iterators building diffs */\n\twhile (!error && (info.oitem || info.nitem)) {\n\t\tint cmp;\n\n\t\t/* report progress */\n\t\tif (opts && opts->progress_cb) {\n\t\t\tif ((error = opts->progress_cb(diff,\n\t\t\t\t\tinfo.oitem ? info.oitem->path : NULL,\n\t\t\t\t\tinfo.nitem ? info.nitem->path : NULL,\n\t\t\t\t\topts->payload)))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcmp = info.oitem ?\n\t\t\t(info.nitem ? diff->entrycomp(info.oitem, info.nitem) : -1) : 1;\n\n\t\t/* create DELETED records for old items not matched in new */\n\t\tif (cmp < 0)\n\t\t\terror = handle_unmatched_old_item(diff, &info);\n\n\t\t/* create ADDED, TRACKED, or IGNORED records for new items not\n\t\t * matched in old (and/or descend into directories as needed)\n\t\t */\n\t\telse if (cmp > 0)\n\t\t\terror = handle_unmatched_new_item(diff, &info);\n\n\t\t/* otherwise item paths match, so create MODIFIED record\n\t\t * (or ADDED and DELETED pair if type changed)\n\t\t */\n\t\telse\n\t\t\terror = handle_matched_item(diff, &info);\n\t}\n\n\tdiff->perf.stat_calls += old_iter->stat_calls + new_iter->stat_calls;\n\ncleanup:\n\tif (!error)\n\t\t*diff_ptr = diff;\n\telse\n\t\tgit_diff_free(diff);\n\n\treturn error;\n}"
  },
  {
    "function_name": "handle_matched_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1198-1210",
    "snippet": "static int handle_matched_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\n\tif ((error = maybe_modified(diff, info)) < 0)\n\t\treturn error;\n\n\tif (!(error = iterator_advance(&info->oitem, info->old_iter)))\n\t\terror = iterator_advance(&info->nitem, info->new_iter);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterator_advance",
          "args": [
            "&info->nitem",
            "info->new_iter"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_advance_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "969-981",
          "snippet": "static int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_modified",
          "args": [
            "diff",
            "info"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_modified",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "756-902",
          "snippet": "static int maybe_modified(\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tgit_oid noid;\n\tgit_delta_t status = GIT_DELTA_MODIFIED;\n\tconst git_index_entry *oitem = info->oitem;\n\tconst git_index_entry *nitem = info->nitem;\n\tunsigned int omode = oitem->mode;\n\tunsigned int nmode = nitem->mode;\n\tbool new_is_workdir = (info->new_iter->type == GIT_ITERATOR_TYPE_WORKDIR);\n\tbool modified_uncertain = false;\n\tconst char *matched_pathspec;\n\tint error = 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, oitem))\n\t\treturn 0;\n\n\tmemset(&noid, 0, sizeof(noid));\n\n\t/* on platforms with no symlinks, preserve mode of existing symlinks */\n\tif (S_ISLNK(omode) && S_ISREG(nmode) && new_is_workdir &&\n\t\t!(diff->diffcaps & GIT_DIFFCAPS_HAS_SYMLINKS))\n\t\tnmode = omode;\n\n\t/* on platforms with no execmode, just preserve old mode */\n\tif (!(diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) &&\n\t\t(nmode & MODE_BITS_MASK) != (omode & MODE_BITS_MASK) &&\n\t\tnew_is_workdir)\n\t\tnmode = (nmode & ~MODE_BITS_MASK) | (omode & MODE_BITS_MASK);\n\n\t/* if one side is a conflict, mark the whole delta as conflicted */\n\tif (git_index_entry_is_conflict(oitem) ||\n\t\t\tgit_index_entry_is_conflict(nitem)) {\n\t\tstatus = GIT_DELTA_CONFLICTED;\n\n\t/* support \"assume unchanged\" (poorly, b/c we still stat everything) */\n\t} else if ((oitem->flags & GIT_IDXENTRY_VALID) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* support \"skip worktree\" index bit */\n\t} else if ((oitem->flags_extended & GIT_IDXENTRY_SKIP_WORKTREE) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if basic type of file changed, then split into delete and add */\n\t} else if (GIT_MODE_TYPE(omode) != GIT_MODE_TYPE(nmode)) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE)) {\n\t\t\tstatus = GIT_DELTA_TYPECHANGE;\n\t\t}\n\n\t\telse if (nmode == GIT_FILEMODE_UNREADABLE) {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_UNREADABLE, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t\telse {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t/* if oids and modes match (and are valid), then file is unmodified */\n\t} else if (git_oid_equal(&oitem->id, &nitem->id) &&\n\t\t\t omode == nmode &&\n\t\t\t !git_oid_iszero(&oitem->id)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if we have an unknown OID and a workdir iterator, then check some\n\t * circumstances that can accelerate things or need special handling\n\t */\n\t} else if (git_oid_iszero(&nitem->id) && new_is_workdir) {\n\t\tbool use_ctime = ((diff->diffcaps & GIT_DIFFCAPS_TRUST_CTIME) != 0);\n\t\tgit_index *index;\n\t\tgit_iterator_index(&index, info->new_iter);\n\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t\tif (S_ISGITLINK(nmode)) {\n\t\t\tif ((error = maybe_modified_submodule(&status, &noid, diff, info)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* if the stat data looks different, then mark modified - this just\n\t\t * means that the OID will be recalculated below to confirm change\n\t\t */\n\t\telse if (omode != nmode || oitem->file_size != nitem->file_size) {\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain =\n\t\t\t\t(oitem->file_size <= 0 && nitem->file_size > 0);\n\t\t}\n\t\telse if (!git_index_time_eq(&oitem->mtime, &nitem->mtime) ||\n\t\t\t(use_ctime && !git_index_time_eq(&oitem->ctime, &nitem->ctime)) ||\n\t\t\toitem->ino != nitem->ino ||\n\t\t\toitem->uid != nitem->uid ||\n\t\t\toitem->gid != nitem->gid ||\n\t\t\tgit_index_entry_newer_than_index(nitem, index))\n\t\t{\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain = true;\n\t\t}\n\n\t/* if mode is GITLINK and submodules are ignored, then skip */\n\t} else if (S_ISGITLINK(nmode) &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* if we got here and decided that the files are modified, but we\n\t * haven't calculated the OID of the new item, then calculate it now\n\t */\n\tif (modified_uncertain && git_oid_iszero(&nitem->id)) {\n\t\tconst git_oid *update_check =\n\t\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) && omode == nmode ?\n\t\t\t&oitem->id : NULL;\n\n\t\tif ((error = git_diff__oid_for_entry(\n\t\t\t\t&noid, diff, nitem, nmode, update_check)) < 0)\n\t\t\treturn error;\n\n\t\t/* if oid matches, then mark unmodified (except submodules, where\n\t\t * the filesystem content may be modified even if the oid still\n\t\t * matches between the index and the workdir HEAD)\n\t\t */\n\t\tif (omode == nmode && !S_ISGITLINK(omode) &&\n\t\t\tgit_oid_equal(&oitem->id, &noid))\n\t\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* If we want case changes, then break this into a delete of the old\n\t * and an add of the new so that consumers can act accordingly (eg,\n\t * checkout will update the case on disk.)\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE) &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_CASECHANGE) &&\n\t\tstrcmp(oitem->path, nitem->path) != 0) {\n\n\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\n\t\treturn error;\n\t}\n\n\treturn diff_delta__from_two(\n\t\tdiff, status, oitem, omode, nitem, nmode,\n\t\tgit_oid_iszero(&noid) ? NULL : &noid, matched_pathspec);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MODE_BITS_MASK 0000777"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\n#define MODE_BITS_MASK 0000777\n\nstatic int maybe_modified(\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tgit_oid noid;\n\tgit_delta_t status = GIT_DELTA_MODIFIED;\n\tconst git_index_entry *oitem = info->oitem;\n\tconst git_index_entry *nitem = info->nitem;\n\tunsigned int omode = oitem->mode;\n\tunsigned int nmode = nitem->mode;\n\tbool new_is_workdir = (info->new_iter->type == GIT_ITERATOR_TYPE_WORKDIR);\n\tbool modified_uncertain = false;\n\tconst char *matched_pathspec;\n\tint error = 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, oitem))\n\t\treturn 0;\n\n\tmemset(&noid, 0, sizeof(noid));\n\n\t/* on platforms with no symlinks, preserve mode of existing symlinks */\n\tif (S_ISLNK(omode) && S_ISREG(nmode) && new_is_workdir &&\n\t\t!(diff->diffcaps & GIT_DIFFCAPS_HAS_SYMLINKS))\n\t\tnmode = omode;\n\n\t/* on platforms with no execmode, just preserve old mode */\n\tif (!(diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) &&\n\t\t(nmode & MODE_BITS_MASK) != (omode & MODE_BITS_MASK) &&\n\t\tnew_is_workdir)\n\t\tnmode = (nmode & ~MODE_BITS_MASK) | (omode & MODE_BITS_MASK);\n\n\t/* if one side is a conflict, mark the whole delta as conflicted */\n\tif (git_index_entry_is_conflict(oitem) ||\n\t\t\tgit_index_entry_is_conflict(nitem)) {\n\t\tstatus = GIT_DELTA_CONFLICTED;\n\n\t/* support \"assume unchanged\" (poorly, b/c we still stat everything) */\n\t} else if ((oitem->flags & GIT_IDXENTRY_VALID) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* support \"skip worktree\" index bit */\n\t} else if ((oitem->flags_extended & GIT_IDXENTRY_SKIP_WORKTREE) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if basic type of file changed, then split into delete and add */\n\t} else if (GIT_MODE_TYPE(omode) != GIT_MODE_TYPE(nmode)) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE)) {\n\t\t\tstatus = GIT_DELTA_TYPECHANGE;\n\t\t}\n\n\t\telse if (nmode == GIT_FILEMODE_UNREADABLE) {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_UNREADABLE, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t\telse {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t/* if oids and modes match (and are valid), then file is unmodified */\n\t} else if (git_oid_equal(&oitem->id, &nitem->id) &&\n\t\t\t omode == nmode &&\n\t\t\t !git_oid_iszero(&oitem->id)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if we have an unknown OID and a workdir iterator, then check some\n\t * circumstances that can accelerate things or need special handling\n\t */\n\t} else if (git_oid_iszero(&nitem->id) && new_is_workdir) {\n\t\tbool use_ctime = ((diff->diffcaps & GIT_DIFFCAPS_TRUST_CTIME) != 0);\n\t\tgit_index *index;\n\t\tgit_iterator_index(&index, info->new_iter);\n\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t\tif (S_ISGITLINK(nmode)) {\n\t\t\tif ((error = maybe_modified_submodule(&status, &noid, diff, info)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* if the stat data looks different, then mark modified - this just\n\t\t * means that the OID will be recalculated below to confirm change\n\t\t */\n\t\telse if (omode != nmode || oitem->file_size != nitem->file_size) {\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain =\n\t\t\t\t(oitem->file_size <= 0 && nitem->file_size > 0);\n\t\t}\n\t\telse if (!git_index_time_eq(&oitem->mtime, &nitem->mtime) ||\n\t\t\t(use_ctime && !git_index_time_eq(&oitem->ctime, &nitem->ctime)) ||\n\t\t\toitem->ino != nitem->ino ||\n\t\t\toitem->uid != nitem->uid ||\n\t\t\toitem->gid != nitem->gid ||\n\t\t\tgit_index_entry_newer_than_index(nitem, index))\n\t\t{\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain = true;\n\t\t}\n\n\t/* if mode is GITLINK and submodules are ignored, then skip */\n\t} else if (S_ISGITLINK(nmode) &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* if we got here and decided that the files are modified, but we\n\t * haven't calculated the OID of the new item, then calculate it now\n\t */\n\tif (modified_uncertain && git_oid_iszero(&nitem->id)) {\n\t\tconst git_oid *update_check =\n\t\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) && omode == nmode ?\n\t\t\t&oitem->id : NULL;\n\n\t\tif ((error = git_diff__oid_for_entry(\n\t\t\t\t&noid, diff, nitem, nmode, update_check)) < 0)\n\t\t\treturn error;\n\n\t\t/* if oid matches, then mark unmodified (except submodules, where\n\t\t * the filesystem content may be modified even if the oid still\n\t\t * matches between the index and the workdir HEAD)\n\t\t */\n\t\tif (omode == nmode && !S_ISGITLINK(omode) &&\n\t\t\tgit_oid_equal(&oitem->id, &noid))\n\t\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* If we want case changes, then break this into a delete of the old\n\t * and an add of the new so that consumers can act accordingly (eg,\n\t * checkout will update the case on disk.)\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE) &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_CASECHANGE) &&\n\t\tstrcmp(oitem->path, nitem->path) != 0) {\n\n\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\n\t\treturn error;\n\t}\n\n\treturn diff_delta__from_two(\n\t\tdiff, status, oitem, omode, nitem, nmode,\n\t\tgit_oid_iszero(&noid) ? NULL : &noid, matched_pathspec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int handle_matched_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\n\tif ((error = maybe_modified(diff, info)) < 0)\n\t\treturn error;\n\n\tif (!(error = iterator_advance(&info->oitem, info->old_iter)))\n\t\terror = iterator_advance(&info->nitem, info->new_iter);\n\n\treturn error;\n}"
  },
  {
    "function_name": "handle_unmatched_old_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "1160-1196",
    "snippet": "static int handle_unmatched_old_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tgit_delta_t delta_type = GIT_DELTA_DELETED;\n\tint error;\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(info->oitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\tif ((error = diff_delta__from_one(diff, delta_type, info->oitem, NULL)) < 0)\n\t\treturn error;\n\n\t/* if we are generating TYPECHANGE records then check for that\n\t * instead of just generating a DELETE record\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tentry_is_prefixed(diff, info->nitem, info->oitem))\n\t{\n\t\t/* this entry has become a tree! convert to TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, info->oitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->new_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\n\t\t/* If new_iter is a workdir iterator, then this situation\n\t\t * will certainly be followed by a series of untracked items.\n\t\t * Unless RECURSE_UNTRACKED_DIRS is set, skip over them...\n\t\t */\n\t\tif (S_ISDIR(info->nitem->mode) &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS))\n\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t}\n\n\treturn iterator_advance(&info->oitem, info->old_iter);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterator_advance",
          "args": [
            "&info->oitem",
            "info->old_iter"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_advance_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "969-981",
          "snippet": "static int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_RECURSE_UNTRACKED_DIRS"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "info->nitem->mode"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_delta__last_for_item",
          "args": [
            "diff",
            "info->oitem"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__last_for_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "229-263",
          "snippet": "static git_diff_delta *diff_delta__last_for_item(\n\tgit_diff *diff,\n\tconst git_index_entry *item)\n{\n\tgit_diff_delta *delta = git_vector_last(&diff->deltas);\n\tif (!delta)\n\t\treturn NULL;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\t\tif (git_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (diff->strcomp(delta->new_file.path, item->path) == 0 &&\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0 ||\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *diff_delta__last_for_item(\n\tgit_diff *diff,\n\tconst git_index_entry *item)\n{\n\tgit_diff_delta *delta = git_vector_last(&diff->deltas);\n\tif (!delta)\n\t\treturn NULL;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\t\tif (git_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (diff->strcomp(delta->new_file.path, item->path) == 0 &&\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0 ||\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_is_prefixed",
          "args": [
            "diff",
            "info->nitem",
            "info->oitem"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "entry_is_prefixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "904-919",
          "snippet": "static bool entry_is_prefixed(\n\tgit_diff *diff,\n\tconst git_index_entry *item,\n\tconst git_index_entry *prefix_item)\n{\n\tsize_t pathlen;\n\n\tif (!item || diff->pfxcomp(item->path, prefix_item->path) != 0)\n\t\treturn false;\n\n\tpathlen = strlen(prefix_item->path);\n\n\treturn (prefix_item->path[pathlen - 1] == '/' ||\n\t\t\titem->path[pathlen] == '\\0' ||\n\t\t\titem->path[pathlen] == '/');\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic bool entry_is_prefixed(\n\tgit_diff *diff,\n\tconst git_index_entry *item,\n\tconst git_index_entry *prefix_item)\n{\n\tsize_t pathlen;\n\n\tif (!item || diff->pfxcomp(item->path, prefix_item->path) != 0)\n\t\treturn false;\n\n\tpathlen = strlen(prefix_item->path);\n\n\treturn (prefix_item->path[pathlen - 1] == '/' ||\n\t\t\titem->path[pathlen] == '\\0' ||\n\t\t\titem->path[pathlen] == '/');\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_TYPECHANGE_TREES"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_delta__from_one",
          "args": [
            "diff",
            "delta_type",
            "info->oitem",
            "NULL"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__from_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "103-167",
          "snippet": "static int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "info->oitem"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int handle_unmatched_old_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tgit_delta_t delta_type = GIT_DELTA_DELETED;\n\tint error;\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(info->oitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\tif ((error = diff_delta__from_one(diff, delta_type, info->oitem, NULL)) < 0)\n\t\treturn error;\n\n\t/* if we are generating TYPECHANGE records then check for that\n\t * instead of just generating a DELETE record\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tentry_is_prefixed(diff, info->nitem, info->oitem))\n\t{\n\t\t/* this entry has become a tree! convert to TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, info->oitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->new_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\n\t\t/* If new_iter is a workdir iterator, then this situation\n\t\t * will certainly be followed by a series of untracked items.\n\t\t * Unless RECURSE_UNTRACKED_DIRS is set, skip over them...\n\t\t */\n\t\tif (S_ISDIR(info->nitem->mode) &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS))\n\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t}\n\n\treturn iterator_advance(&info->oitem, info->old_iter);\n}"
  },
  {
    "function_name": "handle_unmatched_new_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "999-1158",
    "snippet": "static int handle_unmatched_new_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\tconst git_index_entry *nitem = info->nitem;\n\tgit_delta_t delta_type = GIT_DELTA_UNTRACKED;\n\tbool contains_oitem;\n\n\t/* check if this is a prefix of the other side */\n\tcontains_oitem = entry_is_prefixed(diff, info->oitem, nitem);\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(nitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\t/* update delta_type if this item is ignored */\n\telse if (git_iterator_current_is_ignored(info->new_iter))\n\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\tif (nitem->mode == GIT_FILEMODE_TREE) {\n\t\tbool recurse_into_dir = contains_oitem;\n\n\t\t/* check if user requests recursion into this type of dir */\n\t\trecurse_into_dir = contains_oitem ||\n\t\t\t(delta_type == GIT_DELTA_UNTRACKED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS)) ||\n\t\t\t(delta_type == GIT_DELTA_IGNORED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS));\n\n\t\t/* do not advance into directories that contain a .git file */\n\t\tif (recurse_into_dir && !contains_oitem) {\n\t\t\tgit_buf *full = NULL;\n\t\t\tif (git_iterator_current_workdir_path(&full, info->new_iter) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (full && git_path_contains(full, DOT_GIT)) {\n\t\t\t\t/* TODO: warning if not a valid git repository */\n\t\t\t\trecurse_into_dir = false;\n\t\t\t}\n\t\t}\n\n\t\t/* still have to look into untracked directories to match core git -\n\t\t * with no untracked files, directory is treated as ignored\n\t\t */\n\t\tif (!recurse_into_dir &&\n\t\t\tdelta_type == GIT_DELTA_UNTRACKED &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS))\n\t\t{\n\t\t\tgit_diff_delta *last;\n\t\t\tgit_iterator_status_t untracked_state;\n\n\t\t\t/* attempt to insert record for this directory */\n\t\t\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if delta wasn't created (because of rules), just skip ahead */\n\t\t\tlast = diff_delta__last_for_item(diff, nitem);\n\t\t\tif (!last)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\t\t\t/* iterate into dir looking for an actual untracked file */\n\t\t\tif ((error = iterator_advance_over_with_status(\n\t\t\t\t\t&info->nitem, &untracked_state, info->new_iter)) < 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if we found nothing that matched our pathlist filter, exclude */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_FILTERED) {\n\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\tgit__free(last);\n\t\t\t}\n\n\t\t\t/* if we found nothing or just ignored items, update the record */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_IGNORED ||\n\t\t\t\tuntracked_state == GIT_ITERATOR_STATUS_EMPTY) {\n\t\t\t\tlast->status = GIT_DELTA_IGNORED;\n\n\t\t\t\t/* remove the record if we don't want ignored records */\n\t\t\t\tif (DIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED)) {\n\t\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\t\tgit__free(last);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* try to advance into directory if necessary */\n\t\tif (recurse_into_dir) {\n\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\n\t\t\t/* if real error or no error, proceed with iteration */\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\tgiterr_clear();\n\n\t\t\t/* if directory is empty, can't advance into it, so either skip\n\t\t\t * it or ignore it\n\t\t\t */\n\t\t\tif (contains_oitem)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\t\t}\n\t}\n\n\telse if (delta_type == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS) &&\n\t\tgit_iterator_current_tree_is_ignored(info->new_iter))\n\t\t/* item contained in ignored directory, so skip over it */\n\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\telse if (info->new_iter->type != GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif (delta_type != GIT_DELTA_CONFLICTED)\n\t\t\tdelta_type = GIT_DELTA_ADDED;\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_COMMIT) {\n\t\t/* ignore things that are not actual submodules */\n\t\tif (git_submodule_lookup(NULL, info->repo, nitem->path) != 0) {\n\t\t\tgiterr_clear();\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\t\t\t/* if this contains a tracked item, treat as normal TREE */\n\t\t\tif (contains_oitem) {\n\t\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\t\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\t\treturn error;\n\n\t\t\t\tgiterr_clear();\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_UNREADABLE) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED))\n\t\t\tdelta_type = GIT_DELTA_UNTRACKED;\n\t\telse\n\t\t\tdelta_type = GIT_DELTA_UNREADABLE;\n\t}\n\n\t/* Actually create the record for this item if necessary */\n\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\treturn error;\n\n\t/* If user requested TYPECHANGE records, then check for that instead of\n\t * just generating an ADDED/UNTRACKED record\n\t */\n\tif (delta_type != GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tcontains_oitem)\n\t{\n\t\t/* this entry was prefixed with a tree - make TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, nitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->old_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\t}\n\n\treturn iterator_advance(&info->nitem, info->new_iter);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterator_advance",
          "args": [
            "&info->nitem",
            "info->new_iter"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_advance_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "969-981",
          "snippet": "static int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_delta__last_for_item",
          "args": [
            "diff",
            "nitem"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__last_for_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "229-263",
          "snippet": "static git_diff_delta *diff_delta__last_for_item(\n\tgit_diff *diff,\n\tconst git_index_entry *item)\n{\n\tgit_diff_delta *delta = git_vector_last(&diff->deltas);\n\tif (!delta)\n\t\treturn NULL;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\t\tif (git_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (diff->strcomp(delta->new_file.path, item->path) == 0 &&\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0 ||\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *diff_delta__last_for_item(\n\tgit_diff *diff,\n\tconst git_index_entry *item)\n{\n\tgit_diff_delta *delta = git_vector_last(&diff->deltas);\n\tif (!delta)\n\t\treturn NULL;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\t\tif (git_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (diff->strcomp(delta->new_file.path, item->path) == 0 &&\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0 ||\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_TYPECHANGE_TREES"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_delta__from_one",
          "args": [
            "diff",
            "delta_type",
            "NULL",
            "nitem"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__from_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "103-167",
          "snippet": "static int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "NULL",
            "info->repo",
            "nitem->path"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_current_tree_is_ignored",
          "args": [
            "info->new_iter"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_tree_is_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1989-1997",
          "snippet": "bool git_iterator_current_tree_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\treturn (bool)(wi->fi.stack->is_ignored == GIT_IGNORE_TRUE);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nbool git_iterator_current_tree_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\treturn (bool)(wi->fi.stack->is_ignored == GIT_IGNORE_TRUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_RECURSE_IGNORED_DIRS"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "last"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_pop",
          "args": [
            "&diff->deltas"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_pop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "252-256",
          "snippet": "void git_vector_pop(git_vector *v)\n{\n\tif (v->length > 0)\n\t\tv->length--;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_pop(git_vector *v)\n{\n\tif (v->length > 0)\n\t\tv->length--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_IGNORED"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator_advance_over_with_status",
          "args": [
            "&info->nitem",
            "&untracked_state",
            "info->new_iter"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_advance_over_with_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "983-997",
          "snippet": "static int iterator_advance_over_with_status(\n\tconst git_index_entry **entry,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_over_with_status(\n\t\t\tentry, status, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance_over_with_status(\n\tconst git_index_entry **entry,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_over_with_status(\n\t\t\tentry, status, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_contains",
          "args": [
            "full",
            "DOT_GIT"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_contains_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "678-681",
          "snippet": "bool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nbool git_path_contains_file(git_buf *base, const char *file)\n{\n\treturn _check_dir_contents(base, file, &git_path_isfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_current_workdir_path",
          "args": [
            "&full",
            "info->new_iter"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_workdir_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2014-2024",
          "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_RECURSE_IGNORED_DIRS"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_RECURSE_UNTRACKED_DIRS"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_current_is_ignored",
          "args": [
            "info->new_iter"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_is_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1974-1987",
          "snippet": "bool git_iterator_current_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\tif (wi->is_ignored != GIT_IGNORE_UNCHECKED)\n\t\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n\n\tworkdir_iterator_update_is_ignored(wi);\n\n\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nbool git_iterator_current_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\tif (wi->is_ignored != GIT_IGNORE_UNCHECKED)\n\t\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n\n\tworkdir_iterator_update_is_ignored(wi);\n\n\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "nitem"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry_is_prefixed",
          "args": [
            "diff",
            "info->oitem",
            "nitem"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "entry_is_prefixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "904-919",
          "snippet": "static bool entry_is_prefixed(\n\tgit_diff *diff,\n\tconst git_index_entry *item,\n\tconst git_index_entry *prefix_item)\n{\n\tsize_t pathlen;\n\n\tif (!item || diff->pfxcomp(item->path, prefix_item->path) != 0)\n\t\treturn false;\n\n\tpathlen = strlen(prefix_item->path);\n\n\treturn (prefix_item->path[pathlen - 1] == '/' ||\n\t\t\titem->path[pathlen] == '\\0' ||\n\t\t\titem->path[pathlen] == '/');\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic bool entry_is_prefixed(\n\tgit_diff *diff,\n\tconst git_index_entry *item,\n\tconst git_index_entry *prefix_item)\n{\n\tsize_t pathlen;\n\n\tif (!item || diff->pfxcomp(item->path, prefix_item->path) != 0)\n\t\treturn false;\n\n\tpathlen = strlen(prefix_item->path);\n\n\treturn (prefix_item->path[pathlen - 1] == '/' ||\n\t\t\titem->path[pathlen] == '\\0' ||\n\t\t\titem->path[pathlen] == '/');\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int handle_unmatched_new_item(\n\tgit_diff *diff, diff_in_progress *info)\n{\n\tint error = 0;\n\tconst git_index_entry *nitem = info->nitem;\n\tgit_delta_t delta_type = GIT_DELTA_UNTRACKED;\n\tbool contains_oitem;\n\n\t/* check if this is a prefix of the other side */\n\tcontains_oitem = entry_is_prefixed(diff, info->oitem, nitem);\n\n\t/* update delta_type if this item is conflicted */\n\tif (git_index_entry_is_conflict(nitem))\n\t\tdelta_type = GIT_DELTA_CONFLICTED;\n\n\t/* update delta_type if this item is ignored */\n\telse if (git_iterator_current_is_ignored(info->new_iter))\n\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\tif (nitem->mode == GIT_FILEMODE_TREE) {\n\t\tbool recurse_into_dir = contains_oitem;\n\n\t\t/* check if user requests recursion into this type of dir */\n\t\trecurse_into_dir = contains_oitem ||\n\t\t\t(delta_type == GIT_DELTA_UNTRACKED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_UNTRACKED_DIRS)) ||\n\t\t\t(delta_type == GIT_DELTA_IGNORED &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS));\n\n\t\t/* do not advance into directories that contain a .git file */\n\t\tif (recurse_into_dir && !contains_oitem) {\n\t\t\tgit_buf *full = NULL;\n\t\t\tif (git_iterator_current_workdir_path(&full, info->new_iter) < 0)\n\t\t\t\treturn -1;\n\t\t\tif (full && git_path_contains(full, DOT_GIT)) {\n\t\t\t\t/* TODO: warning if not a valid git repository */\n\t\t\t\trecurse_into_dir = false;\n\t\t\t}\n\t\t}\n\n\t\t/* still have to look into untracked directories to match core git -\n\t\t * with no untracked files, directory is treated as ignored\n\t\t */\n\t\tif (!recurse_into_dir &&\n\t\t\tdelta_type == GIT_DELTA_UNTRACKED &&\n\t\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS))\n\t\t{\n\t\t\tgit_diff_delta *last;\n\t\t\tgit_iterator_status_t untracked_state;\n\n\t\t\t/* attempt to insert record for this directory */\n\t\t\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if delta wasn't created (because of rules), just skip ahead */\n\t\t\tlast = diff_delta__last_for_item(diff, nitem);\n\t\t\tif (!last)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\t\t\t/* iterate into dir looking for an actual untracked file */\n\t\t\tif ((error = iterator_advance_over_with_status(\n\t\t\t\t\t&info->nitem, &untracked_state, info->new_iter)) < 0)\n\t\t\t\treturn error;\n\n\t\t\t/* if we found nothing that matched our pathlist filter, exclude */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_FILTERED) {\n\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\tgit__free(last);\n\t\t\t}\n\n\t\t\t/* if we found nothing or just ignored items, update the record */\n\t\t\tif (untracked_state == GIT_ITERATOR_STATUS_IGNORED ||\n\t\t\t\tuntracked_state == GIT_ITERATOR_STATUS_EMPTY) {\n\t\t\t\tlast->status = GIT_DELTA_IGNORED;\n\n\t\t\t\t/* remove the record if we don't want ignored records */\n\t\t\t\tif (DIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED)) {\n\t\t\t\t\tgit_vector_pop(&diff->deltas);\n\t\t\t\t\tgit__free(last);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* try to advance into directory if necessary */\n\t\tif (recurse_into_dir) {\n\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\n\t\t\t/* if real error or no error, proceed with iteration */\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\t\t\tgiterr_clear();\n\n\t\t\t/* if directory is empty, can't advance into it, so either skip\n\t\t\t * it or ignore it\n\t\t\t */\n\t\t\tif (contains_oitem)\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\t\t}\n\t}\n\n\telse if (delta_type == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_RECURSE_IGNORED_DIRS) &&\n\t\tgit_iterator_current_tree_is_ignored(info->new_iter))\n\t\t/* item contained in ignored directory, so skip over it */\n\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\n\telse if (info->new_iter->type != GIT_ITERATOR_TYPE_WORKDIR) {\n\t\tif (delta_type != GIT_DELTA_CONFLICTED)\n\t\t\tdelta_type = GIT_DELTA_ADDED;\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_COMMIT) {\n\t\t/* ignore things that are not actual submodules */\n\t\tif (git_submodule_lookup(NULL, info->repo, nitem->path) != 0) {\n\t\t\tgiterr_clear();\n\t\t\tdelta_type = GIT_DELTA_IGNORED;\n\n\t\t\t/* if this contains a tracked item, treat as normal TREE */\n\t\t\tif (contains_oitem) {\n\t\t\t\terror = iterator_advance_into(&info->nitem, info->new_iter);\n\t\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\t\treturn error;\n\n\t\t\t\tgiterr_clear();\n\t\t\t\treturn iterator_advance(&info->nitem, info->new_iter);\n\t\t\t}\n\t\t}\n\t}\n\n\telse if (nitem->mode == GIT_FILEMODE_UNREADABLE) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED))\n\t\t\tdelta_type = GIT_DELTA_UNTRACKED;\n\t\telse\n\t\t\tdelta_type = GIT_DELTA_UNREADABLE;\n\t}\n\n\t/* Actually create the record for this item if necessary */\n\tif ((error = diff_delta__from_one(diff, delta_type, NULL, nitem)) != 0)\n\t\treturn error;\n\n\t/* If user requested TYPECHANGE records, then check for that instead of\n\t * just generating an ADDED/UNTRACKED record\n\t */\n\tif (delta_type != GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES) &&\n\t\tcontains_oitem)\n\t{\n\t\t/* this entry was prefixed with a tree - make TYPECHANGE */\n\t\tgit_diff_delta *last = diff_delta__last_for_item(diff, nitem);\n\t\tif (last) {\n\t\t\tlast->status = GIT_DELTA_TYPECHANGE;\n\t\t\tlast->old_file.mode = GIT_FILEMODE_TREE;\n\t\t}\n\t}\n\n\treturn iterator_advance(&info->nitem, info->new_iter);\n}"
  },
  {
    "function_name": "iterator_advance_over_with_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "983-997",
    "snippet": "static int iterator_advance_over_with_status(\n\tconst git_index_entry **entry,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_over_with_status(\n\t\t\tentry, status, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_advance_over_with_status",
          "args": [
            "entry",
            "status",
            "iterator"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_over_with_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2038-2114",
          "snippet": "int git_iterator_advance_over_with_status(\n\tconst git_index_entry **entryptr,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iter)\n{\n\tint error = 0;\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\tchar *base = NULL;\n\tconst git_index_entry *entry;\n\n\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn git_iterator_advance(entryptr, iter);\n\tif ((error = git_iterator_current(&entry, iter)) < 0)\n\t\treturn error;\n\n\tif (!S_ISDIR(entry->mode)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\treturn git_iterator_advance(entryptr, iter);\n\t}\n\n\t*status = GIT_ITERATOR_STATUS_EMPTY;\n\n\tbase = git__strdup(entry->path);\n\tGITERR_CHECK_ALLOC(base);\n\n\t/* scan inside directory looking for a non-ignored item */\n\twhile (entry && !iter->prefixcomp(entry->path, base)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\n\t\t/* if we found an explicitly ignored item, then update from\n\t\t * EMPTY to IGNORED\n\t\t */\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\telse if (S_ISDIR(entry->mode)) {\n\t\t\terror = git_iterator_advance_into(&entry, iter);\n\n\t\t\tif (!error)\n\t\t\t\tcontinue;\n\n\t\t\telse if (error == GIT_ENOTFOUND) {\n\t\t\t\t/* we entered this directory only hoping to find child matches to\n\t\t\t\t * our pathlist (eg, this is `foo` and we had a pathlist entry for\n\t\t\t\t * `foo/bar`).  it should not be ignored, it should be excluded.\n\t\t\t\t */\n\t\t\t\tif (wi->fi.pathlist_match == ITERATOR_PATHLIST_MATCH_CHILD)\n\t\t\t\t\t*status = GIT_ITERATOR_STATUS_FILTERED;\n\t\t\t\telse\n\t\t\t\t\twi->is_ignored = GIT_IGNORE_TRUE; /* mark empty dirs ignored */\n\n\t\t\t\terror = 0;\n\t\t\t} else\n\t\t\t\tbreak; /* real error, stop here */\n\t\t} else {\n\t\t\t/* we found a non-ignored item, treat parent as untracked */\n\t\t\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\t}\n\n\t/* wrap up scan back to base directory */\n\twhile (entry && !iter->prefixcomp(entry->path, base))\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\n\t*entryptr = entry;\n\tgit__free(base);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_advance_over_with_status(\n\tconst git_index_entry **entryptr,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iter)\n{\n\tint error = 0;\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\tchar *base = NULL;\n\tconst git_index_entry *entry;\n\n\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn git_iterator_advance(entryptr, iter);\n\tif ((error = git_iterator_current(&entry, iter)) < 0)\n\t\treturn error;\n\n\tif (!S_ISDIR(entry->mode)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\treturn git_iterator_advance(entryptr, iter);\n\t}\n\n\t*status = GIT_ITERATOR_STATUS_EMPTY;\n\n\tbase = git__strdup(entry->path);\n\tGITERR_CHECK_ALLOC(base);\n\n\t/* scan inside directory looking for a non-ignored item */\n\twhile (entry && !iter->prefixcomp(entry->path, base)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\n\t\t/* if we found an explicitly ignored item, then update from\n\t\t * EMPTY to IGNORED\n\t\t */\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\telse if (S_ISDIR(entry->mode)) {\n\t\t\terror = git_iterator_advance_into(&entry, iter);\n\n\t\t\tif (!error)\n\t\t\t\tcontinue;\n\n\t\t\telse if (error == GIT_ENOTFOUND) {\n\t\t\t\t/* we entered this directory only hoping to find child matches to\n\t\t\t\t * our pathlist (eg, this is `foo` and we had a pathlist entry for\n\t\t\t\t * `foo/bar`).  it should not be ignored, it should be excluded.\n\t\t\t\t */\n\t\t\t\tif (wi->fi.pathlist_match == ITERATOR_PATHLIST_MATCH_CHILD)\n\t\t\t\t\t*status = GIT_ITERATOR_STATUS_FILTERED;\n\t\t\t\telse\n\t\t\t\t\twi->is_ignored = GIT_IGNORE_TRUE; /* mark empty dirs ignored */\n\n\t\t\t\terror = 0;\n\t\t\t} else\n\t\t\t\tbreak; /* real error, stop here */\n\t\t} else {\n\t\t\t/* we found a non-ignored item, treat parent as untracked */\n\t\t\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\t}\n\n\t/* wrap up scan back to base directory */\n\twhile (entry && !iter->prefixcomp(entry->path, base))\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\n\t*entryptr = entry;\n\tgit__free(base);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance_over_with_status(\n\tconst git_index_entry **entry,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_over_with_status(\n\t\t\tentry, status, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "iterator_advance_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "969-981",
    "snippet": "static int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_advance_into",
          "args": [
            "entry",
            "iterator"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance_into(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_advance_into(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "iterator_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "935-967",
    "snippet": "static int iterator_advance(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tconst git_index_entry *prev_entry = *entry;\n\tint cmp, error;\n\n\t/* if we're looking for conflicts, we only want to report\n\t * one conflict for each file, instead of all three sides.\n\t * so if this entry is a conflict for this file, and the\n\t * previous one was a conflict for the same file, skip it.\n\t */\n\twhile ((error = git_iterator_advance(entry, iterator)) == 0) {\n\t\tif (!(iterator->flags & GIT_ITERATOR_INCLUDE_CONFLICTS) ||\n\t\t\t!git_index_entry_is_conflict(prev_entry) ||\n\t\t\t!git_index_entry_is_conflict(*entry))\n\t\t\tbreak;\n\n\t\tcmp = (iterator->flags & GIT_ITERATOR_IGNORE_CASE) ?\n\t\t\tstrcasecmp(prev_entry->path, (*entry)->path) :\n\t\t\tstrcmp(prev_entry->path, (*entry)->path);\n\n\t\tif (cmp)\n\t\t\tbreak;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "prev_entry->path",
            "(*entry)->path"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "prev_entry->path",
            "(*entry)->path"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "*entry"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "entry",
            "iterator"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_advance(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tconst git_index_entry *prev_entry = *entry;\n\tint cmp, error;\n\n\t/* if we're looking for conflicts, we only want to report\n\t * one conflict for each file, instead of all three sides.\n\t * so if this entry is a conflict for this file, and the\n\t * previous one was a conflict for the same file, skip it.\n\t */\n\twhile ((error = git_iterator_advance(entry, iterator)) == 0) {\n\t\tif (!(iterator->flags & GIT_ITERATOR_INCLUDE_CONFLICTS) ||\n\t\t\t!git_index_entry_is_conflict(prev_entry) ||\n\t\t\t!git_index_entry_is_conflict(*entry))\n\t\t\tbreak;\n\n\t\tcmp = (iterator->flags & GIT_ITERATOR_IGNORE_CASE) ?\n\t\t\tstrcasecmp(prev_entry->path, (*entry)->path) :\n\t\t\tstrcmp(prev_entry->path, (*entry)->path);\n\n\t\tif (cmp)\n\t\t\tbreak;\n\t}\n\n\tif (error == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "iterator_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "921-933",
    "snippet": "static int iterator_current(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_current(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_current",
          "args": [
            "entry",
            "iterator"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_workdir_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2014-2024",
          "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int iterator_current(\n\tconst git_index_entry **entry,\n\tgit_iterator *iterator)\n{\n\tint error;\n\n\tif ((error = git_iterator_current(entry, iterator)) == GIT_ITEROVER) {\n\t\t*entry = NULL;\n\t\terror = 0;\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "entry_is_prefixed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "904-919",
    "snippet": "static bool entry_is_prefixed(\n\tgit_diff *diff,\n\tconst git_index_entry *item,\n\tconst git_index_entry *prefix_item)\n{\n\tsize_t pathlen;\n\n\tif (!item || diff->pfxcomp(item->path, prefix_item->path) != 0)\n\t\treturn false;\n\n\tpathlen = strlen(prefix_item->path);\n\n\treturn (prefix_item->path[pathlen - 1] == '/' ||\n\t\t\titem->path[pathlen] == '\\0' ||\n\t\t\titem->path[pathlen] == '/');\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix_item->path"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff->pfxcomp",
          "args": [
            "item->path",
            "prefix_item->path"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic bool entry_is_prefixed(\n\tgit_diff *diff,\n\tconst git_index_entry *item,\n\tconst git_index_entry *prefix_item)\n{\n\tsize_t pathlen;\n\n\tif (!item || diff->pfxcomp(item->path, prefix_item->path) != 0)\n\t\treturn false;\n\n\tpathlen = strlen(prefix_item->path);\n\n\treturn (prefix_item->path[pathlen - 1] == '/' ||\n\t\t\titem->path[pathlen] == '\\0' ||\n\t\t\titem->path[pathlen] == '/');\n}"
  },
  {
    "function_name": "maybe_modified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "756-902",
    "snippet": "static int maybe_modified(\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tgit_oid noid;\n\tgit_delta_t status = GIT_DELTA_MODIFIED;\n\tconst git_index_entry *oitem = info->oitem;\n\tconst git_index_entry *nitem = info->nitem;\n\tunsigned int omode = oitem->mode;\n\tunsigned int nmode = nitem->mode;\n\tbool new_is_workdir = (info->new_iter->type == GIT_ITERATOR_TYPE_WORKDIR);\n\tbool modified_uncertain = false;\n\tconst char *matched_pathspec;\n\tint error = 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, oitem))\n\t\treturn 0;\n\n\tmemset(&noid, 0, sizeof(noid));\n\n\t/* on platforms with no symlinks, preserve mode of existing symlinks */\n\tif (S_ISLNK(omode) && S_ISREG(nmode) && new_is_workdir &&\n\t\t!(diff->diffcaps & GIT_DIFFCAPS_HAS_SYMLINKS))\n\t\tnmode = omode;\n\n\t/* on platforms with no execmode, just preserve old mode */\n\tif (!(diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) &&\n\t\t(nmode & MODE_BITS_MASK) != (omode & MODE_BITS_MASK) &&\n\t\tnew_is_workdir)\n\t\tnmode = (nmode & ~MODE_BITS_MASK) | (omode & MODE_BITS_MASK);\n\n\t/* if one side is a conflict, mark the whole delta as conflicted */\n\tif (git_index_entry_is_conflict(oitem) ||\n\t\t\tgit_index_entry_is_conflict(nitem)) {\n\t\tstatus = GIT_DELTA_CONFLICTED;\n\n\t/* support \"assume unchanged\" (poorly, b/c we still stat everything) */\n\t} else if ((oitem->flags & GIT_IDXENTRY_VALID) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* support \"skip worktree\" index bit */\n\t} else if ((oitem->flags_extended & GIT_IDXENTRY_SKIP_WORKTREE) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if basic type of file changed, then split into delete and add */\n\t} else if (GIT_MODE_TYPE(omode) != GIT_MODE_TYPE(nmode)) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE)) {\n\t\t\tstatus = GIT_DELTA_TYPECHANGE;\n\t\t}\n\n\t\telse if (nmode == GIT_FILEMODE_UNREADABLE) {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_UNREADABLE, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t\telse {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t/* if oids and modes match (and are valid), then file is unmodified */\n\t} else if (git_oid_equal(&oitem->id, &nitem->id) &&\n\t\t\t omode == nmode &&\n\t\t\t !git_oid_iszero(&oitem->id)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if we have an unknown OID and a workdir iterator, then check some\n\t * circumstances that can accelerate things or need special handling\n\t */\n\t} else if (git_oid_iszero(&nitem->id) && new_is_workdir) {\n\t\tbool use_ctime = ((diff->diffcaps & GIT_DIFFCAPS_TRUST_CTIME) != 0);\n\t\tgit_index *index;\n\t\tgit_iterator_index(&index, info->new_iter);\n\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t\tif (S_ISGITLINK(nmode)) {\n\t\t\tif ((error = maybe_modified_submodule(&status, &noid, diff, info)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* if the stat data looks different, then mark modified - this just\n\t\t * means that the OID will be recalculated below to confirm change\n\t\t */\n\t\telse if (omode != nmode || oitem->file_size != nitem->file_size) {\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain =\n\t\t\t\t(oitem->file_size <= 0 && nitem->file_size > 0);\n\t\t}\n\t\telse if (!git_index_time_eq(&oitem->mtime, &nitem->mtime) ||\n\t\t\t(use_ctime && !git_index_time_eq(&oitem->ctime, &nitem->ctime)) ||\n\t\t\toitem->ino != nitem->ino ||\n\t\t\toitem->uid != nitem->uid ||\n\t\t\toitem->gid != nitem->gid ||\n\t\t\tgit_index_entry_newer_than_index(nitem, index))\n\t\t{\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain = true;\n\t\t}\n\n\t/* if mode is GITLINK and submodules are ignored, then skip */\n\t} else if (S_ISGITLINK(nmode) &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* if we got here and decided that the files are modified, but we\n\t * haven't calculated the OID of the new item, then calculate it now\n\t */\n\tif (modified_uncertain && git_oid_iszero(&nitem->id)) {\n\t\tconst git_oid *update_check =\n\t\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) && omode == nmode ?\n\t\t\t&oitem->id : NULL;\n\n\t\tif ((error = git_diff__oid_for_entry(\n\t\t\t\t&noid, diff, nitem, nmode, update_check)) < 0)\n\t\t\treturn error;\n\n\t\t/* if oid matches, then mark unmodified (except submodules, where\n\t\t * the filesystem content may be modified even if the oid still\n\t\t * matches between the index and the workdir HEAD)\n\t\t */\n\t\tif (omode == nmode && !S_ISGITLINK(omode) &&\n\t\t\tgit_oid_equal(&oitem->id, &noid))\n\t\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* If we want case changes, then break this into a delete of the old\n\t * and an add of the new so that consumers can act accordingly (eg,\n\t * checkout will update the case on disk.)\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE) &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_CASECHANGE) &&\n\t\tstrcmp(oitem->path, nitem->path) != 0) {\n\n\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\n\t\treturn error;\n\t}\n\n\treturn diff_delta__from_two(\n\t\tdiff, status, oitem, omode, nitem, nmode,\n\t\tgit_oid_iszero(&noid) ? NULL : &noid, matched_pathspec);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [
      "#define MODE_BITS_MASK 0000777"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_delta__from_two",
          "args": [
            "diff",
            "status",
            "oitem",
            "omode",
            "nitem",
            "nmode",
            "git_oid_iszero(&noid) ? NULL : &noid",
            "matched_pathspec"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__from_two",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "169-227",
          "snippet": "static int diff_delta__from_two(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *old_entry,\n\tuint32_t old_mode,\n\tconst git_index_entry *new_entry,\n\tuint32_t new_mode,\n\tconst git_oid *new_id,\n\tconst char *matched_pathspec)\n{\n\tconst git_oid *old_id = &old_entry->id;\n\tgit_diff_delta *delta;\n\tconst char *canonical_path = old_entry->path;\n\n\tif (status == GIT_DELTA_UNMODIFIED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNMODIFIED))\n\t\treturn 0;\n\n\tif (!new_id)\n\t\tnew_id = &new_entry->id;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tuint32_t temp_mode = old_mode;\n\t\tconst git_index_entry *temp_entry = old_entry;\n\t\tconst git_oid *temp_id = old_id;\n\n\t\told_entry = new_entry;\n\t\tnew_entry = temp_entry;\n\t\told_mode = new_mode;\n\t\tnew_mode = temp_mode;\n\t\told_id = new_id;\n\t\tnew_id = temp_id;\n\t}\n\n\tdelta = diff_delta__alloc(diff, status, canonical_path);\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->nfiles = 2;\n\n\tif (!git_index_entry_is_conflict(old_entry)) {\n\t\tdelta->old_file.size = old_entry->file_size;\n\t\tdelta->old_file.mode = old_mode;\n\t\tgit_oid_cpy(&delta->old_file.id, old_id);\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID |\n\t\t\tGIT_DIFF_FLAG_EXISTS;\n\t}\n\n\tif (!git_index_entry_is_conflict(new_entry)) {\n\t\tgit_oid_cpy(&delta->new_file.id, new_id);\n\t\tdelta->new_file.size = new_entry->file_size;\n\t\tdelta->new_file.mode = new_mode;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\n\t\tif (!git_oid_iszero(&new_entry->id))\n\t\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_delta__from_two(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *old_entry,\n\tuint32_t old_mode,\n\tconst git_index_entry *new_entry,\n\tuint32_t new_mode,\n\tconst git_oid *new_id,\n\tconst char *matched_pathspec)\n{\n\tconst git_oid *old_id = &old_entry->id;\n\tgit_diff_delta *delta;\n\tconst char *canonical_path = old_entry->path;\n\n\tif (status == GIT_DELTA_UNMODIFIED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNMODIFIED))\n\t\treturn 0;\n\n\tif (!new_id)\n\t\tnew_id = &new_entry->id;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tuint32_t temp_mode = old_mode;\n\t\tconst git_index_entry *temp_entry = old_entry;\n\t\tconst git_oid *temp_id = old_id;\n\n\t\told_entry = new_entry;\n\t\tnew_entry = temp_entry;\n\t\told_mode = new_mode;\n\t\tnew_mode = temp_mode;\n\t\told_id = new_id;\n\t\tnew_id = temp_id;\n\t}\n\n\tdelta = diff_delta__alloc(diff, status, canonical_path);\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->nfiles = 2;\n\n\tif (!git_index_entry_is_conflict(old_entry)) {\n\t\tdelta->old_file.size = old_entry->file_size;\n\t\tdelta->old_file.mode = old_mode;\n\t\tgit_oid_cpy(&delta->old_file.id, old_id);\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID |\n\t\t\tGIT_DIFF_FLAG_EXISTS;\n\t}\n\n\tif (!git_index_entry_is_conflict(new_entry)) {\n\t\tgit_oid_cpy(&delta->new_file.id, new_id);\n\t\tdelta->new_file.size = new_entry->file_size;\n\t\tdelta->new_file.mode = new_mode;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\n\t\tif (!git_oid_iszero(&new_entry->id))\n\t\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&noid"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_delta__from_one",
          "args": [
            "diff",
            "GIT_DELTA_ADDED",
            "NULL",
            "nitem"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__from_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "103-167",
          "snippet": "static int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "oitem->path",
            "nitem->path"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_CASECHANGE"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_CASE"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&oitem->id",
            "&noid"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "omode"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_diff__oid_for_entry",
          "args": [
            "&noid",
            "diff",
            "nitem",
            "nmode",
            "update_check"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__oid_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "606-695",
          "snippet": "int git_diff__oid_for_entry(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst git_index_entry *src,\n\tuint16_t mode,\n\tconst git_oid *update_match)\n{\n\tint error = 0;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tgit_index_entry entry = *src;\n\tgit_filter_list *fl = NULL;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (git_buf_joinpath(\n\t\t&full_path, git_repository_workdir(diff->repo), entry.path) < 0)\n\t\treturn -1;\n\n\tif (!mode) {\n\t\tstruct stat st;\n\n\t\tdiff->perf.stat_calls++;\n\n\t\tif (p_stat(full_path.ptr, &st) < 0) {\n\t\t\terror = git_path_set_error(errno, entry.path, \"stat\");\n\t\t\tgit_buf_free(&full_path);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_index_entry__init_from_stat(\n\t\t\t&entry, &st, (diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0);\n\t}\n\n\t/* calculate OID for file if possible */\n\tif (S_ISGITLINK(mode)) {\n\t\tgit_submodule *sm;\n\n\t\tif (!git_submodule_lookup(&sm, diff->repo, entry.path)) {\n\t\t\tconst git_oid *sm_oid = git_submodule_wd_id(sm);\n\t\t\tif (sm_oid)\n\t\t\t\tgit_oid_cpy(out, sm_oid);\n\t\t\tgit_submodule_free(sm);\n\t\t} else {\n\t\t\t/* if submodule lookup failed probably just in an intermediate\n\t\t\t * state where some init hasn't happened, so ignore the error\n\t\t\t */\n\t\t\tgiterr_clear();\n\t\t}\n\t} else if (S_ISLNK(mode)) {\n\t\terror = git_odb__hashlink(out, full_path.ptr);\n\t\tdiff->perf.oid_calculations++;\n\t} else if (!git__is_sizet(entry.file_size)) {\n\t\tgiterr_set(GITERR_OS, \"File size overflow (for 32-bits) on '%s'\",\n\t\t\tentry.path);\n\t\terror = -1;\n\t} else if (!(error = git_filter_list_load(\n\t\t&fl, diff->repo, NULL, entry.path,\n\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)))\n\t{\n\t\tint fd = git_futils_open_ro(full_path.ptr);\n\t\tif (fd < 0)\n\t\t\terror = fd;\n\t\telse {\n\t\t\terror = git_odb__hashfd_filtered(\n\t\t\t\tout, fd, (size_t)entry.file_size, GIT_OBJ_BLOB, fl);\n\t\t\tp_close(fd);\n\t\t\tdiff->perf.oid_calculations++;\n\t\t}\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\t/* update index for entry if requested */\n\tif (!error && update_match && git_oid_equal(out, update_match)) {\n\t\tgit_index *idx;\n\t\tgit_index_entry updated_entry;\n\n\t\tmemcpy(&updated_entry, &entry, sizeof(git_index_entry));\n\t\tupdated_entry.mode = mode;\n\t\tgit_oid_cpy(&updated_entry.id, out);\n\n\t\tif (!(error = git_repository_index__weakptr(&idx, diff->repo))) {\n\t\t\terror = git_index_add(idx, &updated_entry);\n\t\t\tdiff->index_updated = true;\n\t\t}\n \t}\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__oid_for_entry(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst git_index_entry *src,\n\tuint16_t mode,\n\tconst git_oid *update_match)\n{\n\tint error = 0;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tgit_index_entry entry = *src;\n\tgit_filter_list *fl = NULL;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (git_buf_joinpath(\n\t\t&full_path, git_repository_workdir(diff->repo), entry.path) < 0)\n\t\treturn -1;\n\n\tif (!mode) {\n\t\tstruct stat st;\n\n\t\tdiff->perf.stat_calls++;\n\n\t\tif (p_stat(full_path.ptr, &st) < 0) {\n\t\t\terror = git_path_set_error(errno, entry.path, \"stat\");\n\t\t\tgit_buf_free(&full_path);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_index_entry__init_from_stat(\n\t\t\t&entry, &st, (diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0);\n\t}\n\n\t/* calculate OID for file if possible */\n\tif (S_ISGITLINK(mode)) {\n\t\tgit_submodule *sm;\n\n\t\tif (!git_submodule_lookup(&sm, diff->repo, entry.path)) {\n\t\t\tconst git_oid *sm_oid = git_submodule_wd_id(sm);\n\t\t\tif (sm_oid)\n\t\t\t\tgit_oid_cpy(out, sm_oid);\n\t\t\tgit_submodule_free(sm);\n\t\t} else {\n\t\t\t/* if submodule lookup failed probably just in an intermediate\n\t\t\t * state where some init hasn't happened, so ignore the error\n\t\t\t */\n\t\t\tgiterr_clear();\n\t\t}\n\t} else if (S_ISLNK(mode)) {\n\t\terror = git_odb__hashlink(out, full_path.ptr);\n\t\tdiff->perf.oid_calculations++;\n\t} else if (!git__is_sizet(entry.file_size)) {\n\t\tgiterr_set(GITERR_OS, \"File size overflow (for 32-bits) on '%s'\",\n\t\t\tentry.path);\n\t\terror = -1;\n\t} else if (!(error = git_filter_list_load(\n\t\t&fl, diff->repo, NULL, entry.path,\n\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)))\n\t{\n\t\tint fd = git_futils_open_ro(full_path.ptr);\n\t\tif (fd < 0)\n\t\t\terror = fd;\n\t\telse {\n\t\t\terror = git_odb__hashfd_filtered(\n\t\t\t\tout, fd, (size_t)entry.file_size, GIT_OBJ_BLOB, fl);\n\t\t\tp_close(fd);\n\t\t\tdiff->perf.oid_calculations++;\n\t\t}\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\t/* update index for entry if requested */\n\tif (!error && update_match && git_oid_equal(out, update_match)) {\n\t\tgit_index *idx;\n\t\tgit_index_entry updated_entry;\n\n\t\tmemcpy(&updated_entry, &entry, sizeof(git_index_entry));\n\t\tupdated_entry.mode = mode;\n\t\tgit_oid_cpy(&updated_entry.id, out);\n\n\t\tif (!(error = git_repository_index__weakptr(&idx, diff->repo))) {\n\t\t\terror = git_index_add(idx, &updated_entry);\n\t\t\tdiff->index_updated = true;\n\t\t}\n \t}\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_UPDATE_INDEX"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_SUBMODULES"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "nmode"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_entry_newer_than_index",
          "args": [
            "nitem",
            "index"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_newer_than_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.h",
          "lines": "86-104",
          "snippet": "GIT_INLINE(bool) git_index_entry_newer_than_index(\n\tconst git_index_entry *entry, git_index *index)\n{\n\t/* If we never read the index, we can't have this race either */\n\tif (!index || index->stamp.mtime.tv_sec == 0)\n\t\treturn false;\n\n\t/* If the timestamp is the same or newer than the index, it's racy */\n#if defined(GIT_USE_NSEC)\n\tif ((int32_t)index->stamp.mtime.tv_sec < entry->mtime.seconds)\n\t\treturn true;\n\telse if ((int32_t)index->stamp.mtime.tv_sec > entry->mtime.seconds)\n\t\treturn false;\n\telse\n\t\treturn (uint32_t)index->stamp.mtime.tv_nsec <= entry->mtime.nanoseconds;\n#else\n\treturn ((int32_t)index->stamp.mtime.tv_sec) <= entry->mtime.seconds;\n#endif\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/odb.h\"",
            "#include \"tree-cache.h\"",
            "#include \"idxmap.h\"",
            "#include \"vector.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/odb.h\"\n#include \"tree-cache.h\"\n#include \"idxmap.h\"\n#include \"vector.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n\nGIT_INLINE(bool) git_index_entry_newer_than_index(\n\tconst git_index_entry *entry, git_index *index)\n{\n\t/* If we never read the index, we can't have this race either */\n\tif (!index || index->stamp.mtime.tv_sec == 0)\n\t\treturn false;\n\n\t/* If the timestamp is the same or newer than the index, it's racy */\n#if defined(GIT_USE_NSEC)\n\tif ((int32_t)index->stamp.mtime.tv_sec < entry->mtime.seconds)\n\t\treturn true;\n\telse if ((int32_t)index->stamp.mtime.tv_sec > entry->mtime.seconds)\n\t\treturn false;\n\telse\n\t\treturn (uint32_t)index->stamp.mtime.tv_nsec <= entry->mtime.nanoseconds;\n#else\n\treturn ((int32_t)index->stamp.mtime.tv_sec) <= entry->mtime.seconds;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_time_eq",
          "args": [
            "&oitem->ctime",
            "&nitem->ctime"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_time_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.h",
          "lines": "68-79",
          "snippet": "GIT_INLINE(bool) git_index_time_eq(const git_index_time *one, const git_index_time *two)\n{\n\tif (one->seconds != two->seconds)\n\t\treturn false;\n\n#ifdef GIT_USE_NSEC\n\tif (one->nanoseconds != two->nanoseconds)\n\t\treturn false;\n#endif\n\n\treturn true;\n}",
          "includes": [
            "#include \"git2/index.h\"",
            "#include \"git2/odb.h\"",
            "#include \"tree-cache.h\"",
            "#include \"idxmap.h\"",
            "#include \"vector.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/index.h\"\n#include \"git2/odb.h\"\n#include \"tree-cache.h\"\n#include \"idxmap.h\"\n#include \"vector.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n\nGIT_INLINE(bool) git_index_time_eq(const git_index_time *one, const git_index_time *two)\n{\n\tif (one->seconds != two->seconds)\n\t\treturn false;\n\n#ifdef GIT_USE_NSEC\n\tif (one->nanoseconds != two->nanoseconds)\n\t\treturn false;\n#endif\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_modified_submodule",
          "args": [
            "&status",
            "&noid",
            "diff",
            "info"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_modified_submodule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "707-754",
          "snippet": "static int maybe_modified_submodule(\n\tgit_delta_t *status,\n\tgit_oid *found_oid,\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tint error = 0;\n\tgit_submodule *sub;\n\tunsigned int sm_status = 0;\n\tgit_submodule_ignore_t ign = diff->opts.ignore_submodules;\n\n\t*status = GIT_DELTA_UNMODIFIED;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES) ||\n\t\tign == GIT_SUBMODULE_IGNORE_ALL)\n\t\treturn 0;\n\n\tif ((error = git_submodule_lookup(\n\t\t\t&sub, diff->repo, info->nitem->path)) < 0) {\n\n\t\t/* GIT_EEXISTS means dir with .git in it was found - ignore it */\n\t\tif (error == GIT_EEXISTS) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\tif (ign <= 0 && git_submodule_ignore(sub) == GIT_SUBMODULE_IGNORE_ALL)\n\t\t/* ignore it */;\n\telse if ((error = git_submodule__status(\n\t\t\t&sm_status, NULL, NULL, found_oid, sub, ign)) < 0)\n\t\t/* return error below */;\n\n\t/* check IS_WD_UNMODIFIED because this case is only used\n\t * when the new side of the diff is the working directory\n\t */\n\telse if (!GIT_SUBMODULE_STATUS_IS_WD_UNMODIFIED(sm_status))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\t/* now that we have a HEAD OID, check if HEAD moved */\n\telse if ((sm_status & GIT_SUBMODULE_STATUS_IN_WD) != 0 &&\n\t\t!git_oid_equal(&info->oitem->id, found_oid))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\tgit_submodule_free(sub);\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int maybe_modified_submodule(\n\tgit_delta_t *status,\n\tgit_oid *found_oid,\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tint error = 0;\n\tgit_submodule *sub;\n\tunsigned int sm_status = 0;\n\tgit_submodule_ignore_t ign = diff->opts.ignore_submodules;\n\n\t*status = GIT_DELTA_UNMODIFIED;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES) ||\n\t\tign == GIT_SUBMODULE_IGNORE_ALL)\n\t\treturn 0;\n\n\tif ((error = git_submodule_lookup(\n\t\t\t&sub, diff->repo, info->nitem->path)) < 0) {\n\n\t\t/* GIT_EEXISTS means dir with .git in it was found - ignore it */\n\t\tif (error == GIT_EEXISTS) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\tif (ign <= 0 && git_submodule_ignore(sub) == GIT_SUBMODULE_IGNORE_ALL)\n\t\t/* ignore it */;\n\telse if ((error = git_submodule__status(\n\t\t\t&sm_status, NULL, NULL, found_oid, sub, ign)) < 0)\n\t\t/* return error below */;\n\n\t/* check IS_WD_UNMODIFIED because this case is only used\n\t * when the new side of the diff is the working directory\n\t */\n\telse if (!GIT_SUBMODULE_STATUS_IS_WD_UNMODIFIED(sm_status))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\t/* now that we have a HEAD OID, check if HEAD moved */\n\telse if ((sm_status & GIT_SUBMODULE_STATUS_IN_WD) != 0 &&\n\t\t!git_oid_equal(&info->oitem->id, found_oid))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\tgit_submodule_free(sub);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "nmode"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_index",
          "args": [
            "&index",
            "info->new_iter"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2026-2036",
          "snippet": "int git_iterator_index(git_index **out, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\t*out = NULL;\n\n\t*out = wi->index;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_index(git_index **out, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\t*out = NULL;\n\n\t*out = wi->index;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_TYPECHANGE"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MODE_TYPE",
          "args": [
            "nmode"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_MODE_TYPE",
          "args": [
            "omode"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "nitem"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "nmode"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "omode"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&noid",
            "0",
            "sizeof(noid)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_pathspec_match",
          "args": [
            "&matched_pathspec",
            "diff",
            "oitem"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "diff_pathspec_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "77-101",
          "snippet": "static bool diff_pathspec_match(\n\tconst char **matched_pathspec,\n\tgit_diff *diff,\n\tconst git_index_entry *entry)\n{\n\tbool disable_pathspec_match =\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_DISABLE_PATHSPEC_MATCH);\n\n\t/* If we're disabling fnmatch, then the iterator has already applied\n\t * the filters to the files for us and we don't have to do anything.\n\t * However, this only applies to *files* - the iterator will include\n\t * directories that we need to recurse into when not autoexpanding,\n\t * so we still need to apply the pathspec match to directories.\n\t */\n\tif ((S_ISLNK(entry->mode) || S_ISREG(entry->mode)) &&\n\t\tdisable_pathspec_match) {\n\t\t*matched_pathspec = entry->path;\n\t\treturn true;\n\t}\n\n\treturn git_pathspec__match(\n\t\t&diff->pathspec, entry->path, disable_pathspec_match,\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE),\n\t\tmatched_pathspec, NULL);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic bool diff_pathspec_match(\n\tconst char **matched_pathspec,\n\tgit_diff *diff,\n\tconst git_index_entry *entry)\n{\n\tbool disable_pathspec_match =\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_DISABLE_PATHSPEC_MATCH);\n\n\t/* If we're disabling fnmatch, then the iterator has already applied\n\t * the filters to the files for us and we don't have to do anything.\n\t * However, this only applies to *files* - the iterator will include\n\t * directories that we need to recurse into when not autoexpanding,\n\t * so we still need to apply the pathspec match to directories.\n\t */\n\tif ((S_ISLNK(entry->mode) || S_ISREG(entry->mode)) &&\n\t\tdisable_pathspec_match) {\n\t\t*matched_pathspec = entry->path;\n\t\treturn true;\n\t}\n\n\treturn git_pathspec__match(\n\t\t&diff->pathspec, entry->path, disable_pathspec_match,\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE),\n\t\tmatched_pathspec, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\n#define MODE_BITS_MASK 0000777\n\nstatic int maybe_modified(\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tgit_oid noid;\n\tgit_delta_t status = GIT_DELTA_MODIFIED;\n\tconst git_index_entry *oitem = info->oitem;\n\tconst git_index_entry *nitem = info->nitem;\n\tunsigned int omode = oitem->mode;\n\tunsigned int nmode = nitem->mode;\n\tbool new_is_workdir = (info->new_iter->type == GIT_ITERATOR_TYPE_WORKDIR);\n\tbool modified_uncertain = false;\n\tconst char *matched_pathspec;\n\tint error = 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, oitem))\n\t\treturn 0;\n\n\tmemset(&noid, 0, sizeof(noid));\n\n\t/* on platforms with no symlinks, preserve mode of existing symlinks */\n\tif (S_ISLNK(omode) && S_ISREG(nmode) && new_is_workdir &&\n\t\t!(diff->diffcaps & GIT_DIFFCAPS_HAS_SYMLINKS))\n\t\tnmode = omode;\n\n\t/* on platforms with no execmode, just preserve old mode */\n\tif (!(diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) &&\n\t\t(nmode & MODE_BITS_MASK) != (omode & MODE_BITS_MASK) &&\n\t\tnew_is_workdir)\n\t\tnmode = (nmode & ~MODE_BITS_MASK) | (omode & MODE_BITS_MASK);\n\n\t/* if one side is a conflict, mark the whole delta as conflicted */\n\tif (git_index_entry_is_conflict(oitem) ||\n\t\t\tgit_index_entry_is_conflict(nitem)) {\n\t\tstatus = GIT_DELTA_CONFLICTED;\n\n\t/* support \"assume unchanged\" (poorly, b/c we still stat everything) */\n\t} else if ((oitem->flags & GIT_IDXENTRY_VALID) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* support \"skip worktree\" index bit */\n\t} else if ((oitem->flags_extended & GIT_IDXENTRY_SKIP_WORKTREE) != 0) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if basic type of file changed, then split into delete and add */\n\t} else if (GIT_MODE_TYPE(omode) != GIT_MODE_TYPE(nmode)) {\n\t\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE)) {\n\t\t\tstatus = GIT_DELTA_TYPECHANGE;\n\t\t}\n\n\t\telse if (nmode == GIT_FILEMODE_UNREADABLE) {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_UNREADABLE, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t\telse {\n\t\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\t\t\treturn error;\n\t\t}\n\n\t/* if oids and modes match (and are valid), then file is unmodified */\n\t} else if (git_oid_equal(&oitem->id, &nitem->id) &&\n\t\t\t omode == nmode &&\n\t\t\t !git_oid_iszero(&oitem->id)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t/* if we have an unknown OID and a workdir iterator, then check some\n\t * circumstances that can accelerate things or need special handling\n\t */\n\t} else if (git_oid_iszero(&nitem->id) && new_is_workdir) {\n\t\tbool use_ctime = ((diff->diffcaps & GIT_DIFFCAPS_TRUST_CTIME) != 0);\n\t\tgit_index *index;\n\t\tgit_iterator_index(&index, info->new_iter);\n\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\n\t\tif (S_ISGITLINK(nmode)) {\n\t\t\tif ((error = maybe_modified_submodule(&status, &noid, diff, info)) < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\t/* if the stat data looks different, then mark modified - this just\n\t\t * means that the OID will be recalculated below to confirm change\n\t\t */\n\t\telse if (omode != nmode || oitem->file_size != nitem->file_size) {\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain =\n\t\t\t\t(oitem->file_size <= 0 && nitem->file_size > 0);\n\t\t}\n\t\telse if (!git_index_time_eq(&oitem->mtime, &nitem->mtime) ||\n\t\t\t(use_ctime && !git_index_time_eq(&oitem->ctime, &nitem->ctime)) ||\n\t\t\toitem->ino != nitem->ino ||\n\t\t\toitem->uid != nitem->uid ||\n\t\t\toitem->gid != nitem->gid ||\n\t\t\tgit_index_entry_newer_than_index(nitem, index))\n\t\t{\n\t\t\tstatus = GIT_DELTA_MODIFIED;\n\t\t\tmodified_uncertain = true;\n\t\t}\n\n\t/* if mode is GITLINK and submodules are ignored, then skip */\n\t} else if (S_ISGITLINK(nmode) &&\n\t\t\t DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES)) {\n\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* if we got here and decided that the files are modified, but we\n\t * haven't calculated the OID of the new item, then calculate it now\n\t */\n\tif (modified_uncertain && git_oid_iszero(&nitem->id)) {\n\t\tconst git_oid *update_check =\n\t\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) && omode == nmode ?\n\t\t\t&oitem->id : NULL;\n\n\t\tif ((error = git_diff__oid_for_entry(\n\t\t\t\t&noid, diff, nitem, nmode, update_check)) < 0)\n\t\t\treturn error;\n\n\t\t/* if oid matches, then mark unmodified (except submodules, where\n\t\t * the filesystem content may be modified even if the oid still\n\t\t * matches between the index and the workdir HEAD)\n\t\t */\n\t\tif (omode == nmode && !S_ISGITLINK(omode) &&\n\t\t\tgit_oid_equal(&oitem->id, &noid))\n\t\t\tstatus = GIT_DELTA_UNMODIFIED;\n\t}\n\n\t/* If we want case changes, then break this into a delete of the old\n\t * and an add of the new so that consumers can act accordingly (eg,\n\t * checkout will update the case on disk.)\n\t */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE) &&\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_CASECHANGE) &&\n\t\tstrcmp(oitem->path, nitem->path) != 0) {\n\n\t\tif (!(error = diff_delta__from_one(diff, GIT_DELTA_DELETED, oitem, NULL)))\n\t\t\terror = diff_delta__from_one(diff, GIT_DELTA_ADDED, NULL, nitem);\n\n\t\treturn error;\n\t}\n\n\treturn diff_delta__from_two(\n\t\tdiff, status, oitem, omode, nitem, nmode,\n\t\tgit_oid_iszero(&noid) ? NULL : &noid, matched_pathspec);\n}"
  },
  {
    "function_name": "maybe_modified_submodule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "707-754",
    "snippet": "static int maybe_modified_submodule(\n\tgit_delta_t *status,\n\tgit_oid *found_oid,\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tint error = 0;\n\tgit_submodule *sub;\n\tunsigned int sm_status = 0;\n\tgit_submodule_ignore_t ign = diff->opts.ignore_submodules;\n\n\t*status = GIT_DELTA_UNMODIFIED;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES) ||\n\t\tign == GIT_SUBMODULE_IGNORE_ALL)\n\t\treturn 0;\n\n\tif ((error = git_submodule_lookup(\n\t\t\t&sub, diff->repo, info->nitem->path)) < 0) {\n\n\t\t/* GIT_EEXISTS means dir with .git in it was found - ignore it */\n\t\tif (error == GIT_EEXISTS) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\tif (ign <= 0 && git_submodule_ignore(sub) == GIT_SUBMODULE_IGNORE_ALL)\n\t\t/* ignore it */;\n\telse if ((error = git_submodule__status(\n\t\t\t&sm_status, NULL, NULL, found_oid, sub, ign)) < 0)\n\t\t/* return error below */;\n\n\t/* check IS_WD_UNMODIFIED because this case is only used\n\t * when the new side of the diff is the working directory\n\t */\n\telse if (!GIT_SUBMODULE_STATUS_IS_WD_UNMODIFIED(sm_status))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\t/* now that we have a HEAD OID, check if HEAD moved */\n\telse if ((sm_status & GIT_SUBMODULE_STATUS_IN_WD) != 0 &&\n\t\t!git_oid_equal(&info->oitem->id, found_oid))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\tgit_submodule_free(sub);\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sub"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "&info->oitem->id",
            "found_oid"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_SUBMODULE_STATUS_IS_WD_UNMODIFIED",
          "args": [
            "sm_status"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_submodule__status",
          "args": [
            "&sm_status",
            "NULL",
            "NULL",
            "found_oid",
            "sub",
            "ign"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule__status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1473-1531",
          "snippet": "int git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule__status(\n\tunsigned int *out_status,\n\tgit_oid *out_head_id,\n\tgit_oid *out_index_id,\n\tgit_oid *out_wd_id,\n\tgit_submodule *sm,\n\tgit_submodule_ignore_t ign)\n{\n\tunsigned int status;\n\tgit_repository *smrepo = NULL;\n\n\tif (ign == GIT_SUBMODULE_IGNORE_UNSPECIFIED)\n\t\tign = sm->ignore;\n\n\t/* only return location info if ignore == all */\n\tif (ign == GIT_SUBMODULE_IGNORE_ALL) {\n\t\t*out_status = (sm->flags & GIT_SUBMODULE_STATUS__IN_FLAGS);\n\t\treturn 0;\n\t}\n\n\t/* refresh the index OID */\n\tif (submodule_update_index(sm) < 0)\n\t\treturn -1;\n\n\t/* refresh the HEAD OID */\n\tif (submodule_update_head(sm) < 0)\n\t\treturn -1;\n\n\t/* for ignore == dirty, don't scan the working directory */\n\tif (ign == GIT_SUBMODULE_IGNORE_DIRTY) {\n\t\t/* git_submodule_open_bare will load WD OID data */\n\t\tif (git_submodule_open_bare(&smrepo, sm) < 0)\n\t\t\tgiterr_clear();\n\t\telse\n\t\t\tgit_repository_free(smrepo);\n\t\tsmrepo = NULL;\n\t} else if (git_submodule_open(&smrepo, sm) < 0) {\n\t\tgiterr_clear();\n\t\tsmrepo = NULL;\n\t}\n\n\tstatus = GIT_SUBMODULE_STATUS__CLEAR_INTERNAL(sm->flags);\n\n\tsubmodule_get_index_status(&status, sm);\n\tsubmodule_get_wd_status(&status, sm, smrepo, ign);\n\n\tgit_repository_free(smrepo);\n\n\t*out_status = status;\n\n\tsubmodule_copy_oid_maybe(out_head_id, &sm->head_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__HEAD_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_index_id, &sm->index_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__INDEX_OID_VALID) != 0);\n\tsubmodule_copy_oid_maybe(out_wd_id, &sm->wd_oid,\n\t\t(sm->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID) != 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_ignore",
          "args": [
            "sub"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "974-979",
          "snippet": "git_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn (submodule->ignore < GIT_SUBMODULE_IGNORE_NONE) ?\n\t\tGIT_SUBMODULE_IGNORE_NONE : submodule->ignore;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\ngit_submodule_ignore_t git_submodule_ignore(git_submodule *submodule)\n{\n\tassert(submodule);\n\treturn (submodule->ignore < GIT_SUBMODULE_IGNORE_NONE) ?\n\t\tGIT_SUBMODULE_IGNORE_NONE : submodule->ignore;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "&sub",
            "diff->repo",
            "info->nitem->path"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_SUBMODULES"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int maybe_modified_submodule(\n\tgit_delta_t *status,\n\tgit_oid *found_oid,\n\tgit_diff *diff,\n\tdiff_in_progress *info)\n{\n\tint error = 0;\n\tgit_submodule *sub;\n\tunsigned int sm_status = 0;\n\tgit_submodule_ignore_t ign = diff->opts.ignore_submodules;\n\n\t*status = GIT_DELTA_UNMODIFIED;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_SUBMODULES) ||\n\t\tign == GIT_SUBMODULE_IGNORE_ALL)\n\t\treturn 0;\n\n\tif ((error = git_submodule_lookup(\n\t\t\t&sub, diff->repo, info->nitem->path)) < 0) {\n\n\t\t/* GIT_EEXISTS means dir with .git in it was found - ignore it */\n\t\tif (error == GIT_EEXISTS) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\t\treturn error;\n\t}\n\n\tif (ign <= 0 && git_submodule_ignore(sub) == GIT_SUBMODULE_IGNORE_ALL)\n\t\t/* ignore it */;\n\telse if ((error = git_submodule__status(\n\t\t\t&sm_status, NULL, NULL, found_oid, sub, ign)) < 0)\n\t\t/* return error below */;\n\n\t/* check IS_WD_UNMODIFIED because this case is only used\n\t * when the new side of the diff is the working directory\n\t */\n\telse if (!GIT_SUBMODULE_STATUS_IS_WD_UNMODIFIED(sm_status))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\t/* now that we have a HEAD OID, check if HEAD moved */\n\telse if ((sm_status & GIT_SUBMODULE_STATUS_IN_WD) != 0 &&\n\t\t!git_oid_equal(&info->oitem->id, found_oid))\n\t\t*status = GIT_DELTA_MODIFIED;\n\n\tgit_submodule_free(sub);\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff__oid_for_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "606-695",
    "snippet": "int git_diff__oid_for_entry(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst git_index_entry *src,\n\tuint16_t mode,\n\tconst git_oid *update_match)\n{\n\tint error = 0;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tgit_index_entry entry = *src;\n\tgit_filter_list *fl = NULL;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (git_buf_joinpath(\n\t\t&full_path, git_repository_workdir(diff->repo), entry.path) < 0)\n\t\treturn -1;\n\n\tif (!mode) {\n\t\tstruct stat st;\n\n\t\tdiff->perf.stat_calls++;\n\n\t\tif (p_stat(full_path.ptr, &st) < 0) {\n\t\t\terror = git_path_set_error(errno, entry.path, \"stat\");\n\t\t\tgit_buf_free(&full_path);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_index_entry__init_from_stat(\n\t\t\t&entry, &st, (diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0);\n\t}\n\n\t/* calculate OID for file if possible */\n\tif (S_ISGITLINK(mode)) {\n\t\tgit_submodule *sm;\n\n\t\tif (!git_submodule_lookup(&sm, diff->repo, entry.path)) {\n\t\t\tconst git_oid *sm_oid = git_submodule_wd_id(sm);\n\t\t\tif (sm_oid)\n\t\t\t\tgit_oid_cpy(out, sm_oid);\n\t\t\tgit_submodule_free(sm);\n\t\t} else {\n\t\t\t/* if submodule lookup failed probably just in an intermediate\n\t\t\t * state where some init hasn't happened, so ignore the error\n\t\t\t */\n\t\t\tgiterr_clear();\n\t\t}\n\t} else if (S_ISLNK(mode)) {\n\t\terror = git_odb__hashlink(out, full_path.ptr);\n\t\tdiff->perf.oid_calculations++;\n\t} else if (!git__is_sizet(entry.file_size)) {\n\t\tgiterr_set(GITERR_OS, \"File size overflow (for 32-bits) on '%s'\",\n\t\t\tentry.path);\n\t\terror = -1;\n\t} else if (!(error = git_filter_list_load(\n\t\t&fl, diff->repo, NULL, entry.path,\n\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)))\n\t{\n\t\tint fd = git_futils_open_ro(full_path.ptr);\n\t\tif (fd < 0)\n\t\t\terror = fd;\n\t\telse {\n\t\t\terror = git_odb__hashfd_filtered(\n\t\t\t\tout, fd, (size_t)entry.file_size, GIT_OBJ_BLOB, fl);\n\t\t\tp_close(fd);\n\t\t\tdiff->perf.oid_calculations++;\n\t\t}\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\t/* update index for entry if requested */\n\tif (!error && update_match && git_oid_equal(out, update_match)) {\n\t\tgit_index *idx;\n\t\tgit_index_entry updated_entry;\n\n\t\tmemcpy(&updated_entry, &entry, sizeof(git_index_entry));\n\t\tupdated_entry.mode = mode;\n\t\tgit_oid_cpy(&updated_entry.id, out);\n\n\t\tif (!(error = git_repository_index__weakptr(&idx, diff->repo))) {\n\t\t\terror = git_index_add(idx, &updated_entry);\n\t\t\tdiff->index_updated = true;\n\t\t}\n \t}\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&full_path"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_add",
          "args": [
            "idx",
            "&updated_entry"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "1580-1598",
          "snippet": "int git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);",
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_add(git_index *index, const git_index_entry *source_entry)\n{\n\tgit_index_entry *entry = NULL;\n\tint ret;\n\n\tassert(index && source_entry && source_entry->path);\n\n\tif (!valid_filemode(source_entry->mode)) {\n\t\tgiterr_set(GITERR_INDEX, \"invalid filemode\");\n\t\treturn -1;\n\t}\n\n\tif ((ret = index_entry_dup(&entry, index, source_entry)) < 0 ||\n\t\t(ret = index_insert(index, &entry, 1, true, true, false)) < 0)\n\t\treturn ret;\n\n\tgit_tree_cache_invalidate_path(index->tree, entry->path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&idx",
            "diff->repo"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&updated_entry.id",
            "out"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&updated_entry",
            "&entry",
            "sizeof(git_index_entry)"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_equal",
          "args": [
            "out",
            "update_match"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "184-187",
          "snippet": "int git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_equal(const git_oid *a, const git_oid *b)\n{\n\treturn (git_oid__cmp(a, b) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_free",
          "args": [
            "fl"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "589-604",
          "snippet": "void git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nvoid git_filter_list_free(git_filter_list *fl)\n{\n\tuint32_t i;\n\n\tif (!fl)\n\t\treturn;\n\n\tfor (i = 0; i < git_array_size(fl->filters); ++i) {\n\t\tgit_filter_entry *fe = git_array_get(fl->filters, i);\n\t\tif (fe->filter->cleanup)\n\t\t\tfe->filter->cleanup(fe->filter, fe->payload);\n\t}\n\n\tgit_array_clear(fl->filters);\n\tgit__free(fl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_close",
          "args": [
            "fd"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "winhttp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "1359-1377",
          "snippet": "static int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int winhttp_close(git_smart_subtransport *subtransport)\n{\n\twinhttp_subtransport *t = (winhttp_subtransport *)subtransport;\n\n\tgitno_connection_data_free_ptrs(&t->connection_data);\n\tmemset(&t->connection_data, 0x0, sizeof(gitno_connection_data));\n\n\tif (t->cred) {\n\t\tt->cred->free(t->cred);\n\t\tt->cred = NULL;\n\t}\n\n\tif (t->url_cred) {\n\t\tt->url_cred->free(t->url_cred);\n\t\tt->url_cred = NULL;\n\t}\n\n\treturn winhttp_close_connection(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__hashfd_filtered",
          "args": [
            "out",
            "fd",
            "(size_t)entry.file_size",
            "GIT_OBJ_BLOB",
            "fl"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__hashfd_filtered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "190-217",
          "snippet": "int git_odb__hashfd_filtered(\n\tgit_oid *out, git_file fd, size_t size, git_otype type, git_filter_list *fl)\n{\n\tint error;\n\tgit_buf raw = GIT_BUF_INIT;\n\n\tif (!fl)\n\t\treturn git_odb__hashfd(out, fd, size, type);\n\n\t/* size of data is used in header, so we have to read the whole file\n\t * into memory to apply filters before beginning to calculate the hash\n\t */\n\n\tif (!(error = git_futils_readbuffer_fd(&raw, fd, size))) {\n\t\tgit_buf post = GIT_BUF_INIT;\n\n\t\terror = git_filter_list_apply_to_data(&post, fl, &raw);\n\n\t\tgit_buf_free(&raw);\n\n\t\tif (!error)\n\t\t\terror = git_odb_hash(out, post.ptr, post.size, type);\n\n\t\tgit_buf_free(&post);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__hashfd_filtered(\n\tgit_oid *out, git_file fd, size_t size, git_otype type, git_filter_list *fl)\n{\n\tint error;\n\tgit_buf raw = GIT_BUF_INIT;\n\n\tif (!fl)\n\t\treturn git_odb__hashfd(out, fd, size, type);\n\n\t/* size of data is used in header, so we have to read the whole file\n\t * into memory to apply filters before beginning to calculate the hash\n\t */\n\n\tif (!(error = git_futils_readbuffer_fd(&raw, fd, size))) {\n\t\tgit_buf post = GIT_BUF_INIT;\n\n\t\terror = git_filter_list_apply_to_data(&post, fl, &raw);\n\n\t\tgit_buf_free(&raw);\n\n\t\tif (!error)\n\t\t\terror = git_odb_hash(out, post.ptr, post.size, type);\n\n\t\tgit_buf_free(&post);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_open_ro",
          "args": [
            "full_path.ptr"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_open_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "90-96",
          "snippet": "int git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_open_ro(const char *path)\n{\n\tint fd = p_open(path, O_RDONLY);\n\tif (fd < 0)\n\t\treturn git_path_set_error(errno, path, \"open\");\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filter_list_load",
          "args": [
            "&fl",
            "diff->repo",
            "NULL",
            "entry.path",
            "GIT_FILTER_TO_ODB",
            "GIT_FILTER_ALLOW_UNSAFE"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "git_filter_list_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filter.c",
          "lines": "573-587",
          "snippet": "int git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}",
          "includes": [
            "#include \"array.h\"",
            "#include \"attr_file.h\"",
            "#include \"blob.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/sys/filter.h\"",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"array.h\"\n#include \"attr_file.h\"\n#include \"blob.h\"\n#include \"git2/config.h\"\n#include \"git2/sys/filter.h\"\n#include \"global.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_filter_list_load(\n\tgit_filter_list **filters,\n\tgit_repository *repo,\n\tgit_blob *blob, /* can be NULL */\n\tconst char *path,\n\tgit_filter_mode_t mode,\n\tuint32_t flags)\n{\n\tgit_filter_options filter_opts = GIT_FILTER_OPTIONS_INIT;\n\n\tfilter_opts.flags = flags;\n\n\treturn git_filter_list__load_ext(\n\t\tfilters, repo, blob, path, mode, &filter_opts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_OS",
            "\"File size overflow (for 32-bits) on '%s'\"",
            "entry.path"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__is_sizet",
          "args": [
            "entry.file_size"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "git__is_sizet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/integer.h",
          "lines": "11-15",
          "snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "GIT_INLINE(int) git__is_sizet(git_off_t p)\n{\n\tsize_t r = (size_t)p;\n\treturn p == (git_off_t)r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_odb__hashlink",
          "args": [
            "out",
            "full_path.ptr"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "git_odb__hashlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb.c",
          "lines": "219-263",
          "snippet": "int git_odb__hashlink(git_oid *out, const char *path)\n{\n\tstruct stat st;\n\tint size;\n\tint result;\n\n\tif (git_path_lstat(path, &st) < 0)\n\t\treturn -1;\n\n\tif (!git__is_int(st.st_size) || (int)st.st_size < 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"File size overflow for 32-bit systems\");\n\t\treturn -1;\n\t}\n\n\tsize = (int)st.st_size;\n\n\tif (S_ISLNK(st.st_mode)) {\n\t\tchar *link_data;\n\t\tint read_len;\n\t\tsize_t alloc_size;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, size, 1);\n\t\tlink_data = git__malloc(alloc_size);\n\t\tGITERR_CHECK_ALLOC(link_data);\n\n\t\tread_len = p_readlink(path, link_data, size);\n\t\tlink_data[size] = '\\0';\n\t\tif (read_len != size) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to read symlink data for '%s'\", path);\n\t\t\tgit__free(link_data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tresult = git_odb_hash(out, link_data, size, GIT_OBJ_BLOB);\n\t\tgit__free(link_data);\n\t} else {\n\t\tint fd = git_futils_open_ro(path);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\t\tresult = git_odb__hashfd(out, fd, size, GIT_OBJ_BLOB);\n\t\tp_close(fd);\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"git2/oid.h\"",
            "#include \"git2/odb_backend.h\"",
            "#include \"repository.h\"",
            "#include \"filter.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/object.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n#include \"git2/odb_backend.h\"\n#include \"repository.h\"\n#include \"filter.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/object.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nint git_odb__hashlink(git_oid *out, const char *path)\n{\n\tstruct stat st;\n\tint size;\n\tint result;\n\n\tif (git_path_lstat(path, &st) < 0)\n\t\treturn -1;\n\n\tif (!git__is_int(st.st_size) || (int)st.st_size < 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"File size overflow for 32-bit systems\");\n\t\treturn -1;\n\t}\n\n\tsize = (int)st.st_size;\n\n\tif (S_ISLNK(st.st_mode)) {\n\t\tchar *link_data;\n\t\tint read_len;\n\t\tsize_t alloc_size;\n\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_size, size, 1);\n\t\tlink_data = git__malloc(alloc_size);\n\t\tGITERR_CHECK_ALLOC(link_data);\n\n\t\tread_len = p_readlink(path, link_data, size);\n\t\tlink_data[size] = '\\0';\n\t\tif (read_len != size) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to read symlink data for '%s'\", path);\n\t\t\tgit__free(link_data);\n\t\t\treturn -1;\n\t\t}\n\n\t\tresult = git_odb_hash(out, link_data, size, GIT_OBJ_BLOB);\n\t\tgit__free(link_data);\n\t} else {\n\t\tint fd = git_futils_open_ro(path);\n\t\tif (fd < 0)\n\t\t\treturn -1;\n\t\tresult = git_odb__hashfd(out, fd, size, GIT_OBJ_BLOB);\n\t\tp_close(fd);\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_free",
          "args": [
            "sm"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1611-1616",
          "snippet": "void git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nvoid git_submodule_free(git_submodule *sm)\n{\n\tif (!sm)\n\t\treturn;\n\tGIT_REFCOUNT_DEC(sm, submodule_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_wd_id",
          "args": [
            "sm"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_wd_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "953-972",
          "snippet": "const git_oid *git_submodule_wd_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\t/* load unless we think we have a valid oid */\n\tif (!(submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)) {\n\t\tgit_repository *subrepo;\n\n\t\t/* calling submodule open grabs the HEAD OID if possible */\n\t\tif (!git_submodule_open_bare(&subrepo, submodule))\n\t\t\tgit_repository_free(subrepo);\n\t\telse\n\t\t\tgiterr_clear();\n\t}\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)\n\t\treturn &submodule->wd_oid;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nconst git_oid *git_submodule_wd_id(git_submodule *submodule)\n{\n\tassert(submodule);\n\n\t/* load unless we think we have a valid oid */\n\tif (!(submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)) {\n\t\tgit_repository *subrepo;\n\n\t\t/* calling submodule open grabs the HEAD OID if possible */\n\t\tif (!git_submodule_open_bare(&subrepo, submodule))\n\t\t\tgit_repository_free(subrepo);\n\t\telse\n\t\t\tgiterr_clear();\n\t}\n\n\tif (submodule->flags & GIT_SUBMODULE_STATUS__WD_OID_VALID)\n\t\treturn &submodule->wd_oid;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_lookup",
          "args": [
            "&sm",
            "diff->repo",
            "entry.path"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "187-285",
          "snippet": "int git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);",
            "static git_config *gitmodules_snapshot(git_repository *repo);",
            "static int get_url_base(git_buf *url, git_repository *repo);",
            "static int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);",
            "static int submodule_load_from_wd_lite(git_submodule *);",
            "static void submodule_get_index_status(unsigned int *, git_submodule *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic int submodule_alloc(git_submodule **out, git_repository *repo, const char *name);\nstatic git_config *gitmodules_snapshot(git_repository *repo);\nstatic int get_url_base(git_buf *url, git_repository *repo);\nstatic int lookup_head_remote_key(git_buf *remote_key, git_repository *repo);\nstatic int submodule_load_from_wd_lite(git_submodule *);\nstatic void submodule_get_index_status(unsigned int *, git_submodule *);\n\nint git_submodule_lookup(\n\tgit_submodule **out, /* NULL if user only wants to test existence */\n\tgit_repository *repo,\n\tconst char *name)    /* trailing slash is allowed */\n{\n\tint error;\n\tunsigned int location;\n\tgit_submodule *sm;\n\n\tassert(repo && name);\n\n\tif ((error = submodule_alloc(&sm, repo, name)) < 0)\n\t\treturn error;\n\n\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If it's not configured or we're looking by path  */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_config_backend *mods;\n\t\tconst char *pattern = \"submodule\\\\..*\\\\.path\";\n\t\tgit_buf path = GIT_BUF_INIT;\n\t\tfbp_data data = { NULL, NULL };\n\n\t\tgit_buf_puts(&path, name);\n\t\twhile (path.ptr[path.size-1] == '/') {\n\t\t\tpath.ptr[--path.size] = '\\0';\n\t\t}\n\t\tdata.path = path.ptr;\n\n\t\tmods = open_gitmodules(repo, GITMODULES_EXISTING);\n\n\t\tif (mods)\n\t\t\terror = git_config_file_foreach_match(mods, pattern, find_by_path, &data);\n\n\t\tgit_config_file_free(mods);\n\n\t\tif (error < 0) {\n\t\t\tgit_submodule_free(sm);\n\t\t\tgit_buf_free(&path);\n\t\t\treturn error;\n\t\t}\n\n\t\tif (data.name) {\n\t\t\tgit__free(sm->name);\n\t\t\tsm->name = data.name;\n\t\t\tsm->path = git_buf_detach(&path);\n\n\t\t\t/* Try to load again with the right name */\n\t\t\tif ((error = git_submodule_reload(sm, false)) < 0) {\n\t\t\t\tgit_submodule_free(sm);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\n\t\tgit_buf_free(&path);\n\t}\n\n\tif ((error = git_submodule_location(&location, sm)) < 0) {\n\t\tgit_submodule_free(sm);\n\t\treturn error;\n\t}\n\n\t/* If we still haven't found it, do the WD check */\n\tif (location == 0 || location == GIT_SUBMODULE_STATUS_IN_WD) {\n\t\tgit_submodule_free(sm);\n\t\terror = GIT_ENOTFOUND;\n\n\t\t/* If it's not configured, we still check if there's a repo at the path */\n\t\tif (git_repository_workdir(repo)) {\n\t\t\tgit_buf path = GIT_BUF_INIT;\n\t\t\tif (git_buf_join3(&path,\n\t\t\t\t\t  '/', git_repository_workdir(repo), name, DOT_GIT) < 0)\n\t\t\t\treturn -1;\n\n\t\t\tif (git_path_exists(path.ptr))\n\t\t\t\terror = GIT_EEXISTS;\n\n\t\t\tgit_buf_free(&path);\n\t\t}\n\n\t\tsubmodule_set_lookup_error(error, name);\n\t\treturn error;\n\t}\n\n\tif (out)\n\t\t*out = sm;\n\telse\n\t\tgit_submodule_free(sm);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISGITLINK",
          "args": [
            "mode"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_index_entry__init_from_stat",
          "args": [
            "&entry",
            "&st",
            "(diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry__init_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "827-843",
          "snippet": "void git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_set_error",
          "args": [
            "errno",
            "entry.path",
            "\"stat\""
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_set_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "611-632",
          "snippet": "int git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_set_error(int errno_value, const char *path, const char *action)\n{\n\tswitch (errno_value) {\n\tcase ENOENT:\n\tcase ENOTDIR:\n\t\tgiterr_set(GITERR_OS, \"Could not find '%s' to %s\", path, action);\n\t\treturn GIT_ENOTFOUND;\n\n\tcase EINVAL:\n\tcase ENAMETOOLONG:\n\t\tgiterr_set(GITERR_OS, \"Invalid path for filesystem '%s'\", path);\n\t\treturn GIT_EINVALIDSPEC;\n\n\tcase EEXIST:\n\t\tgiterr_set(GITERR_OS, \"Failed %s - '%s' already exists\", action, path);\n\t\treturn GIT_EEXISTS;\n\n\tdefault:\n\t\tgiterr_set(GITERR_OS, \"Could not %s '%s'\", action, path);\n\t\treturn -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "p_stat",
          "args": [
            "full_path.ptr",
            "&st"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "p_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/win32/posix_w32.c",
          "lines": "417-432",
          "snippet": "int p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ws2tcpip.h>",
            "#include <fcntl.h>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include \"buffer.h\"",
            "#include \"global.h\"",
            "#include \"reparse.h\"",
            "#include \"repository.h\"",
            "#include \"utf-conv.h\"",
            "#include \"path_w32.h\"",
            "#include \"path.h\"",
            "#include \"../fileops.h\"",
            "#include \"../posix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ws2tcpip.h>\n#include <fcntl.h>\n#include <io.h>\n#include <errno.h>\n#include \"buffer.h\"\n#include \"global.h\"\n#include \"reparse.h\"\n#include \"repository.h\"\n#include \"utf-conv.h\"\n#include \"path_w32.h\"\n#include \"path.h\"\n#include \"../fileops.h\"\n#include \"../posix.h\"\n\nint p_stat(const char* path, struct stat* buf)\n{\n\tgit_win32_path path_w;\n\tint len;\n\n\tif ((len = git_win32_path_from_utf8(path_w, path)) < 0 ||\n\t\tlstat_w(path_w, buf, false) < 0)\n\t\treturn -1;\n\n\t/* The item is a symbolic link or mount point. No need to iterate\n\t * to follow multiple links; use GetFinalPathNameFromHandle. */\n\tif (S_ISLNK(buf->st_mode))\n\t\treturn follow_and_lstat_link(path_w, buf);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&full_path",
            "git_repository_workdir(diff->repo)",
            "entry.path"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "diff->repo"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "out",
            "0",
            "sizeof(*out)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__oid_for_entry(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst git_index_entry *src,\n\tuint16_t mode,\n\tconst git_oid *update_match)\n{\n\tint error = 0;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tgit_index_entry entry = *src;\n\tgit_filter_list *fl = NULL;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (git_buf_joinpath(\n\t\t&full_path, git_repository_workdir(diff->repo), entry.path) < 0)\n\t\treturn -1;\n\n\tif (!mode) {\n\t\tstruct stat st;\n\n\t\tdiff->perf.stat_calls++;\n\n\t\tif (p_stat(full_path.ptr, &st) < 0) {\n\t\t\terror = git_path_set_error(errno, entry.path, \"stat\");\n\t\t\tgit_buf_free(&full_path);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_index_entry__init_from_stat(\n\t\t\t&entry, &st, (diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0);\n\t}\n\n\t/* calculate OID for file if possible */\n\tif (S_ISGITLINK(mode)) {\n\t\tgit_submodule *sm;\n\n\t\tif (!git_submodule_lookup(&sm, diff->repo, entry.path)) {\n\t\t\tconst git_oid *sm_oid = git_submodule_wd_id(sm);\n\t\t\tif (sm_oid)\n\t\t\t\tgit_oid_cpy(out, sm_oid);\n\t\t\tgit_submodule_free(sm);\n\t\t} else {\n\t\t\t/* if submodule lookup failed probably just in an intermediate\n\t\t\t * state where some init hasn't happened, so ignore the error\n\t\t\t */\n\t\t\tgiterr_clear();\n\t\t}\n\t} else if (S_ISLNK(mode)) {\n\t\terror = git_odb__hashlink(out, full_path.ptr);\n\t\tdiff->perf.oid_calculations++;\n\t} else if (!git__is_sizet(entry.file_size)) {\n\t\tgiterr_set(GITERR_OS, \"File size overflow (for 32-bits) on '%s'\",\n\t\t\tentry.path);\n\t\terror = -1;\n\t} else if (!(error = git_filter_list_load(\n\t\t&fl, diff->repo, NULL, entry.path,\n\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)))\n\t{\n\t\tint fd = git_futils_open_ro(full_path.ptr);\n\t\tif (fd < 0)\n\t\t\terror = fd;\n\t\telse {\n\t\t\terror = git_odb__hashfd_filtered(\n\t\t\t\tout, fd, (size_t)entry.file_size, GIT_OBJ_BLOB, fl);\n\t\t\tp_close(fd);\n\t\t\tdiff->perf.oid_calculations++;\n\t\t}\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\t/* update index for entry if requested */\n\tif (!error && update_match && git_oid_equal(out, update_match)) {\n\t\tgit_index *idx;\n\t\tgit_index_entry updated_entry;\n\n\t\tmemcpy(&updated_entry, &entry, sizeof(git_index_entry));\n\t\tupdated_entry.mode = mode;\n\t\tgit_oid_cpy(&updated_entry.id, out);\n\n\t\tif (!(error = git_repository_index__weakptr(&idx, diff->repo))) {\n\t\t\terror = git_index_add(idx, &updated_entry);\n\t\t\tdiff->index_updated = true;\n\t\t}\n \t}\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}"
  },
  {
    "function_name": "git_diff__oid_for_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "589-604",
    "snippet": "int git_diff__oid_for_file(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst char *path,\n\tuint16_t mode,\n\tgit_off_t size)\n{\n\tgit_index_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.mode = mode;\n\tentry.file_size = size;\n\tentry.path = (char *)path;\n\n\treturn git_diff__oid_for_entry(out, diff, &entry, mode, NULL);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_diff__oid_for_entry",
          "args": [
            "out",
            "diff",
            "&entry",
            "mode",
            "NULL"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff__oid_for_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "606-695",
          "snippet": "int git_diff__oid_for_entry(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst git_index_entry *src,\n\tuint16_t mode,\n\tconst git_oid *update_match)\n{\n\tint error = 0;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tgit_index_entry entry = *src;\n\tgit_filter_list *fl = NULL;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (git_buf_joinpath(\n\t\t&full_path, git_repository_workdir(diff->repo), entry.path) < 0)\n\t\treturn -1;\n\n\tif (!mode) {\n\t\tstruct stat st;\n\n\t\tdiff->perf.stat_calls++;\n\n\t\tif (p_stat(full_path.ptr, &st) < 0) {\n\t\t\terror = git_path_set_error(errno, entry.path, \"stat\");\n\t\t\tgit_buf_free(&full_path);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_index_entry__init_from_stat(\n\t\t\t&entry, &st, (diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0);\n\t}\n\n\t/* calculate OID for file if possible */\n\tif (S_ISGITLINK(mode)) {\n\t\tgit_submodule *sm;\n\n\t\tif (!git_submodule_lookup(&sm, diff->repo, entry.path)) {\n\t\t\tconst git_oid *sm_oid = git_submodule_wd_id(sm);\n\t\t\tif (sm_oid)\n\t\t\t\tgit_oid_cpy(out, sm_oid);\n\t\t\tgit_submodule_free(sm);\n\t\t} else {\n\t\t\t/* if submodule lookup failed probably just in an intermediate\n\t\t\t * state where some init hasn't happened, so ignore the error\n\t\t\t */\n\t\t\tgiterr_clear();\n\t\t}\n\t} else if (S_ISLNK(mode)) {\n\t\terror = git_odb__hashlink(out, full_path.ptr);\n\t\tdiff->perf.oid_calculations++;\n\t} else if (!git__is_sizet(entry.file_size)) {\n\t\tgiterr_set(GITERR_OS, \"File size overflow (for 32-bits) on '%s'\",\n\t\t\tentry.path);\n\t\terror = -1;\n\t} else if (!(error = git_filter_list_load(\n\t\t&fl, diff->repo, NULL, entry.path,\n\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)))\n\t{\n\t\tint fd = git_futils_open_ro(full_path.ptr);\n\t\tif (fd < 0)\n\t\t\terror = fd;\n\t\telse {\n\t\t\terror = git_odb__hashfd_filtered(\n\t\t\t\tout, fd, (size_t)entry.file_size, GIT_OBJ_BLOB, fl);\n\t\t\tp_close(fd);\n\t\t\tdiff->perf.oid_calculations++;\n\t\t}\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\t/* update index for entry if requested */\n\tif (!error && update_match && git_oid_equal(out, update_match)) {\n\t\tgit_index *idx;\n\t\tgit_index_entry updated_entry;\n\n\t\tmemcpy(&updated_entry, &entry, sizeof(git_index_entry));\n\t\tupdated_entry.mode = mode;\n\t\tgit_oid_cpy(&updated_entry.id, out);\n\n\t\tif (!(error = git_repository_index__weakptr(&idx, diff->repo))) {\n\t\t\terror = git_index_add(idx, &updated_entry);\n\t\t\tdiff->index_updated = true;\n\t\t}\n \t}\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__oid_for_entry(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst git_index_entry *src,\n\tuint16_t mode,\n\tconst git_oid *update_match)\n{\n\tint error = 0;\n\tgit_buf full_path = GIT_BUF_INIT;\n\tgit_index_entry entry = *src;\n\tgit_filter_list *fl = NULL;\n\n\tmemset(out, 0, sizeof(*out));\n\n\tif (git_buf_joinpath(\n\t\t&full_path, git_repository_workdir(diff->repo), entry.path) < 0)\n\t\treturn -1;\n\n\tif (!mode) {\n\t\tstruct stat st;\n\n\t\tdiff->perf.stat_calls++;\n\n\t\tif (p_stat(full_path.ptr, &st) < 0) {\n\t\t\terror = git_path_set_error(errno, entry.path, \"stat\");\n\t\t\tgit_buf_free(&full_path);\n\t\t\treturn error;\n\t\t}\n\n\t\tgit_index_entry__init_from_stat(\n\t\t\t&entry, &st, (diff->diffcaps & GIT_DIFFCAPS_TRUST_MODE_BITS) != 0);\n\t}\n\n\t/* calculate OID for file if possible */\n\tif (S_ISGITLINK(mode)) {\n\t\tgit_submodule *sm;\n\n\t\tif (!git_submodule_lookup(&sm, diff->repo, entry.path)) {\n\t\t\tconst git_oid *sm_oid = git_submodule_wd_id(sm);\n\t\t\tif (sm_oid)\n\t\t\t\tgit_oid_cpy(out, sm_oid);\n\t\t\tgit_submodule_free(sm);\n\t\t} else {\n\t\t\t/* if submodule lookup failed probably just in an intermediate\n\t\t\t * state where some init hasn't happened, so ignore the error\n\t\t\t */\n\t\t\tgiterr_clear();\n\t\t}\n\t} else if (S_ISLNK(mode)) {\n\t\terror = git_odb__hashlink(out, full_path.ptr);\n\t\tdiff->perf.oid_calculations++;\n\t} else if (!git__is_sizet(entry.file_size)) {\n\t\tgiterr_set(GITERR_OS, \"File size overflow (for 32-bits) on '%s'\",\n\t\t\tentry.path);\n\t\terror = -1;\n\t} else if (!(error = git_filter_list_load(\n\t\t&fl, diff->repo, NULL, entry.path,\n\t\tGIT_FILTER_TO_ODB, GIT_FILTER_ALLOW_UNSAFE)))\n\t{\n\t\tint fd = git_futils_open_ro(full_path.ptr);\n\t\tif (fd < 0)\n\t\t\terror = fd;\n\t\telse {\n\t\t\terror = git_odb__hashfd_filtered(\n\t\t\t\tout, fd, (size_t)entry.file_size, GIT_OBJ_BLOB, fl);\n\t\t\tp_close(fd);\n\t\t\tdiff->perf.oid_calculations++;\n\t\t}\n\n\t\tgit_filter_list_free(fl);\n\t}\n\n\t/* update index for entry if requested */\n\tif (!error && update_match && git_oid_equal(out, update_match)) {\n\t\tgit_index *idx;\n\t\tgit_index_entry updated_entry;\n\n\t\tmemcpy(&updated_entry, &entry, sizeof(git_index_entry));\n\t\tupdated_entry.mode = mode;\n\t\tgit_oid_cpy(&updated_entry.id, out);\n\n\t\tif (!(error = git_repository_index__weakptr(&idx, diff->repo))) {\n\t\t\terror = git_index_add(idx, &updated_entry);\n\t\t\tdiff->index_updated = true;\n\t\t}\n \t}\n\n\tgit_buf_free(&full_path);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&entry",
            "0",
            "sizeof(entry)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff__oid_for_file(\n\tgit_oid *out,\n\tgit_diff *diff,\n\tconst char *path,\n\tuint16_t mode,\n\tgit_off_t size)\n{\n\tgit_index_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.mode = mode;\n\tentry.file_size = size;\n\tentry.path = (char *)path;\n\n\treturn git_diff__oid_for_entry(out, diff, &entry, mode, NULL);\n}"
  },
  {
    "function_name": "git_diff_addref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "584-587",
    "snippet": "void git_diff_addref(git_diff *diff)\n{\n\tGIT_REFCOUNT_INC(diff);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "diff"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_addref(git_diff *diff)\n{\n\tGIT_REFCOUNT_INC(diff);\n}"
  },
  {
    "function_name": "git_diff_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "576-582",
    "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_DEC",
          "args": [
            "diff",
            "diff_list_free"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
  },
  {
    "function_name": "diff_list_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "565-574",
    "snippet": "static void diff_list_free(git_diff *diff)\n{\n\tgit_vector_free_deep(&diff->deltas);\n\n\tgit_pathspec__vfree(&diff->pathspec);\n\tgit_pool_clear(&diff->pool);\n\n\tgit__memzero(diff, sizeof(*diff));\n\tgit__free(diff);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "diff"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__memzero",
          "args": [
            "diff",
            "sizeof(*diff)"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "git__memzero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "521-531",
          "snippet": "GIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__memzero(void *data, size_t size)\n{\n#ifdef _MSC_VER\n\tSecureZeroMemory((PVOID)data, size);\n#else\n\tvolatile uint8_t *scan = (volatile uint8_t *)data;\n\n\twhile (size--)\n\t\t*scan++ = 0x0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&diff->pool"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pathspec__vfree",
          "args": [
            "&diff->pathspec"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__vfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "106-109",
          "snippet": "void git_pathspec__vfree(git_vector *vspec)\n{\n\tgit_vector_free_deep(vspec);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nvoid git_pathspec__vfree(git_vector *vspec)\n{\n\tgit_vector_free_deep(vspec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&diff->deltas"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic void diff_list_free(git_diff *diff)\n{\n\tgit_vector_free_deep(&diff->deltas);\n\n\tgit_pathspec__vfree(&diff->pathspec);\n\tgit_pool_clear(&diff->pool);\n\n\tgit__memzero(diff, sizeof(*diff));\n\tgit__free(diff);\n}"
  },
  {
    "function_name": "diff_list_apply_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "450-563",
    "snippet": "static int diff_list_apply_options(\n\tgit_diff *diff,\n\tconst git_diff_options *opts)\n{\n\tgit_config *cfg = NULL;\n\tgit_repository *repo = diff->repo;\n\tgit_pool *pool = &diff->pool;\n\tint val;\n\n\tif (opts) {\n\t\t/* copy user options (except case sensitivity info from iterators) */\n\t\tbool icase = DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE);\n\t\tmemcpy(&diff->opts, opts, sizeof(diff->opts));\n\t\tDIFF_FLAG_SET(diff, GIT_DIFF_IGNORE_CASE, icase);\n\n\t\t/* initialize pathspec from options */\n\t\tif (git_pathspec__vinit(&diff->pathspec, &opts->pathspec, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* flag INCLUDE_TYPECHANGE_TREES implies INCLUDE_TYPECHANGE */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE;\n\n\t/* flag INCLUDE_UNTRACKED_CONTENT implies INCLUDE_UNTRACKED */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_SHOW_UNTRACKED_CONTENT))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* load config values that affect diff behavior */\n\tif ((val = git_repository_config_snapshot(&cfg, repo)) < 0)\n\t\treturn val;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_SYMLINKS) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_HAS_SYMLINKS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_IGNORESTAT) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_IGNORE_STAT;\n\n\tif ((diff->opts.flags & GIT_DIFF_IGNORE_FILEMODE) == 0 &&\n\t\t!git_config__cvar(&val, cfg, GIT_CVAR_FILEMODE) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_MODE_BITS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_TRUSTCTIME) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_CTIME;\n\n\t/* Don't set GIT_DIFFCAPS_USE_DEV - compile time option in core git */\n\n\t/* If not given explicit `opts`, check `diff.xyz` configs */\n\tif (!opts) {\n\t\tint context = git_config__get_int_force(cfg, \"diff.context\", 3);\n\t\tdiff->opts.context_lines = context >= 0 ? (uint32_t)context : 3;\n\n\t\t/* add other defaults here */\n\t}\n\n\t/* Reverse src info if diff is reversed */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tgit_iterator_type_t tmp_src = diff->old_src;\n\t\tdiff->old_src = diff->new_src;\n\t\tdiff->new_src = tmp_src;\n\t}\n\n\t/* Unset UPDATE_INDEX unless diffing workdir and index */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) &&\n\t\t(!(diff->old_src == GIT_ITERATOR_TYPE_WORKDIR ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ||\n\t\t !(diff->old_src == GIT_ITERATOR_TYPE_INDEX ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_INDEX)))\n\t\tdiff->opts.flags &= ~GIT_DIFF_UPDATE_INDEX;\n\n\t/* if ignore_submodules not explicitly set, check diff config */\n\tif (diff->opts.ignore_submodules <= 0) {\n\t\t git_config_entry *entry;\n\t\tgit_config__lookup_entry(&entry, cfg, \"diff.ignoresubmodules\", true);\n\n\t\tif (entry && git_submodule_parse_ignore(\n\t\t\t\t&diff->opts.ignore_submodules, entry->value) < 0)\n\t\t\tgiterr_clear();\n\t\tgit_config_entry_free(entry);\n\t}\n\n\t/* if either prefix is not set, figure out appropriate value */\n\tif (!diff->opts.old_prefix || !diff->opts.new_prefix) {\n\t\tconst char *use_old = DIFF_OLD_PREFIX_DEFAULT;\n\t\tconst char *use_new = DIFF_NEW_PREFIX_DEFAULT;\n\n\t\tif (git_config__get_bool_force(cfg, \"diff.noprefix\", 0))\n\t\t\tuse_old = use_new = \"\";\n\t\telse if (git_config__get_bool_force(cfg, \"diff.mnemonicprefix\", 0)) {\n\t\t\tuse_old = diff_mnemonic_prefix(diff->old_src, true);\n\t\t\tuse_new = diff_mnemonic_prefix(diff->new_src, false);\n\t\t}\n\n\t\tif (!diff->opts.old_prefix)\n\t\t\tdiff->opts.old_prefix = use_old;\n\t\tif (!diff->opts.new_prefix)\n\t\t\tdiff->opts.new_prefix = use_new;\n\t}\n\n\t/* strdup prefix from pool so we're not dependent on external data */\n\tdiff->opts.old_prefix = diff_strdup_prefix(pool, diff->opts.old_prefix);\n\tdiff->opts.new_prefix = diff_strdup_prefix(pool, diff->opts.new_prefix);\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tconst char *tmp_prefix = diff->opts.old_prefix;\n\t\tdiff->opts.old_prefix  = diff->opts.new_prefix;\n\t\tdiff->opts.new_prefix  = tmp_prefix;\n\t}\n\n\tgit_config_free(cfg);\n\n\t/* check strdup results for error */\n\treturn (!diff->opts.old_prefix || !diff->opts.new_prefix) ? -1 : 0;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_config_free",
          "args": [
            "cfg"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "63-69",
          "snippet": "void git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_free(git_config *cfg)\n{\n\tif (cfg == NULL)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(cfg, config_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_REVERSE"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_strdup_prefix",
          "args": [
            "pool",
            "diff->opts.new_prefix"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "diff_strdup_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "265-274",
          "snippet": "static char *diff_strdup_prefix(git_pool *pool, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\n\t/* append '/' at end if needed */\n\tif (len > 0 && prefix[len - 1] != '/')\n\t\treturn git_pool_strcat(pool, prefix, \"/\");\n\telse\n\t\treturn git_pool_strndup(pool, prefix, len + 1);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic char *diff_strdup_prefix(git_pool *pool, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\n\t/* append '/' at end if needed */\n\tif (len > 0 && prefix[len - 1] != '/')\n\t\treturn git_pool_strcat(pool, prefix, \"/\");\n\telse\n\t\treturn git_pool_strndup(pool, prefix, len + 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_mnemonic_prefix",
          "args": [
            "diff->new_src",
            "false"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "diff_mnemonic_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "353-372",
          "snippet": "static const char *diff_mnemonic_prefix(\n\tgit_iterator_type_t type, bool left_side)\n{\n\tconst char *pfx = \"\";\n\n\tswitch (type) {\n\tcase GIT_ITERATOR_TYPE_EMPTY:   pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_TREE:    pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_INDEX:   pfx = \"i\"; break;\n\tcase GIT_ITERATOR_TYPE_WORKDIR: pfx = \"w\"; break;\n\tcase GIT_ITERATOR_TYPE_FS:      pfx = left_side ? \"1\" : \"2\"; break;\n\tdefault: break;\n\t}\n\n\t/* note: without a deeper look at pathspecs, there is no easy way\n\t * to get the (o)bject / (w)ork tree mnemonics working...\n\t */\n\n\treturn pfx;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic const char *diff_mnemonic_prefix(\n\tgit_iterator_type_t type, bool left_side)\n{\n\tconst char *pfx = \"\";\n\n\tswitch (type) {\n\tcase GIT_ITERATOR_TYPE_EMPTY:   pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_TREE:    pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_INDEX:   pfx = \"i\"; break;\n\tcase GIT_ITERATOR_TYPE_WORKDIR: pfx = \"w\"; break;\n\tcase GIT_ITERATOR_TYPE_FS:      pfx = left_side ? \"1\" : \"2\"; break;\n\tdefault: break;\n\t}\n\n\t/* note: without a deeper look at pathspecs, there is no easy way\n\t * to get the (o)bject / (w)ork tree mnemonics working...\n\t */\n\n\treturn pfx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__get_bool_force",
          "args": [
            "cfg",
            "\"diff.mnemonicprefix\"",
            "0"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__get_bool_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "890-903",
          "snippet": "int git_config__get_bool_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint val = fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_bool(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn val;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__get_bool_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint val = fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_bool(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config_entry_free",
          "args": [
            "entry"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "git_config_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "23-29",
          "snippet": "void git_config_entry_free(git_config_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->free(entry);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nvoid git_config_entry_free(git_config_entry *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tentry->free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_submodule_parse_ignore",
          "args": [
            "&diff->opts.ignore_submodules",
            "entry->value"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "git_submodule_parse_ignore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/submodule.c",
          "lines": "1625-1637",
          "snippet": "int git_submodule_parse_ignore(git_submodule_ignore_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_IGNORE_NONE;\n\t\treturn submodule_config_error(\"ignore\", value);\n\t}\n\n\t*out = (git_submodule_ignore_t)val;\n\treturn 0;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"path.h\"",
            "#include \"iterator.h\"",
            "#include \"tree.h\"",
            "#include \"submodule.h\"",
            "#include \"repository.h\"",
            "#include \"config.h\"",
            "#include \"config_file.h\"",
            "#include \"posix.h\"",
            "#include \"vector.h\"",
            "#include \"buf_text.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/index.h\"",
            "#include \"git2/types.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};",
            "static void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"path.h\"\n#include \"iterator.h\"\n#include \"tree.h\"\n#include \"submodule.h\"\n#include \"repository.h\"\n#include \"config.h\"\n#include \"config_file.h\"\n#include \"posix.h\"\n#include \"vector.h\"\n#include \"buf_text.h\"\n#include \"buffer.h\"\n#include \"git2/index.h\"\n#include \"git2/types.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"common.h\"\n\nstatic git_cvar_map _sm_ignore_map[] = {\n\t{GIT_CVAR_STRING, \"none\", GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_STRING, \"untracked\", GIT_SUBMODULE_IGNORE_UNTRACKED},\n\t{GIT_CVAR_STRING, \"dirty\", GIT_SUBMODULE_IGNORE_DIRTY},\n\t{GIT_CVAR_STRING, \"all\", GIT_SUBMODULE_IGNORE_ALL},\n\t{GIT_CVAR_FALSE, NULL, GIT_SUBMODULE_IGNORE_NONE},\n\t{GIT_CVAR_TRUE, NULL, GIT_SUBMODULE_IGNORE_ALL},\n};\nstatic void submodule_get_wd_status(unsigned int *, git_submodule *, git_repository *, git_submodule_ignore_t);\n\nint git_submodule_parse_ignore(git_submodule_ignore_t *out, const char *value)\n{\n\tint val;\n\n\tif (git_config_lookup_map_value(\n\t\t\t&val, _sm_ignore_map, ARRAY_SIZE(_sm_ignore_map), value) < 0) {\n\t\t*out = GIT_SUBMODULE_IGNORE_NONE;\n\t\treturn submodule_config_error(\"ignore\", value);\n\t}\n\n\t*out = (git_submodule_ignore_t)val;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__lookup_entry",
          "args": [
            "&entry",
            "cfg",
            "\"diff.ignoresubmodules\"",
            "true"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__lookup_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "737-745",
          "snippet": "int git_config__lookup_entry(\n\tgit_config_entry **out,\n\tconst git_config *cfg,\n\tconst char *key,\n\tbool no_errors)\n{\n\treturn get_entry(\n\t\tout, cfg, key, false, no_errors ? GET_NO_ERRORS : GET_NO_MISSING);\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__lookup_entry(\n\tgit_config_entry **out,\n\tconst git_config *cfg,\n\tconst char *key,\n\tbool no_errors)\n{\n\treturn get_entry(\n\t\tout, cfg, key, false, no_errors ? GET_NO_ERRORS : GET_NO_MISSING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_UPDATE_INDEX"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_REVERSE"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_config__get_int_force",
          "args": [
            "cfg",
            "\"diff.context\"",
            "3"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__get_int_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config.c",
          "lines": "905-918",
          "snippet": "int git_config__get_int_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint32_t val = (int32_t)fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_int32(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn (int)val;\n}",
          "includes": [
            "#include <ctype.h>",
            "# include <windows.h>",
            "#include \"transaction.h\"",
            "#include \"config_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"vector.h\"",
            "#include \"git2/sys/config.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"sysdir.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n# include <windows.h>\n#include \"transaction.h\"\n#include \"config_file.h\"\n#include \"buf_text.h\"\n#include \"vector.h\"\n#include \"git2/sys/config.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"sysdir.h\"\n#include \"common.h\"\n\nint git_config__get_int_force(\n\tconst git_config *cfg, const char *key, int fallback_value)\n{\n\tint32_t val = (int32_t)fallback_value;\n\tgit_config_entry *entry;\n\n\tget_entry(&entry, cfg, key, false, GET_NO_ERRORS);\n\n\tif (entry && git_config_parse_int32(&val, entry->value) < 0)\n\t\tgiterr_clear();\n\n\tgit_config_entry_free(entry);\n\treturn (int)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_config__cvar",
          "args": [
            "&val",
            "cfg",
            "GIT_CVAR_TRUSTCTIME"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "git_config__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "83-102",
          "snippet": "int git_config__cvar(int *out, git_config *config, git_cvar_cached cvar)\n{\n\tint error = 0;\n\tstruct map_data *data = &_cvar_maps[(int)cvar];\n\tgit_config_entry *entry;\n\n\tif ((error = git_config__lookup_entry(&entry, config, data->cvar_name, false)) < 0)\n\t\treturn error;\n\n\tif (!entry)\n\t\t*out = data->default_value;\n\telse if (data->maps)\n\t\terror = git_config_lookup_map_value(\n\t\t\tout, data->maps, data->map_count, entry->value);\n\telse\n\t\terror = git_config_parse_bool(out, entry->value);\n\n\tgit_config_entry_free(entry);\n\treturn error;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct map_data _cvar_maps[] = {\n\t{\"core.autocrlf\", _cvar_map_autocrlf, ARRAY_SIZE(_cvar_map_autocrlf), GIT_AUTO_CRLF_DEFAULT},\n\t{\"core.eol\", _cvar_map_eol, ARRAY_SIZE(_cvar_map_eol), GIT_EOL_DEFAULT},\n\t{\"core.symlinks\", NULL, 0, GIT_SYMLINKS_DEFAULT },\n\t{\"core.ignorecase\", NULL, 0, GIT_IGNORECASE_DEFAULT },\n\t{\"core.filemode\", NULL, 0, GIT_FILEMODE_DEFAULT },\n\t{\"core.ignorestat\", NULL, 0, GIT_IGNORESTAT_DEFAULT },\n\t{\"core.trustctime\", NULL, 0, GIT_TRUSTCTIME_DEFAULT },\n\t{\"core.abbrev\", _cvar_map_int, 1, GIT_ABBREV_DEFAULT },\n\t{\"core.precomposeunicode\", NULL, 0, GIT_PRECOMPOSE_DEFAULT },\n\t{\"core.safecrlf\", _cvar_map_safecrlf, ARRAY_SIZE(_cvar_map_safecrlf), GIT_SAFE_CRLF_DEFAULT},\n\t{\"core.logallrefupdates\", NULL, 0, GIT_LOGALLREFUPDATES_DEFAULT },\n\t{\"core.protecthfs\", NULL, 0, GIT_PROTECTHFS_DEFAULT },\n\t{\"core.protectntfs\", NULL, 0, GIT_PROTECTNTFS_DEFAULT },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nstatic struct map_data _cvar_maps[] = {\n\t{\"core.autocrlf\", _cvar_map_autocrlf, ARRAY_SIZE(_cvar_map_autocrlf), GIT_AUTO_CRLF_DEFAULT},\n\t{\"core.eol\", _cvar_map_eol, ARRAY_SIZE(_cvar_map_eol), GIT_EOL_DEFAULT},\n\t{\"core.symlinks\", NULL, 0, GIT_SYMLINKS_DEFAULT },\n\t{\"core.ignorecase\", NULL, 0, GIT_IGNORECASE_DEFAULT },\n\t{\"core.filemode\", NULL, 0, GIT_FILEMODE_DEFAULT },\n\t{\"core.ignorestat\", NULL, 0, GIT_IGNORESTAT_DEFAULT },\n\t{\"core.trustctime\", NULL, 0, GIT_TRUSTCTIME_DEFAULT },\n\t{\"core.abbrev\", _cvar_map_int, 1, GIT_ABBREV_DEFAULT },\n\t{\"core.precomposeunicode\", NULL, 0, GIT_PRECOMPOSE_DEFAULT },\n\t{\"core.safecrlf\", _cvar_map_safecrlf, ARRAY_SIZE(_cvar_map_safecrlf), GIT_SAFE_CRLF_DEFAULT},\n\t{\"core.logallrefupdates\", NULL, 0, GIT_LOGALLREFUPDATES_DEFAULT },\n\t{\"core.protecthfs\", NULL, 0, GIT_PROTECTHFS_DEFAULT },\n\t{\"core.protectntfs\", NULL, 0, GIT_PROTECTNTFS_DEFAULT },\n};\n\nint git_config__cvar(int *out, git_config *config, git_cvar_cached cvar)\n{\n\tint error = 0;\n\tstruct map_data *data = &_cvar_maps[(int)cvar];\n\tgit_config_entry *entry;\n\n\tif ((error = git_config__lookup_entry(&entry, config, data->cvar_name, false)) < 0)\n\t\treturn error;\n\n\tif (!entry)\n\t\t*out = data->default_value;\n\telse if (data->maps)\n\t\terror = git_config_lookup_map_value(\n\t\t\tout, data->maps, data->map_count, entry->value);\n\telse\n\t\terror = git_config_parse_bool(out, entry->value);\n\n\tgit_config_entry_free(entry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_config_snapshot",
          "args": [
            "&cfg",
            "repo"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_config_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "716-725",
          "snippet": "int git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_config_snapshot(git_config **out, git_repository *repo)\n{\n\tint error;\n\tgit_config *weak;\n\n\tif ((error = git_repository_config__weakptr(&weak, repo)) < 0)\n\t\treturn error;\n\n\treturn git_config_snapshot(out, weak);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_SHOW_UNTRACKED_CONTENT"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_TYPECHANGE_TREES"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pathspec__vinit",
          "args": [
            "&diff->pathspec",
            "&opts->pathspec",
            "pool"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__vinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "66-103",
          "snippet": "int git_pathspec__vinit(\n\tgit_vector *vspec, const git_strarray *strspec, git_pool *strpool)\n{\n\tsize_t i;\n\n\tmemset(vspec, 0, sizeof(*vspec));\n\n\tif (git_pathspec_is_empty(strspec))\n\t\treturn 0;\n\n\tif (git_vector_init(vspec, strspec->count, NULL) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < strspec->count; ++i) {\n\t\tint ret;\n\t\tconst char *pattern = strspec->strings[i];\n\t\tgit_attr_fnmatch *match = git__calloc(1, sizeof(git_attr_fnmatch));\n\t\tif (!match)\n\t\t\treturn -1;\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE |\n\t\t\tGIT_ATTR_FNMATCH_ALLOWNEG | GIT_ATTR_FNMATCH_NOLEADINGDIR;\n\n\t\tret = git_attr_fnmatch__parse(match, strpool, NULL, &pattern);\n\t\tif (ret == GIT_ENOTFOUND) {\n\t\t\tgit__free(match);\n\t\t\tcontinue;\n\t\t} else if (ret < 0) {\n\t\t\tgit__free(match);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (git_vector_insert(vspec, match) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nint git_pathspec__vinit(\n\tgit_vector *vspec, const git_strarray *strspec, git_pool *strpool)\n{\n\tsize_t i;\n\n\tmemset(vspec, 0, sizeof(*vspec));\n\n\tif (git_pathspec_is_empty(strspec))\n\t\treturn 0;\n\n\tif (git_vector_init(vspec, strspec->count, NULL) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < strspec->count; ++i) {\n\t\tint ret;\n\t\tconst char *pattern = strspec->strings[i];\n\t\tgit_attr_fnmatch *match = git__calloc(1, sizeof(git_attr_fnmatch));\n\t\tif (!match)\n\t\t\treturn -1;\n\n\t\tmatch->flags = GIT_ATTR_FNMATCH_ALLOWSPACE |\n\t\t\tGIT_ATTR_FNMATCH_ALLOWNEG | GIT_ATTR_FNMATCH_NOLEADINGDIR;\n\n\t\tret = git_attr_fnmatch__parse(match, strpool, NULL, &pattern);\n\t\tif (ret == GIT_ENOTFOUND) {\n\t\t\tgit__free(match);\n\t\t\tcontinue;\n\t\t} else if (ret < 0) {\n\t\t\tgit__free(match);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (git_vector_insert(vspec, match) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_CASE",
            "icase"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&diff->opts",
            "opts",
            "sizeof(diff->opts)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_CASE"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_list_apply_options(\n\tgit_diff *diff,\n\tconst git_diff_options *opts)\n{\n\tgit_config *cfg = NULL;\n\tgit_repository *repo = diff->repo;\n\tgit_pool *pool = &diff->pool;\n\tint val;\n\n\tif (opts) {\n\t\t/* copy user options (except case sensitivity info from iterators) */\n\t\tbool icase = DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE);\n\t\tmemcpy(&diff->opts, opts, sizeof(diff->opts));\n\t\tDIFF_FLAG_SET(diff, GIT_DIFF_IGNORE_CASE, icase);\n\n\t\t/* initialize pathspec from options */\n\t\tif (git_pathspec__vinit(&diff->pathspec, &opts->pathspec, pool) < 0)\n\t\t\treturn -1;\n\t}\n\n\t/* flag INCLUDE_TYPECHANGE_TREES implies INCLUDE_TYPECHANGE */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_INCLUDE_TYPECHANGE_TREES))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_TYPECHANGE;\n\n\t/* flag INCLUDE_UNTRACKED_CONTENT implies INCLUDE_UNTRACKED */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_SHOW_UNTRACKED_CONTENT))\n\t\tdiff->opts.flags |= GIT_DIFF_INCLUDE_UNTRACKED;\n\n\t/* load config values that affect diff behavior */\n\tif ((val = git_repository_config_snapshot(&cfg, repo)) < 0)\n\t\treturn val;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_SYMLINKS) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_HAS_SYMLINKS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_IGNORESTAT) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_IGNORE_STAT;\n\n\tif ((diff->opts.flags & GIT_DIFF_IGNORE_FILEMODE) == 0 &&\n\t\t!git_config__cvar(&val, cfg, GIT_CVAR_FILEMODE) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_MODE_BITS;\n\n\tif (!git_config__cvar(&val, cfg, GIT_CVAR_TRUSTCTIME) && val)\n\t\tdiff->diffcaps = diff->diffcaps | GIT_DIFFCAPS_TRUST_CTIME;\n\n\t/* Don't set GIT_DIFFCAPS_USE_DEV - compile time option in core git */\n\n\t/* If not given explicit `opts`, check `diff.xyz` configs */\n\tif (!opts) {\n\t\tint context = git_config__get_int_force(cfg, \"diff.context\", 3);\n\t\tdiff->opts.context_lines = context >= 0 ? (uint32_t)context : 3;\n\n\t\t/* add other defaults here */\n\t}\n\n\t/* Reverse src info if diff is reversed */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tgit_iterator_type_t tmp_src = diff->old_src;\n\t\tdiff->old_src = diff->new_src;\n\t\tdiff->new_src = tmp_src;\n\t}\n\n\t/* Unset UPDATE_INDEX unless diffing workdir and index */\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_UPDATE_INDEX) &&\n\t\t(!(diff->old_src == GIT_ITERATOR_TYPE_WORKDIR ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_WORKDIR) ||\n\t\t !(diff->old_src == GIT_ITERATOR_TYPE_INDEX ||\n\t\t   diff->new_src == GIT_ITERATOR_TYPE_INDEX)))\n\t\tdiff->opts.flags &= ~GIT_DIFF_UPDATE_INDEX;\n\n\t/* if ignore_submodules not explicitly set, check diff config */\n\tif (diff->opts.ignore_submodules <= 0) {\n\t\t git_config_entry *entry;\n\t\tgit_config__lookup_entry(&entry, cfg, \"diff.ignoresubmodules\", true);\n\n\t\tif (entry && git_submodule_parse_ignore(\n\t\t\t\t&diff->opts.ignore_submodules, entry->value) < 0)\n\t\t\tgiterr_clear();\n\t\tgit_config_entry_free(entry);\n\t}\n\n\t/* if either prefix is not set, figure out appropriate value */\n\tif (!diff->opts.old_prefix || !diff->opts.new_prefix) {\n\t\tconst char *use_old = DIFF_OLD_PREFIX_DEFAULT;\n\t\tconst char *use_new = DIFF_NEW_PREFIX_DEFAULT;\n\n\t\tif (git_config__get_bool_force(cfg, \"diff.noprefix\", 0))\n\t\t\tuse_old = use_new = \"\";\n\t\telse if (git_config__get_bool_force(cfg, \"diff.mnemonicprefix\", 0)) {\n\t\t\tuse_old = diff_mnemonic_prefix(diff->old_src, true);\n\t\t\tuse_new = diff_mnemonic_prefix(diff->new_src, false);\n\t\t}\n\n\t\tif (!diff->opts.old_prefix)\n\t\t\tdiff->opts.old_prefix = use_old;\n\t\tif (!diff->opts.new_prefix)\n\t\t\tdiff->opts.new_prefix = use_new;\n\t}\n\n\t/* strdup prefix from pool so we're not dependent on external data */\n\tdiff->opts.old_prefix = diff_strdup_prefix(pool, diff->opts.old_prefix);\n\tdiff->opts.new_prefix = diff_strdup_prefix(pool, diff->opts.new_prefix);\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tconst char *tmp_prefix = diff->opts.old_prefix;\n\t\tdiff->opts.old_prefix  = diff->opts.new_prefix;\n\t\tdiff->opts.new_prefix  = tmp_prefix;\n\t}\n\n\tgit_config_free(cfg);\n\n\t/* check strdup results for error */\n\treturn (!diff->opts.old_prefix || !diff->opts.new_prefix) ? -1 : 0;\n}"
  },
  {
    "function_name": "diff_list_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "415-448",
    "snippet": "static git_diff *diff_list_alloc(\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter)\n{\n\tgit_diff_options dflt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = git__calloc(1, sizeof(git_diff));\n\tif (!diff)\n\t\treturn NULL;\n\n\tassert(repo && old_iter && new_iter);\n\n\tGIT_REFCOUNT_INC(diff);\n\tdiff->repo = repo;\n\tdiff->old_src = old_iter->type;\n\tdiff->new_src = new_iter->type;\n\tmemcpy(&diff->opts, &dflt, sizeof(diff->opts));\n\n\tgit_pool_init(&diff->pool, 1);\n\n\tif (git_vector_init(&diff->deltas, 0, git_diff_delta__cmp) < 0) {\n\t\tgit_diff_free(diff);\n\t\treturn NULL;\n\t}\n\n\t/* Use case-insensitive compare if either iterator has\n\t * the ignore_case bit set */\n\tdiff_set_ignore_case(\n\t\tdiff,\n\t\tgit_iterator_ignore_case(old_iter) ||\n\t\tgit_iterator_ignore_case(new_iter));\n\n\treturn diff;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_set_ignore_case",
          "args": [
            "diff",
            "git_iterator_ignore_case(old_iter) ||\n\t\tgit_iterator_ignore_case(new_iter)"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "diff_set_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "390-413",
          "snippet": "static void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_ignore_case",
          "args": [
            "new_iter"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "248-251",
          "snippet": "GIT_INLINE(bool) git_iterator_ignore_case(git_iterator *iter)\n{\n\treturn ((iter->flags & GIT_ITERATOR_IGNORE_CASE) != 0);\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(bool) git_iterator_ignore_case(git_iterator *iter)\n{\n\treturn ((iter->flags & GIT_ITERATOR_IGNORE_CASE) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_diff_free",
          "args": [
            "diff"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "576-582",
          "snippet": "void git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nvoid git_diff_free(git_diff *diff)\n{\n\tif (!diff)\n\t\treturn;\n\n\tGIT_REFCOUNT_DEC(diff, diff_list_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&diff->deltas",
            "0",
            "git_diff_delta__cmp"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&diff->pool",
            "1"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&diff->opts",
            "&dflt",
            "sizeof(diff->opts)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_REFCOUNT_INC",
          "args": [
            "diff"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && old_iter && new_iter"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_diff)"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff *diff_list_alloc(\n\tgit_repository *repo,\n\tgit_iterator *old_iter,\n\tgit_iterator *new_iter)\n{\n\tgit_diff_options dflt = GIT_DIFF_OPTIONS_INIT;\n\tgit_diff *diff = git__calloc(1, sizeof(git_diff));\n\tif (!diff)\n\t\treturn NULL;\n\n\tassert(repo && old_iter && new_iter);\n\n\tGIT_REFCOUNT_INC(diff);\n\tdiff->repo = repo;\n\tdiff->old_src = old_iter->type;\n\tdiff->new_src = new_iter->type;\n\tmemcpy(&diff->opts, &dflt, sizeof(diff->opts));\n\n\tgit_pool_init(&diff->pool, 1);\n\n\tif (git_vector_init(&diff->deltas, 0, git_diff_delta__cmp) < 0) {\n\t\tgit_diff_free(diff);\n\t\treturn NULL;\n\t}\n\n\t/* Use case-insensitive compare if either iterator has\n\t * the ignore_case bit set */\n\tdiff_set_ignore_case(\n\t\tdiff,\n\t\tgit_iterator_ignore_case(old_iter) ||\n\t\tgit_iterator_ignore_case(new_iter));\n\n\treturn diff;\n}"
  },
  {
    "function_name": "diff_set_ignore_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "390-413",
    "snippet": "static void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&diff->deltas"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&diff->deltas",
            "git_diff_delta__casecmp"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic void diff_set_ignore_case(git_diff *diff, bool ignore_case)\n{\n\tif (!ignore_case) {\n\t\tdiff->opts.flags &= ~GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcmp;\n\t\tdiff->strncomp   = git__strncmp;\n\t\tdiff->pfxcomp    = git__prefixcmp;\n\t\tdiff->entrycomp  = diff_entry_cmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__cmp);\n\t} else {\n\t\tdiff->opts.flags |= GIT_DIFF_IGNORE_CASE;\n\n\t\tdiff->strcomp    = git__strcasecmp;\n\t\tdiff->strncomp   = git__strncasecmp;\n\t\tdiff->pfxcomp    = git__prefixcmp_icase;\n\t\tdiff->entrycomp  = diff_entry_icmp;\n\n\t\tgit_vector_set_cmp(&diff->deltas, git_diff_delta__casecmp);\n\t}\n\n\tgit_vector_sort(&diff->deltas);\n}"
  },
  {
    "function_name": "diff_entry_icmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "382-388",
    "snippet": "static int diff_entry_icmp(const void *a, const void *b)\n{\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\treturn strcasecmp(entry_a->path, entry_b->path);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "entry_a->path",
            "entry_b->path"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_entry_icmp(const void *a, const void *b)\n{\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\treturn strcasecmp(entry_a->path, entry_b->path);\n}"
  },
  {
    "function_name": "diff_entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "374-380",
    "snippet": "static int diff_entry_cmp(const void *a, const void *b)\n{\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\treturn strcmp(entry_a->path, entry_b->path);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "entry_a->path",
            "entry_b->path"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_entry_cmp(const void *a, const void *b)\n{\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\treturn strcmp(entry_a->path, entry_b->path);\n}"
  },
  {
    "function_name": "diff_mnemonic_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "353-372",
    "snippet": "static const char *diff_mnemonic_prefix(\n\tgit_iterator_type_t type, bool left_side)\n{\n\tconst char *pfx = \"\";\n\n\tswitch (type) {\n\tcase GIT_ITERATOR_TYPE_EMPTY:   pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_TREE:    pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_INDEX:   pfx = \"i\"; break;\n\tcase GIT_ITERATOR_TYPE_WORKDIR: pfx = \"w\"; break;\n\tcase GIT_ITERATOR_TYPE_FS:      pfx = left_side ? \"1\" : \"2\"; break;\n\tdefault: break;\n\t}\n\n\t/* note: without a deeper look at pathspecs, there is no easy way\n\t * to get the (o)bject / (w)ork tree mnemonics working...\n\t */\n\n\treturn pfx;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic const char *diff_mnemonic_prefix(\n\tgit_iterator_type_t type, bool left_side)\n{\n\tconst char *pfx = \"\";\n\n\tswitch (type) {\n\tcase GIT_ITERATOR_TYPE_EMPTY:   pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_TREE:    pfx = \"c\"; break;\n\tcase GIT_ITERATOR_TYPE_INDEX:   pfx = \"i\"; break;\n\tcase GIT_ITERATOR_TYPE_WORKDIR: pfx = \"w\"; break;\n\tcase GIT_ITERATOR_TYPE_FS:      pfx = left_side ? \"1\" : \"2\"; break;\n\tdefault: break;\n\t}\n\n\t/* note: without a deeper look at pathspecs, there is no easy way\n\t * to get the (o)bject / (w)ork tree mnemonics working...\n\t */\n\n\treturn pfx;\n}"
  },
  {
    "function_name": "git_diff_delta__should_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "328-350",
    "snippet": "bool git_diff_delta__should_skip(\n\tconst git_diff_options *opts, const git_diff_delta *delta)\n{\n\tuint32_t flags = opts ? opts->flags : 0;\n\n\tif (delta->status == GIT_DELTA_UNMODIFIED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNMODIFIED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_IGNORED &&\n\t\t(flags & GIT_DIFF_INCLUDE_IGNORED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNTRACKED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNTRACKED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNREADABLE &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNREADABLE) == 0)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nbool git_diff_delta__should_skip(\n\tconst git_diff_options *opts, const git_diff_delta *delta)\n{\n\tuint32_t flags = opts ? opts->flags : 0;\n\n\tif (delta->status == GIT_DELTA_UNMODIFIED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNMODIFIED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_IGNORED &&\n\t\t(flags & GIT_DIFF_INCLUDE_IGNORED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNTRACKED &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNTRACKED) == 0)\n\t\treturn true;\n\n\tif (delta->status == GIT_DELTA_UNREADABLE &&\n\t\t(flags & GIT_DIFF_INCLUDE_UNREADABLE) == 0)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "git_diff_delta__i2w_casecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "321-326",
    "snippet": "int git_diff_delta__i2w_casecmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcasecmp(diff_delta__i2w_path(da), diff_delta__i2w_path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "diff_delta__i2w_path(da)",
            "diff_delta__i2w_path(db)"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_delta__i2w_path",
          "args": [
            "db"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__i2w_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "308-312",
          "snippet": "GIT_INLINE(const char *) diff_delta__i2w_path(const git_diff_delta *delta)\n{\n\treturn delta->old_file.path ?\n\t\tdelta->old_file.path : delta->new_file.path;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) diff_delta__i2w_path(const git_diff_delta *delta)\n{\n\treturn delta->old_file.path ?\n\t\tdelta->old_file.path : delta->new_file.path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_delta__i2w_casecmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcasecmp(diff_delta__i2w_path(da), diff_delta__i2w_path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}"
  },
  {
    "function_name": "git_diff_delta__i2w_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "314-319",
    "snippet": "int git_diff_delta__i2w_cmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcmp(diff_delta__i2w_path(da), diff_delta__i2w_path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "diff_delta__i2w_path(da)",
            "diff_delta__i2w_path(db)"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_delta__i2w_path",
          "args": [
            "db"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__i2w_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "308-312",
          "snippet": "GIT_INLINE(const char *) diff_delta__i2w_path(const git_diff_delta *delta)\n{\n\treturn delta->old_file.path ?\n\t\tdelta->old_file.path : delta->new_file.path;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) diff_delta__i2w_path(const git_diff_delta *delta)\n{\n\treturn delta->old_file.path ?\n\t\tdelta->old_file.path : delta->new_file.path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_delta__i2w_cmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcmp(diff_delta__i2w_path(da), diff_delta__i2w_path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}"
  },
  {
    "function_name": "diff_delta__i2w_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "308-312",
    "snippet": "GIT_INLINE(const char *) diff_delta__i2w_path(const git_diff_delta *delta)\n{\n\treturn delta->old_file.path ?\n\t\tdelta->old_file.path : delta->new_file.path;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) diff_delta__i2w_path(const git_diff_delta *delta)\n{\n\treturn delta->old_file.path ?\n\t\tdelta->old_file.path : delta->new_file.path;\n}"
  },
  {
    "function_name": "git_diff_delta__casecmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "301-306",
    "snippet": "int git_diff_delta__casecmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcasecmp(diff_delta__path(da), diff_delta__path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "diff_delta__path(da)",
            "diff_delta__path(db)"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_delta__path",
          "args": [
            "db"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_delta__path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "289-292",
          "snippet": "const char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_delta__casecmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcasecmp(diff_delta__path(da), diff_delta__path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}"
  },
  {
    "function_name": "git_diff_delta__cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "294-299",
    "snippet": "int git_diff_delta__cmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcmp(diff_delta__path(da), diff_delta__path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "diff_delta__path(da)",
            "diff_delta__path(db)"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_delta__path",
          "args": [
            "db"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_delta__path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "289-292",
          "snippet": "const char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nint git_diff_delta__cmp(const void *a, const void *b)\n{\n\tconst git_diff_delta *da = a, *db = b;\n\tint val = strcmp(diff_delta__path(da), diff_delta__path(db));\n\treturn val ? val : ((int)da->status - (int)db->status);\n}"
  },
  {
    "function_name": "git_diff_delta__path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "289-292",
    "snippet": "const char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_delta__path",
          "args": [
            "delta"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "git_diff_delta__path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "289-292",
          "snippet": "const char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nconst char *git_diff_delta__path(const git_diff_delta *delta)\n{\n\treturn diff_delta__path(delta);\n}"
  },
  {
    "function_name": "diff_delta__path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "276-287",
    "snippet": "GIT_INLINE(const char *) diff_delta__path(const git_diff_delta *delta)\n{\n\tconst char *str = delta->old_file.path;\n\n\tif (!str ||\n\t\tdelta->status == GIT_DELTA_ADDED ||\n\t\tdelta->status == GIT_DELTA_RENAMED ||\n\t\tdelta->status == GIT_DELTA_COPIED)\n\t\tstr = delta->new_file.path;\n\n\treturn str;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) diff_delta__path(const git_diff_delta *delta)\n{\n\tconst char *str = delta->old_file.path;\n\n\tif (!str ||\n\t\tdelta->status == GIT_DELTA_ADDED ||\n\t\tdelta->status == GIT_DELTA_RENAMED ||\n\t\tdelta->status == GIT_DELTA_COPIED)\n\t\tstr = delta->new_file.path;\n\n\treturn str;\n}"
  },
  {
    "function_name": "diff_strdup_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "265-274",
    "snippet": "static char *diff_strdup_prefix(git_pool *pool, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\n\t/* append '/' at end if needed */\n\tif (len > 0 && prefix[len - 1] != '/')\n\t\treturn git_pool_strcat(pool, prefix, \"/\");\n\telse\n\t\treturn git_pool_strndup(pool, prefix, len + 1);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pool_strndup",
          "args": [
            "pool",
            "prefix",
            "len + 1"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strndup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "190-205",
          "snippet": "char *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strndup(git_pool *pool, const char *str, size_t n)\n{\n\tchar *ptr = NULL;\n\n\tassert(pool && str && pool->item_size == sizeof(char));\n\n\tif ((uint32_t)(n + 1) < n)\n\t\treturn NULL;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(n + 1))) != NULL) {\n\t\tmemcpy(ptr, str, n);\n\t\tptr[n] = '\\0';\n\t}\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strcat",
          "args": [
            "pool",
            "prefix",
            "\"/\""
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strcat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "218-236",
          "snippet": "char *git_pool_strcat(git_pool *pool, const char *a, const char *b)\n{\n\tvoid *ptr;\n\tsize_t len_a, len_b;\n\n\tassert(pool && pool->item_size == sizeof(char));\n\n\tlen_a = a ? strlen(a) : 0;\n\tlen_b = b ? strlen(b) : 0;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(len_a + len_b + 1))) != NULL) {\n\t\tif (len_a)\n\t\t\tmemcpy(ptr, a, len_a);\n\t\tif (len_b)\n\t\t\tmemcpy(((char *)ptr) + len_a, b, len_b);\n\t\t*(((char *)ptr) + len_a + len_b) = '\\0';\n\t}\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strcat(git_pool *pool, const char *a, const char *b)\n{\n\tvoid *ptr;\n\tsize_t len_a, len_b;\n\n\tassert(pool && pool->item_size == sizeof(char));\n\n\tlen_a = a ? strlen(a) : 0;\n\tlen_b = b ? strlen(b) : 0;\n\n\tif ((ptr = git_pool_malloc(pool, (uint32_t)(len_a + len_b + 1))) != NULL) {\n\t\tif (len_a)\n\t\t\tmemcpy(ptr, a, len_a);\n\t\tif (len_b)\n\t\t\tmemcpy(((char *)ptr) + len_a, b, len_b);\n\t\t*(((char *)ptr) + len_a + len_b) = '\\0';\n\t}\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic char *diff_strdup_prefix(git_pool *pool, const char *prefix)\n{\n\tsize_t len = strlen(prefix);\n\n\t/* append '/' at end if needed */\n\tif (len > 0 && prefix[len - 1] != '/')\n\t\treturn git_pool_strcat(pool, prefix, \"/\");\n\telse\n\t\treturn git_pool_strndup(pool, prefix, len + 1);\n}"
  },
  {
    "function_name": "diff_delta__last_for_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "229-263",
    "snippet": "static git_diff_delta *diff_delta__last_for_item(\n\tgit_diff *diff,\n\tconst git_index_entry *item)\n{\n\tgit_diff_delta *delta = git_vector_last(&diff->deltas);\n\tif (!delta)\n\t\treturn NULL;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\t\tif (git_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (diff->strcomp(delta->new_file.path, item->path) == 0 &&\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0 ||\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_oid__cmp",
          "args": [
            "&delta->new_file.id",
            "&item->id"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid__cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.h",
          "lines": "42-45",
          "snippet": "GIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}",
          "includes": [
            "#include \"git2/oid.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/oid.h\"\n\nGIT_INLINE(int) git_oid__cmp(const git_oid *a, const git_oid *b)\n{\n\treturn git_oid__hashcmp(a->id, b->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff->strcomp",
          "args": [
            "delta->new_file.path",
            "item->path"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_last",
          "args": [
            "&diff->deltas"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "72-75",
          "snippet": "GIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_last(const git_vector *v)\n{\n\treturn (v->length > 0) ? git_vector_get(v, v->length - 1) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *diff_delta__last_for_item(\n\tgit_diff *diff,\n\tconst git_index_entry *item)\n{\n\tgit_diff_delta *delta = git_vector_last(&diff->deltas);\n\tif (!delta)\n\t\treturn NULL;\n\n\tswitch (delta->status) {\n\tcase GIT_DELTA_UNMODIFIED:\n\tcase GIT_DELTA_DELETED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_ADDED:\n\t\tif (git_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_UNREADABLE:\n\tcase GIT_DELTA_UNTRACKED:\n\t\tif (diff->strcomp(delta->new_file.path, item->path) == 0 &&\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tcase GIT_DELTA_MODIFIED:\n\t\tif (git_oid__cmp(&delta->old_file.id, &item->id) == 0 ||\n\t\t\tgit_oid__cmp(&delta->new_file.id, &item->id) == 0)\n\t\t\treturn delta;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "diff_delta__from_two",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "169-227",
    "snippet": "static int diff_delta__from_two(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *old_entry,\n\tuint32_t old_mode,\n\tconst git_index_entry *new_entry,\n\tuint32_t new_mode,\n\tconst git_oid *new_id,\n\tconst char *matched_pathspec)\n{\n\tconst git_oid *old_id = &old_entry->id;\n\tgit_diff_delta *delta;\n\tconst char *canonical_path = old_entry->path;\n\n\tif (status == GIT_DELTA_UNMODIFIED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNMODIFIED))\n\t\treturn 0;\n\n\tif (!new_id)\n\t\tnew_id = &new_entry->id;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tuint32_t temp_mode = old_mode;\n\t\tconst git_index_entry *temp_entry = old_entry;\n\t\tconst git_oid *temp_id = old_id;\n\n\t\told_entry = new_entry;\n\t\tnew_entry = temp_entry;\n\t\told_mode = new_mode;\n\t\tnew_mode = temp_mode;\n\t\told_id = new_id;\n\t\tnew_id = temp_id;\n\t}\n\n\tdelta = diff_delta__alloc(diff, status, canonical_path);\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->nfiles = 2;\n\n\tif (!git_index_entry_is_conflict(old_entry)) {\n\t\tdelta->old_file.size = old_entry->file_size;\n\t\tdelta->old_file.mode = old_mode;\n\t\tgit_oid_cpy(&delta->old_file.id, old_id);\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID |\n\t\t\tGIT_DIFF_FLAG_EXISTS;\n\t}\n\n\tif (!git_index_entry_is_conflict(new_entry)) {\n\t\tgit_oid_cpy(&delta->new_file.id, new_id);\n\t\tdelta->new_file.size = new_entry->file_size;\n\t\tdelta->new_file.mode = new_mode;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\n\t\tif (!git_oid_iszero(&new_entry->id))\n\t\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_insert_delta",
          "args": [
            "diff",
            "delta",
            "matched_pathspec"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "diff_insert_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "52-75",
          "snippet": "static int diff_insert_delta(\n\tgit_diff *diff, git_diff_delta *delta, const char *matched_pathspec)\n{\n\tint error = 0;\n\n\tif (diff->opts.notify_cb) {\n\t\terror = diff->opts.notify_cb(\n\t\t\tdiff, delta, matched_pathspec, diff->opts.payload);\n\n\t\tif (error) {\n\t\t\tgit__free(delta);\n\n\t\t\tif (error > 0)\t/* positive value means to skip this delta */\n\t\t\t\treturn 0;\n\t\t\telse\t\t\t/* negative value means to cancel diff */\n\t\t\t\treturn giterr_set_after_callback_function(error, \"git_diff\");\n\t\t}\n\t}\n\n\tif ((error = git_vector_insert(&diff->deltas, delta)) < 0)\n\t\tgit__free(delta);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_insert_delta(\n\tgit_diff *diff, git_diff_delta *delta, const char *matched_pathspec)\n{\n\tint error = 0;\n\n\tif (diff->opts.notify_cb) {\n\t\terror = diff->opts.notify_cb(\n\t\t\tdiff, delta, matched_pathspec, diff->opts.payload);\n\n\t\tif (error) {\n\t\t\tgit__free(delta);\n\n\t\t\tif (error > 0)\t/* positive value means to skip this delta */\n\t\t\t\treturn 0;\n\t\t\telse\t\t\t/* negative value means to cancel diff */\n\t\t\t\treturn giterr_set_after_callback_function(error, \"git_diff\");\n\t\t}\n\t}\n\n\tif ((error = git_vector_insert(&diff->deltas, delta)) < 0)\n\t\tgit__free(delta);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&new_entry->id"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&delta->new_file.id",
            "new_id"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "new_entry"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "delta"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_delta__alloc",
          "args": [
            "diff",
            "status",
            "canonical_path"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "23-50",
          "snippet": "static git_diff_delta *diff_delta__alloc(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst char *path)\n{\n\tgit_diff_delta *delta = git__calloc(1, sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tdelta->old_file.path = git_pool_strdup(&diff->pool, path);\n\tif (delta->old_file.path == NULL) {\n\t\tgit__free(delta);\n\t\treturn NULL;\n\t}\n\n\tdelta->new_file.path = delta->old_file.path;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tswitch (status) {\n\t\tcase GIT_DELTA_ADDED:   status = GIT_DELTA_DELETED; break;\n\t\tcase GIT_DELTA_DELETED: status = GIT_DELTA_ADDED; break;\n\t\tdefault: break; /* leave other status values alone */\n\t\t}\n\t}\n\tdelta->status = status;\n\n\treturn delta;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *diff_delta__alloc(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst char *path)\n{\n\tgit_diff_delta *delta = git__calloc(1, sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tdelta->old_file.path = git_pool_strdup(&diff->pool, path);\n\tif (delta->old_file.path == NULL) {\n\t\tgit__free(delta);\n\t\treturn NULL;\n\t}\n\n\tdelta->new_file.path = delta->old_file.path;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tswitch (status) {\n\t\tcase GIT_DELTA_ADDED:   status = GIT_DELTA_DELETED; break;\n\t\tcase GIT_DELTA_DELETED: status = GIT_DELTA_ADDED; break;\n\t\tdefault: break; /* leave other status values alone */\n\t\t}\n\t}\n\tdelta->status = status;\n\n\treturn delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_REVERSE"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_UNMODIFIED"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_delta__from_two(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *old_entry,\n\tuint32_t old_mode,\n\tconst git_index_entry *new_entry,\n\tuint32_t new_mode,\n\tconst git_oid *new_id,\n\tconst char *matched_pathspec)\n{\n\tconst git_oid *old_id = &old_entry->id;\n\tgit_diff_delta *delta;\n\tconst char *canonical_path = old_entry->path;\n\n\tif (status == GIT_DELTA_UNMODIFIED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNMODIFIED))\n\t\treturn 0;\n\n\tif (!new_id)\n\t\tnew_id = &new_entry->id;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tuint32_t temp_mode = old_mode;\n\t\tconst git_index_entry *temp_entry = old_entry;\n\t\tconst git_oid *temp_id = old_id;\n\n\t\told_entry = new_entry;\n\t\tnew_entry = temp_entry;\n\t\told_mode = new_mode;\n\t\tnew_mode = temp_mode;\n\t\told_id = new_id;\n\t\tnew_id = temp_id;\n\t}\n\n\tdelta = diff_delta__alloc(diff, status, canonical_path);\n\tGITERR_CHECK_ALLOC(delta);\n\tdelta->nfiles = 2;\n\n\tif (!git_index_entry_is_conflict(old_entry)) {\n\t\tdelta->old_file.size = old_entry->file_size;\n\t\tdelta->old_file.mode = old_mode;\n\t\tgit_oid_cpy(&delta->old_file.id, old_id);\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID |\n\t\t\tGIT_DIFF_FLAG_EXISTS;\n\t}\n\n\tif (!git_index_entry_is_conflict(new_entry)) {\n\t\tgit_oid_cpy(&delta->new_file.id, new_id);\n\t\tdelta->new_file.size = new_entry->file_size;\n\t\tdelta->new_file.mode = new_mode;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\n\t\tif (!git_oid_iszero(&new_entry->id))\n\t\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\t}\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}"
  },
  {
    "function_name": "diff_delta__from_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "103-167",
    "snippet": "static int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff_insert_delta",
          "args": [
            "diff",
            "delta",
            "matched_pathspec"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "diff_insert_delta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "52-75",
          "snippet": "static int diff_insert_delta(\n\tgit_diff *diff, git_diff_delta *delta, const char *matched_pathspec)\n{\n\tint error = 0;\n\n\tif (diff->opts.notify_cb) {\n\t\terror = diff->opts.notify_cb(\n\t\t\tdiff, delta, matched_pathspec, diff->opts.payload);\n\n\t\tif (error) {\n\t\t\tgit__free(delta);\n\n\t\t\tif (error > 0)\t/* positive value means to skip this delta */\n\t\t\t\treturn 0;\n\t\t\telse\t\t\t/* negative value means to cancel diff */\n\t\t\t\treturn giterr_set_after_callback_function(error, \"git_diff\");\n\t\t}\n\t}\n\n\tif ((error = git_vector_insert(&diff->deltas, delta)) < 0)\n\t\tgit__free(delta);\n\n\treturn error;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_insert_delta(\n\tgit_diff *diff, git_diff_delta *delta, const char *matched_pathspec)\n{\n\tint error = 0;\n\n\tif (diff->opts.notify_cb) {\n\t\terror = diff->opts.notify_cb(\n\t\t\tdiff, delta, matched_pathspec, diff->opts.payload);\n\n\t\tif (error) {\n\t\t\tgit__free(delta);\n\n\t\t\tif (error > 0)\t/* positive value means to skip this delta */\n\t\t\t\treturn 0;\n\t\t\telse\t\t\t/* negative value means to cancel diff */\n\t\t\t\treturn giterr_set_after_callback_function(error, \"git_diff\");\n\t\t}\n\t}\n\n\tif ((error = git_vector_insert(&diff->deltas, delta)) < 0)\n\t\tgit__free(delta);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_iszero",
          "args": [
            "&delta->new_file.id"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_iszero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "239-247",
          "snippet": "int git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_iszero(const git_oid *oid_a)\n{\n\tconst unsigned char *a = oid_a->id;\n\tunsigned int i;\n\tfor (i = 0; i < GIT_OID_RAWSZ; ++i, ++a)\n\t\tif (*a != 0)\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&delta->new_file.id",
            "&entry->id"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "status != GIT_DELTA_MODIFIED"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "delta"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff_delta__alloc",
          "args": [
            "diff",
            "status",
            "entry->path"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "diff_delta__alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "23-50",
          "snippet": "static git_diff_delta *diff_delta__alloc(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst char *path)\n{\n\tgit_diff_delta *delta = git__calloc(1, sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tdelta->old_file.path = git_pool_strdup(&diff->pool, path);\n\tif (delta->old_file.path == NULL) {\n\t\tgit__free(delta);\n\t\treturn NULL;\n\t}\n\n\tdelta->new_file.path = delta->old_file.path;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tswitch (status) {\n\t\tcase GIT_DELTA_ADDED:   status = GIT_DELTA_DELETED; break;\n\t\tcase GIT_DELTA_DELETED: status = GIT_DELTA_ADDED; break;\n\t\tdefault: break; /* leave other status values alone */\n\t\t}\n\t}\n\tdelta->status = status;\n\n\treturn delta;\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *diff_delta__alloc(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst char *path)\n{\n\tgit_diff_delta *delta = git__calloc(1, sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tdelta->old_file.path = git_pool_strdup(&diff->pool, path);\n\tif (delta->old_file.path == NULL) {\n\t\tgit__free(delta);\n\t\treturn NULL;\n\t}\n\n\tdelta->new_file.path = delta->old_file.path;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tswitch (status) {\n\t\tcase GIT_DELTA_ADDED:   status = GIT_DELTA_DELETED; break;\n\t\tcase GIT_DELTA_DELETED: status = GIT_DELTA_ADDED; break;\n\t\tdefault: break; /* leave other status values alone */\n\t\t}\n\t}\n\tdelta->status = status;\n\n\treturn delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff_pathspec_match",
          "args": [
            "&matched_pathspec",
            "diff",
            "entry"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "diff_pathspec_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
          "lines": "77-101",
          "snippet": "static bool diff_pathspec_match(\n\tconst char **matched_pathspec,\n\tgit_diff *diff,\n\tconst git_index_entry *entry)\n{\n\tbool disable_pathspec_match =\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_DISABLE_PATHSPEC_MATCH);\n\n\t/* If we're disabling fnmatch, then the iterator has already applied\n\t * the filters to the files for us and we don't have to do anything.\n\t * However, this only applies to *files* - the iterator will include\n\t * directories that we need to recurse into when not autoexpanding,\n\t * so we still need to apply the pathspec match to directories.\n\t */\n\tif ((S_ISLNK(entry->mode) || S_ISREG(entry->mode)) &&\n\t\tdisable_pathspec_match) {\n\t\t*matched_pathspec = entry->path;\n\t\treturn true;\n\t}\n\n\treturn git_pathspec__match(\n\t\t&diff->pathspec, entry->path, disable_pathspec_match,\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE),\n\t\tmatched_pathspec, NULL);\n}",
          "includes": [
            "#include \"submodule.h\"",
            "#include \"odb.h\"",
            "#include \"index.h\"",
            "#include \"pathspec.h\"",
            "#include \"filter.h\"",
            "#include \"attr_file.h\"",
            "#include \"config.h\"",
            "#include \"fileops.h\"",
            "#include \"diff.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic bool diff_pathspec_match(\n\tconst char **matched_pathspec,\n\tgit_diff *diff,\n\tconst git_index_entry *entry)\n{\n\tbool disable_pathspec_match =\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_DISABLE_PATHSPEC_MATCH);\n\n\t/* If we're disabling fnmatch, then the iterator has already applied\n\t * the filters to the files for us and we don't have to do anything.\n\t * However, this only applies to *files* - the iterator will include\n\t * directories that we need to recurse into when not autoexpanding,\n\t * so we still need to apply the pathspec match to directories.\n\t */\n\tif ((S_ISLNK(entry->mode) || S_ISREG(entry->mode)) &&\n\t\tdisable_pathspec_match) {\n\t\t*matched_pathspec = entry->path;\n\t\treturn true;\n\t}\n\n\treturn git_pathspec__match(\n\t\t&diff->pathspec, entry->path, disable_pathspec_match,\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE),\n\t\tmatched_pathspec, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_UNREADABLE"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_UNTRACKED"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_ISNT_SET",
          "args": [
            "diff",
            "GIT_DIFF_INCLUDE_IGNORED"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_REVERSE"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(oitem != NULL) ^ (nitem != NULL)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_delta__from_one(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst git_index_entry *oitem,\n\tconst git_index_entry *nitem)\n{\n\tconst git_index_entry *entry = nitem;\n\tbool has_old = false;\n\tgit_diff_delta *delta;\n\tconst char *matched_pathspec;\n\n\tassert((oitem != NULL) ^ (nitem != NULL));\n\n\tif (oitem) {\n\t\tentry = oitem;\n\t\thas_old = true;\n\t}\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE))\n\t\thas_old = !has_old;\n\n\tif ((entry->flags & GIT_IDXENTRY_VALID) != 0)\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_IGNORED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_IGNORED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNTRACKED &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNTRACKED))\n\t\treturn 0;\n\n\tif (status == GIT_DELTA_UNREADABLE &&\n\t\tDIFF_FLAG_ISNT_SET(diff, GIT_DIFF_INCLUDE_UNREADABLE))\n\t\treturn 0;\n\n\tif (!diff_pathspec_match(&matched_pathspec, diff, entry))\n\t\treturn 0;\n\n\tdelta = diff_delta__alloc(diff, status, entry->path);\n\tGITERR_CHECK_ALLOC(delta);\n\n\t/* This fn is just for single-sided diffs */\n\tassert(status != GIT_DELTA_MODIFIED);\n\tdelta->nfiles = 1;\n\n\tif (has_old) {\n\t\tdelta->old_file.mode = entry->mode;\n\t\tdelta->old_file.size = entry->file_size;\n\t\tdelta->old_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->old_file.id, &entry->id);\n\t} else /* ADDED, IGNORED, UNTRACKED */ {\n\t\tdelta->new_file.mode = entry->mode;\n\t\tdelta->new_file.size = entry->file_size;\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_EXISTS;\n\t\tgit_oid_cpy(&delta->new_file.id, &entry->id);\n\t}\n\n\tdelta->old_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\tif (has_old || !git_oid_iszero(&delta->new_file.id))\n\t\tdelta->new_file.flags |= GIT_DIFF_FLAG_VALID_ID;\n\n\treturn diff_insert_delta(diff, delta, matched_pathspec);\n}"
  },
  {
    "function_name": "diff_pathspec_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "77-101",
    "snippet": "static bool diff_pathspec_match(\n\tconst char **matched_pathspec,\n\tgit_diff *diff,\n\tconst git_index_entry *entry)\n{\n\tbool disable_pathspec_match =\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_DISABLE_PATHSPEC_MATCH);\n\n\t/* If we're disabling fnmatch, then the iterator has already applied\n\t * the filters to the files for us and we don't have to do anything.\n\t * However, this only applies to *files* - the iterator will include\n\t * directories that we need to recurse into when not autoexpanding,\n\t * so we still need to apply the pathspec match to directories.\n\t */\n\tif ((S_ISLNK(entry->mode) || S_ISREG(entry->mode)) &&\n\t\tdisable_pathspec_match) {\n\t\t*matched_pathspec = entry->path;\n\t\treturn true;\n\t}\n\n\treturn git_pathspec__match(\n\t\t&diff->pathspec, entry->path, disable_pathspec_match,\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE),\n\t\tmatched_pathspec, NULL);\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_pathspec__match",
          "args": [
            "&diff->pathspec",
            "entry->path",
            "disable_pathspec_match",
            "DIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE)",
            "matched_pathspec",
            "NULL"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "git_pathspec__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pathspec.c",
          "lines": "196-230",
          "snippet": "bool git_pathspec__match(\n\tconst git_vector *vspec,\n\tconst char *path,\n\tbool disable_fnmatch,\n\tbool casefold,\n\tconst char **matched_pathspec,\n\tsize_t *matched_at)\n{\n\tint result;\n\tsize_t pos;\n\tstruct pathspec_match_context ctxt;\n\n\tif (matched_pathspec)\n\t\t*matched_pathspec = NULL;\n\tif (matched_at)\n\t\t*matched_at = GIT_PATHSPEC_NOMATCH;\n\n\tif (!vspec || !vspec->length)\n\t\treturn true;\n\n\tpathspec_match_context_init(&ctxt, disable_fnmatch, casefold);\n\n\tresult = git_pathspec__match_at(&pos, vspec, &ctxt, path, NULL);\n\tif (result >= 0) {\n\t\tif (matched_pathspec) {\n\t\t\tconst git_attr_fnmatch *match = git_vector_get(vspec, pos);\n\t\t\t*matched_pathspec = match->pattern;\n\t\t}\n\n\t\tif (matched_at)\n\t\t\t*matched_at = pos;\n\t}\n\n\treturn (result > 0);\n}",
          "includes": [
            "#include \"diff.h\"",
            "#include \"bitvec.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"iterator.h\"",
            "#include \"attr_file.h\"",
            "#include \"buf_text.h\"",
            "#include \"pathspec.h\"",
            "#include \"git2/diff.h\"",
            "#include \"git2/pathspec.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff.h\"\n#include \"bitvec.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"iterator.h\"\n#include \"attr_file.h\"\n#include \"buf_text.h\"\n#include \"pathspec.h\"\n#include \"git2/diff.h\"\n#include \"git2/pathspec.h\"\n\nbool git_pathspec__match(\n\tconst git_vector *vspec,\n\tconst char *path,\n\tbool disable_fnmatch,\n\tbool casefold,\n\tconst char **matched_pathspec,\n\tsize_t *matched_at)\n{\n\tint result;\n\tsize_t pos;\n\tstruct pathspec_match_context ctxt;\n\n\tif (matched_pathspec)\n\t\t*matched_pathspec = NULL;\n\tif (matched_at)\n\t\t*matched_at = GIT_PATHSPEC_NOMATCH;\n\n\tif (!vspec || !vspec->length)\n\t\treturn true;\n\n\tpathspec_match_context_init(&ctxt, disable_fnmatch, casefold);\n\n\tresult = git_pathspec__match_at(&pos, vspec, &ctxt, path, NULL);\n\tif (result >= 0) {\n\t\tif (matched_pathspec) {\n\t\t\tconst git_attr_fnmatch *match = git_vector_get(vspec, pos);\n\t\t\t*matched_pathspec = match->pattern;\n\t\t}\n\n\t\tif (matched_at)\n\t\t\t*matched_at = pos;\n\t}\n\n\treturn (result > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_IGNORE_CASE"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "entry->mode"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "entry->mode"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_DISABLE_PATHSPEC_MATCH"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic bool diff_pathspec_match(\n\tconst char **matched_pathspec,\n\tgit_diff *diff,\n\tconst git_index_entry *entry)\n{\n\tbool disable_pathspec_match =\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_DISABLE_PATHSPEC_MATCH);\n\n\t/* If we're disabling fnmatch, then the iterator has already applied\n\t * the filters to the files for us and we don't have to do anything.\n\t * However, this only applies to *files* - the iterator will include\n\t * directories that we need to recurse into when not autoexpanding,\n\t * so we still need to apply the pathspec match to directories.\n\t */\n\tif ((S_ISLNK(entry->mode) || S_ISREG(entry->mode)) &&\n\t\tdisable_pathspec_match) {\n\t\t*matched_pathspec = entry->path;\n\t\treturn true;\n\t}\n\n\treturn git_pathspec__match(\n\t\t&diff->pathspec, entry->path, disable_pathspec_match,\n\t\tDIFF_FLAG_IS_SET(diff, GIT_DIFF_IGNORE_CASE),\n\t\tmatched_pathspec, NULL);\n}"
  },
  {
    "function_name": "diff_insert_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "52-75",
    "snippet": "static int diff_insert_delta(\n\tgit_diff *diff, git_diff_delta *delta, const char *matched_pathspec)\n{\n\tint error = 0;\n\n\tif (diff->opts.notify_cb) {\n\t\terror = diff->opts.notify_cb(\n\t\t\tdiff, delta, matched_pathspec, diff->opts.payload);\n\n\t\tif (error) {\n\t\t\tgit__free(delta);\n\n\t\t\tif (error > 0)\t/* positive value means to skip this delta */\n\t\t\t\treturn 0;\n\t\t\telse\t\t\t/* negative value means to cancel diff */\n\t\t\t\treturn giterr_set_after_callback_function(error, \"git_diff\");\n\t\t}\n\t}\n\n\tif ((error = git_vector_insert(&diff->deltas, delta)) < 0)\n\t\tgit__free(delta);\n\n\treturn error;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "delta"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&diff->deltas",
            "delta"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback_function",
          "args": [
            "error",
            "\"git_diff\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "diff->opts.notify_cb",
          "args": [
            "diff",
            "delta",
            "matched_pathspec",
            "diff->opts.payload"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic int diff_insert_delta(\n\tgit_diff *diff, git_diff_delta *delta, const char *matched_pathspec)\n{\n\tint error = 0;\n\n\tif (diff->opts.notify_cb) {\n\t\terror = diff->opts.notify_cb(\n\t\t\tdiff, delta, matched_pathspec, diff->opts.payload);\n\n\t\tif (error) {\n\t\t\tgit__free(delta);\n\n\t\t\tif (error > 0)\t/* positive value means to skip this delta */\n\t\t\t\treturn 0;\n\t\t\telse\t\t\t/* negative value means to cancel diff */\n\t\t\t\treturn giterr_set_after_callback_function(error, \"git_diff\");\n\t\t}\n\t}\n\n\tif ((error = git_vector_insert(&diff->deltas, delta)) < 0)\n\t\tgit__free(delta);\n\n\treturn error;\n}"
  },
  {
    "function_name": "diff_delta__alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/diff.c",
    "lines": "23-50",
    "snippet": "static git_diff_delta *diff_delta__alloc(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst char *path)\n{\n\tgit_diff_delta *delta = git__calloc(1, sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tdelta->old_file.path = git_pool_strdup(&diff->pool, path);\n\tif (delta->old_file.path == NULL) {\n\t\tgit__free(delta);\n\t\treturn NULL;\n\t}\n\n\tdelta->new_file.path = delta->old_file.path;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tswitch (status) {\n\t\tcase GIT_DELTA_ADDED:   status = GIT_DELTA_DELETED; break;\n\t\tcase GIT_DELTA_DELETED: status = GIT_DELTA_ADDED; break;\n\t\tdefault: break; /* leave other status values alone */\n\t\t}\n\t}\n\tdelta->status = status;\n\n\treturn delta;\n}",
    "includes": [
      "#include \"submodule.h\"",
      "#include \"odb.h\"",
      "#include \"index.h\"",
      "#include \"pathspec.h\"",
      "#include \"filter.h\"",
      "#include \"attr_file.h\"",
      "#include \"config.h\"",
      "#include \"fileops.h\"",
      "#include \"diff.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIFF_FLAG_IS_SET",
          "args": [
            "diff",
            "GIT_DIFF_REVERSE"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "delta"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_strdup",
          "args": [
            "&diff->pool",
            "path"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_strdup_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "213-216",
          "snippet": "char *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nchar *git_pool_strdup_safe(git_pool *pool, const char *str)\n{\n\treturn str ? git_pool_strdup(pool, str) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(git_diff_delta)"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"submodule.h\"\n#include \"odb.h\"\n#include \"index.h\"\n#include \"pathspec.h\"\n#include \"filter.h\"\n#include \"attr_file.h\"\n#include \"config.h\"\n#include \"fileops.h\"\n#include \"diff.h\"\n#include \"common.h\"\n\nstatic git_diff_delta *diff_delta__alloc(\n\tgit_diff *diff,\n\tgit_delta_t status,\n\tconst char *path)\n{\n\tgit_diff_delta *delta = git__calloc(1, sizeof(git_diff_delta));\n\tif (!delta)\n\t\treturn NULL;\n\n\tdelta->old_file.path = git_pool_strdup(&diff->pool, path);\n\tif (delta->old_file.path == NULL) {\n\t\tgit__free(delta);\n\t\treturn NULL;\n\t}\n\n\tdelta->new_file.path = delta->old_file.path;\n\n\tif (DIFF_FLAG_IS_SET(diff, GIT_DIFF_REVERSE)) {\n\t\tswitch (status) {\n\t\tcase GIT_DELTA_ADDED:   status = GIT_DELTA_DELETED; break;\n\t\tcase GIT_DELTA_DELETED: status = GIT_DELTA_ADDED; break;\n\t\tdefault: break; /* leave other status values alone */\n\t\t}\n\t}\n\tdelta->status = status;\n\n\treturn delta;\n}"
  }
]