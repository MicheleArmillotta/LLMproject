[
  {
    "function_name": "git_hash_vec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash.c",
    "lines": "27-47",
    "snippet": "int git_hash_vec(git_oid *out, git_buf_vec *vec, size_t n)\n{\n\tgit_hash_ctx ctx;\n\tsize_t i;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif ((error = git_hash_update(&ctx, vec[i].data, vec[i].len)) < 0)\n\t\t\tgoto done;\n\t}\n\n\terror = git_hash_final(out, &ctx);\n\ndone:\n\tgit_hash_ctx_cleanup(&ctx);\n\n\treturn error;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_ctx_cleanup",
          "args": [
            "&ctx"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "268-276",
          "snippet": "void git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_final",
          "args": [
            "out",
            "&ctx"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "37-42",
          "snippet": "GIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&ctx",
            "vec[i].data",
            "vec[i].len"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_init",
          "args": [
            "&ctx"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "231-248",
          "snippet": "int git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct git_hash_prov hash_prov = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic struct git_hash_prov hash_prov = {0};\n\nint git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"common.h\"\n\nint git_hash_vec(git_oid *out, git_buf_vec *vec, size_t n)\n{\n\tgit_hash_ctx ctx;\n\tsize_t i;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif ((error = git_hash_update(&ctx, vec[i].data, vec[i].len)) < 0)\n\t\t\tgoto done;\n\t}\n\n\terror = git_hash_final(out, &ctx);\n\ndone:\n\tgit_hash_ctx_cleanup(&ctx);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_hash_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash.c",
    "lines": "11-25",
    "snippet": "int git_hash_buf(git_oid *out, const void *data, size_t len)\n{\n\tgit_hash_ctx ctx;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tif ((error = git_hash_update(&ctx, data, len)) >= 0)\n\t\terror = git_hash_final(out, &ctx);\n\n\tgit_hash_ctx_cleanup(&ctx);\n\t\n\treturn error;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_hash_ctx_cleanup",
          "args": [
            "&ctx"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "268-276",
          "snippet": "void git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid git_hash_ctx_cleanup(git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\n\tif (ctx->type == CNG)\n\t\thash_ctx_cng_cleanup(ctx);\n\telse if(ctx->type == CRYPTOAPI)\n\t\thash_ctx_cryptoapi_cleanup(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_final",
          "args": [
            "out",
            "&ctx"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "37-42",
          "snippet": "GIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_final(git_oid *out, git_hash_ctx *ctx)\n{\n\tassert(ctx);\n\tSHA1_Final(out->id, &ctx->c);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_update",
          "args": [
            "&ctx",
            "data",
            "len"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_openssl.h",
          "lines": "30-35",
          "snippet": "GIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}",
          "includes": [
            "#include <openssl/sha.h>",
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/sha.h>\n#include \"hash.h\"\n\nGIT_INLINE(int) git_hash_update(git_hash_ctx *ctx, const void *data, size_t len)\n{\n\tassert(ctx);\n\tSHA1_Update(&ctx->c, data, len);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_hash_ctx_init",
          "args": [
            "&ctx"
          ],
          "line": 16
        },
        "resolved": true,
        "details": {
          "function_name": "git_hash_ctx_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/hash/hash_win32.c",
          "lines": "231-248",
          "snippet": "int git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}",
          "includes": [
            "#include <strsafe.h>",
            "#include <wincrypt.h>",
            "#include \"hash/hash_win32.h\"",
            "#include \"hash.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct git_hash_prov hash_prov = {0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <strsafe.h>\n#include <wincrypt.h>\n#include \"hash/hash_win32.h\"\n#include \"hash.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic struct git_hash_prov hash_prov = {0};\n\nint git_hash_ctx_init(git_hash_ctx *ctx)\n{\n\tint error = 0;\n\n\tassert(ctx);\n\n\t/*\n\t * When compiled with GIT_THREADS, the global hash_prov data is\n\t * initialized with git_libgit2_init.  Otherwise, it must be initialized\n\t * at first use.\n\t */\n\tif (hash_prov.type == INVALID && (error = git_hash_global_init()) < 0)\n\t\treturn error;\n\n\tmemset(ctx, 0x0, sizeof(git_hash_ctx));\n\n\treturn (hash_prov.type == CNG) ? hash_ctx_cng_init(ctx) : hash_ctx_cryptoapi_init(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"common.h\"\n\nint git_hash_buf(git_oid *out, const void *data, size_t len)\n{\n\tgit_hash_ctx ctx;\n\tint error = 0;\n\n\tif (git_hash_ctx_init(&ctx) < 0)\n\t\treturn -1;\n\n\tif ((error = git_hash_update(&ctx, data, len)) >= 0)\n\t\terror = git_hash_final(out, &ctx);\n\n\tgit_hash_ctx_cleanup(&ctx);\n\t\n\treturn error;\n}"
  }
]