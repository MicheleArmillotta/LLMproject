[
  {
    "function_name": "git_fetchhead_ref_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "293-301",
    "snippet": "void git_fetchhead_ref_free(git_fetchhead_ref *fetchhead_ref)\n{\n\tif (fetchhead_ref == NULL)\n\t\treturn;\n\n\tgit__free(fetchhead_ref->remote_url);\n\tgit__free(fetchhead_ref->ref_name);\n\tgit__free(fetchhead_ref);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "fetchhead_ref"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nvoid git_fetchhead_ref_free(git_fetchhead_ref *fetchhead_ref)\n{\n\tif (fetchhead_ref == NULL)\n\t\treturn;\n\n\tgit__free(fetchhead_ref->remote_url);\n\tgit__free(fetchhead_ref->ref_name);\n\tgit__free(fetchhead_ref);\n}"
  },
  {
    "function_name": "git_repository_fetchhead_foreach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "237-291",
    "snippet": "int git_repository_fetchhead_foreach(git_repository *repo,\n\tgit_repository_fetchhead_foreach_cb cb,\n\tvoid *payload)\n{\n\tgit_buf path = GIT_BUF_INIT, file = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\tconst char *ref_name;\n\tgit_oid oid;\n\tconst char *remote_url;\n\tunsigned int is_merge = 0;\n\tchar *buffer, *line;\n\tsize_t line_num = 0;\n\tint error = 0;\n\n\tassert(repo && cb);\n\n\tif (git_buf_joinpath(&path, repo->path_repository, GIT_FETCH_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif ((error = git_futils_readbuffer(&file, git_buf_cstr(&path))) < 0)\n\t\tgoto done;\n\n\tbuffer = file.ptr;\n\n\twhile ((line = git__strsep(&buffer, \"\\n\")) != NULL) {\n\t\t++line_num;\n\n\t\tif ((error = fetchhead_ref_parse(\n\t\t\t\t&oid, &is_merge, &name, &remote_url, line, line_num)) < 0)\n\t\t\tgoto done;\n\n\t\tif (git_buf_len(&name) > 0)\n\t\t\tref_name = git_buf_cstr(&name);\n\t\telse\n\t\t\tref_name = NULL;\n\n\t\terror = cb(ref_name, remote_url, &oid, is_merge, payload);\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (*buffer) {\n\t\tgiterr_set(GITERR_FETCHHEAD, \"No EOL at line %d\", line_num+1);\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\ndone:\n\tgit_buf_free(&file);\n\tgit_buf_free(&path);\n\tgit_buf_free(&name);\n\n\treturn error;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&name"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_FETCHHEAD",
            "\"No EOL at line %d\"",
            "line_num+1"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set_after_callback",
          "args": [
            "error"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "ref_name",
            "remote_url",
            "&oid",
            "is_merge",
            "payload"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "fallback_cred_acquire_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/winhttp.c",
          "lines": "160-214",
          "snippet": "static int fallback_cred_acquire_cb(\n\tgit_cred **cred,\n\tconst char *url,\n\tconst char *username_from_url,\n\tunsigned int allowed_types,\n\tvoid *payload)\n{\n\tint error = 1;\n\n\tGIT_UNUSED(username_from_url);\n\tGIT_UNUSED(payload);\n\n\t/* If the target URI supports integrated Windows authentication\n\t * as an authentication mechanism */\n\tif (GIT_CREDTYPE_DEFAULT & allowed_types) {\n\t\twchar_t *wide_url;\n\n\t\t/* Convert URL to wide characters */\n\t\tif (git__utf8_to_16_alloc(&wide_url, url) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n\t\t\tIInternetSecurityManager* pISM;\n\n\t\t\t/* And if the target URI is in the My Computer, Intranet, or Trusted zones */\n\t\t\tif (SUCCEEDED(CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM))) {\n\t\t\t\tDWORD dwZone;\n\n\t\t\t\tif (SUCCEEDED(pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)) &&\n\t\t\t\t\t(URLZONE_LOCAL_MACHINE == dwZone ||\n\t\t\t\t\tURLZONE_INTRANET == dwZone ||\n\t\t\t\t\tURLZONE_TRUSTED == dwZone)) {\n\t\t\t\t\tgit_cred *existing = *cred;\n\n\t\t\t\t\tif (existing)\n\t\t\t\t\t\texisting->free(existing);\n\n\t\t\t\t\t/* Then use default Windows credentials to authenticate this request */\n\t\t\t\t\terror = git_cred_default_new(cred);\n\t\t\t\t}\n\n\t\t\t\tpISM->lpVtbl->Release(pISM);\n\t\t\t}\n\n\t\t\tCoUninitialize();\n\t\t}\n\n\t\tgit__free(wide_url);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <urlmon.h>",
            "#include <objbase.h>",
            "#include <winhttp.h>",
            "#include <wincrypt.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"remote.h\"",
            "#include \"smart.h\"",
            "#include \"netops.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\"",
            "#include \"git2/transport.h\"",
            "#include \"git2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <urlmon.h>\n#include <objbase.h>\n#include <winhttp.h>\n#include <wincrypt.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"remote.h\"\n#include \"smart.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n#include \"git2/transport.h\"\n#include \"git2.h\"\n\nstatic int fallback_cred_acquire_cb(\n\tgit_cred **cred,\n\tconst char *url,\n\tconst char *username_from_url,\n\tunsigned int allowed_types,\n\tvoid *payload)\n{\n\tint error = 1;\n\n\tGIT_UNUSED(username_from_url);\n\tGIT_UNUSED(payload);\n\n\t/* If the target URI supports integrated Windows authentication\n\t * as an authentication mechanism */\n\tif (GIT_CREDTYPE_DEFAULT & allowed_types) {\n\t\twchar_t *wide_url;\n\n\t\t/* Convert URL to wide characters */\n\t\tif (git__utf8_to_16_alloc(&wide_url, url) < 0) {\n\t\t\tgiterr_set(GITERR_OS, \"Failed to convert string to wide form\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (SUCCEEDED(CoInitializeEx(NULL, COINIT_MULTITHREADED))) {\n\t\t\tIInternetSecurityManager* pISM;\n\n\t\t\t/* And if the target URI is in the My Computer, Intranet, or Trusted zones */\n\t\t\tif (SUCCEEDED(CoCreateInstance(&CLSID_InternetSecurityManager, NULL,\n\t\t\t\tCLSCTX_ALL, &IID_IInternetSecurityManager, (void **)&pISM))) {\n\t\t\t\tDWORD dwZone;\n\n\t\t\t\tif (SUCCEEDED(pISM->lpVtbl->MapUrlToZone(pISM, wide_url, &dwZone, 0)) &&\n\t\t\t\t\t(URLZONE_LOCAL_MACHINE == dwZone ||\n\t\t\t\t\tURLZONE_INTRANET == dwZone ||\n\t\t\t\t\tURLZONE_TRUSTED == dwZone)) {\n\t\t\t\t\tgit_cred *existing = *cred;\n\n\t\t\t\t\tif (existing)\n\t\t\t\t\t\texisting->free(existing);\n\n\t\t\t\t\t/* Then use default Windows credentials to authenticate this request */\n\t\t\t\t\terror = git_cred_default_new(cred);\n\t\t\t\t}\n\n\t\t\t\tpISM->lpVtbl->Release(pISM);\n\t\t\t}\n\n\t\t\tCoUninitialize();\n\t\t}\n\n\t\tgit__free(wide_url);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_cstr",
          "args": [
            "&name"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_cstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "136-139",
          "snippet": "GIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(const char *) git_buf_cstr(const git_buf *buf)\n{\n\treturn buf->ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_len",
          "args": [
            "&name"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "141-144",
          "snippet": "GIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(size_t) git_buf_len(const git_buf *buf)\n{\n\treturn buf->size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetchhead_ref_parse",
          "args": [
            "&oid",
            "&is_merge",
            "&name",
            "&remote_url",
            "line",
            "line_num"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "fetchhead_ref_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
          "lines": "136-235",
          "snippet": "static int fetchhead_ref_parse(\n\tgit_oid *oid,\n\tunsigned int *is_merge,\n\tgit_buf *ref_name,\n\tconst char **remote_url,\n\tchar *line,\n\tsize_t line_num)\n{\n\tchar *oid_str, *is_merge_str, *desc, *name = NULL;\n\tconst char *type = NULL;\n\tint error = 0;\n\n\t*remote_url = NULL;\n\n\tif (!*line) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Empty line in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\t/* Compat with old git clients that wrote FETCH_HEAD like a loose ref. */\n\tif ((oid_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\toid_str = line;\n\t\tline += strlen(line);\n\n\t\t*is_merge = 1;\n\t}\n\n\tif (strlen(oid_str) != GIT_OID_HEXSZ) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Invalid object ID in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\tif (git_oid_fromstr(oid, oid_str) < 0) {\n\t\tconst git_error *oid_err = giterr_last();\n\t\tconst char *err_msg = oid_err ? oid_err->message : \"Invalid object ID\";\n\n\t\tgiterr_set(GITERR_FETCHHEAD, \"%s in FETCH_HEAD line %d\",\n\t\t\terr_msg, line_num);\n\t\treturn -1;\n\t}\n\n\t/* Parse new data from newer git clients */\n\tif (*line) {\n\t\tif ((is_merge_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description data in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*is_merge_str == '\\0')\n\t\t\t*is_merge = 1;\n\t\telse if (strcmp(is_merge_str, \"not-for-merge\") == 0)\n\t\t\t*is_merge = 0;\n\t\telse {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid for-merge entry in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((desc = line) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (git__prefixcmp(desc, \"branch '\") == 0) {\n\t\t\ttype = GIT_REFS_HEADS_DIR;\n\t\t\tname = desc + 8;\n\t\t} else if (git__prefixcmp(desc, \"tag '\") == 0) {\n\t\t\ttype = GIT_REFS_TAGS_DIR;\n\t\t\tname = desc + 5;\n\t\t} else if (git__prefixcmp(desc, \"'\") == 0)\n\t\t\tname = desc + 1;\n\n\t\tif (name) {\n\t\t\tif ((desc = strstr(name, \"' \")) == NULL ||\n\t\t\t\tgit__prefixcmp(desc, \"' of \") != 0) {\n\t\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*desc = '\\0';\n\t\t\tdesc += 5;\n\t\t}\n\n\t\t*remote_url = desc;\n\t}\n\n\tgit_buf_clear(ref_name);\n\n\tif (type)\n\t\tgit_buf_join(ref_name, '/', type, name);\n\telse if(name)\n\t\tgit_buf_puts(ref_name, name);\n\n\treturn error;\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include \"fetchhead.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nstatic int fetchhead_ref_parse(\n\tgit_oid *oid,\n\tunsigned int *is_merge,\n\tgit_buf *ref_name,\n\tconst char **remote_url,\n\tchar *line,\n\tsize_t line_num)\n{\n\tchar *oid_str, *is_merge_str, *desc, *name = NULL;\n\tconst char *type = NULL;\n\tint error = 0;\n\n\t*remote_url = NULL;\n\n\tif (!*line) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Empty line in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\t/* Compat with old git clients that wrote FETCH_HEAD like a loose ref. */\n\tif ((oid_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\toid_str = line;\n\t\tline += strlen(line);\n\n\t\t*is_merge = 1;\n\t}\n\n\tif (strlen(oid_str) != GIT_OID_HEXSZ) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Invalid object ID in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\tif (git_oid_fromstr(oid, oid_str) < 0) {\n\t\tconst git_error *oid_err = giterr_last();\n\t\tconst char *err_msg = oid_err ? oid_err->message : \"Invalid object ID\";\n\n\t\tgiterr_set(GITERR_FETCHHEAD, \"%s in FETCH_HEAD line %d\",\n\t\t\terr_msg, line_num);\n\t\treturn -1;\n\t}\n\n\t/* Parse new data from newer git clients */\n\tif (*line) {\n\t\tif ((is_merge_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description data in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*is_merge_str == '\\0')\n\t\t\t*is_merge = 1;\n\t\telse if (strcmp(is_merge_str, \"not-for-merge\") == 0)\n\t\t\t*is_merge = 0;\n\t\telse {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid for-merge entry in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((desc = line) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (git__prefixcmp(desc, \"branch '\") == 0) {\n\t\t\ttype = GIT_REFS_HEADS_DIR;\n\t\t\tname = desc + 8;\n\t\t} else if (git__prefixcmp(desc, \"tag '\") == 0) {\n\t\t\ttype = GIT_REFS_TAGS_DIR;\n\t\t\tname = desc + 5;\n\t\t} else if (git__prefixcmp(desc, \"'\") == 0)\n\t\t\tname = desc + 1;\n\n\t\tif (name) {\n\t\t\tif ((desc = strstr(name, \"' \")) == NULL ||\n\t\t\t\tgit__prefixcmp(desc, \"' of \") != 0) {\n\t\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*desc = '\\0';\n\t\t\tdesc += 5;\n\t\t}\n\n\t\t*remote_url = desc;\n\t}\n\n\tgit_buf_clear(ref_name);\n\n\tif (type)\n\t\tgit_buf_join(ref_name, '/', type, name);\n\telse if(name)\n\t\tgit_buf_puts(ref_name, name);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strsep",
          "args": [
            "&buffer",
            "\"\\n\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "git__strsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "307-322",
          "snippet": "char *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nchar *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_futils_readbuffer",
          "args": [
            "&file",
            "git_buf_cstr(&path)"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_readbuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "224-227",
          "snippet": "int git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_futils_readbuffer(git_buf *buf, const char *path)\n{\n\treturn git_futils_readbuffer_updated(buf, path, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "repo->path_repository",
            "GIT_FETCH_HEAD_FILE"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && cb"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nint git_repository_fetchhead_foreach(git_repository *repo,\n\tgit_repository_fetchhead_foreach_cb cb,\n\tvoid *payload)\n{\n\tgit_buf path = GIT_BUF_INIT, file = GIT_BUF_INIT, name = GIT_BUF_INIT;\n\tconst char *ref_name;\n\tgit_oid oid;\n\tconst char *remote_url;\n\tunsigned int is_merge = 0;\n\tchar *buffer, *line;\n\tsize_t line_num = 0;\n\tint error = 0;\n\n\tassert(repo && cb);\n\n\tif (git_buf_joinpath(&path, repo->path_repository, GIT_FETCH_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif ((error = git_futils_readbuffer(&file, git_buf_cstr(&path))) < 0)\n\t\tgoto done;\n\n\tbuffer = file.ptr;\n\n\twhile ((line = git__strsep(&buffer, \"\\n\")) != NULL) {\n\t\t++line_num;\n\n\t\tif ((error = fetchhead_ref_parse(\n\t\t\t\t&oid, &is_merge, &name, &remote_url, line, line_num)) < 0)\n\t\t\tgoto done;\n\n\t\tif (git_buf_len(&name) > 0)\n\t\t\tref_name = git_buf_cstr(&name);\n\t\telse\n\t\t\tref_name = NULL;\n\n\t\terror = cb(ref_name, remote_url, &oid, is_merge, payload);\n\t\tif (error) {\n\t\t\tgiterr_set_after_callback(error);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (*buffer) {\n\t\tgiterr_set(GITERR_FETCHHEAD, \"No EOL at line %d\", line_num+1);\n\t\terror = -1;\n\t\tgoto done;\n\t}\n\ndone:\n\tgit_buf_free(&file);\n\tgit_buf_free(&path);\n\tgit_buf_free(&name);\n\n\treturn error;\n}"
  },
  {
    "function_name": "fetchhead_ref_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "136-235",
    "snippet": "static int fetchhead_ref_parse(\n\tgit_oid *oid,\n\tunsigned int *is_merge,\n\tgit_buf *ref_name,\n\tconst char **remote_url,\n\tchar *line,\n\tsize_t line_num)\n{\n\tchar *oid_str, *is_merge_str, *desc, *name = NULL;\n\tconst char *type = NULL;\n\tint error = 0;\n\n\t*remote_url = NULL;\n\n\tif (!*line) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Empty line in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\t/* Compat with old git clients that wrote FETCH_HEAD like a loose ref. */\n\tif ((oid_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\toid_str = line;\n\t\tline += strlen(line);\n\n\t\t*is_merge = 1;\n\t}\n\n\tif (strlen(oid_str) != GIT_OID_HEXSZ) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Invalid object ID in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\tif (git_oid_fromstr(oid, oid_str) < 0) {\n\t\tconst git_error *oid_err = giterr_last();\n\t\tconst char *err_msg = oid_err ? oid_err->message : \"Invalid object ID\";\n\n\t\tgiterr_set(GITERR_FETCHHEAD, \"%s in FETCH_HEAD line %d\",\n\t\t\terr_msg, line_num);\n\t\treturn -1;\n\t}\n\n\t/* Parse new data from newer git clients */\n\tif (*line) {\n\t\tif ((is_merge_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description data in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*is_merge_str == '\\0')\n\t\t\t*is_merge = 1;\n\t\telse if (strcmp(is_merge_str, \"not-for-merge\") == 0)\n\t\t\t*is_merge = 0;\n\t\telse {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid for-merge entry in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((desc = line) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (git__prefixcmp(desc, \"branch '\") == 0) {\n\t\t\ttype = GIT_REFS_HEADS_DIR;\n\t\t\tname = desc + 8;\n\t\t} else if (git__prefixcmp(desc, \"tag '\") == 0) {\n\t\t\ttype = GIT_REFS_TAGS_DIR;\n\t\t\tname = desc + 5;\n\t\t} else if (git__prefixcmp(desc, \"'\") == 0)\n\t\t\tname = desc + 1;\n\n\t\tif (name) {\n\t\t\tif ((desc = strstr(name, \"' \")) == NULL ||\n\t\t\t\tgit__prefixcmp(desc, \"' of \") != 0) {\n\t\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*desc = '\\0';\n\t\t\tdesc += 5;\n\t\t}\n\n\t\t*remote_url = desc;\n\t}\n\n\tgit_buf_clear(ref_name);\n\n\tif (type)\n\t\tgit_buf_join(ref_name, '/', type, name);\n\telse if(name)\n\t\tgit_buf_puts(ref_name, name);\n\n\treturn error;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_puts",
          "args": [
            "ref_name",
            "name"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "225-229",
          "snippet": "int git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_puts(git_buf *buf, const char *string)\n{\n\tassert(string);\n\treturn git_buf_put(buf, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_join",
          "args": [
            "ref_name",
            "'/'",
            "type",
            "name"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "607-655",
          "snippet": "int git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_join(\n\tgit_buf *buf,\n\tchar separator,\n\tconst char *str_a,\n\tconst char *str_b)\n{\n\tsize_t strlen_a = str_a ? strlen(str_a) : 0;\n\tsize_t strlen_b = strlen(str_b);\n\tsize_t alloc_len;\n\tint need_sep = 0;\n\tssize_t offset_a = -1;\n\n\t/* not safe to have str_b point internally to the buffer */\n\tassert(str_b < buf->ptr || str_b >= buf->ptr + buf->size);\n\n\t/* figure out if we need to insert a separator */\n\tif (separator && strlen_a) {\n\t\twhile (*str_b == separator) { str_b++; strlen_b--; }\n\t\tif (str_a[strlen_a - 1] != separator)\n\t\t\tneed_sep = 1;\n\t}\n\n\t/* str_a could be part of the buffer */\n\tif (str_a >= buf->ptr && str_a < buf->ptr + buf->size)\n\t\toffset_a = str_a - buf->ptr;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, strlen_a, strlen_b);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, need_sep);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tif (git_buf_grow(buf, alloc_len) < 0)\n\t\treturn -1;\n\tassert(buf->ptr);\n\n\t/* fix up internal pointers */\n\tif (offset_a >= 0)\n\t\tstr_a = buf->ptr + offset_a;\n\n\t/* do the actual copying */\n\tif (offset_a != 0 && str_a)\n\t\tmemmove(buf->ptr, str_a, strlen_a);\n\tif (need_sep)\n\t\tbuf->ptr[strlen_a] = separator;\n\tmemcpy(buf->ptr + strlen_a + need_sep, str_b, strlen_b);\n\n\tbuf->size = strlen_a + strlen_b + need_sep;\n\tbuf->ptr[buf->size] = '\\0';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "ref_name"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_FETCHHEAD",
            "\"Invalid description in FETCH_HEAD line %d\"",
            "line_num"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "desc",
            "\"' of \""
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "name",
            "\"' \""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "is_merge_str",
            "\"not-for-merge\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strsep",
          "args": [
            "&line",
            "\"\\t\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "git__strsep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "307-322",
          "snippet": "char *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nchar *git__strsep(char **end, const char *sep)\n{\n\tchar *start = *end, *ptr = *end;\n\n\twhile (*ptr && !strchr(sep, *ptr))\n\t\t++ptr;\n\n\tif (*ptr) {\n\t\t*end = ptr + 1;\n\t\t*ptr = '\\0';\n\n\t\treturn start;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_last",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "134-137",
          "snippet": "const git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_fromstr",
          "args": [
            "oid",
            "oid_str"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fromstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "54-57",
          "snippet": "int git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nint git_oid_fromstr(git_oid *out, const char *str)\n{\n\treturn git_oid_fromstrn(out, str, GIT_OID_HEXSZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oid_str"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nstatic int fetchhead_ref_parse(\n\tgit_oid *oid,\n\tunsigned int *is_merge,\n\tgit_buf *ref_name,\n\tconst char **remote_url,\n\tchar *line,\n\tsize_t line_num)\n{\n\tchar *oid_str, *is_merge_str, *desc, *name = NULL;\n\tconst char *type = NULL;\n\tint error = 0;\n\n\t*remote_url = NULL;\n\n\tif (!*line) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Empty line in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\t/* Compat with old git clients that wrote FETCH_HEAD like a loose ref. */\n\tif ((oid_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\toid_str = line;\n\t\tline += strlen(line);\n\n\t\t*is_merge = 1;\n\t}\n\n\tif (strlen(oid_str) != GIT_OID_HEXSZ) {\n\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\"Invalid object ID in FETCH_HEAD line %d\", line_num);\n\t\treturn -1;\n\t}\n\n\tif (git_oid_fromstr(oid, oid_str) < 0) {\n\t\tconst git_error *oid_err = giterr_last();\n\t\tconst char *err_msg = oid_err ? oid_err->message : \"Invalid object ID\";\n\n\t\tgiterr_set(GITERR_FETCHHEAD, \"%s in FETCH_HEAD line %d\",\n\t\t\terr_msg, line_num);\n\t\treturn -1;\n\t}\n\n\t/* Parse new data from newer git clients */\n\tif (*line) {\n\t\tif ((is_merge_str = git__strsep(&line, \"\\t\")) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description data in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (*is_merge_str == '\\0')\n\t\t\t*is_merge = 1;\n\t\telse if (strcmp(is_merge_str, \"not-for-merge\") == 0)\n\t\t\t*is_merge = 0;\n\t\telse {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid for-merge entry in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((desc = line) == NULL) {\n\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (git__prefixcmp(desc, \"branch '\") == 0) {\n\t\t\ttype = GIT_REFS_HEADS_DIR;\n\t\t\tname = desc + 8;\n\t\t} else if (git__prefixcmp(desc, \"tag '\") == 0) {\n\t\t\ttype = GIT_REFS_TAGS_DIR;\n\t\t\tname = desc + 5;\n\t\t} else if (git__prefixcmp(desc, \"'\") == 0)\n\t\t\tname = desc + 1;\n\n\t\tif (name) {\n\t\t\tif ((desc = strstr(name, \"' \")) == NULL ||\n\t\t\t\tgit__prefixcmp(desc, \"' of \") != 0) {\n\t\t\t\tgiterr_set(GITERR_FETCHHEAD,\n\t\t\t\t\t\"Invalid description in FETCH_HEAD line %d\", line_num);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*desc = '\\0';\n\t\t\tdesc += 5;\n\t\t}\n\n\t\t*remote_url = desc;\n\t}\n\n\tgit_buf_clear(ref_name);\n\n\tif (type)\n\t\tgit_buf_join(ref_name, '/', type, name);\n\telse if(name)\n\t\tgit_buf_puts(ref_name, name);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_fetchhead_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "109-134",
    "snippet": "int git_fetchhead_write(git_repository *repo, git_vector *fetchhead_refs)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int i;\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(repo && fetchhead_refs);\n\n\tif (git_buf_joinpath(&path, repo->path_repository, GIT_FETCH_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_filebuf_open(&file, path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&path);\n\n\tgit_vector_sort(fetchhead_refs);\n\n\tgit_vector_foreach(fetchhead_refs, i, fetchhead_ref)\n\t\tfetchhead_ref_write(&file, fetchhead_ref);\n\n\treturn git_filebuf_commit(&file);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_commit",
          "args": [
            "&file"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "410-443",
          "snippet": "int git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_commit(git_filebuf *file)\n{\n\t/* temporary files cannot be committed */\n\tassert(file && file->path_original);\n\n\tfile->flush_mode = Z_FINISH;\n\tflush_buffer(file);\n\n\tif (verify_last_error(file) < 0)\n\t\tgoto on_error;\n\n\tfile->fd_is_open = false;\n\n\tif (p_close(file->fd) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to close file at '%s'\", file->path_lock);\n\t\tgoto on_error;\n\t}\n\n\tfile->fd = -1;\n\n\tif (p_rename(file->path_lock, file->path_original) < 0) {\n\t\tgiterr_set(GITERR_OS, \"Failed to rename lockfile to '%s'\", file->path_original);\n\t\tgoto on_error;\n\t}\n\n\tfile->did_rename = true;\n\n\tgit_filebuf_cleanup(file);\n\treturn 0;\n\non_error:\n\tgit_filebuf_cleanup(file);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fetchhead_ref_write",
          "args": [
            "&file",
            "fetchhead_ref"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "fetchhead_ref_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
          "lines": "71-107",
          "snippet": "static int fetchhead_ref_write(\n\tgit_filebuf *file,\n\tgit_fetchhead_ref *fetchhead_ref)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tconst char *type, *name;\n\tint head = 0;\n\n\tassert(file && fetchhead_ref);\n\n\tgit_oid_fmt(oid, &fetchhead_ref->oid);\n\toid[GIT_OID_HEXSZ] = '\\0';\n\n\tif (git__prefixcmp(fetchhead_ref->ref_name, GIT_REFS_HEADS_DIR) == 0) {\n\t\ttype = \"branch \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_HEADS_DIR);\n\t} else if(git__prefixcmp(fetchhead_ref->ref_name,\n\t\tGIT_REFS_TAGS_DIR) == 0) {\n\t\ttype = \"tag \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_TAGS_DIR);\n\t} else if (!git__strcmp(fetchhead_ref->ref_name, GIT_HEAD_FILE)) {\n\t\thead = 1;\n\t} else {\n\t\ttype = \"\";\n\t\tname = fetchhead_ref->ref_name;\n\t}\n\n\tif (head)\n\t\treturn git_filebuf_printf(file, \"%s\\t\\t%s\\n\", oid, fetchhead_ref->remote_url);\n\n\treturn git_filebuf_printf(file, \"%s\\t%s\\t%s'%s' of %s\\n\",\n\t\toid,\n\t\t(fetchhead_ref->is_merge) ? \"\" : \"not-for-merge\",\n\t\ttype,\n\t\tname,\n\t\tfetchhead_ref->remote_url);\n}",
          "includes": [
            "#include \"repository.h\"",
            "#include \"refs.h\"",
            "#include \"filebuf.h\"",
            "#include \"fileops.h\"",
            "#include \"buffer.h\"",
            "#include \"common.h\"",
            "#include \"fetchhead.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nstatic int fetchhead_ref_write(\n\tgit_filebuf *file,\n\tgit_fetchhead_ref *fetchhead_ref)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tconst char *type, *name;\n\tint head = 0;\n\n\tassert(file && fetchhead_ref);\n\n\tgit_oid_fmt(oid, &fetchhead_ref->oid);\n\toid[GIT_OID_HEXSZ] = '\\0';\n\n\tif (git__prefixcmp(fetchhead_ref->ref_name, GIT_REFS_HEADS_DIR) == 0) {\n\t\ttype = \"branch \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_HEADS_DIR);\n\t} else if(git__prefixcmp(fetchhead_ref->ref_name,\n\t\tGIT_REFS_TAGS_DIR) == 0) {\n\t\ttype = \"tag \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_TAGS_DIR);\n\t} else if (!git__strcmp(fetchhead_ref->ref_name, GIT_HEAD_FILE)) {\n\t\thead = 1;\n\t} else {\n\t\ttype = \"\";\n\t\tname = fetchhead_ref->ref_name;\n\t}\n\n\tif (head)\n\t\treturn git_filebuf_printf(file, \"%s\\t\\t%s\\n\", oid, fetchhead_ref->remote_url);\n\n\treturn git_filebuf_printf(file, \"%s\\t%s\\t%s'%s' of %s\\n\",\n\t\toid,\n\t\t(fetchhead_ref->is_merge) ? \"\" : \"not-for-merge\",\n\t\ttype,\n\t\tname,\n\t\tfetchhead_ref->remote_url);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "fetchhead_refs",
            "i",
            "fetchhead_ref"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "fetchhead_refs"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&path"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_filebuf_open",
          "args": [
            "&file",
            "path.ptr",
            "GIT_FILEBUF_FORCE",
            "GIT_REFS_FILE_MODE"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "274-383",
          "snippet": "int git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t WRITE_BUFFER_SIZE = (4096 * 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nstatic const size_t WRITE_BUFFER_SIZE = (4096 * 2);\n\nint git_filebuf_open(git_filebuf *file, const char *path, int flags, mode_t mode)\n{\n\tint compression, error = -1;\n\tsize_t path_len, alloc_len;\n\n\t/* opening an already open buffer is a programming error;\n\t * assert that this never happens instead of returning\n\t * an error code */\n\tassert(file && path && file->buffer == NULL);\n\n\tmemset(file, 0x0, sizeof(git_filebuf));\n\n\tif (flags & GIT_FILEBUF_DO_NOT_BUFFER)\n\t\tfile->do_not_buffer = true;\n\n\tfile->buf_size = WRITE_BUFFER_SIZE;\n\tfile->buf_pos = 0;\n\tfile->fd = -1;\n\tfile->last_error = BUFERR_OK;\n\n\t/* Allocate the main cache buffer */\n\tif (!file->do_not_buffer) {\n\t\tfile->buffer = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->buffer);\n\t}\n\n\t/* If we are hashing on-write, allocate a new hash context */\n\tif (flags & GIT_FILEBUF_HASH_CONTENTS) {\n\t\tfile->compute_digest = 1;\n\n\t\tif (git_hash_ctx_init(&file->digest) < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\tcompression = flags >> GIT_FILEBUF_DEFLATE_SHIFT;\n\n\t/* If we are deflating on-write, */\n\tif (compression != 0) {\n\t\t/* Initialize the ZLib stream */\n\t\tif (deflateInit(&file->zs, compression) != Z_OK) {\n\t\t\tgiterr_set(GITERR_ZLIB, \"Failed to initialize zlib\");\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Allocate the Zlib cache buffer */\n\t\tfile->z_buf = git__malloc(file->buf_size);\n\t\tGITERR_CHECK_ALLOC(file->z_buf);\n\n\t\t/* Never flush */\n\t\tfile->flush_mode = Z_NO_FLUSH;\n\t\tfile->write = &write_deflate;\n\t} else {\n\t\tfile->write = &write_normal;\n\t}\n\n\t/* If we are writing to a temp file */\n\tif (flags & GIT_FILEBUF_TEMPORARY) {\n\t\tgit_buf tmp_path = GIT_BUF_INIT;\n\n\t\t/* Open the file as temporary for locking */\n\t\tfile->fd = git_futils_mktmp(&tmp_path, path, mode);\n\n\t\tif (file->fd < 0) {\n\t\t\tgit_buf_free(&tmp_path);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tfile->fd_is_open = true;\n\t\tfile->created_lock = true;\n\n\t\t/* No original path */\n\t\tfile->path_original = NULL;\n\t\tfile->path_lock = git_buf_detach(&tmp_path);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\t} else {\n\t\tgit_buf resolved_path = GIT_BUF_INIT;\n\n\t\tif ((error = resolve_symlink(&resolved_path, path)) < 0)\n\t\t\tgoto cleanup;\n\n\t\t/* Save the original path of the file */\n\t\tpath_len = resolved_path.size;\n\t\tfile->path_original = git_buf_detach(&resolved_path);\n\n\t\t/* create the locking path by appending \".lock\" to the original */\n\t\tGITERR_CHECK_ALLOC_ADD(&alloc_len, path_len, GIT_FILELOCK_EXTLENGTH);\n\t\tfile->path_lock = git__malloc(alloc_len);\n\t\tGITERR_CHECK_ALLOC(file->path_lock);\n\n\t\tmemcpy(file->path_lock, file->path_original, path_len);\n\t\tmemcpy(file->path_lock + path_len, GIT_FILELOCK_EXTENSION, GIT_FILELOCK_EXTLENGTH);\n\n\t\tif (git_path_isdir(file->path_original)) {\n\t\t\tgiterr_set(GITERR_FILESYSTEM, \"path '%s' is a directory\", file->path_original);\n\t\t\terror = GIT_EDIRECTORY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* open the file for locking */\n\t\tif ((error = lock_file(file, flags, mode)) < 0)\n\t\t\tgoto cleanup;\n\n\t\tfile->created_lock = true;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tgit_filebuf_cleanup(file);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&path",
            "repo->path_repository",
            "GIT_FETCH_HEAD_FILE"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "repo && fetchhead_refs"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nint git_fetchhead_write(git_repository *repo, git_vector *fetchhead_refs)\n{\n\tgit_filebuf file = GIT_FILEBUF_INIT;\n\tgit_buf path = GIT_BUF_INIT;\n\tunsigned int i;\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(repo && fetchhead_refs);\n\n\tif (git_buf_joinpath(&path, repo->path_repository, GIT_FETCH_HEAD_FILE) < 0)\n\t\treturn -1;\n\n\tif (git_filebuf_open(&file, path.ptr, GIT_FILEBUF_FORCE, GIT_REFS_FILE_MODE) < 0) {\n\t\tgit_buf_free(&path);\n\t\treturn -1;\n\t}\n\n\tgit_buf_free(&path);\n\n\tgit_vector_sort(fetchhead_refs);\n\n\tgit_vector_foreach(fetchhead_refs, i, fetchhead_ref)\n\t\tfetchhead_ref_write(&file, fetchhead_ref);\n\n\treturn git_filebuf_commit(&file);\n}"
  },
  {
    "function_name": "fetchhead_ref_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "71-107",
    "snippet": "static int fetchhead_ref_write(\n\tgit_filebuf *file,\n\tgit_fetchhead_ref *fetchhead_ref)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tconst char *type, *name;\n\tint head = 0;\n\n\tassert(file && fetchhead_ref);\n\n\tgit_oid_fmt(oid, &fetchhead_ref->oid);\n\toid[GIT_OID_HEXSZ] = '\\0';\n\n\tif (git__prefixcmp(fetchhead_ref->ref_name, GIT_REFS_HEADS_DIR) == 0) {\n\t\ttype = \"branch \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_HEADS_DIR);\n\t} else if(git__prefixcmp(fetchhead_ref->ref_name,\n\t\tGIT_REFS_TAGS_DIR) == 0) {\n\t\ttype = \"tag \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_TAGS_DIR);\n\t} else if (!git__strcmp(fetchhead_ref->ref_name, GIT_HEAD_FILE)) {\n\t\thead = 1;\n\t} else {\n\t\ttype = \"\";\n\t\tname = fetchhead_ref->ref_name;\n\t}\n\n\tif (head)\n\t\treturn git_filebuf_printf(file, \"%s\\t\\t%s\\n\", oid, fetchhead_ref->remote_url);\n\n\treturn git_filebuf_printf(file, \"%s\\t%s\\t%s'%s' of %s\\n\",\n\t\toid,\n\t\t(fetchhead_ref->is_merge) ? \"\" : \"not-for-merge\",\n\t\ttype,\n\t\tname,\n\t\tfetchhead_ref->remote_url);\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_filebuf_printf",
          "args": [
            "file",
            "\"%s\\t%s\\t%s'%s' of %s\\n\"",
            "oid",
            "(fetchhead_ref->is_merge) ? \"\" : \"not-for-merge\"",
            "type",
            "name",
            "fetchhead_ref->remote_url"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "git_filebuf_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/filebuf.c",
          "lines": "502-556",
          "snippet": "int git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}",
          "includes": [
            "#include \"fileops.h\"",
            "#include \"filebuf.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fileops.h\"\n#include \"filebuf.h\"\n#include \"common.h\"\n\nint git_filebuf_printf(git_filebuf *file, const char *format, ...)\n{\n\tva_list arglist;\n\tsize_t space_left, len, alloclen;\n\tint written, res;\n\tchar *tmp_buffer;\n\n\tENSURE_BUF_OK(file);\n\n\tspace_left = file->buf_size - file->buf_pos;\n\n\tdo {\n\t\tva_start(arglist, format);\n\t\twritten = p_vsnprintf((char *)file->buffer + file->buf_pos, space_left, format, arglist);\n\t\tva_end(arglist);\n\n\t\tif (written < 0) {\n\t\t\tfile->last_error = BUFERR_MEM;\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen = written;\n\t\tif (len + 1 <= space_left) {\n\t\t\tfile->buf_pos += len;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (flush_buffer(file) < 0)\n\t\t\treturn -1;\n\n\t\tspace_left = file->buf_size - file->buf_pos;\n\n\t} while (len + 1 <= space_left);\n\n\tif (GIT_ADD_SIZET_OVERFLOW(&alloclen, len, 1) ||\n\t\t!(tmp_buffer = git__malloc(alloclen))) {\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tva_start(arglist, format);\n\twritten = p_vsnprintf(tmp_buffer, len + 1, format, arglist);\n\tva_end(arglist);\n\n\tif (written < 0) {\n\t\tgit__free(tmp_buffer);\n\t\tfile->last_error = BUFERR_MEM;\n\t\treturn -1;\n\t}\n\n\tres = git_filebuf_write(file, tmp_buffer, len);\n\tgit__free(tmp_buffer);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__strcmp",
          "args": [
            "fetchhead_ref->ref_name",
            "GIT_HEAD_FILE"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__prefixcmp",
          "args": [
            "fetchhead_ref->ref_name",
            "GIT_REFS_TAGS_DIR"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "git__prefixcmp_icase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "252-255",
          "snippet": "int git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__prefixcmp_icase(const char *str, const char *prefix)\n{\n\treturn strncasecmp(str, prefix, strlen(prefix));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GIT_REFS_HEADS_DIR"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_oid_fmt",
          "args": [
            "oid",
            "&fetchhead_ref->oid"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "88-91",
          "snippet": "void git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_fmt(char *str, const git_oid *oid)\n{\n\tgit_oid_nfmt(str, GIT_OID_HEXSZ, oid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "file && fetchhead_ref"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nstatic int fetchhead_ref_write(\n\tgit_filebuf *file,\n\tgit_fetchhead_ref *fetchhead_ref)\n{\n\tchar oid[GIT_OID_HEXSZ + 1];\n\tconst char *type, *name;\n\tint head = 0;\n\n\tassert(file && fetchhead_ref);\n\n\tgit_oid_fmt(oid, &fetchhead_ref->oid);\n\toid[GIT_OID_HEXSZ] = '\\0';\n\n\tif (git__prefixcmp(fetchhead_ref->ref_name, GIT_REFS_HEADS_DIR) == 0) {\n\t\ttype = \"branch \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_HEADS_DIR);\n\t} else if(git__prefixcmp(fetchhead_ref->ref_name,\n\t\tGIT_REFS_TAGS_DIR) == 0) {\n\t\ttype = \"tag \";\n\t\tname = fetchhead_ref->ref_name + strlen(GIT_REFS_TAGS_DIR);\n\t} else if (!git__strcmp(fetchhead_ref->ref_name, GIT_HEAD_FILE)) {\n\t\thead = 1;\n\t} else {\n\t\ttype = \"\";\n\t\tname = fetchhead_ref->ref_name;\n\t}\n\n\tif (head)\n\t\treturn git_filebuf_printf(file, \"%s\\t\\t%s\\n\", oid, fetchhead_ref->remote_url);\n\n\treturn git_filebuf_printf(file, \"%s\\t%s\\t%s'%s' of %s\\n\",\n\t\toid,\n\t\t(fetchhead_ref->is_merge) ? \"\" : \"not-for-merge\",\n\t\ttype,\n\t\tname,\n\t\tfetchhead_ref->remote_url);\n}"
  },
  {
    "function_name": "git_fetchhead_ref_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "39-69",
    "snippet": "int git_fetchhead_ref_create(\n\tgit_fetchhead_ref **out,\n\tgit_oid *oid,\n\tunsigned int is_merge,\n\tconst char *ref_name,\n\tconst char *remote_url)\n{\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(out && oid);\n\n\t*out = NULL;\n\n\tfetchhead_ref = git__malloc(sizeof(git_fetchhead_ref));\n\tGITERR_CHECK_ALLOC(fetchhead_ref);\n\n\tmemset(fetchhead_ref, 0x0, sizeof(git_fetchhead_ref));\n\n\tgit_oid_cpy(&fetchhead_ref->oid, oid);\n\tfetchhead_ref->is_merge = is_merge;\n\n\tif (ref_name)\n\t\tfetchhead_ref->ref_name = git__strdup(ref_name);\n\n\tif (remote_url)\n\t\tfetchhead_ref->remote_url = git__strdup(remote_url);\n\n\t*out = fetchhead_ref;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "remote_url"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&fetchhead_ref->oid",
            "oid"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fetchhead_ref",
            "0x0",
            "sizeof(git_fetchhead_ref)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "fetchhead_ref"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__malloc",
          "args": [
            "sizeof(git_fetchhead_ref)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "git__malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "160-165",
          "snippet": "GIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__malloc(size_t len)\n{\n\tvoid *ptr = malloc(len);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out && oid"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nint git_fetchhead_ref_create(\n\tgit_fetchhead_ref **out,\n\tgit_oid *oid,\n\tunsigned int is_merge,\n\tconst char *ref_name,\n\tconst char *remote_url)\n{\n\tgit_fetchhead_ref *fetchhead_ref;\n\n\tassert(out && oid);\n\n\t*out = NULL;\n\n\tfetchhead_ref = git__malloc(sizeof(git_fetchhead_ref));\n\tGITERR_CHECK_ALLOC(fetchhead_ref);\n\n\tmemset(fetchhead_ref, 0x0, sizeof(git_fetchhead_ref));\n\n\tgit_oid_cpy(&fetchhead_ref->oid, oid);\n\tfetchhead_ref->is_merge = is_merge;\n\n\tif (ref_name)\n\t\tfetchhead_ref->ref_name = git__strdup(ref_name);\n\n\tif (remote_url)\n\t\tfetchhead_ref->remote_url = git__strdup(remote_url);\n\n\t*out = fetchhead_ref;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_fetchhead_ref_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fetchhead.c",
    "lines": "19-37",
    "snippet": "int git_fetchhead_ref_cmp(const void *a, const void *b)\n{\n\tconst git_fetchhead_ref *one = (const git_fetchhead_ref *)a;\n\tconst git_fetchhead_ref *two = (const git_fetchhead_ref *)b;\n\n\tif (one->is_merge && !two->is_merge)\n\t\treturn -1;\n\tif (two->is_merge && !one->is_merge)\n\t\treturn 1;\n\n\tif (one->ref_name && two->ref_name)\n\t\treturn strcmp(one->ref_name, two->ref_name);\n\telse if (one->ref_name)\n\t\treturn -1;\n\telse if (two->ref_name)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"repository.h\"",
      "#include \"refs.h\"",
      "#include \"filebuf.h\"",
      "#include \"fileops.h\"",
      "#include \"buffer.h\"",
      "#include \"common.h\"",
      "#include \"fetchhead.h\"",
      "#include \"git2/oid.h\"",
      "#include \"git2/types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "one->ref_name",
            "two->ref_name"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"repository.h\"\n#include \"refs.h\"\n#include \"filebuf.h\"\n#include \"fileops.h\"\n#include \"buffer.h\"\n#include \"common.h\"\n#include \"fetchhead.h\"\n#include \"git2/oid.h\"\n#include \"git2/types.h\"\n\nint git_fetchhead_ref_cmp(const void *a, const void *b)\n{\n\tconst git_fetchhead_ref *one = (const git_fetchhead_ref *)a;\n\tconst git_fetchhead_ref *two = (const git_fetchhead_ref *)b;\n\n\tif (one->is_merge && !two->is_merge)\n\t\treturn -1;\n\tif (two->is_merge && !one->is_merge)\n\t\treturn 1;\n\n\tif (one->ref_name && two->ref_name)\n\t\treturn strcmp(one->ref_name, two->ref_name);\n\telse if (one->ref_name)\n\t\treturn -1;\n\telse if (two->ref_name)\n\t\treturn 1;\n\n\treturn 0;\n}"
  }
]