[
  {
    "function_name": "git_iterator_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "2116-2201",
    "snippet": "int git_iterator_walk(\n\tgit_iterator **iterators,\n\tsize_t cnt,\n\tgit_iterator_walk_cb cb,\n\tvoid *data)\n{\n\tconst git_index_entry **iterator_item;\t/* next in each iterator */\n\tconst git_index_entry **cur_items;\t\t/* current path in each iter */\n\tconst git_index_entry *first_match;\n\tsize_t i, j;\n\tint error = 0;\n\n\titerator_item = git__calloc(cnt, sizeof(git_index_entry *));\n\tcur_items = git__calloc(cnt, sizeof(git_index_entry *));\n\n\tGITERR_CHECK_ALLOC(iterator_item);\n\tGITERR_CHECK_ALLOC(cur_items);\n\n\t/* Set up the iterators */\n\tfor (i = 0; i < cnt; i++) {\n\t\terror = git_iterator_current(&iterator_item[i], iterators[i]);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tcur_items[i] = NULL;\n\n\t\tfirst_match = NULL;\n\n\t\t/* Find the next path(s) to consume from each iterator */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (iterator_item[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (first_match == NULL) {\n\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t} else {\n\t\t\t\tint path_diff = git_index_entry_cmp(iterator_item[i], first_match);\n\n\t\t\t\tif (path_diff < 0) {\n\t\t\t\t\t/* Found an index entry that sorts before the one we're\n\t\t\t\t\t * looking at.  Forget that we've seen the other and\n\t\t\t\t\t * look at the other iterators for this path.\n\t\t\t\t\t */\n\t\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\t\tcur_items[j] = NULL;\n\n\t\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t} else if (path_diff == 0) {\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (first_match == NULL)\n\t\t\tbreak;\n\n\t\tif ((error = cb(cur_items, data)) != 0)\n\t\t\tgoto done;\n\n\t\t/* Advance each iterator that participated */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (cur_items[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_iterator_advance(&iterator_item[i], iterators[i]);\n\n\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tgit__free((git_index_entry **)iterator_item);\n\tgit__free((git_index_entry **)cur_items);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "(git_index_entry **)cur_items"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "&iterator_item[i]",
            "iterators[i]"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb",
          "args": [
            "cur_items",
            "data"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "packfile_load__cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/odb_pack.c",
          "lines": "193-226",
          "snippet": "static int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}",
          "includes": [
            "#include \"git2/odb_backend.h\"",
            "#include \"pack.h\"",
            "#include \"mwindow.h\"",
            "#include \"sha1_lookup.h\"",
            "#include \"delta-apply.h\"",
            "#include \"odb.h\"",
            "#include \"hash.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/sys/odb_backend.h\"",
            "#include \"git2/indexer.h\"",
            "#include \"git2/repository.h\"",
            "#include <zlib.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int packfile_load__cb(void *_data, git_buf *path);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/odb_backend.h\"\n#include \"pack.h\"\n#include \"mwindow.h\"\n#include \"sha1_lookup.h\"\n#include \"delta-apply.h\"\n#include \"odb.h\"\n#include \"hash.h\"\n#include \"fileops.h\"\n#include \"git2/sys/odb_backend.h\"\n#include \"git2/indexer.h\"\n#include \"git2/repository.h\"\n#include <zlib.h>\n#include \"common.h\"\n\nstatic int packfile_load__cb(void *_data, git_buf *path);\n\nstatic int packfile_load__cb(void *data, git_buf *path)\n{\n\tstruct pack_backend *backend = data;\n\tstruct git_pack_file *pack;\n\tconst char *path_str = git_buf_cstr(path);\n\tsize_t i, cmp_len = git_buf_len(path);\n\tint error;\n\n\tif (cmp_len <= strlen(\".idx\") || git__suffixcmp(path_str, \".idx\") != 0)\n\t\treturn 0; /* not an index */\n\n\tcmp_len -= strlen(\".idx\");\n\n\tfor (i = 0; i < backend->packs.length; ++i) {\n\t\tstruct git_pack_file *p = git_vector_get(&backend->packs, i);\n\n\t\tif (memcmp(p->pack_name, path_str, cmp_len) == 0)\n\t\t\treturn 0;\n\t}\n\n\terror = git_mwindow_get_pack(&pack, path->ptr);\n\n\t/* ignore missing .pack file as git does */\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\treturn 0;\n\t}\n\n\tif (!error)\n\t\terror = git_vector_insert(&backend->packs, pack);\n\n\treturn error;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_cmp",
          "args": [
            "iterator_item[i]",
            "first_match"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "217-229",
          "snippet": "int git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_entry_cmp(const void *a, const void *b)\n{\n\tint diff;\n\tconst git_index_entry *entry_a = a;\n\tconst git_index_entry *entry_b = b;\n\n\tdiff = strcmp(entry_a->path, entry_b->path);\n\n\tif (diff == 0)\n\t\tdiff = (GIT_IDXENTRY_STAGE(entry_a) - GIT_IDXENTRY_STAGE(entry_b));\n\n\treturn diff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_current",
          "args": [
            "&iterator_item[i]",
            "iterators[i]"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_workdir_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2014-2024",
          "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "cur_items"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "iterator_item"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "cnt",
            "sizeof(git_index_entry *)"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_walk(\n\tgit_iterator **iterators,\n\tsize_t cnt,\n\tgit_iterator_walk_cb cb,\n\tvoid *data)\n{\n\tconst git_index_entry **iterator_item;\t/* next in each iterator */\n\tconst git_index_entry **cur_items;\t\t/* current path in each iter */\n\tconst git_index_entry *first_match;\n\tsize_t i, j;\n\tint error = 0;\n\n\titerator_item = git__calloc(cnt, sizeof(git_index_entry *));\n\tcur_items = git__calloc(cnt, sizeof(git_index_entry *));\n\n\tGITERR_CHECK_ALLOC(iterator_item);\n\tGITERR_CHECK_ALLOC(cur_items);\n\n\t/* Set up the iterators */\n\tfor (i = 0; i < cnt; i++) {\n\t\terror = git_iterator_current(&iterator_item[i], iterators[i]);\n\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\n\twhile (true) {\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tcur_items[i] = NULL;\n\n\t\tfirst_match = NULL;\n\n\t\t/* Find the next path(s) to consume from each iterator */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (iterator_item[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\tif (first_match == NULL) {\n\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t} else {\n\t\t\t\tint path_diff = git_index_entry_cmp(iterator_item[i], first_match);\n\n\t\t\t\tif (path_diff < 0) {\n\t\t\t\t\t/* Found an index entry that sorts before the one we're\n\t\t\t\t\t * looking at.  Forget that we've seen the other and\n\t\t\t\t\t * look at the other iterators for this path.\n\t\t\t\t\t */\n\t\t\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\t\t\tcur_items[j] = NULL;\n\n\t\t\t\t\tfirst_match = iterator_item[i];\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t} else if (path_diff == 0) {\n\t\t\t\t\tcur_items[i] = iterator_item[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (first_match == NULL)\n\t\t\tbreak;\n\n\t\tif ((error = cb(cur_items, data)) != 0)\n\t\t\tgoto done;\n\n\t\t/* Advance each iterator that participated */\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tif (cur_items[i] == NULL)\n\t\t\t\tcontinue;\n\n\t\t\terror = git_iterator_advance(&iterator_item[i], iterators[i]);\n\n\t\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tgit__free((git_index_entry **)iterator_item);\n\tgit__free((git_index_entry **)cur_items);\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_iterator_advance_over_with_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "2038-2114",
    "snippet": "int git_iterator_advance_over_with_status(\n\tconst git_index_entry **entryptr,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iter)\n{\n\tint error = 0;\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\tchar *base = NULL;\n\tconst git_index_entry *entry;\n\n\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn git_iterator_advance(entryptr, iter);\n\tif ((error = git_iterator_current(&entry, iter)) < 0)\n\t\treturn error;\n\n\tif (!S_ISDIR(entry->mode)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\treturn git_iterator_advance(entryptr, iter);\n\t}\n\n\t*status = GIT_ITERATOR_STATUS_EMPTY;\n\n\tbase = git__strdup(entry->path);\n\tGITERR_CHECK_ALLOC(base);\n\n\t/* scan inside directory looking for a non-ignored item */\n\twhile (entry && !iter->prefixcomp(entry->path, base)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\n\t\t/* if we found an explicitly ignored item, then update from\n\t\t * EMPTY to IGNORED\n\t\t */\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\telse if (S_ISDIR(entry->mode)) {\n\t\t\terror = git_iterator_advance_into(&entry, iter);\n\n\t\t\tif (!error)\n\t\t\t\tcontinue;\n\n\t\t\telse if (error == GIT_ENOTFOUND) {\n\t\t\t\t/* we entered this directory only hoping to find child matches to\n\t\t\t\t * our pathlist (eg, this is `foo` and we had a pathlist entry for\n\t\t\t\t * `foo/bar`).  it should not be ignored, it should be excluded.\n\t\t\t\t */\n\t\t\t\tif (wi->fi.pathlist_match == ITERATOR_PATHLIST_MATCH_CHILD)\n\t\t\t\t\t*status = GIT_ITERATOR_STATUS_FILTERED;\n\t\t\t\telse\n\t\t\t\t\twi->is_ignored = GIT_IGNORE_TRUE; /* mark empty dirs ignored */\n\n\t\t\t\terror = 0;\n\t\t\t} else\n\t\t\t\tbreak; /* real error, stop here */\n\t\t} else {\n\t\t\t/* we found a non-ignored item, treat parent as untracked */\n\t\t\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\t}\n\n\t/* wrap up scan back to base directory */\n\twhile (entry && !iter->prefixcomp(entry->path, base))\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\n\t*entryptr = entry;\n\tgit__free(base);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "base"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_advance",
          "args": [
            "&entry",
            "iter"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_advance_into_or_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.h",
          "lines": "192-201",
          "snippet": "GIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"ignore.h\"",
            "#include \"buffer.h\"",
            "#include \"vector.h\"",
            "#include \"git2/index.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ignore.h\"\n#include \"buffer.h\"\n#include \"vector.h\"\n#include \"git2/index.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_iterator_advance_into_or_over(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = iter->cb->advance_into(entry, iter);\n\tif (error == GIT_ENOTFOUND) {\n\t\tgiterr_clear();\n\t\terror = iter->cb->advance(entry, iter);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->prefixcomp",
          "args": [
            "entry->path",
            "base"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->mode"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "workdir_iterator_update_is_ignored",
          "args": [
            "wi"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "workdir_iterator_update_is_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1960-1972",
          "snippet": "static void workdir_iterator_update_is_ignored(workdir_iterator *wi)\n{\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&wi->fi.entry);\n\n\tif (git_ignore__lookup(&wi->is_ignored, &wi->ignores, wi->fi.entry.path, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\twi->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* use ignore from containing frame stack */\n\tif (wi->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\twi->is_ignored = wi->fi.stack->is_ignored;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void workdir_iterator_update_is_ignored(workdir_iterator *wi)\n{\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&wi->fi.entry);\n\n\tif (git_ignore__lookup(&wi->is_ignored, &wi->ignores, wi->fi.entry.path, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\twi->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* use ignore from containing frame stack */\n\tif (wi->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\twi->is_ignored = wi->fi.stack->is_ignored;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->prefixcomp",
          "args": [
            "entry->path",
            "base"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "base"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "entry->path"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->mode"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_current",
          "args": [
            "&entry",
            "iter"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_workdir_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2014-2024",
          "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_advance_over_with_status(\n\tconst git_index_entry **entryptr,\n\tgit_iterator_status_t *status,\n\tgit_iterator *iter)\n{\n\tint error = 0;\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\tchar *base = NULL;\n\tconst git_index_entry *entry;\n\n\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn git_iterator_advance(entryptr, iter);\n\tif ((error = git_iterator_current(&entry, iter)) < 0)\n\t\treturn error;\n\n\tif (!S_ISDIR(entry->mode)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\treturn git_iterator_advance(entryptr, iter);\n\t}\n\n\t*status = GIT_ITERATOR_STATUS_EMPTY;\n\n\tbase = git__strdup(entry->path);\n\tGITERR_CHECK_ALLOC(base);\n\n\t/* scan inside directory looking for a non-ignored item */\n\twhile (entry && !iter->prefixcomp(entry->path, base)) {\n\t\tworkdir_iterator_update_is_ignored(wi);\n\n\t\t/* if we found an explicitly ignored item, then update from\n\t\t * EMPTY to IGNORED\n\t\t */\n\t\tif (wi->is_ignored == GIT_IGNORE_TRUE)\n\t\t\t*status = GIT_ITERATOR_STATUS_IGNORED;\n\t\telse if (S_ISDIR(entry->mode)) {\n\t\t\terror = git_iterator_advance_into(&entry, iter);\n\n\t\t\tif (!error)\n\t\t\t\tcontinue;\n\n\t\t\telse if (error == GIT_ENOTFOUND) {\n\t\t\t\t/* we entered this directory only hoping to find child matches to\n\t\t\t\t * our pathlist (eg, this is `foo` and we had a pathlist entry for\n\t\t\t\t * `foo/bar`).  it should not be ignored, it should be excluded.\n\t\t\t\t */\n\t\t\t\tif (wi->fi.pathlist_match == ITERATOR_PATHLIST_MATCH_CHILD)\n\t\t\t\t\t*status = GIT_ITERATOR_STATUS_FILTERED;\n\t\t\t\telse\n\t\t\t\t\twi->is_ignored = GIT_IGNORE_TRUE; /* mark empty dirs ignored */\n\n\t\t\t\terror = 0;\n\t\t\t} else\n\t\t\t\tbreak; /* real error, stop here */\n\t\t} else {\n\t\t\t/* we found a non-ignored item, treat parent as untracked */\n\t\t\t*status = GIT_ITERATOR_STATUS_NORMAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\t}\n\n\t/* wrap up scan back to base directory */\n\twhile (entry && !iter->prefixcomp(entry->path, base))\n\t\tif ((error = git_iterator_advance(&entry, iter)) < 0)\n\t\t\tbreak;\n\n\t*entryptr = entry;\n\tgit__free(base);\n\n\treturn error;\n}"
  },
  {
    "function_name": "git_iterator_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "2026-2036",
    "snippet": "int git_iterator_index(git_index **out, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\t*out = NULL;\n\n\t*out = wi->index;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_index(git_index **out, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\t*out = NULL;\n\n\t*out = wi->index;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_iterator_current_workdir_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "2014-2024",
    "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_iterator_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1999-2012",
    "snippet": "int git_iterator_cmp(git_iterator *iter, const char *path_prefix)\n{\n\tconst git_index_entry *entry;\n\n\t/* a \"done\" iterator is after every prefix */\n\tif (git_iterator_current(&entry, iter) < 0 || entry == NULL)\n\t\treturn 1;\n\n\t/* a NULL prefix is after any valid iterator */\n\tif (!path_prefix)\n\t\treturn -1;\n\n\treturn iter->prefixcomp(entry->path, path_prefix);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter->prefixcomp",
          "args": [
            "entry->path",
            "path_prefix"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_current",
          "args": [
            "&entry",
            "iter"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_current_workdir_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "2014-2024",
          "snippet": "int git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_current_workdir_path(git_buf **path, git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR || !wi->fi.entry.path)\n\t\t*path = NULL;\n\telse\n\t\t*path = &wi->fi.path;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_cmp(git_iterator *iter, const char *path_prefix)\n{\n\tconst git_index_entry *entry;\n\n\t/* a \"done\" iterator is after every prefix */\n\tif (git_iterator_current(&entry, iter) < 0 || entry == NULL)\n\t\treturn 1;\n\n\t/* a NULL prefix is after any valid iterator */\n\tif (!path_prefix)\n\t\treturn -1;\n\n\treturn iter->prefixcomp(entry->path, path_prefix);\n}"
  },
  {
    "function_name": "git_iterator_current_tree_is_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1989-1997",
    "snippet": "bool git_iterator_current_tree_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\treturn (bool)(wi->fi.stack->is_ignored == GIT_IGNORE_TRUE);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nbool git_iterator_current_tree_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\treturn (bool)(wi->fi.stack->is_ignored == GIT_IGNORE_TRUE);\n}"
  },
  {
    "function_name": "git_iterator_current_is_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1974-1987",
    "snippet": "bool git_iterator_current_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\tif (wi->is_ignored != GIT_IGNORE_UNCHECKED)\n\t\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n\n\tworkdir_iterator_update_is_ignored(wi);\n\n\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "workdir_iterator_update_is_ignored",
          "args": [
            "wi"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "workdir_iterator_update_is_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1960-1972",
          "snippet": "static void workdir_iterator_update_is_ignored(workdir_iterator *wi)\n{\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&wi->fi.entry);\n\n\tif (git_ignore__lookup(&wi->is_ignored, &wi->ignores, wi->fi.entry.path, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\twi->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* use ignore from containing frame stack */\n\tif (wi->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\twi->is_ignored = wi->fi.stack->is_ignored;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void workdir_iterator_update_is_ignored(workdir_iterator *wi)\n{\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&wi->fi.entry);\n\n\tif (git_ignore__lookup(&wi->is_ignored, &wi->ignores, wi->fi.entry.path, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\twi->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* use ignore from containing frame stack */\n\tif (wi->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\twi->is_ignored = wi->fi.stack->is_ignored;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nbool git_iterator_current_is_ignored(git_iterator *iter)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)iter;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_WORKDIR)\n\t\treturn false;\n\n\tif (wi->is_ignored != GIT_IGNORE_UNCHECKED)\n\t\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n\n\tworkdir_iterator_update_is_ignored(wi);\n\n\treturn (bool)(wi->is_ignored == GIT_IGNORE_TRUE);\n}"
  },
  {
    "function_name": "workdir_iterator_update_is_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1960-1972",
    "snippet": "static void workdir_iterator_update_is_ignored(workdir_iterator *wi)\n{\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&wi->fi.entry);\n\n\tif (git_ignore__lookup(&wi->is_ignored, &wi->ignores, wi->fi.entry.path, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\twi->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* use ignore from containing frame stack */\n\tif (wi->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\twi->is_ignored = wi->fi.stack->is_ignored;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_ignore__lookup",
          "args": [
            "&wi->is_ignored",
            "&wi->ignores",
            "wi->fi.entry.path",
            "dir_flag"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "430-462",
          "snippet": "int git_ignore__lookup(\n\tint *out, git_ignores *ignores, const char *pathname, git_dir_flag dir_flag)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\tgit_attr_path path;\n\n\t*out = GIT_IGNORE_NOTFOUND;\n\n\tif (git_attr_path__init(\n\t\t&path, pathname, git_repository_workdir(ignores->repo), dir_flag) < 0)\n\t\treturn -1;\n\n\t/* first process builtins - success means path was found */\n\tif (ignore_lookup_in_rules(out, ignores->ign_internal, &path))\n\t\tgoto cleanup;\n\n\t/* next process files in the path */\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* last process global ignores */\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_attr_path__free(&path);\n\treturn 0;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__lookup(\n\tint *out, git_ignores *ignores, const char *pathname, git_dir_flag dir_flag)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\tgit_attr_path path;\n\n\t*out = GIT_IGNORE_NOTFOUND;\n\n\tif (git_attr_path__init(\n\t\t&path, pathname, git_repository_workdir(ignores->repo), dir_flag) < 0)\n\t\treturn -1;\n\n\t/* first process builtins - success means path was found */\n\tif (ignore_lookup_in_rules(out, ignores->ign_internal, &path))\n\t\tgoto cleanup;\n\n\t/* next process files in the path */\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* last process global ignores */\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_attr_path__free(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_entry__dir_flag",
          "args": [
            "&wi->fi.entry"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "git_entry__dir_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1722-1731",
          "snippet": "GIT_INLINE(git_dir_flag) git_entry__dir_flag(git_index_entry *entry) {\n#if defined(GIT_WIN32) && !defined(__MINGW32__)\n\treturn (entry && entry->mode)\n\t\t? S_ISDIR(entry->mode) ? GIT_DIR_FLAG_TRUE : GIT_DIR_FLAG_FALSE\n\t\t: GIT_DIR_FLAG_UNKNOWN;\n#else\n\tGIT_UNUSED(entry);\n\treturn GIT_DIR_FLAG_UNKNOWN;\n#endif\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(git_dir_flag) git_entry__dir_flag(git_index_entry *entry) {\n#if defined(GIT_WIN32) && !defined(__MINGW32__)\n\treturn (entry && entry->mode)\n\t\t? S_ISDIR(entry->mode) ? GIT_DIR_FLAG_TRUE : GIT_DIR_FLAG_FALSE\n\t\t: GIT_DIR_FLAG_UNKNOWN;\n#else\n\tGIT_UNUSED(entry);\n\treturn GIT_DIR_FLAG_UNKNOWN;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void workdir_iterator_update_is_ignored(workdir_iterator *wi)\n{\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&wi->fi.entry);\n\n\tif (git_ignore__lookup(&wi->is_ignored, &wi->ignores, wi->fi.entry.path, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\twi->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* use ignore from containing frame stack */\n\tif (wi->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\twi->is_ignored = wi->fi.stack->is_ignored;\n}"
  },
  {
    "function_name": "git_iterator_current_parent_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1929-1958",
    "snippet": "int git_iterator_current_parent_tree(\n\tconst git_tree **tree_ptr,\n\tgit_iterator *iter,\n\tconst char *parent_path)\n{\n\ttree_iterator *ti = (tree_iterator *)iter;\n\ttree_iterator_frame *tf;\n\tconst char *scan = parent_path;\n\tconst git_tree_entry *te;\n\n\t*tree_ptr = NULL;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_TREE)\n\t\treturn 0;\n\n\tfor (tf = ti->root; *scan; ) {\n\t\tif (!(tf = tf->down) ||\n\t\t\ttf->current >= tf->n_entries ||\n\t\t\t!(te = tf->entries[tf->current]->te) ||\n\t\t\tti->base.strncomp(scan, te->filename, te->filename_len) != 0)\n\t\t\treturn 0;\n\n\t\tscan += te->filename_len;\n\t\tif (*scan == '/')\n\t\t\tscan++;\n\t}\n\n\t*tree_ptr = tf->entries[tf->current]->tree;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ti->base.strncomp",
          "args": [
            "scan",
            "te->filename",
            "te->filename_len"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_current_parent_tree(\n\tconst git_tree **tree_ptr,\n\tgit_iterator *iter,\n\tconst char *parent_path)\n{\n\ttree_iterator *ti = (tree_iterator *)iter;\n\ttree_iterator_frame *tf;\n\tconst char *scan = parent_path;\n\tconst git_tree_entry *te;\n\n\t*tree_ptr = NULL;\n\n\tif (iter->type != GIT_ITERATOR_TYPE_TREE)\n\t\treturn 0;\n\n\tfor (tf = ti->root; *scan; ) {\n\t\tif (!(tf = tf->down) ||\n\t\t\ttf->current >= tf->n_entries ||\n\t\t\t!(te = tf->entries[tf->current]->te) ||\n\t\t\tti->base.strncomp(scan, te->filename, te->filename_len) != 0)\n\t\t\treturn 0;\n\n\t\tscan += te->filename_len;\n\t\tif (*scan == '/')\n\t\t\tscan++;\n\t}\n\n\t*tree_ptr = tf->entries[tf->current]->tree;\n\treturn 0;\n}"
  },
  {
    "function_name": "git_iterator_current_tree_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1915-1927",
    "snippet": "int git_iterator_current_tree_entry(\n\tconst git_tree_entry **tree_entry, git_iterator *iter)\n{\n\tif (iter->type != GIT_ITERATOR_TYPE_TREE)\n\t\t*tree_entry = NULL;\n\telse {\n\t\ttree_iterator_frame *tf = ((tree_iterator *)iter)->head;\n\t\t*tree_entry = (tf->current < tf->n_entries) ?\n\t\t\ttf->entries[tf->current]->te : NULL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_current_tree_entry(\n\tconst git_tree_entry **tree_entry, git_iterator *iter)\n{\n\tif (iter->type != GIT_ITERATOR_TYPE_TREE)\n\t\t*tree_entry = NULL;\n\telse {\n\t\ttree_iterator_frame *tf = ((tree_iterator *)iter)->head;\n\t\t*tree_entry = (tf->current < tf->n_entries) ?\n\t\t\ttf->entries[tf->current]->te : NULL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_iterator_get_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1908-1913",
    "snippet": "git_index *git_iterator_get_index(git_iterator *iter)\n{\n\tif (iter->type == GIT_ITERATOR_TYPE_INDEX)\n\t\treturn ((index_iterator *)iter)->index;\n\treturn NULL;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\ngit_index *git_iterator_get_index(git_iterator *iter)\n{\n\tif (iter->type == GIT_ITERATOR_TYPE_INDEX)\n\t\treturn ((index_iterator *)iter)->index;\n\treturn NULL;\n}"
  },
  {
    "function_name": "git_iterator_set_ignore_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1887-1906",
    "snippet": "int git_iterator_set_ignore_case(git_iterator *iter, bool ignore_case)\n{\n\tbool desire_ignore_case  = (ignore_case != 0);\n\n\tif (iterator__ignore_case(iter) == desire_ignore_case)\n\t\treturn 0;\n\n\tif (iter->type == GIT_ITERATOR_TYPE_EMPTY) {\n\t\tif (desire_ignore_case)\n\t\t\titer->flags |= GIT_ITERATOR_IGNORE_CASE;\n\t\telse\n\t\t\titer->flags &= ~GIT_ITERATOR_IGNORE_CASE;\n\t} else {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Cannot currently set ignore case on non-empty iterators\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_INVALID",
            "\"Cannot currently set ignore case on non-empty iterators\""
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set_after_callback_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/common.h",
          "lines": "122-132",
          "snippet": "GIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include <regex.h>",
            "#include \"integer.h\"",
            "#include \"thread-utils.h\"",
            "#include \"git2/errors.h\"",
            "#include \"git2/types.h\"",
            "# include <arpa/inet.h>",
            "#\tinclude <sched.h>",
            "#\tinclude <pthread.h>",
            "# include <strings.h>",
            "# include <unistd.h>",
            "#   include \"win32/w32_crtdbg_stacktrace.h\"",
            "#   include \"win32/w32_stack.h\"",
            "#\tinclude \"win32/thread.h\"",
            "# include \"win32/version.h\"",
            "# include \"win32/error.h\"",
            "# include \"win32/win32-compat.h\"",
            "# include \"win32/mingw-compat.h\"",
            "# include \"win32/msvc-compat.h\"",
            "# include <ws2tcpip.h>",
            "# include <windows.h>",
            "# include <winsock2.h>",
            "# include <direct.h>",
            "# include <io.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"cc-compat.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include <regex.h>\n#include \"integer.h\"\n#include \"thread-utils.h\"\n#include \"git2/errors.h\"\n#include \"git2/types.h\"\n# include <arpa/inet.h>\n#\tinclude <sched.h>\n#\tinclude <pthread.h>\n# include <strings.h>\n# include <unistd.h>\n#   include \"win32/w32_crtdbg_stacktrace.h\"\n#   include \"win32/w32_stack.h\"\n#\tinclude \"win32/thread.h\"\n# include \"win32/version.h\"\n# include \"win32/error.h\"\n# include \"win32/win32-compat.h\"\n# include \"win32/mingw-compat.h\"\n# include \"win32/msvc-compat.h\"\n# include <ws2tcpip.h>\n# include <windows.h>\n# include <winsock2.h>\n# include <direct.h>\n# include <io.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <errno.h>\n#include <assert.h>\n#include \"cc-compat.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "iter"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_set_ignore_case(git_iterator *iter, bool ignore_case)\n{\n\tbool desire_ignore_case  = (ignore_case != 0);\n\n\tif (iterator__ignore_case(iter) == desire_ignore_case)\n\t\treturn 0;\n\n\tif (iter->type == GIT_ITERATOR_TYPE_EMPTY) {\n\t\tif (desire_ignore_case)\n\t\t\titer->flags |= GIT_ITERATOR_IGNORE_CASE;\n\t\telse\n\t\t\titer->flags &= ~GIT_ITERATOR_IGNORE_CASE;\n\t} else {\n\t\tgiterr_set(GITERR_INVALID,\n\t\t\t\"Cannot currently set ignore case on non-empty iterators\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_iterator_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1871-1885",
    "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iter"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iter",
            "0",
            "sizeof(*iter)"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_free",
          "args": [
            "&iter->pathlist"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->cb->free",
          "args": [
            "iter"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
  },
  {
    "function_name": "git_iterator_for_workdir_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1815-1869",
    "snippet": "int git_iterator_for_workdir_ext(\n\tgit_iterator **out,\n\tgit_repository *repo,\n\tconst char *repo_workdir,\n\tgit_index *index,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error, precompose = 0;\n\tworkdir_iterator *wi;\n\n\tif (!repo_workdir) {\n\t\tif (git_repository__ensure_not_bare(repo, \"scan working directory\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\t\trepo_workdir = git_repository_workdir(repo);\n\t}\n\n\t/* initialize as an fs iterator then do overrides */\n\twi = git__calloc(1, sizeof(workdir_iterator));\n\tGITERR_CHECK_ALLOC(wi);\n\tITERATOR_BASE_INIT((&wi->fi), fs, FS, repo);\n\n\twi->fi.base.type = GIT_ITERATOR_TYPE_WORKDIR;\n\twi->fi.cb.free = workdir_iterator__free;\n\twi->fi.enter_dir_cb = workdir_iterator__enter_dir;\n\twi->fi.leave_dir_cb = workdir_iterator__leave_dir;\n\twi->fi.update_entry_cb = workdir_iterator__update_entry;\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)wi, options ? options->flags : 0)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, \".gitignore\", &wi->ignores)) < 0)\n\t{\n\t\tgit_iterator_free((git_iterator *)wi);\n\t\treturn error;\n\t}\n\n\tif (tree && (error = git_object_dup((git_object **)&wi->tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\twi->index = index;\n\tif (index && (error = git_index_snapshot_new(&wi->index_snapshot, index)) < 0) {\n\t\tgit_iterator_free((git_iterator *)wi);\n\t\treturn error;\n\t}\n\twi->entry_srch = iterator__ignore_case(wi) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\n\t/* try to look up precompose and set flag if appropriate */\n\tif (git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) < 0)\n\t\tgiterr_clear();\n\telse if (precompose)\n\t\twi->fi.base.flags |= GIT_ITERATOR_PRECOMPOSE_UNICODE;\n\n\treturn fs_iterator__initialize(out, &wi->fi, repo_workdir);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__initialize",
          "args": [
            "out",
            "&wi->fi",
            "repo_workdir"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1596-1625",
          "snippet": "static int fs_iterator__initialize(\n\tgit_iterator **out, fs_iterator *fi, const char *root)\n{\n\tint error;\n\n\tif (git_buf_sets(&fi->path, root) < 0 || git_path_to_dir(&fi->path) < 0) {\n\t\tgit__free(fi);\n\t\treturn -1;\n\t}\n\tfi->root_len = fi->path.size;\n\tfi->pathlist_match = ITERATOR_PATHLIST_MATCH_CHILD;\n\n\tfi->dirload_flags =\n\t\t(iterator__ignore_case(fi) ? GIT_PATH_DIR_IGNORE_CASE : 0) |\n\t\t(iterator__flag(fi, PRECOMPOSE_UNICODE) ?\n\t\t\tGIT_PATH_DIR_PRECOMPOSE_UNICODE : 0);\n\n\tif ((error = fs_iterator__expand_dir(fi)) < 0) {\n\t\tif (error == GIT_ENOTFOUND || error == GIT_ITEROVER) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else {\n\t\t\tgit_iterator_free((git_iterator *)fi);\n\t\t\tfi = NULL;\n\t\t}\n\t}\n\n\t*out = (git_iterator *)fi;\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__initialize(\n\tgit_iterator **out, fs_iterator *fi, const char *root)\n{\n\tint error;\n\n\tif (git_buf_sets(&fi->path, root) < 0 || git_path_to_dir(&fi->path) < 0) {\n\t\tgit__free(fi);\n\t\treturn -1;\n\t}\n\tfi->root_len = fi->path.size;\n\tfi->pathlist_match = ITERATOR_PATHLIST_MATCH_CHILD;\n\n\tfi->dirload_flags =\n\t\t(iterator__ignore_case(fi) ? GIT_PATH_DIR_IGNORE_CASE : 0) |\n\t\t(iterator__flag(fi, PRECOMPOSE_UNICODE) ?\n\t\t\tGIT_PATH_DIR_PRECOMPOSE_UNICODE : 0);\n\n\tif ((error = fs_iterator__expand_dir(fi)) < 0) {\n\t\tif (error == GIT_ENOTFOUND || error == GIT_ITEROVER) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else {\n\t\t\tgit_iterator_free((git_iterator *)fi);\n\t\t\tfi = NULL;\n\t\t}\n\t}\n\n\t*out = (git_iterator *)fi;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__cvar",
          "args": [
            "&precompose",
            "repo",
            "GIT_CVAR_PRECOMPOSE"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__cvar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/config_cache.c",
          "lines": "104-120",
          "snippet": "int git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"filter.h\"",
            "#include \"vector.h\"",
            "#include \"git2/config.h\"",
            "#include \"config.h\"",
            "#include \"repository.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filter.h\"\n#include \"vector.h\"\n#include \"git2/config.h\"\n#include \"config.h\"\n#include \"repository.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nint git_repository__cvar(int *out, git_repository *repo, git_cvar_cached cvar)\n{\n\t*out = repo->cvar_cache[(int)cvar];\n\n\tif (*out == GIT_CVAR_NOT_CACHED) {\n\t\tint error;\n\t\tgit_config *config;\n\n\t\tif ((error = git_repository_config__weakptr(&config, repo)) < 0 ||\n\t\t\t(error = git_config__cvar(out, config, cvar)) < 0)\n\t\t\treturn error;\n\n\t\trepo->cvar_cache[(int)cvar] = *out;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "wi"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "(git_iterator *)wi"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_snapshot_new",
          "args": [
            "&wi->index_snapshot",
            "index"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_snapshot_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3320-3335",
          "snippet": "int git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_dup",
          "args": [
            "(git_object **)&wi->tree",
            "(git_object *)tree"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "383-388",
          "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_ignore__for_path",
          "args": [
            "repo",
            "\".gitignore\"",
            "&wi->ignores"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__for_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "273-343",
          "snippet": "int git_ignore__for_path(\n\tgit_repository *repo,\n\tconst char *path,\n\tgit_ignores *ignores)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\n\tassert(ignores && path);\n\n\tmemset(ignores, 0, sizeof(*ignores));\n\tignores->repo = repo;\n\n\t/* Read the ignore_case flag */\n\tif ((error = git_repository__cvar(\n\t\t\t&ignores->ignore_case, repo, GIT_CVAR_IGNORECASE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* given a unrooted path in a non-bare repo, resolve it */\n\tif (workdir && git_path_root(path) < 0) {\n\t\tgit_buf local = GIT_BUF_INIT;\n\n\t\tif ((error = git_path_dirname_r(&local, path)) < 0 ||\n\t\t    (error = git_path_resolve_relative(&local, 0)) < 0 ||\n\t\t    (error = git_path_to_dir(&local)) < 0 ||\n\t\t    (error = git_buf_joinpath(&ignores->dir, workdir, local.ptr)) < 0)\n\t\t{;} /* Nothing, we just want to stop on the first error */\n\t\tgit_buf_free(&local);\n\t} else {\n\t\terror = git_buf_joinpath(&ignores->dir, path, \"\");\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (workdir && !git__prefixcmp(ignores->dir.ptr, workdir))\n\t\tignores->dir_root = strlen(workdir);\n\n\t/* set up internals */\n\tif ((error = get_internal_ignores(&ignores->ign_internal, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* load .gitignore up the path */\n\tif (workdir != NULL) {\n\t\terror = git_path_walk_up(\n\t\t\t&ignores->dir, workdir, push_one_ignore, ignores);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* load .git/info/exclude */\n\terror = push_ignore_file(\n\t\tignores, &ignores->ign_global,\n\t\tgit_repository_path(repo), GIT_IGNORE_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* load core.excludesfile */\n\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)\n\t\terror = push_ignore_file(\n\t\t\tignores, &ignores->ign_global, NULL,\n\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_ignore__free(ignores);\n\n\treturn error;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__for_path(\n\tgit_repository *repo,\n\tconst char *path,\n\tgit_ignores *ignores)\n{\n\tint error = 0;\n\tconst char *workdir = git_repository_workdir(repo);\n\n\tassert(ignores && path);\n\n\tmemset(ignores, 0, sizeof(*ignores));\n\tignores->repo = repo;\n\n\t/* Read the ignore_case flag */\n\tif ((error = git_repository__cvar(\n\t\t\t&ignores->ignore_case, repo, GIT_CVAR_IGNORECASE)) < 0)\n\t\tgoto cleanup;\n\n\tif ((error = git_attr_cache__init(repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* given a unrooted path in a non-bare repo, resolve it */\n\tif (workdir && git_path_root(path) < 0) {\n\t\tgit_buf local = GIT_BUF_INIT;\n\n\t\tif ((error = git_path_dirname_r(&local, path)) < 0 ||\n\t\t    (error = git_path_resolve_relative(&local, 0)) < 0 ||\n\t\t    (error = git_path_to_dir(&local)) < 0 ||\n\t\t    (error = git_buf_joinpath(&ignores->dir, workdir, local.ptr)) < 0)\n\t\t{;} /* Nothing, we just want to stop on the first error */\n\t\tgit_buf_free(&local);\n\t} else {\n\t\terror = git_buf_joinpath(&ignores->dir, path, \"\");\n\t}\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\tif (workdir && !git__prefixcmp(ignores->dir.ptr, workdir))\n\t\tignores->dir_root = strlen(workdir);\n\n\t/* set up internals */\n\tif ((error = get_internal_ignores(&ignores->ign_internal, repo)) < 0)\n\t\tgoto cleanup;\n\n\t/* load .gitignore up the path */\n\tif (workdir != NULL) {\n\t\terror = git_path_walk_up(\n\t\t\t&ignores->dir, workdir, push_one_ignore, ignores);\n\t\tif (error < 0)\n\t\t\tgoto cleanup;\n\t}\n\n\t/* load .git/info/exclude */\n\terror = push_ignore_file(\n\t\tignores, &ignores->ign_global,\n\t\tgit_repository_path(repo), GIT_IGNORE_FILE_INREPO);\n\tif (error < 0)\n\t\tgoto cleanup;\n\n\t/* load core.excludesfile */\n\tif (git_repository_attr_cache(repo)->cfg_excl_file != NULL)\n\t\terror = push_ignore_file(\n\t\t\tignores, &ignores->ign_global, NULL,\n\t\t\tgit_repository_attr_cache(repo)->cfg_excl_file);\n\ncleanup:\n\tif (error < 0)\n\t\tgit_ignore__free(ignores);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__update_ignore_case",
          "args": [
            "(git_iterator *)wi",
            "options ? options->flags : 0"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__update_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "222-259",
          "snippet": "static int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITERATOR_BASE_INIT",
          "args": [
            "(&wi->fi)",
            "fs",
            "FS",
            "repo"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "wi"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(workdir_iterator)"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_workdir",
          "args": [
            "repo"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_workdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "1828-1836",
          "snippet": "const char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nconst char *git_repository_workdir(git_repository *repo)\n{\n\tassert(repo);\n\n\tif (repo->is_bare)\n\t\treturn NULL;\n\n\treturn repo->workdir;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository__ensure_not_bare",
          "args": [
            "repo",
            "\"scan working directory\""
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository__ensure_not_bare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.h",
          "lines": "176-189",
          "snippet": "GIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}",
          "includes": [
            "#include \"diff_driver.h\"",
            "#include \"submodule.h\"",
            "#include \"attrcache.h\"",
            "#include \"object.h\"",
            "#include \"buffer.h\"",
            "#include \"refs.h\"",
            "#include \"cache.h\"",
            "#include \"array.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"git2/odb.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"diff_driver.h\"\n#include \"submodule.h\"\n#include \"attrcache.h\"\n#include \"object.h\"\n#include \"buffer.h\"\n#include \"refs.h\"\n#include \"cache.h\"\n#include \"array.h\"\n#include \"git2/config.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"git2/odb.h\"\n#include \"git2/oid.h\"\n#include \"git2/common.h\"\n\nGIT_INLINE(int) git_repository__ensure_not_bare(\n\tgit_repository *repo,\n\tconst char *operation_name)\n{\n\tif (!git_repository_is_bare(repo))\n\t\treturn 0;\n\n\tgiterr_set(\n\t\tGITERR_REPOSITORY,\n\t\t\"Cannot %s. This operation is not allowed against bare repositories.\",\n\t\toperation_name);\n\n\treturn GIT_EBAREREPO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_for_workdir_ext(\n\tgit_iterator **out,\n\tgit_repository *repo,\n\tconst char *repo_workdir,\n\tgit_index *index,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error, precompose = 0;\n\tworkdir_iterator *wi;\n\n\tif (!repo_workdir) {\n\t\tif (git_repository__ensure_not_bare(repo, \"scan working directory\") < 0)\n\t\t\treturn GIT_EBAREREPO;\n\t\trepo_workdir = git_repository_workdir(repo);\n\t}\n\n\t/* initialize as an fs iterator then do overrides */\n\twi = git__calloc(1, sizeof(workdir_iterator));\n\tGITERR_CHECK_ALLOC(wi);\n\tITERATOR_BASE_INIT((&wi->fi), fs, FS, repo);\n\n\twi->fi.base.type = GIT_ITERATOR_TYPE_WORKDIR;\n\twi->fi.cb.free = workdir_iterator__free;\n\twi->fi.enter_dir_cb = workdir_iterator__enter_dir;\n\twi->fi.leave_dir_cb = workdir_iterator__leave_dir;\n\twi->fi.update_entry_cb = workdir_iterator__update_entry;\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)wi, options ? options->flags : 0)) < 0 ||\n\t\t(error = git_ignore__for_path(repo, \".gitignore\", &wi->ignores)) < 0)\n\t{\n\t\tgit_iterator_free((git_iterator *)wi);\n\t\treturn error;\n\t}\n\n\tif (tree && (error = git_object_dup((git_object **)&wi->tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\twi->index = index;\n\tif (index && (error = git_index_snapshot_new(&wi->index_snapshot, index)) < 0) {\n\t\tgit_iterator_free((git_iterator *)wi);\n\t\treturn error;\n\t}\n\twi->entry_srch = iterator__ignore_case(wi) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\n\t/* try to look up precompose and set flag if appropriate */\n\tif (git_repository__cvar(&precompose, repo, GIT_CVAR_PRECOMPOSE) < 0)\n\t\tgiterr_clear();\n\telse if (precompose)\n\t\twi->fi.base.flags |= GIT_ITERATOR_PRECOMPOSE_UNICODE;\n\n\treturn fs_iterator__initialize(out, &wi->fi, repo_workdir);\n}"
  },
  {
    "function_name": "workdir_iterator__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1805-1813",
    "snippet": "static void workdir_iterator__free(git_iterator *self)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)self;\n\tif (wi->index)\n\t\tgit_index_snapshot_release(&wi->index_snapshot, wi->index);\n\tgit_tree_free(wi->tree);\n\tfs_iterator__free(self);\n\tgit_ignore__free(&wi->ignores);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_ignore__free",
          "args": [
            "&wi->ignores"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "391-411",
          "snippet": "void git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nvoid git_ignore__free(git_ignores *ignores)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\n\tgit_attr_file__free(ignores->ign_internal);\n\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_path.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_path);\n\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tgit_attr_file__free(file);\n\t\tignores->ign_global.contents[i] = NULL;\n\t}\n\tgit_vector_free(&ignores->ign_global);\n\n\tgit_buf_free(&ignores->dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__free",
          "args": [
            "self"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1533-1541",
          "snippet": "static void fs_iterator__free(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\twhile (fi->stack != NULL)\n\t\tfs_iterator__pop_frame(fi, fi->stack, true);\n\n\tgit_buf_free(&fi->path);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);",
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void fs_iterator__free(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\twhile (fi->stack != NULL)\n\t\tfs_iterator__pop_frame(fi, fi->stack, true);\n\n\tgit_buf_free(&fi->path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "wi->tree"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_snapshot_release",
          "args": [
            "&wi->index_snapshot",
            "wi->index"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_snapshot_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3337-3344",
          "snippet": "void git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void workdir_iterator__free(git_iterator *self)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)self;\n\tif (wi->index)\n\t\tgit_index_snapshot_release(&wi->index_snapshot, wi->index);\n\tgit_tree_free(wi->tree);\n\tfs_iterator__free(self);\n\tgit_ignore__free(&wi->ignores);\n}"
  },
  {
    "function_name": "workdir_iterator__update_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1791-1803",
    "snippet": "static int workdir_iterator__update_entry(fs_iterator *fi)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)fi;\n\n\t/* skip over .git entries */\n\tif (workdir_path_is_dotgit(&fi->path))\n\t\treturn GIT_ENOTFOUND;\n\n\t/* reset is_ignored since we haven't checked yet */\n\twi->is_ignored = GIT_IGNORE_UNCHECKED;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "workdir_path_is_dotgit",
          "args": [
            "&fi->path"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "workdir_path_is_dotgit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1660-1677",
          "snippet": "GIT_INLINE(bool) workdir_path_is_dotgit(const git_buf *path)\n{\n\tsize_t len;\n\n\tif (!path || (len = path->size) < 4)\n\t\treturn false;\n\n\tif (path->ptr[len - 1] == '/')\n\t\tlen--;\n\n\tif (git__tolower(path->ptr[len - 1]) != 't' ||\n\t\tgit__tolower(path->ptr[len - 2]) != 'i' ||\n\t\tgit__tolower(path->ptr[len - 3]) != 'g' ||\n\t\tgit__tolower(path->ptr[len - 4]) != '.')\n\t\treturn false;\n\n\treturn (len == 4 || path->ptr[len - 5] == '/');\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(bool) workdir_path_is_dotgit(const git_buf *path)\n{\n\tsize_t len;\n\n\tif (!path || (len = path->size) < 4)\n\t\treturn false;\n\n\tif (path->ptr[len - 1] == '/')\n\t\tlen--;\n\n\tif (git__tolower(path->ptr[len - 1]) != 't' ||\n\t\tgit__tolower(path->ptr[len - 2]) != 'i' ||\n\t\tgit__tolower(path->ptr[len - 3]) != 'g' ||\n\t\tgit__tolower(path->ptr[len - 4]) != '.')\n\t\treturn false;\n\n\treturn (len == 4 || path->ptr[len - 5] == '/');\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int workdir_iterator__update_entry(fs_iterator *fi)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)fi;\n\n\t/* skip over .git entries */\n\tif (workdir_path_is_dotgit(&fi->path))\n\t\treturn GIT_ENOTFOUND;\n\n\t/* reset is_ignored since we haven't checked yet */\n\twi->is_ignored = GIT_IGNORE_UNCHECKED;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "workdir_iterator__leave_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1784-1789",
    "snippet": "static int workdir_iterator__leave_dir(fs_iterator *fi)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)fi;\n\tgit_ignore__pop_dir(&wi->ignores);\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_ignore__pop_dir",
          "args": [
            "&wi->ignores"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__pop_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "356-389",
          "snippet": "int git_ignore__pop_dir(git_ignores *ign)\n{\n\tif (ign->ign_path.length > 0) {\n\t\tgit_attr_file *file = git_vector_last(&ign->ign_path);\n\t\tconst char *start = file->entry->path, *end;\n\n\t\t/* - ign->dir looks something like \"/home/user/a/b/\" (or \"a/b/c/d/\")\n\t\t * - file->path looks something like \"a/b/.gitignore\n\t\t *\n\t\t * We are popping the last directory off ign->dir.  We also want\n\t\t * to remove the file from the vector if the popped directory\n\t\t * matches the ignore path.  We need to test if the \"a/b\" part of\n\t\t * the file key matches the path we are about to pop.\n\t\t */\n\n\t\tif ((end = strrchr(start, '/')) != NULL) {\n\t\t\tsize_t dirlen = (end - start) + 1;\n\t\t\tconst char *relpath = ign->dir.ptr + ign->dir_root;\n\t\t\tsize_t pathlen = ign->dir.size - ign->dir_root;\n\n\t\t\tif (pathlen == dirlen && !memcmp(relpath, start, dirlen)) {\n\t\t\t\tgit_vector_pop(&ign->ign_path);\n\t\t\t\tgit_attr_file__free(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (--ign->depth > 0) {\n\t\tgit_buf_rtruncate_at_char(&ign->dir, '/');\n\t\tgit_path_to_dir(&ign->dir);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__pop_dir(git_ignores *ign)\n{\n\tif (ign->ign_path.length > 0) {\n\t\tgit_attr_file *file = git_vector_last(&ign->ign_path);\n\t\tconst char *start = file->entry->path, *end;\n\n\t\t/* - ign->dir looks something like \"/home/user/a/b/\" (or \"a/b/c/d/\")\n\t\t * - file->path looks something like \"a/b/.gitignore\n\t\t *\n\t\t * We are popping the last directory off ign->dir.  We also want\n\t\t * to remove the file from the vector if the popped directory\n\t\t * matches the ignore path.  We need to test if the \"a/b\" part of\n\t\t * the file key matches the path we are about to pop.\n\t\t */\n\n\t\tif ((end = strrchr(start, '/')) != NULL) {\n\t\t\tsize_t dirlen = (end - start) + 1;\n\t\t\tconst char *relpath = ign->dir.ptr + ign->dir_root;\n\t\t\tsize_t pathlen = ign->dir.size - ign->dir_root;\n\n\t\t\tif (pathlen == dirlen && !memcmp(relpath, start, dirlen)) {\n\t\t\t\tgit_vector_pop(&ign->ign_path);\n\t\t\t\tgit_attr_file__free(file);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (--ign->depth > 0) {\n\t\tgit_buf_rtruncate_at_char(&ign->dir, '/');\n\t\tgit_path_to_dir(&ign->dir);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int workdir_iterator__leave_dir(fs_iterator *fi)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)fi;\n\tgit_ignore__pop_dir(&wi->ignores);\n\treturn 0;\n}"
  },
  {
    "function_name": "workdir_iterator__enter_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1733-1782",
    "snippet": "static int workdir_iterator__enter_dir(fs_iterator *fi)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)fi;\n\tfs_iterator_frame *ff = fi->stack;\n\tsize_t pos;\n\tfs_iterator_path_with_stat *entry;\n\tbool found_submodules = false;\n\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&fi->entry);\n\n\t/* check if this directory is ignored */\n\tif (git_ignore__lookup(&ff->is_ignored, &wi->ignores, fi->path.ptr + fi->root_len, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\tff->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* if this is not the top level directory... */\n\tif (ff->next != NULL) {\n\t\tssize_t slash_pos = git_buf_rfind_next(&fi->path, '/');\n\n\t\t/* inherit ignored from parent if no rule specified */\n\t\tif (ff->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\t\tff->is_ignored = ff->next->is_ignored;\n\n\t\t/* push new ignores for files in this directory */\n\t\t(void)git_ignore__push_dir(&wi->ignores, &fi->path.ptr[slash_pos + 1]);\n\t}\n\n\t/* convert submodules to GITLINK and remove trailing slashes */\n\tgit_vector_foreach(&ff->entries, pos, entry) {\n\t\tif (!S_ISDIR(entry->st.st_mode) || !strcmp(GIT_DIR, entry->path))\n\t\t\tcontinue;\n\n\t\tif (is_submodule(wi, entry)) {\n\t\t\tentry->st.st_mode = GIT_FILEMODE_COMMIT;\n\t\t\tentry->path_len--;\n\t\t\tentry->path[entry->path_len] = '\\0';\n\t\t\tfound_submodules = true;\n\t\t}\n\t}\n\n\t/* if we renamed submodules, re-sort and re-seek to start */\n\tif (found_submodules) {\n\t\tgit_vector_set_sorted(&ff->entries, 0);\n\t\tgit_vector_sort(&ff->entries);\n\t\tfs_iterator__seek_frame_start(fi, ff);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__seek_frame_start",
          "args": [
            "fi",
            "ff"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__seek_frame_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1225-1236",
          "snippet": "static void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&ff->entries"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_sorted",
          "args": [
            "&ff->entries",
            "0"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_submodule",
          "args": [
            "wi",
            "entry"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "is_submodule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1685-1720",
          "snippet": "static int is_submodule(workdir_iterator *wi, fs_iterator_path_with_stat *ie)\n{\n\tint error, is_submodule = 0;\n\n\tif (wi->tree) {\n\t\tgit_tree_entry *e;\n\n\t\t/* remove the trailing slash for finding */\n\t\tie->path[ie->path_len-1] = '\\0';\n\t\terror = git_tree_entry_bypath(&e, wi->tree, ie->path);\n\t\tie->path[ie->path_len-1] = '/';\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\t\tif (!error) {\n\t\t\tis_submodule = e->attr == GIT_FILEMODE_COMMIT;\n\t\t\tgit_tree_entry_free(e);\n\t\t}\n\t}\n\n\tif (!is_submodule && wi->index) {\n\t\tgit_index_entry *e;\n\t\tsize_t pos;\n\n\t\terror = git_index_snapshot_find(&pos, &wi->index_snapshot, wi->entry_srch, ie->path, ie->path_len-1, 0);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\n\t\tif (!error) {\n\t\t\te = git_vector_get(&wi->index_snapshot, pos);\n\n\t\t\tis_submodule = e->mode == GIT_FILEMODE_COMMIT;\n\t\t}\n\t}\n\n\treturn is_submodule;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int is_submodule(workdir_iterator *wi, fs_iterator_path_with_stat *ie)\n{\n\tint error, is_submodule = 0;\n\n\tif (wi->tree) {\n\t\tgit_tree_entry *e;\n\n\t\t/* remove the trailing slash for finding */\n\t\tie->path[ie->path_len-1] = '\\0';\n\t\terror = git_tree_entry_bypath(&e, wi->tree, ie->path);\n\t\tie->path[ie->path_len-1] = '/';\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\t\tif (!error) {\n\t\t\tis_submodule = e->attr == GIT_FILEMODE_COMMIT;\n\t\t\tgit_tree_entry_free(e);\n\t\t}\n\t}\n\n\tif (!is_submodule && wi->index) {\n\t\tgit_index_entry *e;\n\t\tsize_t pos;\n\n\t\terror = git_index_snapshot_find(&pos, &wi->index_snapshot, wi->entry_srch, ie->path, ie->path_len-1, 0);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\n\t\tif (!error) {\n\t\t\te = git_vector_get(&wi->index_snapshot, pos);\n\n\t\t\tis_submodule = e->mode == GIT_FILEMODE_COMMIT;\n\t\t}\n\t}\n\n\treturn is_submodule;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "GIT_DIR",
            "entry->path"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->st.st_mode"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_foreach",
          "args": [
            "&ff->entries",
            "pos",
            "entry"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_ignore__push_dir",
          "args": [
            "&wi->ignores",
            "&fi->path.ptr[slash_pos + 1]"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__push_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "345-354",
          "snippet": "int git_ignore__push_dir(git_ignores *ign, const char *dir)\n{\n\tif (git_buf_joinpath(&ign->dir, ign->dir.ptr, dir) < 0)\n\t\treturn -1;\n\n\tign->depth++;\n\n\treturn push_ignore_file(\n\t\tign, &ign->ign_path, ign->dir.ptr, GIT_IGNORE_FILE);\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__push_dir(git_ignores *ign, const char *dir)\n{\n\tif (git_buf_joinpath(&ign->dir, ign->dir.ptr, dir) < 0)\n\t\treturn -1;\n\n\tign->depth++;\n\n\treturn push_ignore_file(\n\t\tign, &ign->ign_path, ign->dir.ptr, GIT_IGNORE_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rfind_next",
          "args": [
            "&fi->path",
            "'/'"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rfind_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "150-156",
          "snippet": "GIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(ssize_t) git_buf_rfind_next(const git_buf *buf, char ch)\n{\n\tssize_t idx = (ssize_t)buf->size - 1;\n\twhile (idx >= 0 && buf->ptr[idx] == ch) idx--;\n\twhile (idx >= 0 && buf->ptr[idx] != ch) idx--;\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_ignore__lookup",
          "args": [
            "&ff->is_ignored",
            "&wi->ignores",
            "fi->path.ptr + fi->root_len",
            "dir_flag"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "git_ignore__lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/ignore.c",
          "lines": "430-462",
          "snippet": "int git_ignore__lookup(\n\tint *out, git_ignores *ignores, const char *pathname, git_dir_flag dir_flag)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\tgit_attr_path path;\n\n\t*out = GIT_IGNORE_NOTFOUND;\n\n\tif (git_attr_path__init(\n\t\t&path, pathname, git_repository_workdir(ignores->repo), dir_flag) < 0)\n\t\treturn -1;\n\n\t/* first process builtins - success means path was found */\n\tif (ignore_lookup_in_rules(out, ignores->ign_internal, &path))\n\t\tgoto cleanup;\n\n\t/* next process files in the path */\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* last process global ignores */\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_attr_path__free(&path);\n\treturn 0;\n}",
          "includes": [
            "#include \"fnmatch.h\"",
            "#include \"config.h\"",
            "#include \"path.h\"",
            "#include \"attrcache.h\"",
            "#include \"ignore.h\"",
            "#include \"common.h\"",
            "#include \"git2/ignore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fnmatch.h\"\n#include \"config.h\"\n#include \"path.h\"\n#include \"attrcache.h\"\n#include \"ignore.h\"\n#include \"common.h\"\n#include \"git2/ignore.h\"\n\nint git_ignore__lookup(\n\tint *out, git_ignores *ignores, const char *pathname, git_dir_flag dir_flag)\n{\n\tunsigned int i;\n\tgit_attr_file *file;\n\tgit_attr_path path;\n\n\t*out = GIT_IGNORE_NOTFOUND;\n\n\tif (git_attr_path__init(\n\t\t&path, pathname, git_repository_workdir(ignores->repo), dir_flag) < 0)\n\t\treturn -1;\n\n\t/* first process builtins - success means path was found */\n\tif (ignore_lookup_in_rules(out, ignores->ign_internal, &path))\n\t\tgoto cleanup;\n\n\t/* next process files in the path */\n\tgit_vector_foreach(&ignores->ign_path, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\n\t/* last process global ignores */\n\tgit_vector_foreach(&ignores->ign_global, i, file) {\n\t\tif (ignore_lookup_in_rules(out, file, &path))\n\t\t\tgoto cleanup;\n\t}\n\ncleanup:\n\tgit_attr_path__free(&path);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_entry__dir_flag",
          "args": [
            "&fi->entry"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "git_entry__dir_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1722-1731",
          "snippet": "GIT_INLINE(git_dir_flag) git_entry__dir_flag(git_index_entry *entry) {\n#if defined(GIT_WIN32) && !defined(__MINGW32__)\n\treturn (entry && entry->mode)\n\t\t? S_ISDIR(entry->mode) ? GIT_DIR_FLAG_TRUE : GIT_DIR_FLAG_FALSE\n\t\t: GIT_DIR_FLAG_UNKNOWN;\n#else\n\tGIT_UNUSED(entry);\n\treturn GIT_DIR_FLAG_UNKNOWN;\n#endif\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(git_dir_flag) git_entry__dir_flag(git_index_entry *entry) {\n#if defined(GIT_WIN32) && !defined(__MINGW32__)\n\treturn (entry && entry->mode)\n\t\t? S_ISDIR(entry->mode) ? GIT_DIR_FLAG_TRUE : GIT_DIR_FLAG_FALSE\n\t\t: GIT_DIR_FLAG_UNKNOWN;\n#else\n\tGIT_UNUSED(entry);\n\treturn GIT_DIR_FLAG_UNKNOWN;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int workdir_iterator__enter_dir(fs_iterator *fi)\n{\n\tworkdir_iterator *wi = (workdir_iterator *)fi;\n\tfs_iterator_frame *ff = fi->stack;\n\tsize_t pos;\n\tfs_iterator_path_with_stat *entry;\n\tbool found_submodules = false;\n\n\tgit_dir_flag dir_flag = git_entry__dir_flag(&fi->entry);\n\n\t/* check if this directory is ignored */\n\tif (git_ignore__lookup(&ff->is_ignored, &wi->ignores, fi->path.ptr + fi->root_len, dir_flag) < 0) {\n\t\tgiterr_clear();\n\t\tff->is_ignored = GIT_IGNORE_NOTFOUND;\n\t}\n\n\t/* if this is not the top level directory... */\n\tif (ff->next != NULL) {\n\t\tssize_t slash_pos = git_buf_rfind_next(&fi->path, '/');\n\n\t\t/* inherit ignored from parent if no rule specified */\n\t\tif (ff->is_ignored <= GIT_IGNORE_NOTFOUND)\n\t\t\tff->is_ignored = ff->next->is_ignored;\n\n\t\t/* push new ignores for files in this directory */\n\t\t(void)git_ignore__push_dir(&wi->ignores, &fi->path.ptr[slash_pos + 1]);\n\t}\n\n\t/* convert submodules to GITLINK and remove trailing slashes */\n\tgit_vector_foreach(&ff->entries, pos, entry) {\n\t\tif (!S_ISDIR(entry->st.st_mode) || !strcmp(GIT_DIR, entry->path))\n\t\t\tcontinue;\n\n\t\tif (is_submodule(wi, entry)) {\n\t\t\tentry->st.st_mode = GIT_FILEMODE_COMMIT;\n\t\t\tentry->path_len--;\n\t\t\tentry->path[entry->path_len] = '\\0';\n\t\t\tfound_submodules = true;\n\t\t}\n\t}\n\n\t/* if we renamed submodules, re-sort and re-seek to start */\n\tif (found_submodules) {\n\t\tgit_vector_set_sorted(&ff->entries, 0);\n\t\tgit_vector_sort(&ff->entries);\n\t\tfs_iterator__seek_frame_start(fi, ff);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "git_entry__dir_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1722-1731",
    "snippet": "GIT_INLINE(git_dir_flag) git_entry__dir_flag(git_index_entry *entry) {\n#if defined(GIT_WIN32) && !defined(__MINGW32__)\n\treturn (entry && entry->mode)\n\t\t? S_ISDIR(entry->mode) ? GIT_DIR_FLAG_TRUE : GIT_DIR_FLAG_FALSE\n\t\t: GIT_DIR_FLAG_UNKNOWN;\n#else\n\tGIT_UNUSED(entry);\n\treturn GIT_DIR_FLAG_UNKNOWN;\n#endif\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "entry"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entry->mode"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(git_dir_flag) git_entry__dir_flag(git_index_entry *entry) {\n#if defined(GIT_WIN32) && !defined(__MINGW32__)\n\treturn (entry && entry->mode)\n\t\t? S_ISDIR(entry->mode) ? GIT_DIR_FLAG_TRUE : GIT_DIR_FLAG_FALSE\n\t\t: GIT_DIR_FLAG_UNKNOWN;\n#else\n\tGIT_UNUSED(entry);\n\treturn GIT_DIR_FLAG_UNKNOWN;\n#endif\n}"
  },
  {
    "function_name": "is_submodule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1685-1720",
    "snippet": "static int is_submodule(workdir_iterator *wi, fs_iterator_path_with_stat *ie)\n{\n\tint error, is_submodule = 0;\n\n\tif (wi->tree) {\n\t\tgit_tree_entry *e;\n\n\t\t/* remove the trailing slash for finding */\n\t\tie->path[ie->path_len-1] = '\\0';\n\t\terror = git_tree_entry_bypath(&e, wi->tree, ie->path);\n\t\tie->path[ie->path_len-1] = '/';\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\t\tif (!error) {\n\t\t\tis_submodule = e->attr == GIT_FILEMODE_COMMIT;\n\t\t\tgit_tree_entry_free(e);\n\t\t}\n\t}\n\n\tif (!is_submodule && wi->index) {\n\t\tgit_index_entry *e;\n\t\tsize_t pos;\n\n\t\terror = git_index_snapshot_find(&pos, &wi->index_snapshot, wi->entry_srch, ie->path, ie->path_len-1, 0);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\n\t\tif (!error) {\n\t\t\te = git_vector_get(&wi->index_snapshot, pos);\n\n\t\t\tis_submodule = e->mode == GIT_FILEMODE_COMMIT;\n\t\t}\n\t}\n\n\treturn is_submodule;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&wi->index_snapshot",
            "pos"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_snapshot_find",
          "args": [
            "&pos",
            "&wi->index_snapshot",
            "wi->entry_srch",
            "ie->path",
            "ie->path_len-1",
            "0"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_snapshot_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3346-3351",
          "snippet": "int git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_free",
          "args": [
            "e"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "229-235",
          "snippet": "void git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nvoid git_tree_entry_free(git_tree_entry *entry)\n{\n\tif (entry == NULL)\n\t\treturn;\n\n\tgit__free(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry_bypath",
          "args": [
            "&e",
            "wi->tree",
            "ie->path"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_bypath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "897-957",
          "snippet": "int git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nint git_tree_entry_bypath(\n\tgit_tree_entry **entry_out,\n\tconst git_tree *root,\n\tconst char *path)\n{\n\tint error = 0;\n\tgit_tree *subtree;\n\tconst git_tree_entry *entry;\n\tsize_t filename_len;\n\n\t/* Find how long is the current path component (i.e.\n\t * the filename between two slashes */\n\tfilename_len = subpath_len(path);\n\n\tif (filename_len == 0) {\n\t\tgiterr_set(GITERR_TREE, \"Invalid tree path given\");\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tentry = entry_fromname(root, path, filename_len);\n\n\tif (entry == NULL) {\n\t\tgiterr_set(GITERR_TREE,\n\t\t\t   \"the path '%.*s' does not exist in the given tree\", filename_len, path);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\n\tswitch (path[filename_len]) {\n\tcase '/':\n\t\t/* If there are more components in the path...\n\t\t * then this entry *must* be a tree */\n\t\tif (!git_tree_entry__is_tree(entry)) {\n\t\t\tgiterr_set(GITERR_TREE,\n\t\t\t\t   \"the path '%.*s' exists but is not a tree\", filename_len, path);\n\t\t\treturn GIT_ENOTFOUND;\n\t\t}\n\n\t\t/* If there's only a slash left in the path, we \n\t\t * return the current entry; otherwise, we keep\n\t\t * walking down the path */\n\t\tif (path[filename_len + 1] != '\\0')\n\t\t\tbreak;\n\n\tcase '\\0':\n\t\t/* If there are no more components in the path, return\n\t\t * this entry */\n\t\treturn git_tree_entry_dup(entry_out, entry);\n\t}\n\n\tif (git_tree_lookup(&subtree, root->object.repo, entry->oid) < 0)\n\t\treturn -1;\n\n\terror = git_tree_entry_bypath(\n\t\tentry_out,\n\t\tsubtree,\n\t\tpath + filename_len + 1\n\t);\n\n\tgit_tree_free(subtree);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int is_submodule(workdir_iterator *wi, fs_iterator_path_with_stat *ie)\n{\n\tint error, is_submodule = 0;\n\n\tif (wi->tree) {\n\t\tgit_tree_entry *e;\n\n\t\t/* remove the trailing slash for finding */\n\t\tie->path[ie->path_len-1] = '\\0';\n\t\terror = git_tree_entry_bypath(&e, wi->tree, ie->path);\n\t\tie->path[ie->path_len-1] = '/';\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\t\tif (!error) {\n\t\t\tis_submodule = e->attr == GIT_FILEMODE_COMMIT;\n\t\t\tgit_tree_entry_free(e);\n\t\t}\n\t}\n\n\tif (!is_submodule && wi->index) {\n\t\tgit_index_entry *e;\n\t\tsize_t pos;\n\n\t\terror = git_index_snapshot_find(&pos, &wi->index_snapshot, wi->entry_srch, ie->path, ie->path_len-1, 0);\n\t\tif (error < 0 && error != GIT_ENOTFOUND)\n\t\t\treturn 0;\n\n\t\tif (!error) {\n\t\t\te = git_vector_get(&wi->index_snapshot, pos);\n\n\t\t\tis_submodule = e->mode == GIT_FILEMODE_COMMIT;\n\t\t}\n\t}\n\n\treturn is_submodule;\n}"
  },
  {
    "function_name": "workdir_path_is_dotgit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1660-1677",
    "snippet": "GIT_INLINE(bool) workdir_path_is_dotgit(const git_buf *path)\n{\n\tsize_t len;\n\n\tif (!path || (len = path->size) < 4)\n\t\treturn false;\n\n\tif (path->ptr[len - 1] == '/')\n\t\tlen--;\n\n\tif (git__tolower(path->ptr[len - 1]) != 't' ||\n\t\tgit__tolower(path->ptr[len - 2]) != 'i' ||\n\t\tgit__tolower(path->ptr[len - 3]) != 'g' ||\n\t\tgit__tolower(path->ptr[len - 4]) != '.')\n\t\treturn false;\n\n\treturn (len == 4 || path->ptr[len - 5] == '/');\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__tolower",
          "args": [
            "path->ptr[len - 4]"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "git__tolower",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "285-288",
          "snippet": "GIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(int) git__tolower(int c)\n{\n\treturn (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(bool) workdir_path_is_dotgit(const git_buf *path)\n{\n\tsize_t len;\n\n\tif (!path || (len = path->size) < 4)\n\t\treturn false;\n\n\tif (path->ptr[len - 1] == '/')\n\t\tlen--;\n\n\tif (git__tolower(path->ptr[len - 1]) != 't' ||\n\t\tgit__tolower(path->ptr[len - 2]) != 'i' ||\n\t\tgit__tolower(path->ptr[len - 3]) != 'g' ||\n\t\tgit__tolower(path->ptr[len - 4]) != '.')\n\t\treturn false;\n\n\treturn (len == 4 || path->ptr[len - 5] == '/');\n}"
  },
  {
    "function_name": "git_iterator_for_filesystem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1627-1641",
    "snippet": "int git_iterator_for_filesystem(\n\tgit_iterator **out,\n\tconst char *root,\n\tgit_iterator_options *options)\n{\n\tfs_iterator *fi = git__calloc(1, sizeof(fs_iterator));\n\tGITERR_CHECK_ALLOC(fi);\n\n\tITERATOR_BASE_INIT(fi, fs, FS, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tfi->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\treturn fs_iterator__initialize(out, fi, root);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__initialize",
          "args": [
            "out",
            "fi",
            "root"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1596-1625",
          "snippet": "static int fs_iterator__initialize(\n\tgit_iterator **out, fs_iterator *fi, const char *root)\n{\n\tint error;\n\n\tif (git_buf_sets(&fi->path, root) < 0 || git_path_to_dir(&fi->path) < 0) {\n\t\tgit__free(fi);\n\t\treturn -1;\n\t}\n\tfi->root_len = fi->path.size;\n\tfi->pathlist_match = ITERATOR_PATHLIST_MATCH_CHILD;\n\n\tfi->dirload_flags =\n\t\t(iterator__ignore_case(fi) ? GIT_PATH_DIR_IGNORE_CASE : 0) |\n\t\t(iterator__flag(fi, PRECOMPOSE_UNICODE) ?\n\t\t\tGIT_PATH_DIR_PRECOMPOSE_UNICODE : 0);\n\n\tif ((error = fs_iterator__expand_dir(fi)) < 0) {\n\t\tif (error == GIT_ENOTFOUND || error == GIT_ITEROVER) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else {\n\t\t\tgit_iterator_free((git_iterator *)fi);\n\t\t\tfi = NULL;\n\t\t}\n\t}\n\n\t*out = (git_iterator *)fi;\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__initialize(\n\tgit_iterator **out, fs_iterator *fi, const char *root)\n{\n\tint error;\n\n\tif (git_buf_sets(&fi->path, root) < 0 || git_path_to_dir(&fi->path) < 0) {\n\t\tgit__free(fi);\n\t\treturn -1;\n\t}\n\tfi->root_len = fi->path.size;\n\tfi->pathlist_match = ITERATOR_PATHLIST_MATCH_CHILD;\n\n\tfi->dirload_flags =\n\t\t(iterator__ignore_case(fi) ? GIT_PATH_DIR_IGNORE_CASE : 0) |\n\t\t(iterator__flag(fi, PRECOMPOSE_UNICODE) ?\n\t\t\tGIT_PATH_DIR_PRECOMPOSE_UNICODE : 0);\n\n\tif ((error = fs_iterator__expand_dir(fi)) < 0) {\n\t\tif (error == GIT_ENOTFOUND || error == GIT_ITEROVER) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else {\n\t\t\tgit_iterator_free((git_iterator *)fi);\n\t\t\tfi = NULL;\n\t\t}\n\t}\n\n\t*out = (git_iterator *)fi;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITERATOR_BASE_INIT",
          "args": [
            "fi",
            "fs",
            "FS",
            "NULL"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "fi"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(fs_iterator)"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nint git_iterator_for_filesystem(\n\tgit_iterator **out,\n\tconst char *root,\n\tgit_iterator_options *options)\n{\n\tfs_iterator *fi = git__calloc(1, sizeof(fs_iterator));\n\tGITERR_CHECK_ALLOC(fi);\n\n\tITERATOR_BASE_INIT(fi, fs, FS, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tfi->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\treturn fs_iterator__initialize(out, fi, root);\n}"
  },
  {
    "function_name": "fs_iterator__initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1596-1625",
    "snippet": "static int fs_iterator__initialize(\n\tgit_iterator **out, fs_iterator *fi, const char *root)\n{\n\tint error;\n\n\tif (git_buf_sets(&fi->path, root) < 0 || git_path_to_dir(&fi->path) < 0) {\n\t\tgit__free(fi);\n\t\treturn -1;\n\t}\n\tfi->root_len = fi->path.size;\n\tfi->pathlist_match = ITERATOR_PATHLIST_MATCH_CHILD;\n\n\tfi->dirload_flags =\n\t\t(iterator__ignore_case(fi) ? GIT_PATH_DIR_IGNORE_CASE : 0) |\n\t\t(iterator__flag(fi, PRECOMPOSE_UNICODE) ?\n\t\t\tGIT_PATH_DIR_PRECOMPOSE_UNICODE : 0);\n\n\tif ((error = fs_iterator__expand_dir(fi)) < 0) {\n\t\tif (error == GIT_ENOTFOUND || error == GIT_ITEROVER) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else {\n\t\t\tgit_iterator_free((git_iterator *)fi);\n\t\t\tfi = NULL;\n\t\t}\n\t}\n\n\t*out = (git_iterator *)fi;\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "(git_iterator *)fi"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__expand_dir",
          "args": [
            "fi"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__expand_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1349-1394",
          "snippet": "static int fs_iterator__expand_dir(fs_iterator *fi)\n{\n\tint error;\n\tfs_iterator_frame *ff;\n\n\tif (fi->depth > FS_MAX_DEPTH) {\n\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\"Directory nesting is too deep (%d)\", fi->depth);\n\t\treturn -1;\n\t}\n\n\tff = fs_iterator__alloc_frame(fi);\n\tGITERR_CHECK_ALLOC(ff);\n\n\terror = dirload_with_stat(&ff->entries, fi);\n\n\tif (error < 0) {\n\t\tgit_error_state last_error = { 0 };\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\t/* these callbacks may clear the error message */\n\t\tfs_iterator__free_frame(ff);\n\t\tfs_iterator__advance_over(NULL, (git_iterator *)fi);\n\t\t/* next time return value we skipped to */\n\t\tfi->base.flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\t\treturn giterr_state_restore(&last_error);\n\t}\n\n\tif (ff->entries.length == 0) {\n\t\tfs_iterator__free_frame(ff);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\tfi->base.stat_calls += ff->entries.length;\n\n\tfs_iterator__seek_frame_start(fi, ff);\n\n\tff->next  = fi->stack;\n\tfi->stack = ff;\n\tfi->depth++;\n\n\tif (fi->enter_dir_cb && (error = fi->enter_dir_cb(fi)) < 0)\n\t\treturn error;\n\n\treturn fs_iterator__update_entry(fi);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define FS_MAX_DEPTH 100",
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define FS_MAX_DEPTH 100\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__expand_dir(fs_iterator *fi)\n{\n\tint error;\n\tfs_iterator_frame *ff;\n\n\tif (fi->depth > FS_MAX_DEPTH) {\n\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\"Directory nesting is too deep (%d)\", fi->depth);\n\t\treturn -1;\n\t}\n\n\tff = fs_iterator__alloc_frame(fi);\n\tGITERR_CHECK_ALLOC(ff);\n\n\terror = dirload_with_stat(&ff->entries, fi);\n\n\tif (error < 0) {\n\t\tgit_error_state last_error = { 0 };\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\t/* these callbacks may clear the error message */\n\t\tfs_iterator__free_frame(ff);\n\t\tfs_iterator__advance_over(NULL, (git_iterator *)fi);\n\t\t/* next time return value we skipped to */\n\t\tfi->base.flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\t\treturn giterr_state_restore(&last_error);\n\t}\n\n\tif (ff->entries.length == 0) {\n\t\tfs_iterator__free_frame(ff);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\tfi->base.stat_calls += ff->entries.length;\n\n\tfs_iterator__seek_frame_start(fi, ff);\n\n\tff->next  = fi->stack;\n\tfi->stack = ff;\n\tfi->depth++;\n\n\tif (fi->enter_dir_cb && (error = fi->enter_dir_cb(fi)) < 0)\n\t\treturn error;\n\n\treturn fs_iterator__update_entry(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__flag",
          "args": [
            "fi",
            "PRECOMPOSE_UNICODE"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "fi"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "fi"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_to_dir",
          "args": [
            "&fi->path"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_to_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "341-349",
          "snippet": "int git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_to_dir(git_buf *path)\n{\n\tif (path->asize > 0 &&\n\t\tgit_buf_len(path) > 0 &&\n\t\tpath->ptr[git_buf_len(path) - 1] != '/')\n\t\tgit_buf_putc(path, '/');\n\n\treturn git_buf_oom(path) ? -1 : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&fi->path",
            "root"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__initialize(\n\tgit_iterator **out, fs_iterator *fi, const char *root)\n{\n\tint error;\n\n\tif (git_buf_sets(&fi->path, root) < 0 || git_path_to_dir(&fi->path) < 0) {\n\t\tgit__free(fi);\n\t\treturn -1;\n\t}\n\tfi->root_len = fi->path.size;\n\tfi->pathlist_match = ITERATOR_PATHLIST_MATCH_CHILD;\n\n\tfi->dirload_flags =\n\t\t(iterator__ignore_case(fi) ? GIT_PATH_DIR_IGNORE_CASE : 0) |\n\t\t(iterator__flag(fi, PRECOMPOSE_UNICODE) ?\n\t\t\tGIT_PATH_DIR_PRECOMPOSE_UNICODE : 0);\n\n\tif ((error = fs_iterator__expand_dir(fi)) < 0) {\n\t\tif (error == GIT_ENOTFOUND || error == GIT_ITEROVER) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else {\n\t\t\tgit_iterator_free((git_iterator *)fi);\n\t\t\tfi = NULL;\n\t\t}\n\t}\n\n\t*out = (git_iterator *)fi;\n\treturn error;\n}"
  },
  {
    "function_name": "fs_iterator__update_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1543-1594",
    "snippet": "static int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__advance_over_internal",
          "args": [
            "&fi->base"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__advance_over_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1443-1458",
          "snippet": "static void fs_iterator__advance_over_internal(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tfs_iterator_frame *ff;\n\tfs_iterator_path_with_stat *next;\n\n\twhile (fi->entry.path != NULL) {\n\t\tff = fi->stack;\n\t\tnext = git_vector_get(&ff->entries, ++ff->index);\n\n\t\tif (next != NULL)\n\t\t\tbreak;\n\n\t\tfs_iterator__pop_frame(fi, ff, false);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);",
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void fs_iterator__advance_over_internal(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tfs_iterator_frame *ff;\n\tfs_iterator_path_with_stat *next;\n\n\twhile (fi->entry.path != NULL) {\n\t\tff = fi->stack;\n\t\tnext = git_vector_get(&ff->entries, ++ff->index);\n\n\t\tif (next != NULL)\n\t\t\tbreak;\n\n\t\tfs_iterator__pop_frame(fi, ff, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__advance_into",
          "args": [
            "NULL",
            "&fi->base"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__advance_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1415-1441",
          "snippet": "static int fs_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = 0;\n\tfs_iterator *fi = (fs_iterator *)iter;\n\n\titerator__clear_entry(entry);\n\n\t/* Allow you to explicitly advance into a commit/submodule (as well as a\n\t * tree) to avoid cases where an entry is mislabeled as a submodule in\n\t * the working directory.  The fs iterator will never have COMMMIT\n\t * entries on it's own, but a wrapper might add them.\n\t */\n\tif (fi->entry.path != NULL &&\n\t\t(fi->entry.mode == GIT_FILEMODE_TREE ||\n\t\t fi->entry.mode == GIT_FILEMODE_COMMIT))\n\t\t/* returns GIT_ENOTFOUND if the directory is empty */\n\t\terror = fs_iterator__expand_dir(fi);\n\n\tif (!error && entry)\n\t\terror = fs_iterator__current(entry, iter);\n\n\tif (!error && !fi->entry.path)\n\t\terror = GIT_ITEROVER;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = 0;\n\tfs_iterator *fi = (fs_iterator *)iter;\n\n\titerator__clear_entry(entry);\n\n\t/* Allow you to explicitly advance into a commit/submodule (as well as a\n\t * tree) to avoid cases where an entry is mislabeled as a submodule in\n\t * the working directory.  The fs iterator will never have COMMMIT\n\t * entries on it's own, but a wrapper might add them.\n\t */\n\tif (fi->entry.path != NULL &&\n\t\t(fi->entry.mode == GIT_FILEMODE_TREE ||\n\t\t fi->entry.mode == GIT_FILEMODE_COMMIT))\n\t\t/* returns GIT_ENOTFOUND if the directory is empty */\n\t\terror = fs_iterator__expand_dir(fi);\n\n\tif (!error && entry)\n\t\terror = fs_iterator__current(entry, iter);\n\n\tif (!error && !fi->entry.path)\n\t\terror = GIT_ITEROVER;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__include_trees",
          "args": [
            "fi"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fi->update_entry_cb",
          "args": [
            "fi"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_futils_canonical_mode",
          "args": [
            "ps->st.st_mode"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "git_futils_canonical_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/fileops.c",
          "lines": "110-122",
          "snippet": "mode_t git_futils_canonical_mode(mode_t raw_mode)\n{\n\tif (S_ISREG(raw_mode))\n\t\treturn S_IFREG | GIT_PERMS_CANONICAL(raw_mode);\n\telse if (S_ISLNK(raw_mode))\n\t\treturn S_IFLNK;\n\telse if (S_ISGITLINK(raw_mode))\n\t\treturn S_IFGITLINK;\n\telse if (S_ISDIR(raw_mode))\n\t\treturn S_IFDIR;\n\telse\n\t\treturn 0;\n}",
          "includes": [
            "#include \"win32/findfile.h\"",
            "#include <ctype.h>",
            "#include \"strmap.h\"",
            "#include \"global.h\"",
            "#include \"fileops.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"win32/findfile.h\"\n#include <ctype.h>\n#include \"strmap.h\"\n#include \"global.h\"\n#include \"fileops.h\"\n#include \"common.h\"\n\nmode_t git_futils_canonical_mode(mode_t raw_mode)\n{\n\tif (S_ISREG(raw_mode))\n\t\treturn S_IFREG | GIT_PERMS_CANONICAL(raw_mode);\n\telse if (S_ISLNK(raw_mode))\n\t\treturn S_IFLNK;\n\telse if (S_ISGITLINK(raw_mode))\n\t\treturn S_IFGITLINK;\n\telse if (S_ISDIR(raw_mode))\n\t\treturn S_IFDIR;\n\telse\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry__init_from_stat",
          "args": [
            "&fi->entry",
            "&ps->st",
            "true"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry__init_from_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "827-843",
          "snippet": "void git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nvoid git_index_entry__init_from_stat(\n\tgit_index_entry *entry, struct stat *st, bool trust_mode)\n{\n\tentry->ctime.seconds = (int32_t)st->st_ctime;\n\tentry->mtime.seconds = (int32_t)st->st_mtime;\n#if defined(GIT_USE_NSEC)\n\tentry->mtime.nanoseconds = st->st_mtime_nsec;\n\tentry->ctime.nanoseconds = st->st_ctime_nsec;\n#endif\n\tentry->dev  = st->st_rdev;\n\tentry->ino  = st->st_ino;\n\tentry->mode = (!trust_mode && S_ISREG(st->st_mode)) ?\n\t\tgit_index__create_mode(0666) : git_index__create_mode(st->st_mode);\n\tentry->uid  = st->st_uid;\n\tentry->gid  = st->st_gid;\n\tentry->file_size = (uint32_t)st->st_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__past_end",
          "args": [
            "fi",
            "fi->path.ptr + fi->root_len"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_put",
          "args": [
            "&fi->path",
            "ps->path",
            "ps->path_len"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "208-223",
          "snippet": "int git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_put(git_buf *buf, const char *data, size_t len)\n{\n\tif (len) {\n\t\tsize_t new_size;\n\n\t\tassert(data);\n\t\t\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, len);\n\t\tGITERR_CHECK_ALLOC_ADD(&new_size, new_size, 1);\n\t\tENSURE_SIZE(buf, new_size);\n\t\tmemmove(buf->ptr + buf->size, data, len);\n\t\tbuf->size += len;\n\t\tbuf->ptr[buf->size] = '\\0';\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_truncate",
          "args": [
            "&fi->path",
            "fi->root_len"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "446-454",
          "snippet": "void git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_truncate(git_buf *buf, size_t len)\n{\n\tif (len >= buf->size)\n\t\treturn;\n\n\tbuf->size = len;\n\tif (buf->size < buf->asize)\n\t\tbuf->ptr[buf->size] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&fi->stack->entries",
            "fi->stack->index"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fi->entry",
            "0",
            "sizeof(fi->entry)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs_iterator__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1533-1541",
    "snippet": "static void fs_iterator__free(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\twhile (fi->stack != NULL)\n\t\tfs_iterator__pop_frame(fi, fi->stack, true);\n\n\tgit_buf_free(&fi->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);",
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&fi->path"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__pop_frame",
          "args": [
            "fi",
            "fi->stack",
            "true"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__pop_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1195-1212",
          "snippet": "static void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void fs_iterator__free(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\twhile (fi->stack != NULL)\n\t\tfs_iterator__pop_frame(fi, fi->stack, true);\n\n\tgit_buf_free(&fi->path);\n}"
  },
  {
    "function_name": "fs_iterator__reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1511-1531",
    "snippet": "static int fs_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\tint error;\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\twhile (fi->stack != NULL && fi->stack->next != NULL)\n\t\tfs_iterator__pop_frame(fi, fi->stack, false);\n\tfi->depth = 0;\n\n\tif ((error = iterator__reset_range(self, start, end)) < 0)\n\t\treturn error;\n\n\tfs_iterator__seek_frame_start(fi, fi->stack);\n\n\terror = fs_iterator__update_entry(fi);\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);",
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__update_entry",
          "args": [
            "fi"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1543-1594",
          "snippet": "static int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__seek_frame_start",
          "args": [
            "fi",
            "fi->stack"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__seek_frame_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1225-1236",
          "snippet": "static void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__reset_range",
          "args": [
            "self",
            "start",
            "end"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__reset_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "200-220",
          "snippet": "static int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__pop_frame",
          "args": [
            "fi",
            "fi->stack",
            "false"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__pop_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1195-1212",
          "snippet": "static void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\tint error;\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\twhile (fi->stack != NULL && fi->stack->next != NULL)\n\t\tfs_iterator__pop_frame(fi, fi->stack, false);\n\tfi->depth = 0;\n\n\tif ((error = iterator__reset_range(self, start, end)) < 0)\n\t\treturn error;\n\n\tfs_iterator__seek_frame_start(fi, fi->stack);\n\n\terror = fs_iterator__update_entry(fi);\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "fs_iterator__seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1501-1509",
    "snippet": "static int fs_iterator__seek(git_iterator *self, const char *prefix)\n{\n\tGIT_UNUSED(self);\n\tGIT_UNUSED(prefix);\n\t/* pop stack until matching prefix */\n\t/* find prefix item in current frame */\n\t/* push subdirectories as deep as possible while matching */\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "prefix"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "self"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__seek(git_iterator *self, const char *prefix)\n{\n\tGIT_UNUSED(self);\n\tGIT_UNUSED(prefix);\n\t/* pop stack until matching prefix */\n\t/* find prefix item in current frame */\n\t/* push subdirectories as deep as possible while matching */\n\treturn 0;\n}"
  },
  {
    "function_name": "fs_iterator__advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1478-1499",
    "snippet": "static int fs_iterator__advance(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\tif (!iterator__has_been_accessed(fi))\n\t\treturn fs_iterator__current(entry, self);\n\n\t/* given include_trees & autoexpand, we might have to go into a tree */\n\tif (iterator__do_autoexpand(fi) &&\n\t\tfi->entry.path != NULL &&\n\t\tfi->entry.mode == GIT_FILEMODE_TREE)\n\t{\n\t\tint error = fs_iterator__advance_into(entry, self);\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t\t/* continue silently past empty directories if autoexpanding */\n\t\tgiterr_clear();\n\t}\n\n\treturn fs_iterator__advance_over(entry, self);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);",
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__advance_over",
          "args": [
            "entry",
            "self"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__advance_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1460-1476",
          "snippet": "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\n\tif (entry != NULL)\n\t\t*entry = NULL;\n\n\tfs_iterator__advance_over_internal(self);\n\n\terror = fs_iterator__update_entry((fs_iterator *)self);\n\n\tif (!error && entry != NULL)\n\t\terror = fs_iterator__current(entry, self);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\n\tif (entry != NULL)\n\t\t*entry = NULL;\n\n\tfs_iterator__advance_over_internal(self);\n\n\terror = fs_iterator__update_entry((fs_iterator *)self);\n\n\tif (!error && entry != NULL)\n\t\terror = fs_iterator__current(entry, self);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__advance_into",
          "args": [
            "entry",
            "self"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__advance_into",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1415-1441",
          "snippet": "static int fs_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = 0;\n\tfs_iterator *fi = (fs_iterator *)iter;\n\n\titerator__clear_entry(entry);\n\n\t/* Allow you to explicitly advance into a commit/submodule (as well as a\n\t * tree) to avoid cases where an entry is mislabeled as a submodule in\n\t * the working directory.  The fs iterator will never have COMMMIT\n\t * entries on it's own, but a wrapper might add them.\n\t */\n\tif (fi->entry.path != NULL &&\n\t\t(fi->entry.mode == GIT_FILEMODE_TREE ||\n\t\t fi->entry.mode == GIT_FILEMODE_COMMIT))\n\t\t/* returns GIT_ENOTFOUND if the directory is empty */\n\t\terror = fs_iterator__expand_dir(fi);\n\n\tif (!error && entry)\n\t\terror = fs_iterator__current(entry, iter);\n\n\tif (!error && !fi->entry.path)\n\t\terror = GIT_ITEROVER;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = 0;\n\tfs_iterator *fi = (fs_iterator *)iter;\n\n\titerator__clear_entry(entry);\n\n\t/* Allow you to explicitly advance into a commit/submodule (as well as a\n\t * tree) to avoid cases where an entry is mislabeled as a submodule in\n\t * the working directory.  The fs iterator will never have COMMMIT\n\t * entries on it's own, but a wrapper might add them.\n\t */\n\tif (fi->entry.path != NULL &&\n\t\t(fi->entry.mode == GIT_FILEMODE_TREE ||\n\t\t fi->entry.mode == GIT_FILEMODE_COMMIT))\n\t\t/* returns GIT_ENOTFOUND if the directory is empty */\n\t\terror = fs_iterator__expand_dir(fi);\n\n\tif (!error && entry)\n\t\terror = fs_iterator__current(entry, iter);\n\n\tif (!error && !fi->entry.path)\n\t\terror = GIT_ITEROVER;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__do_autoexpand",
          "args": [
            "fi"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_iterator__current",
          "args": [
            "entry",
            "self"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1396-1408",
          "snippet": "static int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);",
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__has_been_accessed",
          "args": [
            "fi"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__advance(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\n\tif (!iterator__has_been_accessed(fi))\n\t\treturn fs_iterator__current(entry, self);\n\n\t/* given include_trees & autoexpand, we might have to go into a tree */\n\tif (iterator__do_autoexpand(fi) &&\n\t\tfi->entry.path != NULL &&\n\t\tfi->entry.mode == GIT_FILEMODE_TREE)\n\t{\n\t\tint error = fs_iterator__advance_into(entry, self);\n\t\tif (error != GIT_ENOTFOUND)\n\t\t\treturn error;\n\t\t/* continue silently past empty directories if autoexpanding */\n\t\tgiterr_clear();\n\t}\n\n\treturn fs_iterator__advance_over(entry, self);\n}"
  },
  {
    "function_name": "fs_iterator__advance_over",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1460-1476",
    "snippet": "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\n\tif (entry != NULL)\n\t\t*entry = NULL;\n\n\tfs_iterator__advance_over_internal(self);\n\n\terror = fs_iterator__update_entry((fs_iterator *)self);\n\n\tif (!error && entry != NULL)\n\t\terror = fs_iterator__current(entry, self);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__current",
          "args": [
            "entry",
            "self"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1396-1408",
          "snippet": "static int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);",
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__update_entry",
          "args": [
            "(fs_iterator *)self"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1543-1594",
          "snippet": "static int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__advance_over_internal",
          "args": [
            "self"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__advance_over_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1443-1458",
          "snippet": "static void fs_iterator__advance_over_internal(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tfs_iterator_frame *ff;\n\tfs_iterator_path_with_stat *next;\n\n\twhile (fi->entry.path != NULL) {\n\t\tff = fi->stack;\n\t\tnext = git_vector_get(&ff->entries, ++ff->index);\n\n\t\tif (next != NULL)\n\t\t\tbreak;\n\n\t\tfs_iterator__pop_frame(fi, ff, false);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);",
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void fs_iterator__advance_over_internal(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tfs_iterator_frame *ff;\n\tfs_iterator_path_with_stat *next;\n\n\twhile (fi->entry.path != NULL) {\n\t\tff = fi->stack;\n\t\tnext = git_vector_get(&ff->entries, ++ff->index);\n\n\t\tif (next != NULL)\n\t\t\tbreak;\n\n\t\tfs_iterator__pop_frame(fi, ff, false);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\n\tif (entry != NULL)\n\t\t*entry = NULL;\n\n\tfs_iterator__advance_over_internal(self);\n\n\terror = fs_iterator__update_entry((fs_iterator *)self);\n\n\tif (!error && entry != NULL)\n\t\terror = fs_iterator__current(entry, self);\n\n\treturn error;\n}"
  },
  {
    "function_name": "fs_iterator__advance_over_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1443-1458",
    "snippet": "static void fs_iterator__advance_over_internal(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tfs_iterator_frame *ff;\n\tfs_iterator_path_with_stat *next;\n\n\twhile (fi->entry.path != NULL) {\n\t\tff = fi->stack;\n\t\tnext = git_vector_get(&ff->entries, ++ff->index);\n\n\t\tif (next != NULL)\n\t\t\tbreak;\n\n\t\tfs_iterator__pop_frame(fi, ff, false);\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);",
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__pop_frame",
          "args": [
            "fi",
            "ff",
            "false"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__pop_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1195-1212",
          "snippet": "static void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ff->entries",
            "++ff->index"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void fs_iterator__advance_over_internal(git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tfs_iterator_frame *ff;\n\tfs_iterator_path_with_stat *next;\n\n\twhile (fi->entry.path != NULL) {\n\t\tff = fi->stack;\n\t\tnext = git_vector_get(&ff->entries, ++ff->index);\n\n\t\tif (next != NULL)\n\t\t\tbreak;\n\n\t\tfs_iterator__pop_frame(fi, ff, false);\n\t}\n}"
  },
  {
    "function_name": "fs_iterator__advance_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1415-1441",
    "snippet": "static int fs_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = 0;\n\tfs_iterator *fi = (fs_iterator *)iter;\n\n\titerator__clear_entry(entry);\n\n\t/* Allow you to explicitly advance into a commit/submodule (as well as a\n\t * tree) to avoid cases where an entry is mislabeled as a submodule in\n\t * the working directory.  The fs iterator will never have COMMMIT\n\t * entries on it's own, but a wrapper might add them.\n\t */\n\tif (fi->entry.path != NULL &&\n\t\t(fi->entry.mode == GIT_FILEMODE_TREE ||\n\t\t fi->entry.mode == GIT_FILEMODE_COMMIT))\n\t\t/* returns GIT_ENOTFOUND if the directory is empty */\n\t\terror = fs_iterator__expand_dir(fi);\n\n\tif (!error && entry)\n\t\terror = fs_iterator__current(entry, iter);\n\n\tif (!error && !fi->entry.path)\n\t\terror = GIT_ITEROVER;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__current",
          "args": [
            "entry",
            "iter"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1396-1408",
          "snippet": "static int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);",
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__expand_dir",
          "args": [
            "fi"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__expand_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1349-1394",
          "snippet": "static int fs_iterator__expand_dir(fs_iterator *fi)\n{\n\tint error;\n\tfs_iterator_frame *ff;\n\n\tif (fi->depth > FS_MAX_DEPTH) {\n\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\"Directory nesting is too deep (%d)\", fi->depth);\n\t\treturn -1;\n\t}\n\n\tff = fs_iterator__alloc_frame(fi);\n\tGITERR_CHECK_ALLOC(ff);\n\n\terror = dirload_with_stat(&ff->entries, fi);\n\n\tif (error < 0) {\n\t\tgit_error_state last_error = { 0 };\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\t/* these callbacks may clear the error message */\n\t\tfs_iterator__free_frame(ff);\n\t\tfs_iterator__advance_over(NULL, (git_iterator *)fi);\n\t\t/* next time return value we skipped to */\n\t\tfi->base.flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\t\treturn giterr_state_restore(&last_error);\n\t}\n\n\tif (ff->entries.length == 0) {\n\t\tfs_iterator__free_frame(ff);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\tfi->base.stat_calls += ff->entries.length;\n\n\tfs_iterator__seek_frame_start(fi, ff);\n\n\tff->next  = fi->stack;\n\tfi->stack = ff;\n\tfi->depth++;\n\n\tif (fi->enter_dir_cb && (error = fi->enter_dir_cb(fi)) < 0)\n\t\treturn error;\n\n\treturn fs_iterator__update_entry(fi);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define FS_MAX_DEPTH 100",
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define FS_MAX_DEPTH 100\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__expand_dir(fs_iterator *fi)\n{\n\tint error;\n\tfs_iterator_frame *ff;\n\n\tif (fi->depth > FS_MAX_DEPTH) {\n\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\"Directory nesting is too deep (%d)\", fi->depth);\n\t\treturn -1;\n\t}\n\n\tff = fs_iterator__alloc_frame(fi);\n\tGITERR_CHECK_ALLOC(ff);\n\n\terror = dirload_with_stat(&ff->entries, fi);\n\n\tif (error < 0) {\n\t\tgit_error_state last_error = { 0 };\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\t/* these callbacks may clear the error message */\n\t\tfs_iterator__free_frame(ff);\n\t\tfs_iterator__advance_over(NULL, (git_iterator *)fi);\n\t\t/* next time return value we skipped to */\n\t\tfi->base.flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\t\treturn giterr_state_restore(&last_error);\n\t}\n\n\tif (ff->entries.length == 0) {\n\t\tfs_iterator__free_frame(ff);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\tfi->base.stat_calls += ff->entries.length;\n\n\tfs_iterator__seek_frame_start(fi, ff);\n\n\tff->next  = fi->stack;\n\tfi->stack = ff;\n\tfi->depth++;\n\n\tif (fi->enter_dir_cb && (error = fi->enter_dir_cb(fi)) < 0)\n\t\treturn error;\n\n\treturn fs_iterator__update_entry(fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__clear_entry",
          "args": [
            "entry"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__clear_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "261-264",
          "snippet": "GIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *iter)\n{\n\tint error = 0;\n\tfs_iterator *fi = (fs_iterator *)iter;\n\n\titerator__clear_entry(entry);\n\n\t/* Allow you to explicitly advance into a commit/submodule (as well as a\n\t * tree) to avoid cases where an entry is mislabeled as a submodule in\n\t * the working directory.  The fs iterator will never have COMMMIT\n\t * entries on it's own, but a wrapper might add them.\n\t */\n\tif (fi->entry.path != NULL &&\n\t\t(fi->entry.mode == GIT_FILEMODE_TREE ||\n\t\t fi->entry.mode == GIT_FILEMODE_COMMIT))\n\t\t/* returns GIT_ENOTFOUND if the directory is empty */\n\t\terror = fs_iterator__expand_dir(fi);\n\n\tif (!error && entry)\n\t\terror = fs_iterator__current(entry, iter);\n\n\tif (!error && !fi->entry.path)\n\t\terror = GIT_ITEROVER;\n\n\treturn error;\n}"
  },
  {
    "function_name": "fs_iterator__at_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1410-1413",
    "snippet": "static int fs_iterator__at_end(git_iterator *self)\n{\n\treturn (((fs_iterator *)self)->entry.path == NULL);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__at_end(git_iterator *self)\n{\n\treturn (((fs_iterator *)self)->entry.path == NULL);\n}"
  },
  {
    "function_name": "fs_iterator__current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1396-1408",
    "snippet": "static int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [
      "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
    ],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);",
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tfs_iterator *fi = (fs_iterator *)self;\n\tconst git_index_entry *fe = (fi->entry.path == NULL) ? NULL : &fi->entry;\n\n\tif (entry)\n\t\t*entry = fe;\n\n\tfi->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (fe != NULL) ? 0 : GIT_ITEROVER;\n}"
  },
  {
    "function_name": "fs_iterator__expand_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1349-1394",
    "snippet": "static int fs_iterator__expand_dir(fs_iterator *fi)\n{\n\tint error;\n\tfs_iterator_frame *ff;\n\n\tif (fi->depth > FS_MAX_DEPTH) {\n\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\"Directory nesting is too deep (%d)\", fi->depth);\n\t\treturn -1;\n\t}\n\n\tff = fs_iterator__alloc_frame(fi);\n\tGITERR_CHECK_ALLOC(ff);\n\n\terror = dirload_with_stat(&ff->entries, fi);\n\n\tif (error < 0) {\n\t\tgit_error_state last_error = { 0 };\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\t/* these callbacks may clear the error message */\n\t\tfs_iterator__free_frame(ff);\n\t\tfs_iterator__advance_over(NULL, (git_iterator *)fi);\n\t\t/* next time return value we skipped to */\n\t\tfi->base.flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\t\treturn giterr_state_restore(&last_error);\n\t}\n\n\tif (ff->entries.length == 0) {\n\t\tfs_iterator__free_frame(ff);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\tfi->base.stat_calls += ff->entries.length;\n\n\tfs_iterator__seek_frame_start(fi, ff);\n\n\tff->next  = fi->stack;\n\tfi->stack = ff;\n\tfi->depth++;\n\n\tif (fi->enter_dir_cb && (error = fi->enter_dir_cb(fi)) < 0)\n\t\treturn error;\n\n\treturn fs_iterator__update_entry(fi);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [
      "#define FS_MAX_DEPTH 100",
      "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
    ],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__update_entry",
          "args": [
            "fi"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1543-1594",
          "snippet": "static int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__update_entry(fs_iterator *fi)\n{\n\tfs_iterator_path_with_stat *ps;\n\n\twhile (true) {\n\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\n\t\tif (!fi->stack)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tps = git_vector_get(&fi->stack->entries, fi->stack->index);\n\t\tif (!ps)\n\t\t\treturn GIT_ITEROVER;\n\n\t\tgit_buf_truncate(&fi->path, fi->root_len);\n\t\tif (git_buf_put(&fi->path, ps->path, ps->path_len) < 0)\n\t\t\treturn -1;\n\n\t\tif (iterator__past_end(fi, fi->path.ptr + fi->root_len))\n\t\t\treturn GIT_ITEROVER;\n\n\t\tfi->entry.path = ps->path;\n\t\tfi->pathlist_match = ps->pathlist_match;\n\t\tgit_index_entry__init_from_stat(&fi->entry, &ps->st, true);\n\n\t\t/* need different mode here to keep directories during iteration */\n\t\tfi->entry.mode = git_futils_canonical_mode(ps->st.st_mode);\n\n\t\t/* allow wrapper to check/update the entry (can force skip) */\n\t\tif (fi->update_entry_cb &&\n\t\t\tfi->update_entry_cb(fi) == GIT_ENOTFOUND) {\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if this is a tree and trees aren't included, then skip */\n\t\tif (fi->entry.mode == GIT_FILEMODE_TREE && !iterator__include_trees(fi)) {\n\t\t\tint error = fs_iterator__advance_into(NULL, &fi->base);\n\n\t\t\tif (error != GIT_ENOTFOUND)\n\t\t\t\treturn error;\n\n\t\t\tgiterr_clear();\n\t\t\tfs_iterator__advance_over_internal(&fi->base);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fi->enter_dir_cb",
          "args": [
            "fi"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_iterator__seek_frame_start",
          "args": [
            "fi",
            "ff"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__seek_frame_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1225-1236",
          "snippet": "static void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__free_frame",
          "args": [
            "ff"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__free_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1189-1193",
          "snippet": "static void fs_iterator__free_frame(fs_iterator_frame *ff)\n{\n\tgit_vector_free_deep(&ff->entries);\n\tgit__free(ff);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void fs_iterator__free_frame(fs_iterator_frame *ff)\n{\n\tgit_vector_free_deep(&ff->entries);\n\tgit__free(ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_state_restore",
          "args": [
            "&last_error"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "165-182",
          "snippet": "int giterr_state_restore(git_error_state *state)\n{\n\tint ret = 0;\n\n\tgiterr_clear();\n\n\tif (state && state->error_msg.message) {\n\t\tif (state->oom)\n\t\t\tgiterr_set_oom();\n\t\telse\n\t\t\tset_error(state->error_msg.klass, state->error_msg.message);\n\n\t\tret = state->error_code;\n\t\tmemset(state, 0, sizeof(git_error_state));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nint giterr_state_restore(git_error_state *state)\n{\n\tint ret = 0;\n\n\tgiterr_clear();\n\n\tif (state && state->error_msg.message) {\n\t\tif (state->oom)\n\t\t\tgiterr_set_oom();\n\t\telse\n\t\t\tset_error(state->error_msg.klass, state->error_msg.message);\n\n\t\tret = state->error_code;\n\t\tmemset(state, 0, sizeof(git_error_state));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_iterator__advance_over",
          "args": [
            "NULL",
            "(git_iterator *)fi"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__advance_over",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1460-1476",
          "snippet": "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\n\tif (entry != NULL)\n\t\t*entry = NULL;\n\n\tfs_iterator__advance_over_internal(self);\n\n\terror = fs_iterator__update_entry((fs_iterator *)self);\n\n\tif (!error && entry != NULL)\n\t\terror = fs_iterator__current(entry, self);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\n\tif (entry != NULL)\n\t\t*entry = NULL;\n\n\tfs_iterator__advance_over_internal(self);\n\n\terror = fs_iterator__update_entry((fs_iterator *)self);\n\n\tif (!error && entry != NULL)\n\t\terror = fs_iterator__current(entry, self);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_state_capture",
          "args": [
            "&last_error",
            "error"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_state_capture",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "139-163",
          "snippet": "int giterr_state_capture(git_error_state *state, int error_code)\n{\n\tgit_error *error = GIT_GLOBAL->last_error;\n\tgit_buf *error_buf = &GIT_GLOBAL->error_buf;\n\n\tmemset(state, 0, sizeof(git_error_state));\n\n\tif (!error_code)\n\t\treturn 0;\n\n\tstate->error_code = error_code;\n\tstate->oom = (error == &g_git_oom_error);\n\n\tif (error) {\n\t\tstate->error_msg.klass = error->klass;\n\n\t\tif (state->oom)\n\t\t\tstate->error_msg.message = g_git_oom_error.message;\n\t\telse\n\t\t\tstate->error_msg.message = git_buf_detach(error_buf);\n\t}\n\n\tgiterr_clear();\n\treturn error_code;\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nstatic git_error g_git_oom_error = {\n\t\"Out of memory\",\n\tGITERR_NOMEMORY\n};\n\nint giterr_state_capture(git_error_state *state, int error_code)\n{\n\tgit_error *error = GIT_GLOBAL->last_error;\n\tgit_buf *error_buf = &GIT_GLOBAL->error_buf;\n\n\tmemset(state, 0, sizeof(git_error_state));\n\n\tif (!error_code)\n\t\treturn 0;\n\n\tstate->error_code = error_code;\n\tstate->oom = (error == &g_git_oom_error);\n\n\tif (error) {\n\t\tstate->error_msg.klass = error->klass;\n\n\t\tif (state->oom)\n\t\t\tstate->error_msg.message = g_git_oom_error.message;\n\t\telse\n\t\t\tstate->error_msg.message = git_buf_detach(error_buf);\n\t}\n\n\tgiterr_clear();\n\treturn error_code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dirload_with_stat",
          "args": [
            "&ff->entries",
            "fi"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "dirload_with_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1238-1346",
          "snippet": "static int dirload_with_stat(git_vector *contents, fs_iterator *fi)\n{\n\tgit_path_diriter diriter = GIT_PATH_DIRITER_INIT;\n\tconst char *path;\n\tsize_t start_len = fi->base.start ? strlen(fi->base.start) : 0;\n\tsize_t end_len = fi->base.end ? strlen(fi->base.end) : 0;\n\tfs_iterator_path_with_stat *ps;\n\tsize_t path_len, cmp_len, ps_size;\n\titerator_pathlist__match_t pathlist_match = ITERATOR_PATHLIST_MATCH;\n\tint error;\n\n\t/* Any error here is equivalent to the dir not existing, skip over it */\n\tif ((error = git_path_diriter_init(\n\t\t\t&diriter, fi->path.ptr, fi->dirload_flags)) < 0) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\twhile ((error = git_path_diriter_next(&diriter)) == 0) {\n\t\tif ((error = git_path_diriter_fullpath(&path, &path_len, &diriter)) < 0)\n\t\t\tgoto done;\n\n\t\tassert(path_len > fi->root_len);\n\n\t\t/* remove the prefix if requested */\n\t\tpath += fi->root_len;\n\t\tpath_len -= fi->root_len;\n\n\t\t/* skip if before start_stat or after end_stat */\n\t\tcmp_len = min(start_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.start, cmp_len) < 0)\n\t\t\tcontinue;\n\t\t/* skip if after end_stat */\n\t\tcmp_len = min(end_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.end, cmp_len) > 0)\n\t\t\tcontinue;\n\n\t\t/* if we have a pathlist that we're limiting to, examine this path.\n\t\t * if the frame has already deemed us inside the path (eg, we're in\n\t\t * `foo/bar` and the pathlist previously was detected to say `foo/`)\n\t\t * then simply continue.  otherwise, examine the pathlist looking for\n\t\t * this path or children of this path.\n\t\t */\n\t\tif (fi->base.pathlist.length &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH_DIRECTORY &&\n\t\t\t!(pathlist_match = iterator_pathlist__match(&fi->base, path, path_len)))\n\t\t\tcontinue;\n\n\t\t/* Make sure to append two bytes, one for the path's null\n\t\t * termination, one for a possible trailing '/' for folders.\n\t\t */\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, sizeof(fs_iterator_path_with_stat), path_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, ps_size, 2);\n\n\t\tps = git__calloc(1, ps_size);\n\t\tps->path_len = path_len;\n\n\t\tmemcpy(ps->path, path, path_len);\n\n\t\t/* TODO: don't stat if assume unchanged for this path */\n\n\t\tif ((error = git_path_diriter_stat(&ps->st, &diriter)) < 0) {\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t/* file was removed between readdir and lstat */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathlist_match == ITERATOR_PATHLIST_MATCH_DIRECTORY) {\n\t\t\t\t/* were looking for a directory, but this is a file */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Treat the file as unreadable if we get any other error */\n\t\t\tmemset(&ps->st, 0, sizeof(ps->st));\n\t\t\tps->st.st_mode = GIT_FILEMODE_UNREADABLE;\n\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else if (S_ISDIR(ps->st.st_mode)) {\n\t\t\t/* Suffix directory paths with a '/' */\n\t\t\tps->path[ps->path_len++] = '/';\n\t\t\tps->path[ps->path_len] = '\\0';\n\t\t} else if(!S_ISREG(ps->st.st_mode) && !S_ISLNK(ps->st.st_mode)) {\n\t\t\t/* Ignore wacky things in the filesystem */\n\t\t\tgit__free(ps);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* record whether this path was explicitly found in the path list\n\t\t * or whether we're only examining it because something beneath it\n\t\t * is in the path list.\n\t\t */\n\t\tps->pathlist_match = pathlist_match;\n\t\tgit_vector_insert(contents, ps);\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\t/* sort now that directory suffix is added */\n\tgit_vector_sort(contents);\n\ndone:\n\tgit_path_diriter_free(&diriter);\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int dirload_with_stat(git_vector *contents, fs_iterator *fi)\n{\n\tgit_path_diriter diriter = GIT_PATH_DIRITER_INIT;\n\tconst char *path;\n\tsize_t start_len = fi->base.start ? strlen(fi->base.start) : 0;\n\tsize_t end_len = fi->base.end ? strlen(fi->base.end) : 0;\n\tfs_iterator_path_with_stat *ps;\n\tsize_t path_len, cmp_len, ps_size;\n\titerator_pathlist__match_t pathlist_match = ITERATOR_PATHLIST_MATCH;\n\tint error;\n\n\t/* Any error here is equivalent to the dir not existing, skip over it */\n\tif ((error = git_path_diriter_init(\n\t\t\t&diriter, fi->path.ptr, fi->dirload_flags)) < 0) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\twhile ((error = git_path_diriter_next(&diriter)) == 0) {\n\t\tif ((error = git_path_diriter_fullpath(&path, &path_len, &diriter)) < 0)\n\t\t\tgoto done;\n\n\t\tassert(path_len > fi->root_len);\n\n\t\t/* remove the prefix if requested */\n\t\tpath += fi->root_len;\n\t\tpath_len -= fi->root_len;\n\n\t\t/* skip if before start_stat or after end_stat */\n\t\tcmp_len = min(start_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.start, cmp_len) < 0)\n\t\t\tcontinue;\n\t\t/* skip if after end_stat */\n\t\tcmp_len = min(end_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.end, cmp_len) > 0)\n\t\t\tcontinue;\n\n\t\t/* if we have a pathlist that we're limiting to, examine this path.\n\t\t * if the frame has already deemed us inside the path (eg, we're in\n\t\t * `foo/bar` and the pathlist previously was detected to say `foo/`)\n\t\t * then simply continue.  otherwise, examine the pathlist looking for\n\t\t * this path or children of this path.\n\t\t */\n\t\tif (fi->base.pathlist.length &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH_DIRECTORY &&\n\t\t\t!(pathlist_match = iterator_pathlist__match(&fi->base, path, path_len)))\n\t\t\tcontinue;\n\n\t\t/* Make sure to append two bytes, one for the path's null\n\t\t * termination, one for a possible trailing '/' for folders.\n\t\t */\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, sizeof(fs_iterator_path_with_stat), path_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, ps_size, 2);\n\n\t\tps = git__calloc(1, ps_size);\n\t\tps->path_len = path_len;\n\n\t\tmemcpy(ps->path, path, path_len);\n\n\t\t/* TODO: don't stat if assume unchanged for this path */\n\n\t\tif ((error = git_path_diriter_stat(&ps->st, &diriter)) < 0) {\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t/* file was removed between readdir and lstat */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathlist_match == ITERATOR_PATHLIST_MATCH_DIRECTORY) {\n\t\t\t\t/* were looking for a directory, but this is a file */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Treat the file as unreadable if we get any other error */\n\t\t\tmemset(&ps->st, 0, sizeof(ps->st));\n\t\t\tps->st.st_mode = GIT_FILEMODE_UNREADABLE;\n\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else if (S_ISDIR(ps->st.st_mode)) {\n\t\t\t/* Suffix directory paths with a '/' */\n\t\t\tps->path[ps->path_len++] = '/';\n\t\t\tps->path[ps->path_len] = '\\0';\n\t\t} else if(!S_ISREG(ps->st.st_mode) && !S_ISLNK(ps->st.st_mode)) {\n\t\t\t/* Ignore wacky things in the filesystem */\n\t\t\tgit__free(ps);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* record whether this path was explicitly found in the path list\n\t\t * or whether we're only examining it because something beneath it\n\t\t * is in the path list.\n\t\t */\n\t\tps->pathlist_match = pathlist_match;\n\t\tgit_vector_insert(contents, ps);\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\t/* sort now that directory suffix is added */\n\tgit_vector_sort(contents);\n\ndone:\n\tgit_path_diriter_free(&diriter);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "ff"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_iterator__alloc_frame",
          "args": [
            "fi"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__alloc_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1173-1187",
          "snippet": "static fs_iterator_frame *fs_iterator__alloc_frame(fs_iterator *fi)\n{\n\tfs_iterator_frame *ff = git__calloc(1, sizeof(fs_iterator_frame));\n\tgit_vector_cmp entry_compare = CASESELECT(\n\t\titerator__ignore_case(fi),\n\t\tfs_iterator_path_with_stat_cmp_icase,\n\t\tfs_iterator_path_with_stat_cmp);\n\n\tif (ff && git_vector_init(&ff->entries, 0, entry_compare) < 0) {\n\t\tgit__free(ff);\n\t\tff = NULL;\n\t}\n\n\treturn ff;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__update_entry(fs_iterator *fi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic fs_iterator_frame *fs_iterator__alloc_frame(fs_iterator *fi)\n{\n\tfs_iterator_frame *ff = git__calloc(1, sizeof(fs_iterator_frame));\n\tgit_vector_cmp entry_compare = CASESELECT(\n\t\titerator__ignore_case(fi),\n\t\tfs_iterator_path_with_stat_cmp_icase,\n\t\tfs_iterator_path_with_stat_cmp);\n\n\tif (ff && git_vector_init(&ff->entries, 0, entry_compare) < 0) {\n\t\tgit__free(ff);\n\t\tff = NULL;\n\t}\n\n\treturn ff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "giterr_set",
          "args": [
            "GITERR_REPOSITORY",
            "\"Directory nesting is too deep (%d)\"",
            "fi->depth"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "50-89",
          "snippet": "void giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_set(int error_class, const char *string, ...)\n{\n\tva_list arglist;\n#ifdef GIT_WIN32\n\tDWORD win32_error_code = (error_class == GITERR_OS) ? GetLastError() : 0;\n#endif\n\tint error_code = (error_class == GITERR_OS) ? errno : 0;\n\tgit_buf *buf = &GIT_GLOBAL->error_buf;\n\n\tgit_buf_clear(buf);\n\tif (string) {\n\t\tva_start(arglist, string);\n\t\tgit_buf_vprintf(buf, string, arglist);\n\t\tva_end(arglist);\n\n\t\tif (error_class == GITERR_OS)\n\t\t\tgit_buf_PUTS(buf, \": \");\n\t}\n\n\tif (error_class == GITERR_OS) {\n#ifdef GIT_WIN32\n\t\tchar * win32_error = git_win32_get_error_message(win32_error_code);\n\t\tif (win32_error) {\n\t\t\tgit_buf_puts(buf, win32_error);\n\t\t\tgit__free(win32_error);\n\n\t\t\tSetLastError(0);\n\t\t}\n\t\telse\n#endif\n\t\tif (error_code)\n\t\t\tgit_buf_puts(buf, strerror(error_code));\n\n\t\tif (error_code)\n\t\t\terrno = 0;\n\t}\n\n\tif (!git_buf_oom(buf))\n\t\tset_error_from_buffer(error_class);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define FS_MAX_DEPTH 100\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__expand_dir(fs_iterator *fi)\n{\n\tint error;\n\tfs_iterator_frame *ff;\n\n\tif (fi->depth > FS_MAX_DEPTH) {\n\t\tgiterr_set(GITERR_REPOSITORY,\n\t\t\t\"Directory nesting is too deep (%d)\", fi->depth);\n\t\treturn -1;\n\t}\n\n\tff = fs_iterator__alloc_frame(fi);\n\tGITERR_CHECK_ALLOC(ff);\n\n\terror = dirload_with_stat(&ff->entries, fi);\n\n\tif (error < 0) {\n\t\tgit_error_state last_error = { 0 };\n\t\tgiterr_state_capture(&last_error, error);\n\n\t\t/* these callbacks may clear the error message */\n\t\tfs_iterator__free_frame(ff);\n\t\tfs_iterator__advance_over(NULL, (git_iterator *)fi);\n\t\t/* next time return value we skipped to */\n\t\tfi->base.flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\t\treturn giterr_state_restore(&last_error);\n\t}\n\n\tif (ff->entries.length == 0) {\n\t\tfs_iterator__free_frame(ff);\n\t\treturn GIT_ENOTFOUND;\n\t}\n\tfi->base.stat_calls += ff->entries.length;\n\n\tfs_iterator__seek_frame_start(fi, ff);\n\n\tff->next  = fi->stack;\n\tfi->stack = ff;\n\tfi->depth++;\n\n\tif (fi->enter_dir_cb && (error = fi->enter_dir_cb(fi)) < 0)\n\t\treturn error;\n\n\treturn fs_iterator__update_entry(fi);\n}"
  },
  {
    "function_name": "dirload_with_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1238-1346",
    "snippet": "static int dirload_with_stat(git_vector *contents, fs_iterator *fi)\n{\n\tgit_path_diriter diriter = GIT_PATH_DIRITER_INIT;\n\tconst char *path;\n\tsize_t start_len = fi->base.start ? strlen(fi->base.start) : 0;\n\tsize_t end_len = fi->base.end ? strlen(fi->base.end) : 0;\n\tfs_iterator_path_with_stat *ps;\n\tsize_t path_len, cmp_len, ps_size;\n\titerator_pathlist__match_t pathlist_match = ITERATOR_PATHLIST_MATCH;\n\tint error;\n\n\t/* Any error here is equivalent to the dir not existing, skip over it */\n\tif ((error = git_path_diriter_init(\n\t\t\t&diriter, fi->path.ptr, fi->dirload_flags)) < 0) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\twhile ((error = git_path_diriter_next(&diriter)) == 0) {\n\t\tif ((error = git_path_diriter_fullpath(&path, &path_len, &diriter)) < 0)\n\t\t\tgoto done;\n\n\t\tassert(path_len > fi->root_len);\n\n\t\t/* remove the prefix if requested */\n\t\tpath += fi->root_len;\n\t\tpath_len -= fi->root_len;\n\n\t\t/* skip if before start_stat or after end_stat */\n\t\tcmp_len = min(start_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.start, cmp_len) < 0)\n\t\t\tcontinue;\n\t\t/* skip if after end_stat */\n\t\tcmp_len = min(end_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.end, cmp_len) > 0)\n\t\t\tcontinue;\n\n\t\t/* if we have a pathlist that we're limiting to, examine this path.\n\t\t * if the frame has already deemed us inside the path (eg, we're in\n\t\t * `foo/bar` and the pathlist previously was detected to say `foo/`)\n\t\t * then simply continue.  otherwise, examine the pathlist looking for\n\t\t * this path or children of this path.\n\t\t */\n\t\tif (fi->base.pathlist.length &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH_DIRECTORY &&\n\t\t\t!(pathlist_match = iterator_pathlist__match(&fi->base, path, path_len)))\n\t\t\tcontinue;\n\n\t\t/* Make sure to append two bytes, one for the path's null\n\t\t * termination, one for a possible trailing '/' for folders.\n\t\t */\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, sizeof(fs_iterator_path_with_stat), path_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, ps_size, 2);\n\n\t\tps = git__calloc(1, ps_size);\n\t\tps->path_len = path_len;\n\n\t\tmemcpy(ps->path, path, path_len);\n\n\t\t/* TODO: don't stat if assume unchanged for this path */\n\n\t\tif ((error = git_path_diriter_stat(&ps->st, &diriter)) < 0) {\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t/* file was removed between readdir and lstat */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathlist_match == ITERATOR_PATHLIST_MATCH_DIRECTORY) {\n\t\t\t\t/* were looking for a directory, but this is a file */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Treat the file as unreadable if we get any other error */\n\t\t\tmemset(&ps->st, 0, sizeof(ps->st));\n\t\t\tps->st.st_mode = GIT_FILEMODE_UNREADABLE;\n\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else if (S_ISDIR(ps->st.st_mode)) {\n\t\t\t/* Suffix directory paths with a '/' */\n\t\t\tps->path[ps->path_len++] = '/';\n\t\t\tps->path[ps->path_len] = '\\0';\n\t\t} else if(!S_ISREG(ps->st.st_mode) && !S_ISLNK(ps->st.st_mode)) {\n\t\t\t/* Ignore wacky things in the filesystem */\n\t\t\tgit__free(ps);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* record whether this path was explicitly found in the path list\n\t\t * or whether we're only examining it because something beneath it\n\t\t * is in the path list.\n\t\t */\n\t\tps->pathlist_match = pathlist_match;\n\t\tgit_vector_insert(contents, ps);\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\t/* sort now that directory suffix is added */\n\tgit_vector_sort(contents);\n\ndone:\n\tgit_path_diriter_free(&diriter);\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_diriter_free",
          "args": [
            "&diriter"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1378-1393",
          "snippet": "void git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tif (diriter->dir) {\n\t\tclosedir(diriter->dir);\n\t\tdiriter->dir = NULL;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&diriter->ic);\n#endif\n\n\tgit_buf_free(&diriter->path);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nvoid git_path_diriter_free(git_path_diriter *diriter)\n{\n\tif (diriter == NULL)\n\t\treturn;\n\n\tif (diriter->dir) {\n\t\tclosedir(diriter->dir);\n\t\tdiriter->dir = NULL;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tgit_path_iconv_clear(&diriter->ic);\n#endif\n\n\tgit_buf_free(&diriter->path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "contents"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "contents",
            "ps"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ps"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ps->st.st_mode"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ps->st.st_mode"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ps->st.st_mode"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giterr_clear",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "giterr_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/errors.c",
          "lines": "121-132",
          "snippet": "void giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}",
          "includes": [
            "#include \"buffer.h\"",
            "#include \"posix.h\"",
            "#include \"global.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer.h\"\n#include \"posix.h\"\n#include \"global.h\"\n#include \"common.h\"\n\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ps->st",
            "0",
            "sizeof(ps->st)"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_diriter_stat",
          "args": [
            "&ps->st",
            "&diriter"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1371-1376",
          "snippet": "int git_path_diriter_stat(struct stat *out, git_path_diriter *diriter)\n{\n\tassert(out && diriter);\n\n\treturn git_path_lstat(diriter->path.ptr, out);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_stat(struct stat *out, git_path_diriter *diriter)\n{\n\tassert(out && diriter);\n\n\treturn git_path_lstat(diriter->path.ptr, out);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ps->path",
            "path",
            "path_len"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "ps_size"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&ps_size",
            "ps_size",
            "2"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&ps_size",
            "sizeof(fs_iterator_path_with_stat)",
            "path_len"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator_pathlist__match",
          "args": [
            "&fi->base",
            "path",
            "path_len"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_pathlist__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "95-133",
          "snippet": "static iterator_pathlist__match_t iterator_pathlist__match(\n\tgit_iterator *iter, const char *path, size_t path_len)\n{\n\tconst char *p;\n\tsize_t idx;\n\tint error;\n\n\terror = git_vector_bsearch2(&idx, &iter->pathlist,\n\t\t(git_vector_cmp)iter->strcomp, path);\n\n\tif (error == 0)\n\t\treturn ITERATOR_PATHLIST_MATCH;\n\n\t/* at this point, the path we're examining may be a directory (though we\n\t * don't know that yet, since we're avoiding a stat unless it's necessary)\n\t * so see if the pathlist contains a file beneath this directory.\n\t */\n\twhile ((p = git_vector_get(&iter->pathlist, idx)) != NULL) {\n\t\tif (iter->prefixcomp(p, path) != 0)\n\t\t\tbreak;\n\n\t\t/* an exact match would have been matched by the bsearch above */\n\t\tassert(p[path_len]);\n\n\t\t/* is this a literal directory entry (eg `foo/`) or a file beneath */\n\t\tif (p[path_len] == '/') {\n\t\t\treturn (p[path_len+1] == '\\0') ?\n\t\t\t\tITERATOR_PATHLIST_MATCH_DIRECTORY :\n\t\t\t\tITERATOR_PATHLIST_MATCH_CHILD;\n\t\t}\n\n\t\tif (p[path_len] > '/')\n\t\t\tbreak;\n\n\t\tidx++;\n\t}\n\n\treturn ITERATOR_PATHLIST_NONE;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic iterator_pathlist__match_t iterator_pathlist__match(\n\tgit_iterator *iter, const char *path, size_t path_len)\n{\n\tconst char *p;\n\tsize_t idx;\n\tint error;\n\n\terror = git_vector_bsearch2(&idx, &iter->pathlist,\n\t\t(git_vector_cmp)iter->strcomp, path);\n\n\tif (error == 0)\n\t\treturn ITERATOR_PATHLIST_MATCH;\n\n\t/* at this point, the path we're examining may be a directory (though we\n\t * don't know that yet, since we're avoiding a stat unless it's necessary)\n\t * so see if the pathlist contains a file beneath this directory.\n\t */\n\twhile ((p = git_vector_get(&iter->pathlist, idx)) != NULL) {\n\t\tif (iter->prefixcomp(p, path) != 0)\n\t\t\tbreak;\n\n\t\t/* an exact match would have been matched by the bsearch above */\n\t\tassert(p[path_len]);\n\n\t\t/* is this a literal directory entry (eg `foo/`) or a file beneath */\n\t\tif (p[path_len] == '/') {\n\t\t\treturn (p[path_len+1] == '\\0') ?\n\t\t\t\tITERATOR_PATHLIST_MATCH_DIRECTORY :\n\t\t\t\tITERATOR_PATHLIST_MATCH_CHILD;\n\t\t}\n\n\t\tif (p[path_len] > '/')\n\t\t\tbreak;\n\n\t\tidx++;\n\t}\n\n\treturn ITERATOR_PATHLIST_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fi->base.strncomp",
          "args": [
            "path",
            "fi->base.end",
            "cmp_len"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end_len",
            "path_len"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "homing_search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "130-143",
          "snippet": "static int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nstatic int homing_search_cmp(const void *key, const void *array_member)\n{\n\tconst struct tree_key_search *ksearch = key;\n\tconst git_tree_entry *entry = array_member;\n\n\tconst uint16_t len1 = ksearch->filename_len;\n\tconst uint16_t len2 = entry->filename_len;\n\n\treturn memcmp(\n\t\tksearch->filename,\n\t\tentry->filename,\n\t\tlen1 < len2 ? len1 : len2\n\t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fi->base.strncomp",
          "args": [
            "path",
            "fi->base.start",
            "cmp_len"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "path_len > fi->root_len"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_path_diriter_fullpath",
          "args": [
            "&path",
            "&path_len",
            "&diriter"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_fullpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1359-1369",
          "snippet": "int git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path.ptr;\n\t*out_len = diriter->path.size;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_fullpath(\n\tconst char **out,\n\tsize_t *out_len,\n\tgit_path_diriter *diriter)\n{\n\tassert(out && out_len && diriter);\n\n\t*out = diriter->path.ptr;\n\t*out_len = diriter->path.size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_diriter_next",
          "args": [
            "&diriter"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1299-1343",
          "snippet": "int git_path_diriter_next(git_path_diriter *diriter)\n{\n\tstruct dirent *de;\n\tconst char *filename;\n\tsize_t filename_len;\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\tint error = 0;\n\n\tassert(diriter);\n\n\terrno = 0;\n\n\tdo {\n\t\tif ((de = readdir(diriter->dir)) == NULL) {\n\t\t\tif (!errno)\n\t\t\t\treturn GIT_ITEROVER;\n\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Could not read directory '%s'\", diriter->path);\n\t\t\treturn -1;\n\t\t}\n\t} while (skip_dot && git_path_is_dot_or_dotdot(de->d_name));\n\n\tfilename = de->d_name;\n\tfilename_len = strlen(filename);\n\n#ifdef GIT_USE_ICONV\n\tif ((diriter->flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0 &&\n\t\t(error = git_path_iconv(&diriter->ic, &filename, &filename_len)) < 0)\n\t\treturn error;\n#endif\n\n\tgit_buf_truncate(&diriter->path, diriter->parent_len);\n\n\tif (diriter->parent_len > 0 &&\n\t\tdiriter->path.ptr[diriter->parent_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path, '/');\n\n\tgit_buf_put(&diriter->path, filename, filename_len);\n\n\tif (git_buf_oom(&diriter->path))\n\t\treturn -1;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_next(git_path_diriter *diriter)\n{\n\tstruct dirent *de;\n\tconst char *filename;\n\tsize_t filename_len;\n\tbool skip_dot = !(diriter->flags & GIT_PATH_DIR_INCLUDE_DOT_AND_DOTDOT);\n\tint error = 0;\n\n\tassert(diriter);\n\n\terrno = 0;\n\n\tdo {\n\t\tif ((de = readdir(diriter->dir)) == NULL) {\n\t\t\tif (!errno)\n\t\t\t\treturn GIT_ITEROVER;\n\n\t\t\tgiterr_set(GITERR_OS,\n\t\t\t\t\"Could not read directory '%s'\", diriter->path);\n\t\t\treturn -1;\n\t\t}\n\t} while (skip_dot && git_path_is_dot_or_dotdot(de->d_name));\n\n\tfilename = de->d_name;\n\tfilename_len = strlen(filename);\n\n#ifdef GIT_USE_ICONV\n\tif ((diriter->flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0 &&\n\t\t(error = git_path_iconv(&diriter->ic, &filename, &filename_len)) < 0)\n\t\treturn error;\n#endif\n\n\tgit_buf_truncate(&diriter->path, diriter->parent_len);\n\n\tif (diriter->parent_len > 0 &&\n\t\tdiriter->path.ptr[diriter->parent_len-1] != '/')\n\t\tgit_buf_putc(&diriter->path, '/');\n\n\tgit_buf_put(&diriter->path, filename, filename_len);\n\n\tif (git_buf_oom(&diriter->path))\n\t\treturn -1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_path_diriter_init",
          "args": [
            "&diriter",
            "fi->path.ptr",
            "fi->dirload_flags"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_diriter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "1262-1297",
          "snippet": "int git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\n\tif (git_buf_puts(&diriter->path, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path);\n\n\tif (diriter->path.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->dir = opendir(diriter->path.ptr)) == NULL) {\n\t\tgit_buf_free(&diriter->path);\n\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&diriter->ic);\n#endif\n\n\tdiriter->parent_len = diriter->path.size;\n\tdiriter->flags = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_diriter_init(\n\tgit_path_diriter *diriter,\n\tconst char *path,\n\tunsigned int flags)\n{\n\tassert(diriter && path);\n\n\tmemset(diriter, 0, sizeof(git_path_diriter));\n\n\tif (git_buf_puts(&diriter->path, path) < 0)\n\t\treturn -1;\n\n\tgit_path_trim_slashes(&diriter->path);\n\n\tif (diriter->path.size == 0) {\n\t\tgiterr_set(GITERR_FILESYSTEM, \"Could not open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif ((diriter->dir = opendir(diriter->path.ptr)) == NULL) {\n\t\tgit_buf_free(&diriter->path);\n\n\t\tgiterr_set(GITERR_OS, \"Failed to open directory '%s'\", path);\n\t\treturn -1;\n\t}\n\n#ifdef GIT_USE_ICONV\n\tif ((flags & GIT_PATH_DIR_PRECOMPOSE_UNICODE) != 0)\n\t\t(void)git_path_iconv_init_precompose(&diriter->ic);\n#endif\n\n\tdiriter->parent_len = diriter->path.size;\n\tdiriter->flags = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fi->base.end"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fi->base.start"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int dirload_with_stat(git_vector *contents, fs_iterator *fi)\n{\n\tgit_path_diriter diriter = GIT_PATH_DIRITER_INIT;\n\tconst char *path;\n\tsize_t start_len = fi->base.start ? strlen(fi->base.start) : 0;\n\tsize_t end_len = fi->base.end ? strlen(fi->base.end) : 0;\n\tfs_iterator_path_with_stat *ps;\n\tsize_t path_len, cmp_len, ps_size;\n\titerator_pathlist__match_t pathlist_match = ITERATOR_PATHLIST_MATCH;\n\tint error;\n\n\t/* Any error here is equivalent to the dir not existing, skip over it */\n\tif ((error = git_path_diriter_init(\n\t\t\t&diriter, fi->path.ptr, fi->dirload_flags)) < 0) {\n\t\terror = GIT_ENOTFOUND;\n\t\tgoto done;\n\t}\n\n\twhile ((error = git_path_diriter_next(&diriter)) == 0) {\n\t\tif ((error = git_path_diriter_fullpath(&path, &path_len, &diriter)) < 0)\n\t\t\tgoto done;\n\n\t\tassert(path_len > fi->root_len);\n\n\t\t/* remove the prefix if requested */\n\t\tpath += fi->root_len;\n\t\tpath_len -= fi->root_len;\n\n\t\t/* skip if before start_stat or after end_stat */\n\t\tcmp_len = min(start_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.start, cmp_len) < 0)\n\t\t\tcontinue;\n\t\t/* skip if after end_stat */\n\t\tcmp_len = min(end_len, path_len);\n\t\tif (cmp_len && fi->base.strncomp(path, fi->base.end, cmp_len) > 0)\n\t\t\tcontinue;\n\n\t\t/* if we have a pathlist that we're limiting to, examine this path.\n\t\t * if the frame has already deemed us inside the path (eg, we're in\n\t\t * `foo/bar` and the pathlist previously was detected to say `foo/`)\n\t\t * then simply continue.  otherwise, examine the pathlist looking for\n\t\t * this path or children of this path.\n\t\t */\n\t\tif (fi->base.pathlist.length &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH &&\n\t\t\tfi->pathlist_match != ITERATOR_PATHLIST_MATCH_DIRECTORY &&\n\t\t\t!(pathlist_match = iterator_pathlist__match(&fi->base, path, path_len)))\n\t\t\tcontinue;\n\n\t\t/* Make sure to append two bytes, one for the path's null\n\t\t * termination, one for a possible trailing '/' for folders.\n\t\t */\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, sizeof(fs_iterator_path_with_stat), path_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&ps_size, ps_size, 2);\n\n\t\tps = git__calloc(1, ps_size);\n\t\tps->path_len = path_len;\n\n\t\tmemcpy(ps->path, path, path_len);\n\n\t\t/* TODO: don't stat if assume unchanged for this path */\n\n\t\tif ((error = git_path_diriter_stat(&ps->st, &diriter)) < 0) {\n\t\t\tif (error == GIT_ENOTFOUND) {\n\t\t\t\t/* file was removed between readdir and lstat */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pathlist_match == ITERATOR_PATHLIST_MATCH_DIRECTORY) {\n\t\t\t\t/* were looking for a directory, but this is a file */\n\t\t\t\tgit__free(ps);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Treat the file as unreadable if we get any other error */\n\t\t\tmemset(&ps->st, 0, sizeof(ps->st));\n\t\t\tps->st.st_mode = GIT_FILEMODE_UNREADABLE;\n\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t} else if (S_ISDIR(ps->st.st_mode)) {\n\t\t\t/* Suffix directory paths with a '/' */\n\t\t\tps->path[ps->path_len++] = '/';\n\t\t\tps->path[ps->path_len] = '\\0';\n\t\t} else if(!S_ISREG(ps->st.st_mode) && !S_ISLNK(ps->st.st_mode)) {\n\t\t\t/* Ignore wacky things in the filesystem */\n\t\t\tgit__free(ps);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* record whether this path was explicitly found in the path list\n\t\t * or whether we're only examining it because something beneath it\n\t\t * is in the path list.\n\t\t */\n\t\tps->pathlist_match = pathlist_match;\n\t\tgit_vector_insert(contents, ps);\n\t}\n\n\tif (error == GIT_ITEROVER)\n\t\terror = 0;\n\n\t/* sort now that directory suffix is added */\n\tgit_vector_sort(contents);\n\ndone:\n\tgit_path_diriter_free(&diriter);\n\treturn error;\n}"
  },
  {
    "function_name": "fs_iterator__seek_frame_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1225-1236",
    "snippet": "static void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "&ff->index",
            "&ff->entries",
            "fs_iterator__entry_cmp",
            "fi"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__seek_frame_start(\n\tfs_iterator *fi, fs_iterator_frame *ff)\n{\n\tif (!ff)\n\t\treturn;\n\n\tif (fi->base.start)\n\t\tgit_vector_bsearch2(\n\t\t\t&ff->index, &ff->entries, fs_iterator__entry_cmp, fi);\n\telse\n\t\tff->index = 0;\n}"
  },
  {
    "function_name": "fs_iterator__entry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1218-1223",
    "snippet": "static int fs_iterator__entry_cmp(const void *i, const void *item)\n{\n\tconst fs_iterator *fi = (const fs_iterator *)i;\n\tconst fs_iterator_path_with_stat *ps = item;\n\treturn fi->base.prefixcomp(fi->base.start, ps->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fi->base.prefixcomp",
          "args": [
            "fi->base.start",
            "ps->path"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic int fs_iterator__entry_cmp(const void *i, const void *item)\n{\n\tconst fs_iterator *fi = (const fs_iterator *)i;\n\tconst fs_iterator_path_with_stat *ps = item;\n\treturn fi->base.prefixcomp(fi->base.start, ps->path);\n}"
  },
  {
    "function_name": "fs_iterator__pop_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1195-1212",
    "snippet": "static void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_iterator__free_frame",
          "args": [
            "ff"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "fs_iterator__free_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1189-1193",
          "snippet": "static void fs_iterator__free_frame(fs_iterator_frame *ff)\n{\n\tgit_vector_free_deep(&ff->entries);\n\tgit__free(ff);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void fs_iterator__free_frame(fs_iterator_frame *ff)\n{\n\tgit_vector_free_deep(&ff->entries);\n\tgit__free(ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fi->leave_dir_cb",
          "args": [
            "fi"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fi->entry",
            "0",
            "sizeof(fi->entry)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic void fs_iterator__pop_frame(\n\tfs_iterator *fi, fs_iterator_frame *ff, bool pop_last)\n{\n\tif (fi && fi->stack == ff) {\n\t\tif (!ff->next && !pop_last) {\n\t\t\tmemset(&fi->entry, 0, sizeof(fi->entry));\n\t\t\treturn;\n\t\t}\n\n\t\tif (fi->leave_dir_cb)\n\t\t\t(void)fi->leave_dir_cb(fi);\n\n\t\tfi->stack = ff->next;\n\t\tfi->depth--;\n\t}\n\n\tfs_iterator__free_frame(ff);\n}"
  },
  {
    "function_name": "fs_iterator__free_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1189-1193",
    "snippet": "static void fs_iterator__free_frame(fs_iterator_frame *ff)\n{\n\tgit_vector_free_deep(&ff->entries);\n\tgit__free(ff);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ff"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_free_deep",
          "args": [
            "&ff->entries"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_free_deep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "83-95",
          "snippet": "void git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_free_deep(git_vector *v)\n{\n\tsize_t i;\n\n\tassert(v);\n\n\tfor (i = 0; i < v->length; ++i) {\n\t\tgit__free(v->contents[i]);\n\t\tv->contents[i] = NULL;\n\t}\n\n\tgit_vector_free(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void fs_iterator__free_frame(fs_iterator_frame *ff)\n{\n\tgit_vector_free_deep(&ff->entries);\n\tgit__free(ff);\n}"
  },
  {
    "function_name": "fs_iterator__alloc_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1173-1187",
    "snippet": "static fs_iterator_frame *fs_iterator__alloc_frame(fs_iterator *fi)\n{\n\tfs_iterator_frame *ff = git__calloc(1, sizeof(fs_iterator_frame));\n\tgit_vector_cmp entry_compare = CASESELECT(\n\t\titerator__ignore_case(fi),\n\t\tfs_iterator_path_with_stat_cmp_icase,\n\t\tfs_iterator_path_with_stat_cmp);\n\n\tif (ff && git_vector_init(&ff->entries, 0, entry_compare) < 0) {\n\t\tgit__free(ff);\n\t\tff = NULL;\n\t}\n\n\treturn ff;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__update_entry(fs_iterator *fi);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ff"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&ff->entries",
            "0",
            "entry_compare"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "CASESELECT",
          "args": [
            "iterator__ignore_case(fi)",
            "fs_iterator_path_with_stat_cmp_icase",
            "fs_iterator_path_with_stat_cmp"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "fi"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(fs_iterator_frame)"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__update_entry(fs_iterator *fi);\n\nstatic fs_iterator_frame *fs_iterator__alloc_frame(fs_iterator *fi)\n{\n\tfs_iterator_frame *ff = git__calloc(1, sizeof(fs_iterator_frame));\n\tgit_vector_cmp entry_compare = CASESELECT(\n\t\titerator__ignore_case(fi),\n\t\tfs_iterator_path_with_stat_cmp_icase,\n\t\tfs_iterator_path_with_stat_cmp);\n\n\tif (ff && git_vector_init(&ff->entries, 0, entry_compare) < 0) {\n\t\tgit__free(ff);\n\t\tff = NULL;\n\t}\n\n\treturn ff;\n}"
  },
  {
    "function_name": "fs_iterator_path_with_stat_cmp_icase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1167-1171",
    "snippet": "static int fs_iterator_path_with_stat_cmp_icase(const void *a, const void *b)\n{\n\tconst fs_iterator_path_with_stat *psa = a, *psb = b;\n\treturn strcasecmp(psa->path, psb->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "psa->path",
            "psb->path"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcasecmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "567-570",
          "snippet": "int git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcasecmp_cb(const void *a, const void *b)\n{\n\treturn strcasecmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator_path_with_stat_cmp_icase(const void *a, const void *b)\n{\n\tconst fs_iterator_path_with_stat *psa = a, *psb = b;\n\treturn strcasecmp(psa->path, psb->path);\n}"
  },
  {
    "function_name": "fs_iterator_path_with_stat_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1161-1165",
    "snippet": "static int fs_iterator_path_with_stat_cmp(const void *a, const void *b)\n{\n\tconst fs_iterator_path_with_stat *psa = a, *psb = b;\n\treturn strcmp(psa->path, psb->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "psa->path",
            "psb->path"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "git__strcmp_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "562-565",
          "snippet": "int git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__strcmp_cb(const void *a, const void *b)\n{\n\treturn strcmp((const char *)a, (const char *)b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator_path_with_stat_cmp(const void *a, const void *b)\n{\n\tconst fs_iterator_path_with_stat *psa = a, *psb = b;\n\treturn strcmp(psa->path, psb->path);\n}"
  },
  {
    "function_name": "git_iterator_for_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1087-1124",
    "snippet": "int git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__reset",
          "args": [
            "(git_iterator *)ii",
            "NULL",
            "NULL"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1039-1077",
          "snippet": "static int index_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie;\n\n\tif (iterator__reset_range(self, start, end) < 0)\n\t\treturn -1;\n\n\tii->current = 0;\n\n\titerator_pathlist_walk__reset(self);\n\n\t/* if we're given a start prefix, find it; if we're given a pathlist, find\n\t * the first of those.  start at the later of the two.\n\t */\n\tif (ii->base.start)\n\t\tgit_index_snapshot_find(\n\t\t\t&ii->current, &ii->entries, ii->entry_srch, ii->base.start, 0, 0);\n\n\tif ((ie = index_iterator__advance_over_unwanted(ii)) == NULL)\n\t\treturn 0;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = 0;\n\n\tif (ii->base.start) {\n\t\tsize_t startlen = strlen(ii->base.start);\n\n\t\tii->partial_pos = (startlen > ii->partial.size) ?\n\t\t\tii->partial.size : startlen;\n\t}\n\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie;\n\n\tif (iterator__reset_range(self, start, end) < 0)\n\t\treturn -1;\n\n\tii->current = 0;\n\n\titerator_pathlist_walk__reset(self);\n\n\t/* if we're given a start prefix, find it; if we're given a pathlist, find\n\t * the first of those.  start at the later of the two.\n\t */\n\tif (ii->base.start)\n\t\tgit_index_snapshot_find(\n\t\t\t&ii->current, &ii->entries, ii->entry_srch, ii->base.start, 0, 0);\n\n\tif ((ie = index_iterator__advance_over_unwanted(ii)) == NULL)\n\t\treturn 0;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = 0;\n\n\tif (ii->base.start) {\n\t\tsize_t startlen = strlen(ii->base.start);\n\n\t\tii->partial_pos = (startlen > ii->partial.size) ?\n\t\t\tii->partial.size : startlen;\n\t}\n\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_init",
          "args": [
            "&ii->partial",
            "0"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "25-33",
          "snippet": "void git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_init(git_buf *buf, size_t initial_size)\n{\n\tbuf->asize = 0;\n\tbuf->size = 0;\n\tbuf->ptr = git_buf__initbuf;\n\n\tif (initial_size)\n\t\tgit_buf_grow(buf, initial_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&ii->entries"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&ii->entries",
            "iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "ii"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "ii"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "(git_iterator *)ii"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__update_ignore_case",
          "args": [
            "(git_iterator *)ii",
            "options ? options->flags : 0"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__update_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "222-259",
          "snippet": "static int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITERATOR_BASE_INIT",
          "args": [
            "ii",
            "index",
            "INDEX",
            "repo"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ii"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_snapshot_new",
          "args": [
            "&ii->entries",
            "index"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_snapshot_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3320-3335",
          "snippet": "int git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nint git_index_snapshot_new(git_vector *snap, git_index *index)\n{\n\tint error;\n\n\tGIT_REFCOUNT_INC(index);\n\n\tgit_atomic_inc(&index->readers);\n\tgit_vector_sort(&index->entries);\n\n\terror = git_vector_dup(snap, &index->entries, index->entries._cmp);\n\n\tif (error < 0)\n\t\tgit_index_free(index);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "ii"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(index_iterator)"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_index(\n\tgit_iterator **iter,\n\tgit_repository *repo,\n\tgit_index  *index,\n\tgit_iterator_options *options)\n{\n\tint error = 0;\n\tindex_iterator *ii = git__calloc(1, sizeof(index_iterator));\n\tGITERR_CHECK_ALLOC(ii);\n\n\tif ((error = git_index_snapshot_new(&ii->entries, index)) < 0) {\n\t\tgit__free(ii);\n\t\treturn error;\n\t}\n\tii->index = index;\n\n\tITERATOR_BASE_INIT(ii, index, INDEX, repo);\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ii, options ? options->flags : 0)) < 0) {\n\t\tgit_iterator_free((git_iterator *)ii);\n\t\treturn error;\n\t}\n\n\tii->entry_srch = iterator__ignore_case(ii) ?\n\t\tgit_index_entry_isrch : git_index_entry_srch;\n\n\tgit_vector_set_cmp(&ii->entries, iterator__ignore_case(ii) ?\n\t\tgit_index_entry_icmp : git_index_entry_cmp);\n\tgit_vector_sort(&ii->entries);\n\n\tgit_buf_init(&ii->partial, 0);\n\tii->tree_entry.mode = GIT_FILEMODE_TREE;\n\n\tindex_iterator__reset((git_iterator *)ii, NULL, NULL);\n\n\t*iter = (git_iterator *)ii;\n\treturn 0;\n}"
  },
  {
    "function_name": "index_iterator__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1079-1085",
    "snippet": "static void index_iterator__free(git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tgit_index_snapshot_release(&ii->entries, ii->index);\n\tii->index = NULL;\n\tgit_buf_free(&ii->partial);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ii->partial"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_snapshot_release",
          "args": [
            "&ii->entries",
            "ii->index"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_snapshot_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3337-3344",
          "snippet": "void git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool is_index_extended(git_index *index);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic bool is_index_extended(git_index *index);\n\nvoid git_index_snapshot_release(git_vector *snap, git_index *index)\n{\n\tgit_vector_free(snap);\n\n\tgit_atomic_dec(&index->readers);\n\n\tgit_index_free(index);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void index_iterator__free(git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tgit_index_snapshot_release(&ii->entries, ii->index);\n\tii->index = NULL;\n\tgit_buf_free(&ii->partial);\n}"
  },
  {
    "function_name": "index_iterator__reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1039-1077",
    "snippet": "static int index_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie;\n\n\tif (iterator__reset_range(self, start, end) < 0)\n\t\treturn -1;\n\n\tii->current = 0;\n\n\titerator_pathlist_walk__reset(self);\n\n\t/* if we're given a start prefix, find it; if we're given a pathlist, find\n\t * the first of those.  start at the later of the two.\n\t */\n\tif (ii->base.start)\n\t\tgit_index_snapshot_find(\n\t\t\t&ii->current, &ii->entries, ii->entry_srch, ii->base.start, 0, 0);\n\n\tif ((ie = index_iterator__advance_over_unwanted(ii)) == NULL)\n\t\treturn 0;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = 0;\n\n\tif (ii->base.start) {\n\t\tsize_t startlen = strlen(ii->base.start);\n\n\t\tii->partial_pos = (startlen > ii->partial.size) ?\n\t\t\tii->partial.size : startlen;\n\t}\n\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__next_prefix_tree",
          "args": [
            "ii"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__next_prefix_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "908-927",
          "snippet": "static void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ii->base.start"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&ii->partial",
            "ie->path"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iterator__advance_over_unwanted",
          "args": [
            "ii"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__advance_over_unwanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "874-906",
          "snippet": "static const git_index_entry *index_iterator__advance_over_unwanted(\n\tindex_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__index_entry(ii);\n\tbool match;\n\n\twhile (ie) {\n\t\tif (!iterator__include_conflicts(ii) &&\n\t\t\t\tgit_index_entry_is_conflict(ie)) {\n\t\t\tii->current++;\n\t\t\tie = index_iterator__index_entry(ii);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if we have a pathlist, this entry's path must be in it to be\n\t\t * returned.  walk the pathlist in unison with the index to\n\t\t * compare paths.\n\t\t */\n\t\tif (ii->base.pathlist.length) {\n\t\t\tmatch = iterator_pathlist_walk__contains(&ii->base, ie->path);\n\n\t\t\tif (!match) {\n\t\t\t\tii->current++;\n\t\t\t\tie = index_iterator__index_entry(ii);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ie;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic const git_index_entry *index_iterator__advance_over_unwanted(\n\tindex_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__index_entry(ii);\n\tbool match;\n\n\twhile (ie) {\n\t\tif (!iterator__include_conflicts(ii) &&\n\t\t\t\tgit_index_entry_is_conflict(ie)) {\n\t\t\tii->current++;\n\t\t\tie = index_iterator__index_entry(ii);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if we have a pathlist, this entry's path must be in it to be\n\t\t * returned.  walk the pathlist in unison with the index to\n\t\t * compare paths.\n\t\t */\n\t\tif (ii->base.pathlist.length) {\n\t\t\tmatch = iterator_pathlist_walk__contains(&ii->base, ie->path);\n\n\t\t\tif (!match) {\n\t\t\t\tii->current++;\n\t\t\t\tie = index_iterator__index_entry(ii);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_snapshot_find",
          "args": [
            "&ii->current",
            "&ii->entries",
            "ii->entry_srch",
            "ii->base.start",
            "0",
            "0"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_snapshot_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "3346-3351",
          "snippet": "int git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nint git_index_snapshot_find(\n\tsize_t *out, git_vector *entries, git_vector_cmp entry_srch,\n\tconst char *path, size_t path_len, int stage)\n{\n\treturn index_find_in_entries(out, entries, entry_srch, path, path_len, stage);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator_pathlist_walk__reset",
          "args": [
            "self"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_pathlist_walk__reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "135-138",
          "snippet": "static void iterator_pathlist_walk__reset(git_iterator *iter)\n{\n\titer->pathlist_walk_idx = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void iterator_pathlist_walk__reset(git_iterator *iter)\n{\n\titer->pathlist_walk_idx = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__reset_range",
          "args": [
            "self",
            "start",
            "end"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__reset_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "200-220",
          "snippet": "static int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie;\n\n\tif (iterator__reset_range(self, start, end) < 0)\n\t\treturn -1;\n\n\tii->current = 0;\n\n\titerator_pathlist_walk__reset(self);\n\n\t/* if we're given a start prefix, find it; if we're given a pathlist, find\n\t * the first of those.  start at the later of the two.\n\t */\n\tif (ii->base.start)\n\t\tgit_index_snapshot_find(\n\t\t\t&ii->current, &ii->entries, ii->entry_srch, ii->base.start, 0, 0);\n\n\tif ((ie = index_iterator__advance_over_unwanted(ii)) == NULL)\n\t\treturn 0;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = 0;\n\n\tif (ii->base.start) {\n\t\tsize_t startlen = strlen(ii->base.start);\n\n\t\tii->partial_pos = (startlen > ii->partial.size) ?\n\t\t\tii->partial.size : startlen;\n\t}\n\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "index_iterator__seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1033-1037",
    "snippet": "static int index_iterator__seek(git_iterator *self, const char *prefix)\n{\n\tGIT_UNUSED(self); GIT_UNUSED(prefix);\n\treturn -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "prefix"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "self"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__seek(git_iterator *self, const char *prefix)\n{\n\tGIT_UNUSED(self); GIT_UNUSED(prefix);\n\treturn -1;\n}"
  },
  {
    "function_name": "index_iterator__advance_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "1018-1031",
    "snippet": "static int index_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tif (ii->restore_terminator)\n\t\t\tii->partial.ptr[ii->partial_pos] = ii->restore_terminator;\n\t\tindex_iterator__next_prefix_tree(ii);\n\t}\n\n\treturn index_iterator__current(entry, self);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__current",
          "args": [
            "entry",
            "self"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "955-972",
          "snippet": "static int index_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tii->tree_entry.path = ii->partial.ptr;\n\t\tie = &ii->tree_entry;\n\t}\n\n\tif (entry)\n\t\t*entry = ie;\n\n\tii->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (ie != NULL) ? 0 : GIT_ITEROVER;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tii->tree_entry.path = ii->partial.ptr;\n\t\tie = &ii->tree_entry;\n\t}\n\n\tif (entry)\n\t\t*entry = ie;\n\n\tii->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (ie != NULL) ? 0 : GIT_ITEROVER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iterator__next_prefix_tree",
          "args": [
            "ii"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__next_prefix_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "908-927",
          "snippet": "static void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iterator__at_tree",
          "args": [
            "ii"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ii->entries",
            "ii->current"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tif (ii->restore_terminator)\n\t\t\tii->partial.ptr[ii->partial_pos] = ii->restore_terminator;\n\t\tindex_iterator__next_prefix_tree(ii);\n\t}\n\n\treturn index_iterator__current(entry, self);\n}"
  },
  {
    "function_name": "index_iterator__advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "980-1016",
    "snippet": "static int index_iterator__advance(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tsize_t entrycount = git_vector_length(&ii->entries);\n\tconst git_index_entry *ie;\n\n\tif (!iterator__has_been_accessed(ii))\n\t\treturn index_iterator__current(entry, self);\n\n\tif (index_iterator__at_tree(ii)) {\n\t\tif (iterator__do_autoexpand(ii)) {\n\t\t\tii->partial.ptr[ii->partial_pos] = ii->restore_terminator;\n\t\t\tindex_iterator__next_prefix_tree(ii);\n\t\t} else {\n\t\t\t/* advance to sibling tree (i.e. find entry with new prefix) */\n\t\t\twhile (ii->current < entrycount) {\n\t\t\t\tii->current++;\n\n\t\t\t\tif (!(ie = git_vector_get(&ii->entries, ii->current)) ||\n\t\t\t\t\tii->base.prefixcomp(ie->path, ii->partial.ptr) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (index_iterator__first_prefix_tree(ii) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (ii->current < entrycount)\n\t\t\tii->current++;\n\n\t\tif (index_iterator__first_prefix_tree(ii) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn index_iterator__current(entry, self);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__current",
          "args": [
            "entry",
            "self"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "955-972",
          "snippet": "static int index_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tii->tree_entry.path = ii->partial.ptr;\n\t\tie = &ii->tree_entry;\n\t}\n\n\tif (entry)\n\t\t*entry = ie;\n\n\tii->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (ie != NULL) ? 0 : GIT_ITEROVER;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tii->tree_entry.path = ii->partial.ptr;\n\t\tie = &ii->tree_entry;\n\t}\n\n\tif (entry)\n\t\t*entry = ie;\n\n\tii->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (ie != NULL) ? 0 : GIT_ITEROVER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iterator__first_prefix_tree",
          "args": [
            "ii"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__first_prefix_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "929-950",
          "snippet": "static int index_iterator__first_prefix_tree(index_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__advance_over_unwanted(ii);\n\tconst char *scan, *prior, *slash;\n\n\tif (!ie || !iterator__include_trees(ii))\n\t\treturn 0;\n\n\t/* find longest common prefix with prior index entry */\n\tfor (scan = slash = ie->path, prior = ii->partial.ptr;\n\t\t *scan && *scan == *prior; ++scan, ++prior)\n\t\tif (*scan == '/')\n\t\t\tslash = scan;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = (slash - ie->path) + 1;\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int index_iterator__first_prefix_tree(index_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__advance_over_unwanted(ii);\n\tconst char *scan, *prior, *slash;\n\n\tif (!ie || !iterator__include_trees(ii))\n\t\treturn 0;\n\n\t/* find longest common prefix with prior index entry */\n\tfor (scan = slash = ie->path, prior = ii->partial.ptr;\n\t\t *scan && *scan == *prior; ++scan, ++prior)\n\t\tif (*scan == '/')\n\t\t\tslash = scan;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = (slash - ie->path) + 1;\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ii->base.prefixcomp",
          "args": [
            "ie->path",
            "ii->partial.ptr"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ii->entries",
            "ii->current"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iterator__next_prefix_tree",
          "args": [
            "ii"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__next_prefix_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "908-927",
          "snippet": "static void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__do_autoexpand",
          "args": [
            "ii"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_iterator__at_tree",
          "args": [
            "ii"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__has_been_accessed",
          "args": [
            "ii"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_length",
          "args": [
            "&ii->entries"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "67-70",
          "snippet": "GIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__advance(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tsize_t entrycount = git_vector_length(&ii->entries);\n\tconst git_index_entry *ie;\n\n\tif (!iterator__has_been_accessed(ii))\n\t\treturn index_iterator__current(entry, self);\n\n\tif (index_iterator__at_tree(ii)) {\n\t\tif (iterator__do_autoexpand(ii)) {\n\t\t\tii->partial.ptr[ii->partial_pos] = ii->restore_terminator;\n\t\t\tindex_iterator__next_prefix_tree(ii);\n\t\t} else {\n\t\t\t/* advance to sibling tree (i.e. find entry with new prefix) */\n\t\t\twhile (ii->current < entrycount) {\n\t\t\t\tii->current++;\n\n\t\t\t\tif (!(ie = git_vector_get(&ii->entries, ii->current)) ||\n\t\t\t\t\tii->base.prefixcomp(ie->path, ii->partial.ptr) != 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (index_iterator__first_prefix_tree(ii) < 0)\n\t\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif (ii->current < entrycount)\n\t\t\tii->current++;\n\n\t\tif (index_iterator__first_prefix_tree(ii) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn index_iterator__current(entry, self);\n}"
  },
  {
    "function_name": "index_iterator__at_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "974-978",
    "snippet": "static int index_iterator__at_end(git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\treturn (ii->current >= git_vector_length(&ii->entries));\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_length",
          "args": [
            "&ii->entries"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "67-70",
          "snippet": "GIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__at_end(git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\treturn (ii->current >= git_vector_length(&ii->entries));\n}"
  },
  {
    "function_name": "index_iterator__current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "955-972",
    "snippet": "static int index_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tii->tree_entry.path = ii->partial.ptr;\n\t\tie = &ii->tree_entry;\n\t}\n\n\tif (entry)\n\t\t*entry = ie;\n\n\tii->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (ie != NULL) ? 0 : GIT_ITEROVER;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [
      "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
    ],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__at_tree",
          "args": [
            "ii"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ii->entries",
            "ii->current"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int index_iterator__current(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tindex_iterator *ii = (index_iterator *)self;\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && index_iterator__at_tree(ii)) {\n\t\tii->tree_entry.path = ii->partial.ptr;\n\t\tie = &ii->tree_entry;\n\t}\n\n\tif (entry)\n\t\t*entry = ie;\n\n\tii->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn (ie != NULL) ? 0 : GIT_ITEROVER;\n}"
  },
  {
    "function_name": "index_iterator__first_prefix_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "929-950",
    "snippet": "static int index_iterator__first_prefix_tree(index_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__advance_over_unwanted(ii);\n\tconst char *scan, *prior, *slash;\n\n\tif (!ie || !iterator__include_trees(ii))\n\t\treturn 0;\n\n\t/* find longest common prefix with prior index entry */\n\tfor (scan = slash = ie->path, prior = ii->partial.ptr;\n\t\t *scan && *scan == *prior; ++scan, ++prior)\n\t\tif (*scan == '/')\n\t\t\tslash = scan;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = (slash - ie->path) + 1;\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__next_prefix_tree",
          "args": [
            "ii"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__next_prefix_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "908-927",
          "snippet": "static void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_sets",
          "args": [
            "&ii->partial",
            "ie->path"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_sets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "181-184",
          "snippet": "int git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_sets(git_buf *buf, const char *string)\n{\n\treturn git_buf_set(buf, string, string ? strlen(string) : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__include_trees",
          "args": [
            "ii"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "index_iterator__advance_over_unwanted",
          "args": [
            "ii"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__advance_over_unwanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "874-906",
          "snippet": "static const git_index_entry *index_iterator__advance_over_unwanted(\n\tindex_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__index_entry(ii);\n\tbool match;\n\n\twhile (ie) {\n\t\tif (!iterator__include_conflicts(ii) &&\n\t\t\t\tgit_index_entry_is_conflict(ie)) {\n\t\t\tii->current++;\n\t\t\tie = index_iterator__index_entry(ii);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if we have a pathlist, this entry's path must be in it to be\n\t\t * returned.  walk the pathlist in unison with the index to\n\t\t * compare paths.\n\t\t */\n\t\tif (ii->base.pathlist.length) {\n\t\t\tmatch = iterator_pathlist_walk__contains(&ii->base, ie->path);\n\n\t\t\tif (!match) {\n\t\t\t\tii->current++;\n\t\t\t\tie = index_iterator__index_entry(ii);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ie;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic const git_index_entry *index_iterator__advance_over_unwanted(\n\tindex_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__index_entry(ii);\n\tbool match;\n\n\twhile (ie) {\n\t\tif (!iterator__include_conflicts(ii) &&\n\t\t\t\tgit_index_entry_is_conflict(ie)) {\n\t\t\tii->current++;\n\t\t\tie = index_iterator__index_entry(ii);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if we have a pathlist, this entry's path must be in it to be\n\t\t * returned.  walk the pathlist in unison with the index to\n\t\t * compare paths.\n\t\t */\n\t\tif (ii->base.pathlist.length) {\n\t\t\tmatch = iterator_pathlist_walk__contains(&ii->base, ie->path);\n\n\t\t\tif (!match) {\n\t\t\t\tii->current++;\n\t\t\t\tie = index_iterator__index_entry(ii);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int index_iterator__first_prefix_tree(index_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__advance_over_unwanted(ii);\n\tconst char *scan, *prior, *slash;\n\n\tif (!ie || !iterator__include_trees(ii))\n\t\treturn 0;\n\n\t/* find longest common prefix with prior index entry */\n\tfor (scan = slash = ie->path, prior = ii->partial.ptr;\n\t\t *scan && *scan == *prior; ++scan, ++prior)\n\t\tif (*scan == '/')\n\t\t\tslash = scan;\n\n\tif (git_buf_sets(&ii->partial, ie->path) < 0)\n\t\treturn -1;\n\n\tii->partial_pos = (slash - ie->path) + 1;\n\tindex_iterator__next_prefix_tree(ii);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "index_iterator__next_prefix_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "908-927",
    "snippet": "static void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__index_entry",
          "args": [
            "ii"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__index_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "862-872",
          "snippet": "static const git_index_entry *index_iterator__index_entry(index_iterator *ii)\n{\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && iterator__past_end(ii, ie->path)) {\n\t\tii->current = git_vector_length(&ii->entries);\n\t\tie = NULL;\n\t}\n\n\treturn ie;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic const git_index_entry *index_iterator__index_entry(index_iterator *ii)\n{\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && iterator__past_end(ii, ie->path)) {\n\t\tii->current = git_vector_length(&ii->entries);\n\t\tie = NULL;\n\t}\n\n\treturn ie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "&ii->partial.ptr[ii->partial_pos]",
            "'/'"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__include_trees",
          "args": [
            "ii"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void index_iterator__next_prefix_tree(index_iterator *ii)\n{\n\tconst char *slash;\n\n\tif (!iterator__include_trees(ii))\n\t\treturn;\n\n\tslash = strchr(&ii->partial.ptr[ii->partial_pos], '/');\n\n\tif (slash != NULL) {\n\t\tii->partial_pos = (slash - ii->partial.ptr) + 1;\n\t\tii->restore_terminator = ii->partial.ptr[ii->partial_pos];\n\t\tii->partial.ptr[ii->partial_pos] = '\\0';\n\t} else {\n\t\tii->partial_pos = ii->partial.size;\n\t}\n\n\tif (index_iterator__index_entry(ii) == NULL)\n\t\tii->partial_pos = ii->partial.size;\n}"
  },
  {
    "function_name": "index_iterator__advance_over_unwanted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "874-906",
    "snippet": "static const git_index_entry *index_iterator__advance_over_unwanted(\n\tindex_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__index_entry(ii);\n\tbool match;\n\n\twhile (ie) {\n\t\tif (!iterator__include_conflicts(ii) &&\n\t\t\t\tgit_index_entry_is_conflict(ie)) {\n\t\t\tii->current++;\n\t\t\tie = index_iterator__index_entry(ii);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if we have a pathlist, this entry's path must be in it to be\n\t\t * returned.  walk the pathlist in unison with the index to\n\t\t * compare paths.\n\t\t */\n\t\tif (ii->base.pathlist.length) {\n\t\t\tmatch = iterator_pathlist_walk__contains(&ii->base, ie->path);\n\n\t\t\tif (!match) {\n\t\t\t\tii->current++;\n\t\t\t\tie = index_iterator__index_entry(ii);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ie;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "index_iterator__index_entry",
          "args": [
            "ii"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "index_iterator__index_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "862-872",
          "snippet": "static const git_index_entry *index_iterator__index_entry(index_iterator *ii)\n{\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && iterator__past_end(ii, ie->path)) {\n\t\tii->current = git_vector_length(&ii->entries);\n\t\tie = NULL;\n\t}\n\n\treturn ie;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic const git_index_entry *index_iterator__index_entry(index_iterator *ii)\n{\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && iterator__past_end(ii, ie->path)) {\n\t\tii->current = git_vector_length(&ii->entries);\n\t\tie = NULL;\n\t}\n\n\treturn ie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator_pathlist_walk__contains",
          "args": [
            "&ii->base",
            "ie->path"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_pathlist_walk__contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "148-189",
          "snippet": "static bool iterator_pathlist_walk__contains(git_iterator *iter, const char *path)\n{\n\tsize_t i;\n\tchar *p;\n\tsize_t p_len;\n\tint cmp;\n\n\tfor (i = iter->pathlist_walk_idx; i < iter->pathlist.length; i++) {\n\t\tp = iter->pathlist.contents[i];\n\t\tp_len = strlen(p);\n\n\t\t/* see if the pathlist entry is a prefix of this path */\n\t\tcmp = iter->strncomp(p, path, p_len);\n\n\t\t/* this pathlist entry sorts before the given path, try the next */\n\t\tif (!p_len || cmp < 0)\n\t\t\titer->pathlist_walk_idx++;\n\n\t\t/* this pathlist sorts after the given path, no match. */\n\t\telse if (cmp > 0)\n\t\t\treturn false;\n\n\t\t/* match!  an exact match (`foo` vs `foo`), the path is a child of an\n\t\t * explicit directory in the pathlist (`foo/` vs `foo/bar`) or the path\n\t\t * is a child of an entry in the pathlist (`foo` vs `foo/bar`)\n\t\t */\n\t\telse if (path[p_len] == '\\0' || p[p_len - 1] == '/' || path[p_len] == '/')\n\t\t\treturn true;\n\n\t\t/* only advance the start index for future callers if we know that we\n\t\t * will not see a child of this path.  eg, a pathlist entry `foo` is\n\t\t * a prefix for `foo.txt` and `foo/bar`.  don't advance the start\n\t\t * pathlist index when we see `foo.txt` or we would miss a subsequent\n\t\t * inspection of `foo/bar`.  only advance when there are no more\n\t\t * potential children.\n\t\t */\n\t\telse if (path[p_len] > '/')\n\t\t\titer->pathlist_walk_idx++;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool iterator_pathlist_walk__contains(git_iterator *iter, const char *path)\n{\n\tsize_t i;\n\tchar *p;\n\tsize_t p_len;\n\tint cmp;\n\n\tfor (i = iter->pathlist_walk_idx; i < iter->pathlist.length; i++) {\n\t\tp = iter->pathlist.contents[i];\n\t\tp_len = strlen(p);\n\n\t\t/* see if the pathlist entry is a prefix of this path */\n\t\tcmp = iter->strncomp(p, path, p_len);\n\n\t\t/* this pathlist entry sorts before the given path, try the next */\n\t\tif (!p_len || cmp < 0)\n\t\t\titer->pathlist_walk_idx++;\n\n\t\t/* this pathlist sorts after the given path, no match. */\n\t\telse if (cmp > 0)\n\t\t\treturn false;\n\n\t\t/* match!  an exact match (`foo` vs `foo`), the path is a child of an\n\t\t * explicit directory in the pathlist (`foo/` vs `foo/bar`) or the path\n\t\t * is a child of an entry in the pathlist (`foo` vs `foo/bar`)\n\t\t */\n\t\telse if (path[p_len] == '\\0' || p[p_len - 1] == '/' || path[p_len] == '/')\n\t\t\treturn true;\n\n\t\t/* only advance the start index for future callers if we know that we\n\t\t * will not see a child of this path.  eg, a pathlist entry `foo` is\n\t\t * a prefix for `foo.txt` and `foo/bar`.  don't advance the start\n\t\t * pathlist index when we see `foo.txt` or we would miss a subsequent\n\t\t * inspection of `foo/bar`.  only advance when there are no more\n\t\t * potential children.\n\t\t */\n\t\telse if (path[p_len] > '/')\n\t\t\titer->pathlist_walk_idx++;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_index_entry_is_conflict",
          "args": [
            "ie"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "git_index_entry_is_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/index.c",
          "lines": "2809-2812",
          "snippet": "int git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}",
          "includes": [
            "#include \"git2/sys/index.h\"",
            "#include \"git2/config.h\"",
            "#include \"git2/blob.h\"",
            "#include \"git2/oid.h\"",
            "#include \"git2/odb.h\"",
            "#include \"diff.h\"",
            "#include \"idxmap.h\"",
            "#include \"blob.h\"",
            "#include \"ignore.h\"",
            "#include \"pathspec.h\"",
            "#include \"iterator.h\"",
            "#include \"hash.h\"",
            "#include \"tree-cache.h\"",
            "#include \"tree.h\"",
            "#include \"index.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void index_entry_free(git_index_entry *entry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/sys/index.h\"\n#include \"git2/config.h\"\n#include \"git2/blob.h\"\n#include \"git2/oid.h\"\n#include \"git2/odb.h\"\n#include \"diff.h\"\n#include \"idxmap.h\"\n#include \"blob.h\"\n#include \"ignore.h\"\n#include \"pathspec.h\"\n#include \"iterator.h\"\n#include \"hash.h\"\n#include \"tree-cache.h\"\n#include \"tree.h\"\n#include \"index.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include <stddef.h>\n\nstatic void index_entry_free(git_index_entry *entry);\n\nint git_index_entry_is_conflict(const git_index_entry *entry)\n{\n\treturn (GIT_IDXENTRY_STAGE(entry) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__include_conflicts",
          "args": [
            "ii"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic const git_index_entry *index_iterator__advance_over_unwanted(\n\tindex_iterator *ii)\n{\n\tconst git_index_entry *ie = index_iterator__index_entry(ii);\n\tbool match;\n\n\twhile (ie) {\n\t\tif (!iterator__include_conflicts(ii) &&\n\t\t\t\tgit_index_entry_is_conflict(ie)) {\n\t\t\tii->current++;\n\t\t\tie = index_iterator__index_entry(ii);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* if we have a pathlist, this entry's path must be in it to be\n\t\t * returned.  walk the pathlist in unison with the index to\n\t\t * compare paths.\n\t\t */\n\t\tif (ii->base.pathlist.length) {\n\t\t\tmatch = iterator_pathlist_walk__contains(&ii->base, ie->path);\n\n\t\t\tif (!match) {\n\t\t\t\tii->current++;\n\t\t\t\tie = index_iterator__index_entry(ii);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\treturn ie;\n}"
  },
  {
    "function_name": "index_iterator__index_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "862-872",
    "snippet": "static const git_index_entry *index_iterator__index_entry(index_iterator *ii)\n{\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && iterator__past_end(ii, ie->path)) {\n\t\tii->current = git_vector_length(&ii->entries);\n\t\tie = NULL;\n\t}\n\n\treturn ie;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_length",
          "args": [
            "&ii->entries"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "67-70",
          "snippet": "GIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(size_t) git_vector_length(const git_vector *v)\n{\n\treturn v->length;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__past_end",
          "args": [
            "ii",
            "ie->path"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&ii->entries",
            "ii->current"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic const git_index_entry *index_iterator__index_entry(index_iterator *ii)\n{\n\tconst git_index_entry *ie = git_vector_get(&ii->entries, ii->current);\n\n\tif (ie != NULL && iterator__past_end(ii, ie->path)) {\n\t\tii->current = git_vector_length(&ii->entries);\n\t\tie = NULL;\n\t}\n\n\treturn ie;\n}"
  },
  {
    "function_name": "git_iterator_for_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "809-843",
    "snippet": "int git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_iterator_free",
          "args": [
            "(git_iterator *)ti"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "1871-1885",
          "snippet": "void git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nvoid git_iterator_free(git_iterator *iter)\n{\n\tif (iter == NULL)\n\t\treturn;\n\n\titer->cb->free(iter);\n\n\tgit_vector_free(&iter->pathlist);\n\tgit__free(iter->start);\n\tgit__free(iter->end);\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tgit__free(iter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__push_frame",
          "args": [
            "ti"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__push_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "485-555",
          "snippet": "static int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__create_root_frame",
          "args": [
            "ti",
            "tree"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__create_root_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "790-807",
          "snippet": "static int tree_iterator__create_root_frame(tree_iterator *ti, git_tree *tree)\n{\n\tsize_t sz = sizeof(tree_iterator_frame) + sizeof(tree_iterator_entry);\n\ttree_iterator_frame *root = git__calloc(sz, sizeof(char));\n\tGITERR_CHECK_ALLOC(root);\n\n\troot->n_entries  = 1;\n\troot->next       = 1;\n\troot->start      = ti->base.start;\n\troot->startlen   = root->start ? strlen(root->start) : 0;\n\troot->entries[0] = git_pool_mallocz(&ti->pool, 1);\n\tGITERR_CHECK_ALLOC(root->entries[0]);\n\troot->entries[0]->tree = tree;\n\n\tti->head = ti->root = root;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__create_root_frame(tree_iterator *ti, git_tree *tree)\n{\n\tsize_t sz = sizeof(tree_iterator_frame) + sizeof(tree_iterator_entry);\n\ttree_iterator_frame *root = git__calloc(sz, sizeof(char));\n\tGITERR_CHECK_ALLOC(root);\n\n\troot->n_entries  = 1;\n\troot->next       = 1;\n\troot->start      = ti->base.start;\n\troot->startlen   = root->start ? strlen(root->start) : 0;\n\troot->entries[0] = git_pool_mallocz(&ti->pool, 1);\n\tGITERR_CHECK_ALLOC(root->entries[0]);\n\troot->entries[0]->tree = tree;\n\n\tti->head = ti->root = root;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_init",
          "args": [
            "&ti->pool",
            "sizeof(tree_iterator_entry)"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "120-129",
          "snippet": "void git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_init(git_pool *pool, uint32_t item_size)\n{\n\tassert(pool);\n\tassert(item_size >= 1);\n\n\tmemset(pool, 0, sizeof(git_pool));\n\tpool->item_size = item_size;\n\tpool->page_size = git_pool__system_page_size();\n\tgit_vector_init(&pool->allocations, 100, git_pool__ptr_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__update_ignore_case",
          "args": [
            "(git_iterator *)ti",
            "options ? options->flags : 0"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__update_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "222-259",
          "snippet": "static int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITERATOR_BASE_INIT",
          "args": [
            "ti",
            "tree",
            "TREE",
            "git_tree_owner(tree)"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_owner",
          "args": [
            "tree"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "69-72",
          "snippet": "git_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\ngit_repository *git_tree_owner(const git_tree *obj)\n{\n\treturn git_object_owner((const git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "ti"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(tree_iterator)"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_object_dup",
          "args": [
            "(git_object **)&tree",
            "(git_object *)tree"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "git_object_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object.c",
          "lines": "383-388",
          "snippet": "int git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"oid.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"oid.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_object_dup(git_object **dest, git_object *source)\n{\n\tgit_cached_obj_incref(source);\n\t*dest = source;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_iterator_for_nothing",
          "args": [
            "iter",
            "options"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "git_iterator_for_nothing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "302-320",
          "snippet": "int git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define empty_iterator__advance_into empty_iterator__noop",
            "#define empty_iterator__advance empty_iterator__noop",
            "#define empty_iterator__current empty_iterator__noop"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define empty_iterator__advance_into empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__current empty_iterator__noop\n\nint git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nint git_iterator_for_tree(\n\tgit_iterator **iter,\n\tgit_tree *tree,\n\tgit_iterator_options *options)\n{\n\tint error;\n\ttree_iterator *ti;\n\n\tif (tree == NULL)\n\t\treturn git_iterator_for_nothing(iter, options);\n\n\tif ((error = git_object_dup((git_object **)&tree, (git_object *)tree)) < 0)\n\t\treturn error;\n\n\tti = git__calloc(1, sizeof(tree_iterator));\n\tGITERR_CHECK_ALLOC(ti);\n\n\tITERATOR_BASE_INIT(ti, tree, TREE, git_tree_owner(tree));\n\n\tif ((error = iterator__update_ignore_case((git_iterator *)ti, options ? options->flags : 0)) < 0)\n\t\tgoto fail;\n\n\tgit_pool_init(&ti->pool, sizeof(tree_iterator_entry));\n\n\tif ((error = tree_iterator__create_root_frame(ti, tree)) < 0 ||\n\t\t(error = tree_iterator__push_frame(ti)) < 0) /* expand root now */\n\t\tgoto fail;\n\n\t*iter = (git_iterator *)ti;\n\treturn 0;\n\nfail:\n\tgit_iterator_free((git_iterator *)ti);\n\treturn error;\n}"
  },
  {
    "function_name": "tree_iterator__create_root_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "790-807",
    "snippet": "static int tree_iterator__create_root_frame(tree_iterator *ti, git_tree *tree)\n{\n\tsize_t sz = sizeof(tree_iterator_frame) + sizeof(tree_iterator_entry);\n\ttree_iterator_frame *root = git__calloc(sz, sizeof(char));\n\tGITERR_CHECK_ALLOC(root);\n\n\troot->n_entries  = 1;\n\troot->next       = 1;\n\troot->start      = ti->base.start;\n\troot->startlen   = root->start ? strlen(root->start) : 0;\n\troot->entries[0] = git_pool_mallocz(&ti->pool, 1);\n\tGITERR_CHECK_ALLOC(root->entries[0]);\n\troot->entries[0]->tree = tree;\n\n\tti->head = ti->root = root;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "root->entries[0]"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_mallocz",
          "args": [
            "&ti->pool",
            "1"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "root->start"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "root"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "sz",
            "sizeof(char)"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__create_root_frame(tree_iterator *ti, git_tree *tree)\n{\n\tsize_t sz = sizeof(tree_iterator_frame) + sizeof(tree_iterator_entry);\n\ttree_iterator_frame *root = git__calloc(sz, sizeof(char));\n\tGITERR_CHECK_ALLOC(root);\n\n\troot->n_entries  = 1;\n\troot->next       = 1;\n\troot->start      = ti->base.start;\n\troot->startlen   = root->start ? strlen(root->start) : 0;\n\troot->entries[0] = git_pool_mallocz(&ti->pool, 1);\n\tGITERR_CHECK_ALLOC(root->entries[0]);\n\troot->entries[0]->tree = tree;\n\n\tti->head = ti->root = root;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_iterator__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "776-788",
    "snippet": "static void tree_iterator__free(git_iterator *self)\n{\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (ti->head) {\n\t\ttree_iterator__pop_all(ti, true, false);\n\t\tgit_tree_free(ti->head->entries[0]->tree);\n\t\tgit__free(ti->head);\n\t}\n\n\tgit_pool_clear(&ti->pool);\n\tgit_buf_free(&ti->path);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_free",
          "args": [
            "&ti->path"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "118-126",
          "snippet": "void git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__oom[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__oom[1];\n\nvoid git_buf_free(git_buf *buf)\n{\n\tif (!buf) return;\n\n\tif (buf->asize > 0 && buf->ptr != NULL && buf->ptr != git_buf__oom)\n\t\tgit__free(buf->ptr);\n\n\tgit_buf_init(buf, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_pool_clear",
          "args": [
            "&ti->pool"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "131-134",
          "snippet": "void git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nvoid git_pool_clear(git_pool *pool)\n{\n\tgit_vector_free_deep(&pool->allocations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "ti->head"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "ti->head->entries[0]->tree"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__pop_all",
          "args": [
            "ti",
            "true",
            "false"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__pop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "581-592",
          "snippet": "static void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic void tree_iterator__free(git_iterator *self)\n{\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (ti->head) {\n\t\ttree_iterator__pop_all(ti, true, false);\n\t\tgit_tree_free(ti->head->entries[0]->tree);\n\t\tgit__free(ti->head);\n\t}\n\n\tgit_pool_clear(&ti->pool);\n\tgit_buf_free(&ti->path);\n}"
  },
  {
    "function_name": "tree_iterator__at_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "770-774",
    "snippet": "static int tree_iterator__at_end(git_iterator *self)\n{\n\ttree_iterator *ti = (tree_iterator *)self;\n\treturn (ti->head->current >= ti->head->n_entries);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__at_end(git_iterator *self)\n{\n\ttree_iterator *ti = (tree_iterator *)self;\n\treturn (ti->head->current >= ti->head->n_entries);\n}"
  },
  {
    "function_name": "tree_iterator__reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "757-768",
    "snippet": "static int tree_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\ttree_iterator__pop_all(ti, false, false);\n\n\tif (iterator__reset_range(self, start, end) < 0)\n\t\treturn -1;\n\n\treturn tree_iterator__push_frame(ti); /* re-expand root tree */\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__push_frame",
          "args": [
            "ti"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__push_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "485-555",
          "snippet": "static int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__reset_range",
          "args": [
            "self",
            "start",
            "end"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__reset_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "200-220",
          "snippet": "static int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__pop_all",
          "args": [
            "ti",
            "false",
            "false"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__pop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "581-592",
          "snippet": "static void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__reset(\n\tgit_iterator *self, const char *start, const char *end)\n{\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\ttree_iterator__pop_all(ti, false, false);\n\n\tif (iterator__reset_range(self, start, end) < 0)\n\t\treturn -1;\n\n\treturn tree_iterator__push_frame(ti); /* re-expand root tree */\n}"
  },
  {
    "function_name": "tree_iterator__seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "751-755",
    "snippet": "static int tree_iterator__seek(git_iterator *self, const char *prefix)\n{\n\tGIT_UNUSED(self); GIT_UNUSED(prefix);\n\treturn -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "prefix"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "self"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__seek(git_iterator *self, const char *prefix)\n{\n\tGIT_UNUSED(self); GIT_UNUSED(prefix);\n\treturn -1;\n}"
  },
  {
    "function_name": "tree_iterator__advance_into",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "738-749",
    "snippet": "static int tree_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error = tree_iterator__advance_into_internal(self);\n\n\titerator__clear_entry(entry);\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn tree_iterator__current(entry, self);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__current",
          "args": [
            "entry",
            "self"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "695-723",
          "snippet": "static int tree_iterator__current(\n\tconst git_index_entry **out, git_iterator *self)\n{\n\tconst git_index_entry *entry = NULL;\n\titerator_pathlist__match_t m;\n\tint error;\n\n\tdo {\n\t\tif ((error = tree_iterator__current_internal(&entry, self)) < 0)\n\t\t\treturn error;\n\n\t\tif (self->pathlist.length) {\n\t\t\tm = iterator_pathlist__match(\n\t\t\t\tself, entry->path, strlen(entry->path));\n\n\t\t\tif (m != ITERATOR_PATHLIST_MATCH) {\n\t\t\t\tif ((error = tree_iterator__advance_internal(self)) < 0)\n\t\t\t\t\treturn error;\n\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t} while (!entry);\n\n\tif (out)\n\t\t*out = entry;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__current(\n\tconst git_index_entry **out, git_iterator *self)\n{\n\tconst git_index_entry *entry = NULL;\n\titerator_pathlist__match_t m;\n\tint error;\n\n\tdo {\n\t\tif ((error = tree_iterator__current_internal(&entry, self)) < 0)\n\t\t\treturn error;\n\n\t\tif (self->pathlist.length) {\n\t\t\tm = iterator_pathlist__match(\n\t\t\t\tself, entry->path, strlen(entry->path));\n\n\t\t\tif (m != ITERATOR_PATHLIST_MATCH) {\n\t\t\t\tif ((error = tree_iterator__advance_internal(self)) < 0)\n\t\t\t\t\treturn error;\n\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t} while (!entry);\n\n\tif (out)\n\t\t*out = entry;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__clear_entry",
          "args": [
            "entry"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__clear_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "261-264",
          "snippet": "GIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__advance_into_internal",
          "args": [
            "self"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__advance_into_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "647-656",
          "snippet": "static int tree_iterator__advance_into_internal(git_iterator *self)\n{\n\tint error = 0;\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (tree_iterator__at_tree(ti))\n\t\terror = tree_iterator__push_frame(ti);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_into_internal(git_iterator *self)\n{\n\tint error = 0;\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (tree_iterator__at_tree(ti))\n\t\terror = tree_iterator__push_frame(ti);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_into(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error = tree_iterator__advance_into_internal(self);\n\n\titerator__clear_entry(entry);\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn tree_iterator__current(entry, self);\n}"
  },
  {
    "function_name": "tree_iterator__advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "725-736",
    "snippet": "static int tree_iterator__advance(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error = tree_iterator__advance_internal(self);\n\n\titerator__clear_entry(entry);\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn tree_iterator__current(entry, self);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__current",
          "args": [
            "entry",
            "self"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "695-723",
          "snippet": "static int tree_iterator__current(\n\tconst git_index_entry **out, git_iterator *self)\n{\n\tconst git_index_entry *entry = NULL;\n\titerator_pathlist__match_t m;\n\tint error;\n\n\tdo {\n\t\tif ((error = tree_iterator__current_internal(&entry, self)) < 0)\n\t\t\treturn error;\n\n\t\tif (self->pathlist.length) {\n\t\t\tm = iterator_pathlist__match(\n\t\t\t\tself, entry->path, strlen(entry->path));\n\n\t\t\tif (m != ITERATOR_PATHLIST_MATCH) {\n\t\t\t\tif ((error = tree_iterator__advance_internal(self)) < 0)\n\t\t\t\t\treturn error;\n\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t} while (!entry);\n\n\tif (out)\n\t\t*out = entry;\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__current(\n\tconst git_index_entry **out, git_iterator *self)\n{\n\tconst git_index_entry *entry = NULL;\n\titerator_pathlist__match_t m;\n\tint error;\n\n\tdo {\n\t\tif ((error = tree_iterator__current_internal(&entry, self)) < 0)\n\t\t\treturn error;\n\n\t\tif (self->pathlist.length) {\n\t\t\tm = iterator_pathlist__match(\n\t\t\t\tself, entry->path, strlen(entry->path));\n\n\t\t\tif (m != ITERATOR_PATHLIST_MATCH) {\n\t\t\t\tif ((error = tree_iterator__advance_internal(self)) < 0)\n\t\t\t\t\treturn error;\n\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t} while (!entry);\n\n\tif (out)\n\t\t*out = entry;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__clear_entry",
          "args": [
            "entry"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__clear_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "261-264",
          "snippet": "GIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__advance_internal",
          "args": [
            "self"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__advance_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "658-693",
          "snippet": "static int tree_iterator__advance_internal(git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif (!iterator__has_been_accessed(ti))\n\t\treturn 0;\n\n\tif (iterator__do_autoexpand(ti) && iterator__include_trees(ti) &&\n\t\ttree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\tif (ti->path_has_filename) {\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t\tti->path_has_filename = ti->entry_is_current = false;\n\t}\n\n\t/* scan forward and up, advancing in frame or popping frame when done */\n\twhile (!tree_iterator__move_to_next(ti, tf) &&\n\t\ttree_iterator__pop_frame(ti, false))\n\t\ttf = ti->head;\n\n\t/* find next and load trees */\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* deal with include_trees / auto_expand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_internal(git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif (!iterator__has_been_accessed(ti))\n\t\treturn 0;\n\n\tif (iterator__do_autoexpand(ti) && iterator__include_trees(ti) &&\n\t\ttree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\tif (ti->path_has_filename) {\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t\tti->path_has_filename = ti->entry_is_current = false;\n\t}\n\n\t/* scan forward and up, advancing in frame or popping frame when done */\n\twhile (!tree_iterator__move_to_next(ti, tf) &&\n\t\ttree_iterator__pop_frame(ti, false))\n\t\ttf = ti->head;\n\n\t/* find next and load trees */\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* deal with include_trees / auto_expand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error = tree_iterator__advance_internal(self);\n\n\titerator__clear_entry(entry);\n\n\tif (error < 0)\n\t\treturn error;\n\n\treturn tree_iterator__current(entry, self);\n}"
  },
  {
    "function_name": "tree_iterator__current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "695-723",
    "snippet": "static int tree_iterator__current(\n\tconst git_index_entry **out, git_iterator *self)\n{\n\tconst git_index_entry *entry = NULL;\n\titerator_pathlist__match_t m;\n\tint error;\n\n\tdo {\n\t\tif ((error = tree_iterator__current_internal(&entry, self)) < 0)\n\t\t\treturn error;\n\n\t\tif (self->pathlist.length) {\n\t\t\tm = iterator_pathlist__match(\n\t\t\t\tself, entry->path, strlen(entry->path));\n\n\t\t\tif (m != ITERATOR_PATHLIST_MATCH) {\n\t\t\t\tif ((error = tree_iterator__advance_internal(self)) < 0)\n\t\t\t\t\treturn error;\n\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t} while (!entry);\n\n\tif (out)\n\t\t*out = entry;\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__advance_internal",
          "args": [
            "self"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__advance_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "658-693",
          "snippet": "static int tree_iterator__advance_internal(git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif (!iterator__has_been_accessed(ti))\n\t\treturn 0;\n\n\tif (iterator__do_autoexpand(ti) && iterator__include_trees(ti) &&\n\t\ttree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\tif (ti->path_has_filename) {\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t\tti->path_has_filename = ti->entry_is_current = false;\n\t}\n\n\t/* scan forward and up, advancing in frame or popping frame when done */\n\twhile (!tree_iterator__move_to_next(ti, tf) &&\n\t\ttree_iterator__pop_frame(ti, false))\n\t\ttf = ti->head;\n\n\t/* find next and load trees */\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* deal with include_trees / auto_expand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_internal(git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif (!iterator__has_been_accessed(ti))\n\t\treturn 0;\n\n\tif (iterator__do_autoexpand(ti) && iterator__include_trees(ti) &&\n\t\ttree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\tif (ti->path_has_filename) {\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t\tti->path_has_filename = ti->entry_is_current = false;\n\t}\n\n\t/* scan forward and up, advancing in frame or popping frame when done */\n\twhile (!tree_iterator__move_to_next(ti, tf) &&\n\t\ttree_iterator__pop_frame(ti, false))\n\t\ttf = ti->head;\n\n\t/* find next and load trees */\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* deal with include_trees / auto_expand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator_pathlist__match",
          "args": [
            "self",
            "entry->path",
            "strlen(entry->path)"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_pathlist__match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "95-133",
          "snippet": "static iterator_pathlist__match_t iterator_pathlist__match(\n\tgit_iterator *iter, const char *path, size_t path_len)\n{\n\tconst char *p;\n\tsize_t idx;\n\tint error;\n\n\terror = git_vector_bsearch2(&idx, &iter->pathlist,\n\t\t(git_vector_cmp)iter->strcomp, path);\n\n\tif (error == 0)\n\t\treturn ITERATOR_PATHLIST_MATCH;\n\n\t/* at this point, the path we're examining may be a directory (though we\n\t * don't know that yet, since we're avoiding a stat unless it's necessary)\n\t * so see if the pathlist contains a file beneath this directory.\n\t */\n\twhile ((p = git_vector_get(&iter->pathlist, idx)) != NULL) {\n\t\tif (iter->prefixcomp(p, path) != 0)\n\t\t\tbreak;\n\n\t\t/* an exact match would have been matched by the bsearch above */\n\t\tassert(p[path_len]);\n\n\t\t/* is this a literal directory entry (eg `foo/`) or a file beneath */\n\t\tif (p[path_len] == '/') {\n\t\t\treturn (p[path_len+1] == '\\0') ?\n\t\t\t\tITERATOR_PATHLIST_MATCH_DIRECTORY :\n\t\t\t\tITERATOR_PATHLIST_MATCH_CHILD;\n\t\t}\n\n\t\tif (p[path_len] > '/')\n\t\t\tbreak;\n\n\t\tidx++;\n\t}\n\n\treturn ITERATOR_PATHLIST_NONE;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic iterator_pathlist__match_t iterator_pathlist__match(\n\tgit_iterator *iter, const char *path, size_t path_len)\n{\n\tconst char *p;\n\tsize_t idx;\n\tint error;\n\n\terror = git_vector_bsearch2(&idx, &iter->pathlist,\n\t\t(git_vector_cmp)iter->strcomp, path);\n\n\tif (error == 0)\n\t\treturn ITERATOR_PATHLIST_MATCH;\n\n\t/* at this point, the path we're examining may be a directory (though we\n\t * don't know that yet, since we're avoiding a stat unless it's necessary)\n\t * so see if the pathlist contains a file beneath this directory.\n\t */\n\twhile ((p = git_vector_get(&iter->pathlist, idx)) != NULL) {\n\t\tif (iter->prefixcomp(p, path) != 0)\n\t\t\tbreak;\n\n\t\t/* an exact match would have been matched by the bsearch above */\n\t\tassert(p[path_len]);\n\n\t\t/* is this a literal directory entry (eg `foo/`) or a file beneath */\n\t\tif (p[path_len] == '/') {\n\t\t\treturn (p[path_len+1] == '\\0') ?\n\t\t\t\tITERATOR_PATHLIST_MATCH_DIRECTORY :\n\t\t\t\tITERATOR_PATHLIST_MATCH_CHILD;\n\t\t}\n\n\t\tif (p[path_len] > '/')\n\t\t\tbreak;\n\n\t\tidx++;\n\t}\n\n\treturn ITERATOR_PATHLIST_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->path"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__current_internal",
          "args": [
            "&entry",
            "self"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__current_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "624-645",
          "snippet": "static int tree_iterator__current_internal(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\titerator__clear_entry(entry);\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif ((error = tree_iterator__update_entry(ti)) < 0)\n\t\treturn error;\n\n\tif (entry)\n\t\t*entry = &ti->entry;\n\n\tti->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [
            "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
          ],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__current_internal(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\titerator__clear_entry(entry);\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif ((error = tree_iterator__update_entry(ti)) < 0)\n\t\treturn error;\n\n\tif (entry)\n\t\t*entry = &ti->entry;\n\n\tti->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__current(\n\tconst git_index_entry **out, git_iterator *self)\n{\n\tconst git_index_entry *entry = NULL;\n\titerator_pathlist__match_t m;\n\tint error;\n\n\tdo {\n\t\tif ((error = tree_iterator__current_internal(&entry, self)) < 0)\n\t\t\treturn error;\n\n\t\tif (self->pathlist.length) {\n\t\t\tm = iterator_pathlist__match(\n\t\t\t\tself, entry->path, strlen(entry->path));\n\n\t\t\tif (m != ITERATOR_PATHLIST_MATCH) {\n\t\t\t\tif ((error = tree_iterator__advance_internal(self)) < 0)\n\t\t\t\t\treturn error;\n\n\t\t\t\tentry = NULL;\n\t\t\t}\n\t\t}\n\t} while (!entry);\n\n\tif (out)\n\t\t*out = entry;\n\n\treturn error;\n}"
  },
  {
    "function_name": "tree_iterator__advance_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "658-693",
    "snippet": "static int tree_iterator__advance_internal(git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif (!iterator__has_been_accessed(ti))\n\t\treturn 0;\n\n\tif (iterator__do_autoexpand(ti) && iterator__include_trees(ti) &&\n\t\ttree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\tif (ti->path_has_filename) {\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t\tti->path_has_filename = ti->entry_is_current = false;\n\t}\n\n\t/* scan forward and up, advancing in frame or popping frame when done */\n\twhile (!tree_iterator__move_to_next(ti, tf) &&\n\t\ttree_iterator__pop_frame(ti, false))\n\t\ttf = ti->head;\n\n\t/* find next and load trees */\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* deal with include_trees / auto_expand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__advance_into_internal",
          "args": [
            "self"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__advance_into_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "647-656",
          "snippet": "static int tree_iterator__advance_into_internal(git_iterator *self)\n{\n\tint error = 0;\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (tree_iterator__at_tree(ti))\n\t\terror = tree_iterator__push_frame(ti);\n\n\treturn error;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_into_internal(git_iterator *self)\n{\n\tint error = 0;\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (tree_iterator__at_tree(ti))\n\t\terror = tree_iterator__push_frame(ti);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__at_tree",
          "args": [
            "ti"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__at_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "479-483",
          "snippet": "GIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__include_trees",
          "args": [
            "ti"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__set_next",
          "args": [
            "ti",
            "tf"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__set_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "445-477",
          "snippet": "static int tree_iterator__set_next(tree_iterator *ti, tree_iterator_frame *tf)\n{\n\tint error = 0;\n\tconst git_tree_entry *te, *last = NULL;\n\n\ttf->next = tf->current;\n\n\tfor (; tf->next < tf->n_entries; tf->next++, last = te) {\n\t\tte = tf->entries[tf->next]->te;\n\n\t\tif (last && tree_iterator__te_cmp(last, te, ti->base.strncomp))\n\t\t\tbreak;\n\n\t\t/* try to load trees for items in [current,next) range */\n\t\tif (!error && git_tree_entry__is_tree(te))\n\t\t\terror = git_tree_lookup(\n\t\t\t\t&tf->entries[tf->next]->tree, ti->base.repo, te->oid);\n\t}\n\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities++;\n\n\t/* if a tree lookup failed, advance over this span and return failure */\n\tif (error < 0) {\n\t\ttree_iterator__move_to_next(ti, tf);\n\t\treturn error;\n\t}\n\n\tif (last && !tree_iterator__current_filename(ti, last))\n\t\treturn -1; /* must have been allocation failure */\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__set_next(tree_iterator *ti, tree_iterator_frame *tf)\n{\n\tint error = 0;\n\tconst git_tree_entry *te, *last = NULL;\n\n\ttf->next = tf->current;\n\n\tfor (; tf->next < tf->n_entries; tf->next++, last = te) {\n\t\tte = tf->entries[tf->next]->te;\n\n\t\tif (last && tree_iterator__te_cmp(last, te, ti->base.strncomp))\n\t\t\tbreak;\n\n\t\t/* try to load trees for items in [current,next) range */\n\t\tif (!error && git_tree_entry__is_tree(te))\n\t\t\terror = git_tree_lookup(\n\t\t\t\t&tf->entries[tf->next]->tree, ti->base.repo, te->oid);\n\t}\n\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities++;\n\n\t/* if a tree lookup failed, advance over this span and return failure */\n\tif (error < 0) {\n\t\ttree_iterator__move_to_next(ti, tf);\n\t\treturn error;\n\t}\n\n\tif (last && !tree_iterator__current_filename(ti, last))\n\t\treturn -1; /* must have been allocation failure */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__pop_frame",
          "args": [
            "ti",
            "false"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__pop_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "557-579",
          "snippet": "static bool tree_iterator__pop_frame(tree_iterator *ti, bool final)\n{\n\ttree_iterator_frame *tf = ti->head;\n\n\tassert(tf);\n\n\tif (!tf->up)\n\t\treturn false;\n\n\tti->head = tf->up;\n\tti->head->down = NULL;\n\n\ttree_iterator__move_to_next(ti, tf);\n\n\tif (!final) { /* if final, don't bother to clean up */\n\t\t// TODO: maybe free the pool so far?\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t}\n\n\tgit__free(tf);\n\n\treturn true;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__pop_frame(tree_iterator *ti, bool final)\n{\n\ttree_iterator_frame *tf = ti->head;\n\n\tassert(tf);\n\n\tif (!tf->up)\n\t\treturn false;\n\n\tti->head = tf->up;\n\tti->head->down = NULL;\n\n\ttree_iterator__move_to_next(ti, tf);\n\n\tif (!final) { /* if final, don't bother to clean up */\n\t\t// TODO: maybe free the pool so far?\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t}\n\n\tgit__free(tf);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__move_to_next",
          "args": [
            "ti",
            "tf"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__move_to_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "426-443",
          "snippet": "static bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtruncate_at_char",
          "args": [
            "&ti->path",
            "'/'"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtruncate_at_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "464-468",
          "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__include_trees",
          "args": [
            "ti"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__do_autoexpand",
          "args": [
            "ti"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__has_been_accessed",
          "args": [
            "ti"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_internal(git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif (!iterator__has_been_accessed(ti))\n\t\treturn 0;\n\n\tif (iterator__do_autoexpand(ti) && iterator__include_trees(ti) &&\n\t\ttree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\tif (ti->path_has_filename) {\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t\tti->path_has_filename = ti->entry_is_current = false;\n\t}\n\n\t/* scan forward and up, advancing in frame or popping frame when done */\n\twhile (!tree_iterator__move_to_next(ti, tf) &&\n\t\ttree_iterator__pop_frame(ti, false))\n\t\ttf = ti->head;\n\n\t/* find next and load trees */\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* deal with include_trees / auto_expand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__advance_into_internal(self);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_iterator__advance_into_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "647-656",
    "snippet": "static int tree_iterator__advance_into_internal(git_iterator *self)\n{\n\tint error = 0;\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (tree_iterator__at_tree(ti))\n\t\terror = tree_iterator__push_frame(ti);\n\n\treturn error;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__push_frame",
          "args": [
            "ti"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__push_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "485-555",
          "snippet": "static int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__at_tree",
          "args": [
            "ti"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__at_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "479-483",
          "snippet": "GIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__advance_into_internal(git_iterator *self)\n{\n\tint error = 0;\n\ttree_iterator *ti = (tree_iterator *)self;\n\n\tif (tree_iterator__at_tree(ti))\n\t\terror = tree_iterator__push_frame(ti);\n\n\treturn error;\n}"
  },
  {
    "function_name": "tree_iterator__current_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "624-645",
    "snippet": "static int tree_iterator__current_internal(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\titerator__clear_entry(entry);\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif ((error = tree_iterator__update_entry(ti)) < 0)\n\t\treturn error;\n\n\tif (entry)\n\t\t*entry = &ti->entry;\n\n\tti->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [
      "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
    ],
    "globals_used": [
      "static int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__update_entry",
          "args": [
            "ti"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__update_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "594-622",
          "snippet": "static int tree_iterator__update_entry(tree_iterator *ti)\n{\n\ttree_iterator_frame *tf;\n    const git_tree_entry *te;\n\n\tif (ti->entry_is_current)\n        return 0;\n\n\ttf = ti->head;\n    te = tf->entries[tf->current]->te;\n\n\tti->entry.mode = te->attr;\n\tgit_oid_cpy(&ti->entry.id, te->oid);\n\n\tti->entry.path = tree_iterator__current_filename(ti, te);\n\tGITERR_CHECK_ALLOC(ti->entry.path);\n\n\tif (ti->path_ambiguities > 0)\n\t\ttree_iterator__rewrite_filename(ti);\n\n\tif (iterator__past_end(ti, ti->entry.path)) {\n\t\ttree_iterator__pop_all(ti, true, false);\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tti->entry_is_current = true;\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__update_entry(tree_iterator *ti)\n{\n\ttree_iterator_frame *tf;\n    const git_tree_entry *te;\n\n\tif (ti->entry_is_current)\n        return 0;\n\n\ttf = ti->head;\n    te = tf->entries[tf->current]->te;\n\n\tti->entry.mode = te->attr;\n\tgit_oid_cpy(&ti->entry.id, te->oid);\n\n\tti->entry.path = tree_iterator__current_filename(ti, te);\n\tGITERR_CHECK_ALLOC(ti->entry.path);\n\n\tif (ti->path_ambiguities > 0)\n\t\ttree_iterator__rewrite_filename(ti);\n\n\tif (iterator__past_end(ti, ti->entry.path)) {\n\t\ttree_iterator__pop_all(ti, true, false);\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tti->entry_is_current = true;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__clear_entry",
          "args": [
            "entry"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__clear_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "261-264",
          "snippet": "GIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int fs_iterator__advance_over(\n\tconst git_index_entry **entry, git_iterator *self);\n\nstatic int tree_iterator__current_internal(\n\tconst git_index_entry **entry, git_iterator *self)\n{\n\tint error;\n\ttree_iterator *ti = (tree_iterator *)self;\n\ttree_iterator_frame *tf = ti->head;\n\n\titerator__clear_entry(entry);\n\n\tif (tf->current >= tf->n_entries)\n\t\treturn GIT_ITEROVER;\n\n\tif ((error = tree_iterator__update_entry(ti)) < 0)\n\t\treturn error;\n\n\tif (entry)\n\t\t*entry = &ti->entry;\n\n\tti->base.flags |= GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_iterator__update_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "594-622",
    "snippet": "static int tree_iterator__update_entry(tree_iterator *ti)\n{\n\ttree_iterator_frame *tf;\n    const git_tree_entry *te;\n\n\tif (ti->entry_is_current)\n        return 0;\n\n\ttf = ti->head;\n    te = tf->entries[tf->current]->te;\n\n\tti->entry.mode = te->attr;\n\tgit_oid_cpy(&ti->entry.id, te->oid);\n\n\tti->entry.path = tree_iterator__current_filename(ti, te);\n\tGITERR_CHECK_ALLOC(ti->entry.path);\n\n\tif (ti->path_ambiguities > 0)\n\t\ttree_iterator__rewrite_filename(ti);\n\n\tif (iterator__past_end(ti, ti->entry.path)) {\n\t\ttree_iterator__pop_all(ti, true, false);\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tti->entry_is_current = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__pop_all",
          "args": [
            "ti",
            "true",
            "false"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__pop_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "581-592",
          "snippet": "static void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__past_end",
          "args": [
            "ti",
            "ti->entry.path"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__rewrite_filename",
          "args": [
            "ti"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__rewrite_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "372-386",
          "snippet": "static void tree_iterator__rewrite_filename(tree_iterator *ti)\n{\n\ttree_iterator_entry *scan = ti->head->entries[ti->head->current];\n\tssize_t strpos = ti->path.size;\n\tconst git_tree_entry *te;\n\n\tif (strpos && ti->path.ptr[strpos - 1] == '/')\n\t\tstrpos--;\n\n\tfor (; scan && (te = scan->te); scan = scan->parent) {\n\t\tstrpos -= te->filename_len;\n\t\tmemcpy(&ti->path.ptr[strpos], te->filename, te->filename_len);\n\t\tstrpos -= 1; /* separator */\n\t}\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void tree_iterator__rewrite_filename(tree_iterator *ti)\n{\n\ttree_iterator_entry *scan = ti->head->entries[ti->head->current];\n\tssize_t strpos = ti->path.size;\n\tconst git_tree_entry *te;\n\n\tif (strpos && ti->path.ptr[strpos - 1] == '/')\n\t\tstrpos--;\n\n\tfor (; scan && (te = scan->te); scan = scan->parent) {\n\t\tstrpos -= te->filename_len;\n\t\tmemcpy(&ti->path.ptr[strpos], te->filename, te->filename_len);\n\t\tstrpos -= 1; /* separator */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "ti->entry.path"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__current_filename",
          "args": [
            "ti",
            "te"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__current_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "356-370",
          "snippet": "static char *tree_iterator__current_filename(\n\ttree_iterator *ti, const git_tree_entry *te)\n{\n\tif (!ti->path_has_filename) {\n\t\tif (git_buf_joinpath(&ti->path, ti->path.ptr, te->filename) < 0)\n\t\t\treturn NULL;\n\n\t\tif (git_tree_entry__is_tree(te) && git_buf_putc(&ti->path, '/') < 0)\n\t\t\treturn NULL;\n\n\t\tti->path_has_filename = true;\n\t}\n\n\treturn ti->path.ptr;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic char *tree_iterator__current_filename(\n\ttree_iterator *ti, const git_tree_entry *te)\n{\n\tif (!ti->path_has_filename) {\n\t\tif (git_buf_joinpath(&ti->path, ti->path.ptr, te->filename) < 0)\n\t\t\treturn NULL;\n\n\t\tif (git_tree_entry__is_tree(te) && git_buf_putc(&ti->path, '/') < 0)\n\t\t\treturn NULL;\n\n\t\tti->path_has_filename = true;\n\t}\n\n\treturn ti->path.ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_oid_cpy",
          "args": [
            "&ti->entry.id",
            "te->oid"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "git_oid_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/oid.c",
          "lines": "174-177",
          "snippet": "void git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}",
          "includes": [
            "#include <limits.h>",
            "#include <string.h>",
            "#include \"global.h\"",
            "#include \"repository.h\"",
            "#include \"git2/oid.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include <string.h>\n#include \"global.h\"\n#include \"repository.h\"\n#include \"git2/oid.h\"\n#include \"common.h\"\n\nvoid git_oid_cpy(git_oid *out, const git_oid *src)\n{\n\tmemcpy(out->id, src->id, sizeof(out->id));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__update_entry(tree_iterator *ti)\n{\n\ttree_iterator_frame *tf;\n    const git_tree_entry *te;\n\n\tif (ti->entry_is_current)\n        return 0;\n\n\ttf = ti->head;\n    te = tf->entries[tf->current]->te;\n\n\tti->entry.mode = te->attr;\n\tgit_oid_cpy(&ti->entry.id, te->oid);\n\n\tti->entry.path = tree_iterator__current_filename(ti, te);\n\tGITERR_CHECK_ALLOC(ti->entry.path);\n\n\tif (ti->path_ambiguities > 0)\n\t\ttree_iterator__rewrite_filename(ti);\n\n\tif (iterator__past_end(ti, ti->entry.path)) {\n\t\ttree_iterator__pop_all(ti, true, false);\n\t\treturn GIT_ITEROVER;\n\t}\n\n\tti->entry_is_current = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_iterator__pop_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "581-592",
    "snippet": "static void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_clear",
          "args": [
            "&ti->path"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "137-148",
          "snippet": "void git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char git_buf__initbuf[1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nchar git_buf__initbuf[1];\n\nvoid git_buf_clear(git_buf *buf)\n{\n\tbuf->size = 0;\n\n\tif (!buf->ptr) {\n\t\tbuf->ptr = git_buf__initbuf;\n\t\tbuf->asize = 0;\n\t}\n\n\tif (buf->asize > 0)\n\t\tbuf->ptr[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ti->head"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__pop_frame",
          "args": [
            "ti",
            "final"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__pop_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "557-579",
          "snippet": "static bool tree_iterator__pop_frame(tree_iterator *ti, bool final)\n{\n\ttree_iterator_frame *tf = ti->head;\n\n\tassert(tf);\n\n\tif (!tf->up)\n\t\treturn false;\n\n\tti->head = tf->up;\n\tti->head->down = NULL;\n\n\ttree_iterator__move_to_next(ti, tf);\n\n\tif (!final) { /* if final, don't bother to clean up */\n\t\t// TODO: maybe free the pool so far?\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t}\n\n\tgit__free(tf);\n\n\treturn true;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__pop_frame(tree_iterator *ti, bool final)\n{\n\ttree_iterator_frame *tf = ti->head;\n\n\tassert(tf);\n\n\tif (!tf->up)\n\t\treturn false;\n\n\tti->head = tf->up;\n\tti->head->down = NULL;\n\n\ttree_iterator__move_to_next(ti, tf);\n\n\tif (!final) { /* if final, don't bother to clean up */\n\t\t// TODO: maybe free the pool so far?\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t}\n\n\tgit__free(tf);\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void tree_iterator__pop_all(tree_iterator *ti, bool to_end, bool final)\n{\n\twhile (tree_iterator__pop_frame(ti, final)) /* pop to root */;\n\n\tif (!final) {\n\t\tassert(ti->head);\n\n\t\tti->head->current = to_end ? ti->head->n_entries : 0;\n\t\tti->path_ambiguities = 0;\n\t\tgit_buf_clear(&ti->path);\n\t}\n}"
  },
  {
    "function_name": "tree_iterator__pop_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "557-579",
    "snippet": "static bool tree_iterator__pop_frame(tree_iterator *ti, bool final)\n{\n\ttree_iterator_frame *tf = ti->head;\n\n\tassert(tf);\n\n\tif (!tf->up)\n\t\treturn false;\n\n\tti->head = tf->up;\n\tti->head->down = NULL;\n\n\ttree_iterator__move_to_next(ti, tf);\n\n\tif (!final) { /* if final, don't bother to clean up */\n\t\t// TODO: maybe free the pool so far?\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t}\n\n\tgit__free(tf);\n\n\treturn true;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "tf"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_rtruncate_at_char",
          "args": [
            "&ti->path",
            "'/'"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_rtruncate_at_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "464-468",
          "snippet": "void git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nvoid git_buf_rtruncate_at_char(git_buf *buf, char separator)\n{\n\tssize_t idx = git_buf_rfind_next(buf, separator);\n\tgit_buf_truncate(buf, idx < 0 ? 0 : (size_t)idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__move_to_next",
          "args": [
            "ti",
            "tf"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__move_to_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "426-443",
          "snippet": "static bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "tf"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__pop_frame(tree_iterator *ti, bool final)\n{\n\ttree_iterator_frame *tf = ti->head;\n\n\tassert(tf);\n\n\tif (!tf->up)\n\t\treturn false;\n\n\tti->head = tf->up;\n\tti->head->down = NULL;\n\n\ttree_iterator__move_to_next(ti, tf);\n\n\tif (!final) { /* if final, don't bother to clean up */\n\t\t// TODO: maybe free the pool so far?\n\t\tgit_buf_rtruncate_at_char(&ti->path, '/');\n\t}\n\n\tgit__free(tf);\n\n\treturn true;\n}"
  },
  {
    "function_name": "tree_iterator__push_frame",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "485-555",
    "snippet": "static int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__push_frame",
          "args": [
            "ti"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__push_frame",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "485-555",
          "snippet": "static int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__at_tree",
          "args": [
            "ti"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__at_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "479-483",
          "snippet": "GIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator__include_trees",
          "args": [
            "ti"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__set_next",
          "args": [
            "ti",
            "tf"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__set_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "445-477",
          "snippet": "static int tree_iterator__set_next(tree_iterator *ti, tree_iterator_frame *tf)\n{\n\tint error = 0;\n\tconst git_tree_entry *te, *last = NULL;\n\n\ttf->next = tf->current;\n\n\tfor (; tf->next < tf->n_entries; tf->next++, last = te) {\n\t\tte = tf->entries[tf->next]->te;\n\n\t\tif (last && tree_iterator__te_cmp(last, te, ti->base.strncomp))\n\t\t\tbreak;\n\n\t\t/* try to load trees for items in [current,next) range */\n\t\tif (!error && git_tree_entry__is_tree(te))\n\t\t\terror = git_tree_lookup(\n\t\t\t\t&tf->entries[tf->next]->tree, ti->base.repo, te->oid);\n\t}\n\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities++;\n\n\t/* if a tree lookup failed, advance over this span and return failure */\n\tif (error < 0) {\n\t\ttree_iterator__move_to_next(ti, tf);\n\t\treturn error;\n\t}\n\n\tif (last && !tree_iterator__current_filename(ti, last))\n\t\treturn -1; /* must have been allocation failure */\n\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__set_next(tree_iterator *ti, tree_iterator_frame *tf)\n{\n\tint error = 0;\n\tconst git_tree_entry *te, *last = NULL;\n\n\ttf->next = tf->current;\n\n\tfor (; tf->next < tf->n_entries; tf->next++, last = te) {\n\t\tte = tf->entries[tf->next]->te;\n\n\t\tif (last && tree_iterator__te_cmp(last, te, ti->base.strncomp))\n\t\t\tbreak;\n\n\t\t/* try to load trees for items in [current,next) range */\n\t\tif (!error && git_tree_entry__is_tree(te))\n\t\t\terror = git_tree_lookup(\n\t\t\t\t&tf->entries[tf->next]->tree, ti->base.repo, te->oid);\n\t}\n\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities++;\n\n\t/* if a tree lookup failed, advance over this span and return failure */\n\tif (error < 0) {\n\t\ttree_iterator__move_to_next(ti, tf);\n\t\treturn error;\n\t}\n\n\tif (last && !tree_iterator__current_filename(ti, last))\n\t\treturn -1; /* must have been allocation failure */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tf->start"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "head->start",
            "'/'"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_iterator__search_cmp",
          "args": [
            "head",
            "tf->entries[tf->current-1]",
            "ti"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__search_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "415-424",
          "snippet": "static int tree_iterator__search_cmp(const void *key, const void *val, void *p)\n{\n\tconst tree_iterator_frame *tf = key;\n\tconst git_tree_entry *te = ((tree_iterator_entry *)val)->te;\n\n\treturn git_path_cmp(\n\t\ttf->start, tf->startlen, false,\n\t\tte->filename, te->filename_len, te->attr == GIT_FILEMODE_TREE,\n\t\t((git_iterator *)p)->strncomp);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__search_cmp(const void *key, const void *val, void *p)\n{\n\tconst tree_iterator_frame *tf = key;\n\tconst git_tree_entry *te = ((tree_iterator_entry *)val)->te;\n\n\treturn git_path_cmp(\n\t\ttf->start, tf->startlen, false,\n\t\tte->filename, te->filename_len, te->attr == GIT_FILEMODE_TREE,\n\t\t((git_iterator *)p)->strncomp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__bsearch_r",
          "args": [
            "(void **)tf->entries",
            "tf->n_entries",
            "head",
            "tree_iterator__search_cmp",
            "ti",
            "&tf->current"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "git__bsearch_r",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.c",
          "lines": "525-554",
          "snippet": "int git__bsearch_r(\n\tvoid **array,\n\tsize_t array_len,\n\tconst void *key,\n\tint (*compare_r)(const void *, const void *, void *),\n\tvoid *payload,\n\tsize_t *position)\n{\n\tsize_t lim;\n\tint cmp = -1;\n\tvoid **part, **base = array;\n\n\tfor (lim = array_len; lim != 0; lim >>= 1) {\n\t\tpart = base + (lim >> 1);\n\t\tcmp = (*compare_r)(key, *part, payload);\n\t\tif (cmp == 0) {\n\t\t\tbase = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp > 0) { /* key > p; take right partition */\n\t\t\tbase = part + 1;\n\t\t\tlim--;\n\t\t} /* else take left partition */\n\t}\n\n\tif (position)\n\t\t*position = (base - array);\n\n\treturn (cmp == 0) ? 0 : GIT_ENOTFOUND;\n}",
          "includes": [
            "# include <Shlwapi.h>",
            "# include \"win32/w32_buffer.h\"",
            "#include \"posix.h\"",
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include \"common.h\"",
            "#include <git2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <Shlwapi.h>\n# include \"win32/w32_buffer.h\"\n#include \"posix.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include \"common.h\"\n#include <git2.h>\n\nint git__bsearch_r(\n\tvoid **array,\n\tsize_t array_len,\n\tconst void *key,\n\tint (*compare_r)(const void *, const void *, void *),\n\tvoid *payload,\n\tsize_t *position)\n{\n\tsize_t lim;\n\tint cmp = -1;\n\tvoid **part, **base = array;\n\n\tfor (lim = array_len; lim != 0; lim >>= 1) {\n\t\tpart = base + (lim >> 1);\n\t\tcmp = (*compare_r)(key, *part, payload);\n\t\tif (cmp == 0) {\n\t\t\tbase = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp > 0) { /* key > p; take right partition */\n\t\t\tbase = part + 1;\n\t\t\tlim--;\n\t\t} /* else take left partition */\n\t}\n\n\tif (position)\n\t\t*position = (base - array);\n\n\treturn (cmp == 0) ? 0 : GIT_ENOTFOUND;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__tsort_r",
          "args": [
            "(void **)tf->entries",
            "tf->n_entries",
            "tree_iterator__ci_cmp",
            "tf"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator__ignore_case",
          "args": [
            "ti"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_tree_entry_byindex",
          "args": [
            "tree",
            "j"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry_byindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "324-329",
          "snippet": "const git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_array_get(tree->entries, idx);\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nconst git_tree_entry *git_tree_entry_byindex(\n\tconst git_tree *tree, size_t idx)\n{\n\tassert(tree);\n\treturn git_array_get(tree->entries, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "entry"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_pool_malloc",
          "args": [
            "&ti->pool",
            "1"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "git_pool_mallocz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/pool.c",
          "lines": "181-188",
          "snippet": "void *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"posix.h\"",
            "#include \"pool.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *pool_alloc_page(git_pool *pool, uint32_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"posix.h\"\n#include \"pool.h\"\n\nstatic void *pool_alloc_page(git_pool *pool, uint32_t size);\n\nvoid *git_pool_mallocz(git_pool *pool, uint32_t items)\n{\n\tconst uint32_t size = alloc_size(pool, items);\n\tvoid *ptr = pool_alloc(pool, size);\n\tif (ptr)\n\t\tmemset(ptr, 0x0, size);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entrycount",
          "args": [
            "tree"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entrycount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.c",
          "lines": "382-386",
          "snippet": "size_t git_tree_entrycount(const git_tree *tree)\n{\n\tassert(tree);\n\treturn tree->entries.size;\n}",
          "includes": [
            "#include \"index.h\"",
            "#include \"tree-cache.h\"",
            "#include \"fileops.h\"",
            "#include \"git2/object.h\"",
            "#include \"git2/repository.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"index.h\"\n#include \"tree-cache.h\"\n#include \"fileops.h\"\n#include \"git2/object.h\"\n#include \"git2/repository.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"common.h\"\n\nsize_t git_tree_entrycount(const git_tree *tree)\n{\n\tassert(tree);\n\treturn tree->entries.size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "tf"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "alloclen"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_ADD",
          "args": [
            "&alloclen",
            "alloclen",
            "sizeof(tree_iterator_frame)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC_MULTIPLY",
          "args": [
            "&alloclen",
            "sizeof(tree_iterator_entry *)",
            "n_entries"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__push_frame(tree_iterator *ti)\n{\n\tint error = 0;\n\ttree_iterator_frame *head = ti->head, *tf = NULL;\n\tsize_t i, n_entries = 0, alloclen;\n\n\tif (head->current >= head->n_entries || !head->entries[head->current]->tree)\n\t\treturn GIT_ITEROVER;\n\n\tfor (i = head->current; i < head->next; ++i)\n\t\tn_entries += git_tree_entrycount(head->entries[i]->tree);\n\n\tGITERR_CHECK_ALLOC_MULTIPLY(&alloclen, sizeof(tree_iterator_entry *), n_entries);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, sizeof(tree_iterator_frame));\n\n\ttf = git__calloc(1, alloclen);\n\tGITERR_CHECK_ALLOC(tf);\n\n\ttf->n_entries = n_entries;\n\n\ttf->up     = head;\n\thead->down = tf;\n\tti->head   = tf;\n\n\tfor (i = head->current, n_entries = 0; i < head->next; ++i) {\n\t\tgit_tree *tree = head->entries[i]->tree;\n\t\tsize_t j, max_j = git_tree_entrycount(tree);\n\n\t\tfor (j = 0; j < max_j; ++j) {\n\t\t\ttree_iterator_entry *entry = git_pool_malloc(&ti->pool, 1);\n\t\t\tGITERR_CHECK_ALLOC(entry);\n\n\t\t\tentry->parent = head->entries[i];\n\t\t\tentry->te     = git_tree_entry_byindex(tree, j);\n\t\t\tentry->tree   = NULL;\n\n\t\t\ttf->entries[n_entries++] = entry;\n\t\t}\n\t}\n\n\t/* if ignore_case, sort entries case insensitively */\n\tif (iterator__ignore_case(ti))\n\t\tgit__tsort_r(\n\t\t\t(void **)tf->entries, tf->n_entries, tree_iterator__ci_cmp, tf);\n\n\t/* pick tf->current based on \"start\" (or start at zero) */\n\tif (head->startlen > 0) {\n\t\tgit__bsearch_r((void **)tf->entries, tf->n_entries, head,\n\t\t\ttree_iterator__search_cmp, ti, &tf->current);\n\n\t\twhile (tf->current &&\n\t\t\t   !tree_iterator__search_cmp(head, tf->entries[tf->current-1], ti))\n\t\t\ttf->current--;\n\n\t\tif ((tf->start = strchr(head->start, '/')) != NULL) {\n\t\t\ttf->start++;\n\t\t\ttf->startlen = strlen(tf->start);\n\t\t}\n\t}\n\n\tti->path_has_filename = ti->entry_is_current = false;\n\n\tif ((error = tree_iterator__set_next(ti, tf)) < 0)\n\t\treturn error;\n\n\t/* autoexpand as needed */\n\tif (!iterator__include_trees(ti) && tree_iterator__at_tree(ti))\n\t\treturn tree_iterator__push_frame(ti);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_iterator__at_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "479-483",
    "snippet": "GIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(bool) tree_iterator__at_tree(tree_iterator *ti)\n{\n\treturn (ti->head->current < ti->head->n_entries &&\n\t\t\tti->head->entries[ti->head->current]->tree != NULL);\n}"
  },
  {
    "function_name": "tree_iterator__set_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "445-477",
    "snippet": "static int tree_iterator__set_next(tree_iterator *ti, tree_iterator_frame *tf)\n{\n\tint error = 0;\n\tconst git_tree_entry *te, *last = NULL;\n\n\ttf->next = tf->current;\n\n\tfor (; tf->next < tf->n_entries; tf->next++, last = te) {\n\t\tte = tf->entries[tf->next]->te;\n\n\t\tif (last && tree_iterator__te_cmp(last, te, ti->base.strncomp))\n\t\t\tbreak;\n\n\t\t/* try to load trees for items in [current,next) range */\n\t\tif (!error && git_tree_entry__is_tree(te))\n\t\t\terror = git_tree_lookup(\n\t\t\t\t&tf->entries[tf->next]->tree, ti->base.repo, te->oid);\n\t}\n\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities++;\n\n\t/* if a tree lookup failed, advance over this span and return failure */\n\tif (error < 0) {\n\t\ttree_iterator__move_to_next(ti, tf);\n\t\treturn error;\n\t}\n\n\tif (last && !tree_iterator__current_filename(ti, last))\n\t\treturn -1; /* must have been allocation failure */\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__current_filename",
          "args": [
            "ti",
            "last"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__current_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "356-370",
          "snippet": "static char *tree_iterator__current_filename(\n\ttree_iterator *ti, const git_tree_entry *te)\n{\n\tif (!ti->path_has_filename) {\n\t\tif (git_buf_joinpath(&ti->path, ti->path.ptr, te->filename) < 0)\n\t\t\treturn NULL;\n\n\t\tif (git_tree_entry__is_tree(te) && git_buf_putc(&ti->path, '/') < 0)\n\t\t\treturn NULL;\n\n\t\tti->path_has_filename = true;\n\t}\n\n\treturn ti->path.ptr;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic char *tree_iterator__current_filename(\n\ttree_iterator *ti, const git_tree_entry *te)\n{\n\tif (!ti->path_has_filename) {\n\t\tif (git_buf_joinpath(&ti->path, ti->path.ptr, te->filename) < 0)\n\t\t\treturn NULL;\n\n\t\tif (git_tree_entry__is_tree(te) && git_buf_putc(&ti->path, '/') < 0)\n\t\t\treturn NULL;\n\n\t\tti->path_has_filename = true;\n\t}\n\n\treturn ti->path.ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__move_to_next",
          "args": [
            "ti",
            "tf"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__move_to_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "426-443",
          "snippet": "static bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_lookup",
          "args": [
            "&tf->entries[tf->next]->tree",
            "ti->base.repo",
            "te->oid"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "49-52",
          "snippet": "int git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nint git_tree_lookup(git_tree **out, git_repository *repo, const git_oid *id)\n{\n\treturn git_object_lookup((git_object **)out, repo, id, GIT_OBJ_TREE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry__is_tree",
          "args": [
            "te"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry__is_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.h",
          "lines": "35-38",
          "snippet": "GIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}",
          "includes": [
            "#include \"pool.h\"",
            "#include \"strmap.h\"",
            "#include \"vector.h\"",
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"git2/tree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pool.h\"\n#include \"strmap.h\"\n#include \"vector.h\"\n#include \"odb.h\"\n#include \"repository.h\"\n#include \"git2/tree.h\"\n\nGIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__te_cmp",
          "args": [
            "last",
            "te",
            "ti->base.strncomp"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__te_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "388-397",
          "snippet": "static int tree_iterator__te_cmp(\n\tconst git_tree_entry *a,\n\tconst git_tree_entry *b,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\treturn git_path_cmp(\n\t\ta->filename, a->filename_len, a->attr == GIT_FILEMODE_TREE,\n\t\tb->filename, b->filename_len, b->attr == GIT_FILEMODE_TREE,\n\t\tcompare);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__te_cmp(\n\tconst git_tree_entry *a,\n\tconst git_tree_entry *b,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\treturn git_path_cmp(\n\t\ta->filename, a->filename_len, a->attr == GIT_FILEMODE_TREE,\n\t\tb->filename, b->filename_len, b->attr == GIT_FILEMODE_TREE,\n\t\tcompare);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__set_next(tree_iterator *ti, tree_iterator_frame *tf)\n{\n\tint error = 0;\n\tconst git_tree_entry *te, *last = NULL;\n\n\ttf->next = tf->current;\n\n\tfor (; tf->next < tf->n_entries; tf->next++, last = te) {\n\t\tte = tf->entries[tf->next]->te;\n\n\t\tif (last && tree_iterator__te_cmp(last, te, ti->base.strncomp))\n\t\t\tbreak;\n\n\t\t/* try to load trees for items in [current,next) range */\n\t\tif (!error && git_tree_entry__is_tree(te))\n\t\t\terror = git_tree_lookup(\n\t\t\t\t&tf->entries[tf->next]->tree, ti->base.repo, te->oid);\n\t}\n\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities++;\n\n\t/* if a tree lookup failed, advance over this span and return failure */\n\tif (error < 0) {\n\t\ttree_iterator__move_to_next(ti, tf);\n\t\treturn error;\n\t}\n\n\tif (last && !tree_iterator__current_filename(ti, last))\n\t\treturn -1; /* must have been allocation failure */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_iterator__move_to_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "426-443",
    "snippet": "static bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_tree_free",
          "args": [
            "tf->entries[tf->current]->tree"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/object_api.c",
          "lines": "59-62",
          "snippet": "void git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}",
          "includes": [
            "#include \"tag.h\"",
            "#include \"blob.h\"",
            "#include \"tree.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/object.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tag.h\"\n#include \"blob.h\"\n#include \"tree.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/object.h\"\n\nvoid git_tree_free(git_tree *obj)\n{\n\tgit_object_free((git_object *)obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool tree_iterator__move_to_next(\n\ttree_iterator *ti, tree_iterator_frame *tf)\n{\n\tif (tf->next > tf->current + 1)\n\t\tti->path_ambiguities--;\n\n\tif (!tf->up) { /* at root */\n\t\ttf->current = tf->next;\n\t\treturn false;\n\t}\n\n\tfor (; tf->current < tf->next; tf->current++) {\n\t\tgit_tree_free(tf->entries[tf->current]->tree);\n\t\ttf->entries[tf->current]->tree = NULL;\n\t}\n\n\treturn (tf->current < tf->n_entries);\n}"
  },
  {
    "function_name": "tree_iterator__search_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "415-424",
    "snippet": "static int tree_iterator__search_cmp(const void *key, const void *val, void *p)\n{\n\tconst tree_iterator_frame *tf = key;\n\tconst git_tree_entry *te = ((tree_iterator_entry *)val)->te;\n\n\treturn git_path_cmp(\n\t\ttf->start, tf->startlen, false,\n\t\tte->filename, te->filename_len, te->attr == GIT_FILEMODE_TREE,\n\t\t((git_iterator *)p)->strncomp);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_cmp",
          "args": [
            "tf->start",
            "tf->startlen",
            "false",
            "te->filename",
            "te->filename_len",
            "te->attr == GIT_FILEMODE_TREE",
            "((git_iterator *)p)->strncomp"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "788-811",
          "snippet": "int git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__search_cmp(const void *key, const void *val, void *p)\n{\n\tconst tree_iterator_frame *tf = key;\n\tconst git_tree_entry *te = ((tree_iterator_entry *)val)->te;\n\n\treturn git_path_cmp(\n\t\ttf->start, tf->startlen, false,\n\t\tte->filename, te->filename_len, te->attr == GIT_FILEMODE_TREE,\n\t\t((git_iterator *)p)->strncomp);\n}"
  },
  {
    "function_name": "tree_iterator__ci_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "399-413",
    "snippet": "static int tree_iterator__ci_cmp(const void *a, const void *b, void *p)\n{\n\tconst tree_iterator_entry *ae = a, *be = b;\n\tint cmp = tree_iterator__te_cmp(ae->te, be->te, git__strncasecmp);\n\n\tif (!cmp) {\n\t\t/* stabilize sort order among equivalent names */\n\t\tif (!ae->parent->te || !be->parent->te)\n\t\t\tcmp = tree_iterator__te_cmp(ae->te, be->te, git__strncmp);\n\t\telse\n\t\t\tcmp = tree_iterator__ci_cmp(ae->parent, be->parent, p);\n\t}\n\n\treturn cmp;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_iterator__ci_cmp",
          "args": [
            "ae->parent",
            "be->parent",
            "p"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__ci_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "399-413",
          "snippet": "static int tree_iterator__ci_cmp(const void *a, const void *b, void *p)\n{\n\tconst tree_iterator_entry *ae = a, *be = b;\n\tint cmp = tree_iterator__te_cmp(ae->te, be->te, git__strncasecmp);\n\n\tif (!cmp) {\n\t\t/* stabilize sort order among equivalent names */\n\t\tif (!ae->parent->te || !be->parent->te)\n\t\t\tcmp = tree_iterator__te_cmp(ae->te, be->te, git__strncmp);\n\t\telse\n\t\t\tcmp = tree_iterator__ci_cmp(ae->parent, be->parent, p);\n\t}\n\n\treturn cmp;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "tree_iterator__te_cmp",
          "args": [
            "ae->te",
            "be->te",
            "git__strncmp"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "tree_iterator__te_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "388-397",
          "snippet": "static int tree_iterator__te_cmp(\n\tconst git_tree_entry *a,\n\tconst git_tree_entry *b,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\treturn git_path_cmp(\n\t\ta->filename, a->filename_len, a->attr == GIT_FILEMODE_TREE,\n\t\tb->filename, b->filename_len, b->attr == GIT_FILEMODE_TREE,\n\t\tcompare);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__te_cmp(\n\tconst git_tree_entry *a,\n\tconst git_tree_entry *b,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\treturn git_path_cmp(\n\t\ta->filename, a->filename_len, a->attr == GIT_FILEMODE_TREE,\n\t\tb->filename, b->filename_len, b->attr == GIT_FILEMODE_TREE,\n\t\tcompare);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__ci_cmp(const void *a, const void *b, void *p)\n{\n\tconst tree_iterator_entry *ae = a, *be = b;\n\tint cmp = tree_iterator__te_cmp(ae->te, be->te, git__strncasecmp);\n\n\tif (!cmp) {\n\t\t/* stabilize sort order among equivalent names */\n\t\tif (!ae->parent->te || !be->parent->te)\n\t\t\tcmp = tree_iterator__te_cmp(ae->te, be->te, git__strncmp);\n\t\telse\n\t\t\tcmp = tree_iterator__ci_cmp(ae->parent, be->parent, p);\n\t}\n\n\treturn cmp;\n}"
  },
  {
    "function_name": "tree_iterator__te_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "388-397",
    "snippet": "static int tree_iterator__te_cmp(\n\tconst git_tree_entry *a,\n\tconst git_tree_entry *b,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\treturn git_path_cmp(\n\t\ta->filename, a->filename_len, a->attr == GIT_FILEMODE_TREE,\n\t\tb->filename, b->filename_len, b->attr == GIT_FILEMODE_TREE,\n\t\tcompare);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_path_cmp",
          "args": [
            "a->filename",
            "a->filename_len",
            "a->attr == GIT_FILEMODE_TREE",
            "b->filename",
            "b->filename_len",
            "b->attr == GIT_FILEMODE_TREE",
            "compare"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "git_path_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/path.c",
          "lines": "788-811",
          "snippet": "int git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <stdio.h>",
            "#include <dirent.h>",
            "#include \"win32/version.h\"",
            "#include \"win32/w32_util.h\"",
            "#include \"win32/w32_buffer.h\"",
            "#include \"win32/posix.h\"",
            "#include \"repository.h\"",
            "#include \"posix.h\"",
            "#include \"path.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"win32/version.h\"\n#include \"win32/w32_util.h\"\n#include \"win32/w32_buffer.h\"\n#include \"win32/posix.h\"\n#include \"repository.h\"\n#include \"posix.h\"\n#include \"path.h\"\n#include \"common.h\"\n\nint git_path_cmp(\n\tconst char *name1, size_t len1, int isdir1,\n\tconst char *name2, size_t len2, int isdir2,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\tunsigned char c1, c2;\n\tsize_t len = len1 < len2 ? len1 : len2;\n\tint cmp;\n\n\tcmp = compare(name1, name2, len);\n\tif (cmp)\n\t\treturn cmp;\n\n\tc1 = name1[len];\n\tc2 = name2[len];\n\n\tif (c1 == '\\0' && isdir1)\n\t\tc1 = '/';\n\n\tif (c2 == '\\0' && isdir2)\n\t\tc2 = '/';\n\n\treturn (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int tree_iterator__te_cmp(\n\tconst git_tree_entry *a,\n\tconst git_tree_entry *b,\n\tint (*compare)(const char *, const char *, size_t))\n{\n\treturn git_path_cmp(\n\t\ta->filename, a->filename_len, a->attr == GIT_FILEMODE_TREE,\n\t\tb->filename, b->filename_len, b->attr == GIT_FILEMODE_TREE,\n\t\tcompare);\n}"
  },
  {
    "function_name": "tree_iterator__rewrite_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "372-386",
    "snippet": "static void tree_iterator__rewrite_filename(tree_iterator *ti)\n{\n\ttree_iterator_entry *scan = ti->head->entries[ti->head->current];\n\tssize_t strpos = ti->path.size;\n\tconst git_tree_entry *te;\n\n\tif (strpos && ti->path.ptr[strpos - 1] == '/')\n\t\tstrpos--;\n\n\tfor (; scan && (te = scan->te); scan = scan->parent) {\n\t\tstrpos -= te->filename_len;\n\t\tmemcpy(&ti->path.ptr[strpos], te->filename, te->filename_len);\n\t\tstrpos -= 1; /* separator */\n\t}\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ti->path.ptr[strpos]",
            "te->filename",
            "te->filename_len"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void tree_iterator__rewrite_filename(tree_iterator *ti)\n{\n\ttree_iterator_entry *scan = ti->head->entries[ti->head->current];\n\tssize_t strpos = ti->path.size;\n\tconst git_tree_entry *te;\n\n\tif (strpos && ti->path.ptr[strpos - 1] == '/')\n\t\tstrpos--;\n\n\tfor (; scan && (te = scan->te); scan = scan->parent) {\n\t\tstrpos -= te->filename_len;\n\t\tmemcpy(&ti->path.ptr[strpos], te->filename, te->filename_len);\n\t\tstrpos -= 1; /* separator */\n\t}\n}"
  },
  {
    "function_name": "tree_iterator__current_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "356-370",
    "snippet": "static char *tree_iterator__current_filename(\n\ttree_iterator *ti, const git_tree_entry *te)\n{\n\tif (!ti->path_has_filename) {\n\t\tif (git_buf_joinpath(&ti->path, ti->path.ptr, te->filename) < 0)\n\t\t\treturn NULL;\n\n\t\tif (git_tree_entry__is_tree(te) && git_buf_putc(&ti->path, '/') < 0)\n\t\t\treturn NULL;\n\n\t\tti->path_has_filename = true;\n\t}\n\n\treturn ti->path.ptr;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_buf_putc",
          "args": [
            "&ti->path",
            "'/'"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.c",
          "lines": "186-194",
          "snippet": "int git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"buf_text.h\"",
            "#include \"git2/buffer.h\"",
            "#include \"posix.h\"",
            "#include \"buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"buf_text.h\"\n#include \"git2/buffer.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\nint git_buf_putc(git_buf *buf, char c)\n{\n\tsize_t new_size;\n\tGITERR_CHECK_ALLOC_ADD(&new_size, buf->size, 2);\n\tENSURE_SIZE(buf, new_size);\n\tbuf->ptr[buf->size++] = c;\n\tbuf->ptr[buf->size] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_tree_entry__is_tree",
          "args": [
            "te"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "git_tree_entry__is_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/tree.h",
          "lines": "35-38",
          "snippet": "GIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}",
          "includes": [
            "#include \"pool.h\"",
            "#include \"strmap.h\"",
            "#include \"vector.h\"",
            "#include \"odb.h\"",
            "#include \"repository.h\"",
            "#include \"git2/tree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pool.h\"\n#include \"strmap.h\"\n#include \"vector.h\"\n#include \"odb.h\"\n#include \"repository.h\"\n#include \"git2/tree.h\"\n\nGIT_INLINE(bool) git_tree_entry__is_tree(const struct git_tree_entry *e)\n{\n\treturn (S_ISDIR(e->attr) && !S_ISGITLINK(e->attr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_buf_joinpath",
          "args": [
            "&ti->path",
            "ti->path.ptr",
            "te->filename"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "git_buf_joinpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/buffer.h",
          "lines": "131-134",
          "snippet": "GIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}",
          "includes": [
            "#include \"git2/buffer.h\"",
            "#include \"git2/strarray.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"git2/buffer.h\"\n#include \"git2/strarray.h\"\n#include \"common.h\"\n\nGIT_INLINE(int) git_buf_joinpath(git_buf *buf, const char *a, const char *b)\n{\n\treturn git_buf_join(buf, '/', a, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic char *tree_iterator__current_filename(\n\ttree_iterator *ti, const git_tree_entry *te)\n{\n\tif (!ti->path_has_filename) {\n\t\tif (git_buf_joinpath(&ti->path, ti->path.ptr, te->filename) < 0)\n\t\t\treturn NULL;\n\n\t\tif (git_tree_entry__is_tree(te) && git_buf_putc(&ti->path, '/') < 0)\n\t\t\treturn NULL;\n\n\t\tti->path_has_filename = true;\n\t}\n\n\treturn ti->path.ptr;\n}"
  },
  {
    "function_name": "git_iterator_for_nothing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "302-320",
    "snippet": "int git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [
      "#define empty_iterator__advance_into empty_iterator__noop",
      "#define empty_iterator__advance empty_iterator__noop",
      "#define empty_iterator__current empty_iterator__noop"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ITERATOR_BASE_INIT",
          "args": [
            "i",
            "empty",
            "EMPTY",
            "NULL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "i"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__calloc",
          "args": [
            "1",
            "sizeof(empty_iterator)"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "git__calloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "167-172",
          "snippet": "GIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void *) git__calloc(size_t nelem, size_t elsize)\n{\n\tvoid *ptr = calloc(nelem, elsize);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define empty_iterator__advance_into empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__current empty_iterator__noop\n\nint git_iterator_for_nothing(\n\tgit_iterator **iter,\n\tgit_iterator_options *options)\n{\n\tempty_iterator *i = git__calloc(1, sizeof(empty_iterator));\n\tGITERR_CHECK_ALLOC(i);\n\n#define empty_iterator__current empty_iterator__noop\n#define empty_iterator__advance empty_iterator__noop\n#define empty_iterator__advance_into empty_iterator__noop\n\n\tITERATOR_BASE_INIT(i, empty, EMPTY, NULL);\n\n\tif (options && (options->flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\ti->base.flags |= GIT_ITERATOR_IGNORE_CASE;\n\n\t*iter = (git_iterator *)i;\n\treturn 0;\n}"
  },
  {
    "function_name": "empty_iterator__free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "292-295",
    "snippet": "static void empty_iterator__free(git_iterator *i)\n{\n\tGIT_UNUSED(i);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "i"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void empty_iterator__free(git_iterator *i)\n{\n\tGIT_UNUSED(i);\n}"
  },
  {
    "function_name": "empty_iterator__at_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "286-290",
    "snippet": "static int empty_iterator__at_end(git_iterator *i)\n{\n\tGIT_UNUSED(i);\n\treturn 1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "i"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int empty_iterator__at_end(git_iterator *i)\n{\n\tGIT_UNUSED(i);\n\treturn 1;\n}"
  },
  {
    "function_name": "empty_iterator__reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "280-284",
    "snippet": "static int empty_iterator__reset(git_iterator *i, const char *s, const char *e)\n{\n\tGIT_UNUSED(i); GIT_UNUSED(s); GIT_UNUSED(e);\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "e"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "s"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "i"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int empty_iterator__reset(git_iterator *i, const char *s, const char *e)\n{\n\tGIT_UNUSED(i); GIT_UNUSED(s); GIT_UNUSED(e);\n\treturn 0;\n}"
  },
  {
    "function_name": "empty_iterator__seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "274-278",
    "snippet": "static int empty_iterator__seek(git_iterator *i, const char *p)\n{\n\tGIT_UNUSED(i); GIT_UNUSED(p);\n\treturn -1;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "p"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "i"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int empty_iterator__seek(git_iterator *i, const char *p)\n{\n\tGIT_UNUSED(i); GIT_UNUSED(p);\n\treturn -1;\n}"
  },
  {
    "function_name": "empty_iterator__noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "267-272",
    "snippet": "static int empty_iterator__noop(const git_index_entry **e, git_iterator *i)\n{\n\tGIT_UNUSED(i);\n\titerator__clear_entry(e);\n\treturn GIT_ITEROVER;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterator__clear_entry",
          "args": [
            "e"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "iterator__clear_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "261-264",
          "snippet": "GIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GIT_UNUSED",
          "args": [
            "i"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int empty_iterator__noop(const git_index_entry **e, git_iterator *i)\n{\n\tGIT_UNUSED(i);\n\titerator__clear_entry(e);\n\treturn GIT_ITEROVER;\n}"
  },
  {
    "function_name": "iterator__clear_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "261-264",
    "snippet": "GIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nGIT_INLINE(void) iterator__clear_entry(const git_index_entry **entry)\n{\n\tif (entry) *entry = NULL;\n}"
  },
  {
    "function_name": "iterator__update_ignore_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "222-259",
    "snippet": "static int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterator_pathlist__update_ignore_case",
          "args": [
            "iter"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "iterator_pathlist__update_ignore_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
          "lines": "191-197",
          "snippet": "static void iterator_pathlist__update_ignore_case(git_iterator *iter)\n{\n\tgit_vector_set_cmp(&iter->pathlist, (git_vector_cmp)iter->strcomp);\n\tgit_vector_sort(&iter->pathlist);\n\n\titer->pathlist_walk_idx = 0;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include \"submodule.h\"",
            "#include \"buffer.h\"",
            "#include \"ignore.h\"",
            "#include \"index.h\"",
            "#include \"tree.h\"",
            "#include \"iterator.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void iterator_pathlist__update_ignore_case(git_iterator *iter)\n{\n\tgit_vector_set_cmp(&iter->pathlist, (git_vector_cmp)iter->strcomp);\n\tgit_vector_sort(&iter->pathlist);\n\n\titer->pathlist_walk_idx = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_repository_index__weakptr",
          "args": [
            "&index",
            "iter->repo"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "git_repository_index__weakptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/repository.c",
          "lines": "819-850",
          "snippet": "int git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}",
          "includes": [
            "#include \"repo_template.h\"",
            "# include \"win32/w32_util.h\"",
            "#include \"annotated_commit.h\"",
            "#include \"diff_driver.h\"",
            "#include \"merge.h\"",
            "#include \"remote.h\"",
            "#include \"odb.h\"",
            "#include \"filter.h\"",
            "#include \"refs.h\"",
            "#include \"config.h\"",
            "#include \"index.h\"",
            "#include \"filebuf.h\"",
            "#include \"sysdir.h\"",
            "#include \"fileops.h\"",
            "#include \"blob.h\"",
            "#include \"tag.h\"",
            "#include \"commit.h\"",
            "#include \"repository.h\"",
            "#include \"common.h\"",
            "#include \"git2/sys/repository.h\"",
            "#include \"git2/refdb.h\"",
            "#include \"git2/object.h\"",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"repo_template.h\"\n# include \"win32/w32_util.h\"\n#include \"annotated_commit.h\"\n#include \"diff_driver.h\"\n#include \"merge.h\"\n#include \"remote.h\"\n#include \"odb.h\"\n#include \"filter.h\"\n#include \"refs.h\"\n#include \"config.h\"\n#include \"index.h\"\n#include \"filebuf.h\"\n#include \"sysdir.h\"\n#include \"fileops.h\"\n#include \"blob.h\"\n#include \"tag.h\"\n#include \"commit.h\"\n#include \"repository.h\"\n#include \"common.h\"\n#include \"git2/sys/repository.h\"\n#include \"git2/refdb.h\"\n#include \"git2/object.h\"\n#include <ctype.h>\n\nint git_repository_index__weakptr(git_index **out, git_repository *repo)\n{\n\tint error = 0;\n\n\tassert(out && repo);\n\n\tif (repo->_index == NULL) {\n\t\tgit_buf index_path = GIT_BUF_INIT;\n\t\tgit_index *index;\n\n\t\tif ((error = git_buf_joinpath(&index_path, repo->path_repository, GIT_INDEX_FILE)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_index_open(&index, index_path.ptr);\n\t\tif (!error) {\n\t\t\tGIT_REFCOUNT_OWN(index, repo);\n\n\t\t\tindex = git__compare_and_swap(&repo->_index, NULL, index);\n\t\t\tif (index != NULL) {\n\t\t\t\tGIT_REFCOUNT_OWN(index, NULL);\n\t\t\t\tgit_index_free(index);\n\t\t\t}\n\n\t\t\terror = git_index_set_caps(repo->_index, GIT_INDEXCAP_FROM_OWNER);\n\t\t}\n\n\t\tgit_buf_free(&index_path);\n\t}\n\n\t*out = repo->_index;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int iterator__update_ignore_case(\n\tgit_iterator *iter,\n\tgit_iterator_flag_t flags)\n{\n\tbool ignore_case;\n\tint error;\n\n\tif ((flags & GIT_ITERATOR_IGNORE_CASE) != 0)\n\t\tignore_case = true;\n\telse if ((flags & GIT_ITERATOR_DONT_IGNORE_CASE) != 0)\n\t\tignore_case = false;\n\telse {\n\t\tgit_index *index;\n\n\t\tif ((error = git_repository_index__weakptr(&index, iter->repo)) < 0)\n\t\t\treturn error;\n\n\t\tignore_case = (index->ignore_case == 1);\n\t}\n\n\tif (ignore_case) {\n\t\titer->flags = (iter->flags | GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcasecmp;\n\t\titer->strncomp = git__strncasecmp;\n\t\titer->prefixcomp = git__prefixcmp_icase;\n\t} else {\n\t\titer->flags = (iter->flags & ~GIT_ITERATOR_IGNORE_CASE);\n\n\t\titer->strcomp = git__strcmp;\n\t\titer->strncomp = git__strncmp;\n\t\titer->prefixcomp = git__prefixcmp;\n\t}\n\n\titerator_pathlist__update_ignore_case(iter);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iterator__reset_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "200-220",
    "snippet": "static int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [
      "#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "iter->end"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git__strdup",
          "args": [
            "end"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "git__strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "174-179",
          "snippet": "GIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(char *) git__strdup(const char *str)\n{\n\tchar *ptr = strdup(str);\n\tif (!ptr) giterr_set_oom();\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git__free",
          "args": [
            "iter->end"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "git__free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/util.h",
          "lines": "244-247",
          "snippet": "GIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}",
          "includes": [
            "#include <sys/time.h>",
            "#include <proto/timer.h>",
            "#include <mach/mach_time.h>",
            "#include \"thread-utils.h\"",
            "#include \"strnlen.h\"",
            "#include \"common.h\"",
            "#include \"win32/w32_crtdbg_stacktrace.h\"",
            "#include <crtdbg.h>",
            "#include <stdlib.h>",
            "#include \"buffer.h\"",
            "#include \"git2/buffer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/time.h>\n#include <proto/timer.h>\n#include <mach/mach_time.h>\n#include \"thread-utils.h\"\n#include \"strnlen.h\"\n#include \"common.h\"\n#include \"win32/w32_crtdbg_stacktrace.h\"\n#include <crtdbg.h>\n#include <stdlib.h>\n#include \"buffer.h\"\n#include \"git2/buffer.h\"\n\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GITERR_CHECK_ALLOC",
          "args": [
            "iter->start"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\n#define GIT_ITERATOR_FIRST_ACCESS (1 << 15)\n\nstatic int iterator__reset_range(\n\tgit_iterator *iter, const char *start, const char *end)\n{\n\tif (start) {\n\t\tif (iter->start)\n\t\t\tgit__free(iter->start);\n\t\titer->start = git__strdup(start);\n\t\tGITERR_CHECK_ALLOC(iter->start);\n\t}\n\n\tif (end) {\n\t\tif (iter->end)\n\t\t\tgit__free(iter->end);\n\t\titer->end = git__strdup(end);\n\t\tGITERR_CHECK_ALLOC(iter->end);\n\t}\n\n\titer->flags &= ~GIT_ITERATOR_FIRST_ACCESS;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iterator_pathlist__update_ignore_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "191-197",
    "snippet": "static void iterator_pathlist__update_ignore_case(git_iterator *iter)\n{\n\tgit_vector_set_cmp(&iter->pathlist, (git_vector_cmp)iter->strcomp);\n\tgit_vector_sort(&iter->pathlist);\n\n\titer->pathlist_walk_idx = 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&iter->pathlist"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_set_cmp",
          "args": [
            "&iter->pathlist",
            "(git_vector_cmp)iter->strcomp"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_set_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "107-113",
          "snippet": "GIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void) git_vector_set_cmp(git_vector *v, git_vector_cmp cmp)\n{\n\tif (cmp != v->_cmp) {\n\t\tv->_cmp = cmp;\n\t\tgit_vector_set_sorted(v, 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void iterator_pathlist__update_ignore_case(git_iterator *iter)\n{\n\tgit_vector_set_cmp(&iter->pathlist, (git_vector_cmp)iter->strcomp);\n\tgit_vector_sort(&iter->pathlist);\n\n\titer->pathlist_walk_idx = 0;\n}"
  },
  {
    "function_name": "iterator_pathlist_walk__contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "148-189",
    "snippet": "static bool iterator_pathlist_walk__contains(git_iterator *iter, const char *path)\n{\n\tsize_t i;\n\tchar *p;\n\tsize_t p_len;\n\tint cmp;\n\n\tfor (i = iter->pathlist_walk_idx; i < iter->pathlist.length; i++) {\n\t\tp = iter->pathlist.contents[i];\n\t\tp_len = strlen(p);\n\n\t\t/* see if the pathlist entry is a prefix of this path */\n\t\tcmp = iter->strncomp(p, path, p_len);\n\n\t\t/* this pathlist entry sorts before the given path, try the next */\n\t\tif (!p_len || cmp < 0)\n\t\t\titer->pathlist_walk_idx++;\n\n\t\t/* this pathlist sorts after the given path, no match. */\n\t\telse if (cmp > 0)\n\t\t\treturn false;\n\n\t\t/* match!  an exact match (`foo` vs `foo`), the path is a child of an\n\t\t * explicit directory in the pathlist (`foo/` vs `foo/bar`) or the path\n\t\t * is a child of an entry in the pathlist (`foo` vs `foo/bar`)\n\t\t */\n\t\telse if (path[p_len] == '\\0' || p[p_len - 1] == '/' || path[p_len] == '/')\n\t\t\treturn true;\n\n\t\t/* only advance the start index for future callers if we know that we\n\t\t * will not see a child of this path.  eg, a pathlist entry `foo` is\n\t\t * a prefix for `foo.txt` and `foo/bar`.  don't advance the start\n\t\t * pathlist index when we see `foo.txt` or we would miss a subsequent\n\t\t * inspection of `foo/bar`.  only advance when there are no more\n\t\t * potential children.\n\t\t */\n\t\telse if (path[p_len] > '/')\n\t\t\titer->pathlist_walk_idx++;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter->strncomp",
          "args": [
            "p",
            "path",
            "p_len"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic bool iterator_pathlist_walk__contains(git_iterator *iter, const char *path)\n{\n\tsize_t i;\n\tchar *p;\n\tsize_t p_len;\n\tint cmp;\n\n\tfor (i = iter->pathlist_walk_idx; i < iter->pathlist.length; i++) {\n\t\tp = iter->pathlist.contents[i];\n\t\tp_len = strlen(p);\n\n\t\t/* see if the pathlist entry is a prefix of this path */\n\t\tcmp = iter->strncomp(p, path, p_len);\n\n\t\t/* this pathlist entry sorts before the given path, try the next */\n\t\tif (!p_len || cmp < 0)\n\t\t\titer->pathlist_walk_idx++;\n\n\t\t/* this pathlist sorts after the given path, no match. */\n\t\telse if (cmp > 0)\n\t\t\treturn false;\n\n\t\t/* match!  an exact match (`foo` vs `foo`), the path is a child of an\n\t\t * explicit directory in the pathlist (`foo/` vs `foo/bar`) or the path\n\t\t * is a child of an entry in the pathlist (`foo` vs `foo/bar`)\n\t\t */\n\t\telse if (path[p_len] == '\\0' || p[p_len - 1] == '/' || path[p_len] == '/')\n\t\t\treturn true;\n\n\t\t/* only advance the start index for future callers if we know that we\n\t\t * will not see a child of this path.  eg, a pathlist entry `foo` is\n\t\t * a prefix for `foo.txt` and `foo/bar`.  don't advance the start\n\t\t * pathlist index when we see `foo.txt` or we would miss a subsequent\n\t\t * inspection of `foo/bar`.  only advance when there are no more\n\t\t * potential children.\n\t\t */\n\t\telse if (path[p_len] > '/')\n\t\t\titer->pathlist_walk_idx++;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "iterator_pathlist_walk__reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "135-138",
    "snippet": "static void iterator_pathlist_walk__reset(git_iterator *iter)\n{\n\titer->pathlist_walk_idx = 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic void iterator_pathlist_walk__reset(git_iterator *iter)\n{\n\titer->pathlist_walk_idx = 0;\n}"
  },
  {
    "function_name": "iterator_pathlist__match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "95-133",
    "snippet": "static iterator_pathlist__match_t iterator_pathlist__match(\n\tgit_iterator *iter, const char *path, size_t path_len)\n{\n\tconst char *p;\n\tsize_t idx;\n\tint error;\n\n\terror = git_vector_bsearch2(&idx, &iter->pathlist,\n\t\t(git_vector_cmp)iter->strcomp, path);\n\n\tif (error == 0)\n\t\treturn ITERATOR_PATHLIST_MATCH;\n\n\t/* at this point, the path we're examining may be a directory (though we\n\t * don't know that yet, since we're avoiding a stat unless it's necessary)\n\t * so see if the pathlist contains a file beneath this directory.\n\t */\n\twhile ((p = git_vector_get(&iter->pathlist, idx)) != NULL) {\n\t\tif (iter->prefixcomp(p, path) != 0)\n\t\t\tbreak;\n\n\t\t/* an exact match would have been matched by the bsearch above */\n\t\tassert(p[path_len]);\n\n\t\t/* is this a literal directory entry (eg `foo/`) or a file beneath */\n\t\tif (p[path_len] == '/') {\n\t\t\treturn (p[path_len+1] == '\\0') ?\n\t\t\t\tITERATOR_PATHLIST_MATCH_DIRECTORY :\n\t\t\t\tITERATOR_PATHLIST_MATCH_CHILD;\n\t\t}\n\n\t\tif (p[path_len] > '/')\n\t\t\tbreak;\n\n\t\tidx++;\n\t}\n\n\treturn ITERATOR_PATHLIST_NONE;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p[path_len]"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->prefixcomp",
          "args": [
            "p",
            "path"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "git_vector_get",
          "args": [
            "&iter->pathlist",
            "idx"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.h",
          "lines": "60-63",
          "snippet": "GIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nGIT_INLINE(void *) git_vector_get(const git_vector *v, size_t position)\n{\n\treturn (position < v->length) ? v->contents[position] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_bsearch2",
          "args": [
            "&idx",
            "&iter->pathlist",
            "(git_vector_cmp)iter->strcomp",
            "path"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_bsearch2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "187-202",
          "snippet": "int git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_bsearch2(\n\tsize_t *at_pos,\n\tgit_vector *v,\n\tgit_vector_cmp key_lookup,\n\tconst void *key)\n{\n\tassert(v && key && key_lookup);\n\n\t/* need comparison function to sort the vector */\n\tif (!v->_cmp)\n\t\treturn -1;\n\n\tgit_vector_sort(v);\n\n\treturn git__bsearch(v->contents, v->length, key, key_lookup, at_pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic iterator_pathlist__match_t iterator_pathlist__match(\n\tgit_iterator *iter, const char *path, size_t path_len)\n{\n\tconst char *p;\n\tsize_t idx;\n\tint error;\n\n\terror = git_vector_bsearch2(&idx, &iter->pathlist,\n\t\t(git_vector_cmp)iter->strcomp, path);\n\n\tif (error == 0)\n\t\treturn ITERATOR_PATHLIST_MATCH;\n\n\t/* at this point, the path we're examining may be a directory (though we\n\t * don't know that yet, since we're avoiding a stat unless it's necessary)\n\t * so see if the pathlist contains a file beneath this directory.\n\t */\n\twhile ((p = git_vector_get(&iter->pathlist, idx)) != NULL) {\n\t\tif (iter->prefixcomp(p, path) != 0)\n\t\t\tbreak;\n\n\t\t/* an exact match would have been matched by the bsearch above */\n\t\tassert(p[path_len]);\n\n\t\t/* is this a literal directory entry (eg `foo/`) or a file beneath */\n\t\tif (p[path_len] == '/') {\n\t\t\treturn (p[path_len+1] == '\\0') ?\n\t\t\t\tITERATOR_PATHLIST_MATCH_DIRECTORY :\n\t\t\t\tITERATOR_PATHLIST_MATCH_CHILD;\n\t\t}\n\n\t\tif (p[path_len] > '/')\n\t\t\tbreak;\n\n\t\tidx++;\n\t}\n\n\treturn ITERATOR_PATHLIST_NONE;\n}"
  },
  {
    "function_name": "iterator_pathlist__init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/iterator.c",
    "lines": "74-93",
    "snippet": "static int iterator_pathlist__init(git_iterator *iter, git_strarray *pathspec)\n{\n\tsize_t i;\n\n\tif (git_vector_init(&iter->pathlist, pathspec->count,\n\t\t\t(git_vector_cmp)iter->strcomp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < pathspec->count; i++) {\n\t\tif (!pathspec->strings[i])\n\t\t\tcontinue;\n\n\t\tif (git_vector_insert(&iter->pathlist, pathspec->strings[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\tgit_vector_sort(&iter->pathlist);\n\n\treturn 0;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include \"submodule.h\"",
      "#include \"buffer.h\"",
      "#include \"ignore.h\"",
      "#include \"index.h\"",
      "#include \"tree.h\"",
      "#include \"iterator.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "git_vector_sort",
          "args": [
            "&iter->pathlist"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "175-185",
          "snippet": "void git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nvoid git_vector_sort(git_vector *v)\n{\n\tassert(v);\n\n\tif (git_vector_is_sorted(v) || !v->_cmp)\n\t\treturn;\n\n\tif (v->length > 1)\n\t\tgit__tsort(v->contents, v->length, v->_cmp);\n\tgit_vector_set_sorted(v, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_insert",
          "args": [
            "&iter->pathlist",
            "pathspec->strings[i]"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "126-139",
          "snippet": "int git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\nint git_vector_insert(git_vector *v, void *element)\n{\n\tassert(v);\n\n\tif (v->length >= v->_alloc_size &&\n\t\tresize_vector(v, compute_new_size(v)) < 0)\n\t\treturn -1;\n\n\tv->contents[v->length++] = element;\n\n\tgit_vector_set_sorted(v, v->length <= 1);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "git_vector_init",
          "args": [
            "&iter->pathlist",
            "pathspec->count",
            "(git_vector_cmp)iter->strcomp"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "git_vector_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/vector.c",
          "lines": "97-108",
          "snippet": "int git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}",
          "includes": [
            "#include \"vector.h\"",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define MIN_ALLOCSIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vector.h\"\n#include \"common.h\"\n\n#define MIN_ALLOCSIZE\t8\n\nint git_vector_init(git_vector *v, size_t initial_size, git_vector_cmp cmp)\n{\n\tassert(v);\n\n\tv->_alloc_size = 0;\n\tv->_cmp = cmp;\n\tv->length = 0;\n\tv->flags = GIT_VECTOR_SORTED;\n\tv->contents = NULL;\n\n\treturn resize_vector(v, max(initial_size, MIN_ALLOCSIZE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include \"submodule.h\"\n#include \"buffer.h\"\n#include \"ignore.h\"\n#include \"index.h\"\n#include \"tree.h\"\n#include \"iterator.h\"\n\nstatic int iterator_pathlist__init(git_iterator *iter, git_strarray *pathspec)\n{\n\tsize_t i;\n\n\tif (git_vector_init(&iter->pathlist, pathspec->count,\n\t\t\t(git_vector_cmp)iter->strcomp) < 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < pathspec->count; i++) {\n\t\tif (!pathspec->strings[i])\n\t\t\tcontinue;\n\n\t\tif (git_vector_insert(&iter->pathlist, pathspec->strings[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\tgit_vector_sort(&iter->pathlist);\n\n\treturn 0;\n}"
  }
]