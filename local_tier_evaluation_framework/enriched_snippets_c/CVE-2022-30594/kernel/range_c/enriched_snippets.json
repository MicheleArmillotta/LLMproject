[
  {
    "function_name": "sort_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
    "lines": "161-165",
    "snippet": "void sort_range(struct range *range, int nr_range)\n{\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/printk.h>",
      "#include <linux/minmax.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "range",
            "nr_range",
            "sizeof(struct range)",
            "cmp_range",
            "NULL"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/printk.h>\n#include <linux/minmax.h>\n#include <linux/init.h>\n\nvoid sort_range(struct range *range, int nr_range)\n{\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n}"
  },
  {
    "function_name": "clean_sort_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
    "lines": "126-159",
    "snippet": "int clean_sort_range(struct range *range, int az)\n{\n\tint i, j, k = az - 1, nr_range = az;\n\n\tfor (i = 0; i < k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j > i; j--) {\n\t\t\tif (range[j].end) {\n\t\t\t\tk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == i)\n\t\t\tbreak;\n\t\trange[i].start = range[k].start;\n\t\trange[i].end   = range[k].end;\n\t\trange[k].start = 0;\n\t\trange[k].end   = 0;\n\t\tk--;\n\t}\n\t/* count it */\n\tfor (i = 0; i < az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n\n\treturn nr_range;\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/printk.h>",
      "#include <linux/minmax.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "range",
            "nr_range",
            "sizeof(struct range)",
            "cmp_range",
            "NULL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/tracing_map.c",
          "lines": "998-1043",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/kmemleak.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/kmemleak.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const void *, const void *);\n\tint (*secondary_fn)(const void *, const void *);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/printk.h>\n#include <linux/minmax.h>\n#include <linux/init.h>\n\nint clean_sort_range(struct range *range, int az)\n{\n\tint i, j, k = az - 1, nr_range = az;\n\n\tfor (i = 0; i < k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j > i; j--) {\n\t\t\tif (range[j].end) {\n\t\t\t\tk = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == i)\n\t\t\tbreak;\n\t\trange[i].start = range[k].start;\n\t\trange[i].end   = range[k].end;\n\t\trange[k].start = 0;\n\t\trange[k].end   = 0;\n\t\tk--;\n\t}\n\t/* count it */\n\tfor (i = 0; i < az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* sort them */\n\tsort(range, nr_range, sizeof(struct range), cmp_range, NULL);\n\n\treturn nr_range;\n}"
  },
  {
    "function_name": "cmp_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
    "lines": "114-124",
    "snippet": "static int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->start < r2->start)\n\t\treturn -1;\n\tif (r1->start > r2->start)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/printk.h>",
      "#include <linux/minmax.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/printk.h>\n#include <linux/minmax.h>\n#include <linux/init.h>\n\nstatic int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->start < r2->start)\n\t\treturn -1;\n\tif (r1->start > r2->start)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "subtract_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
    "lines": "65-112",
    "snippet": "void subtract_range(struct range *range, int az, u64 start, u64 end)\n{\n\tint i, j;\n\n\tif (start >= end)\n\t\treturn;\n\n\tfor (j = 0; j < az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >= range[j].end) {\n\t\t\trange[j].start = 0;\n\t\t\trange[j].end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start <= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start > range[j].start && end >= range[j].end &&\n\t\t    range[j].end > start) {\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start > range[j].start && end < range[j].end) {\n\t\t\t/* Find the new spare: */\n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/printk.h>",
      "#include <linux/minmax.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: run out of slot in ranges\\n\"",
            "__func__"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/printk.h>\n#include <linux/minmax.h>\n#include <linux/init.h>\n\nvoid subtract_range(struct range *range, int az, u64 start, u64 end)\n{\n\tint i, j;\n\n\tif (start >= end)\n\t\treturn;\n\n\tfor (j = 0; j < az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >= range[j].end) {\n\t\t\trange[j].start = 0;\n\t\t\trange[j].end = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start <= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start > range[j].start && end >= range[j].end &&\n\t\t    range[j].end > start) {\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (start > range[j].start && end < range[j].end) {\n\t\t\t/* Find the new spare: */\n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "add_range_with_merge",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
    "lines": "29-63",
    "snippet": "int add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* get new start/end: */\n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t/* new start/end, will add it back at last */\n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t/* Need to add it: */\n\treturn add_range(range, az, nr_range, start, end);\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/printk.h>",
      "#include <linux/minmax.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_range",
          "args": [
            "range",
            "az",
            "nr_range",
            "start",
            "end"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "add_range_with_merge",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
          "lines": "29-63",
          "snippet": "int add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* get new start/end: */\n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t/* new start/end, will add it back at last */\n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t/* Need to add it: */\n\treturn add_range(range, az, nr_range, start, end);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&range[i]",
            "&range[i + 1]",
            "(nr_range - (i + 1)) * sizeof(range[i])"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "range[i].end",
            "end"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "range[i].start",
            "start"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/printk.h>\n#include <linux/minmax.h>\n#include <linux/init.h>\n\nint add_range_with_merge(struct range *range, int az, int nr_range,\n\t\t     u64 start, u64 end)\n{\n\tint i;\n\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* get new start/end: */\n\tfor (i = 0; i < nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start > common_end)\n\t\t\tcontinue;\n\n\t\t/* new start/end, will add it back at last */\n\t\tstart = min(range[i].start, start);\n\t\tend = max(range[i].end, end);\n\n\t\tmemmove(&range[i], &range[i + 1],\n\t\t\t(nr_range - (i + 1)) * sizeof(range[i]));\n\t\trange[nr_range - 1].start = 0;\n\t\trange[nr_range - 1].end   = 0;\n\t\tnr_range--;\n\t\ti--;\n\t}\n\n\t/* Need to add it: */\n\treturn add_range(range, az, nr_range, start, end);\n}"
  },
  {
    "function_name": "add_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/range.c",
    "lines": "12-27",
    "snippet": "int add_range(struct range *range, int az, int nr_range, u64 start, u64 end)\n{\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* Out of slots: */\n\tif (nr_range >= az)\n\t\treturn nr_range;\n\n\trange[nr_range].start = start;\n\trange[nr_range].end = end;\n\n\tnr_range++;\n\n\treturn nr_range;\n}",
    "includes": [
      "#include <linux/range.h>",
      "#include <linux/string.h>",
      "#include <linux/sort.h>",
      "#include <linux/printk.h>",
      "#include <linux/minmax.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/range.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/printk.h>\n#include <linux/minmax.h>\n#include <linux/init.h>\n\nint add_range(struct range *range, int az, int nr_range, u64 start, u64 end)\n{\n\tif (start >= end)\n\t\treturn nr_range;\n\n\t/* Out of slots: */\n\tif (nr_range >= az)\n\t\treturn nr_range;\n\n\trange[nr_range].start = start;\n\trange[nr_range].end = end;\n\n\tnr_range++;\n\n\treturn nr_range;\n}"
  }
]