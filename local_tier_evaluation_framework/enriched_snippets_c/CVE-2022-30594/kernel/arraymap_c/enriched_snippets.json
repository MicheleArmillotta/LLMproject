[
  {
    "function_name": "array_of_map_gen_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1306-1335",
    "snippet": "static int array_of_map_gen_lookup(struct bpf_map *map,\n\t\t\t\t   struct bpf_insn *insn_buf)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 elem_size = round_up(map->value_size, 8);\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\tconst int map_ptr = BPF_REG_1;\n\tconst int index = BPF_REG_2;\n\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, map_ptr, offsetof(struct bpf_array, value));\n\t*insn++ = BPF_LDX_MEM(BPF_W, ret, index, 0);\n\tif (!map->bypass_spec_v1) {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 6);\n\t\t*insn++ = BPF_ALU32_IMM(BPF_AND, ret, array->index_mask);\n\t} else {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 5);\n\t}\n\tif (is_power_of_2(elem_size))\n\t\t*insn++ = BPF_ALU64_IMM(BPF_LSH, ret, ilog2(elem_size));\n\telse\n\t\t*insn++ = BPF_ALU64_IMM(BPF_MUL, ret, elem_size);\n\t*insn++ = BPF_ALU64_REG(BPF_ADD, ret, map_ptr);\n\t*insn++ = BPF_LDX_MEM(BPF_DW, ret, ret, 0);\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 1);\n\t*insn++ = BPF_JMP_IMM(BPF_JA, 0, 0, 1);\n\t*insn++ = BPF_MOV64_IMM(ret, 0);\n\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_MOV64_IMM",
          "args": [
            "ret",
            "0"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JA",
            "0",
            "0",
            "1"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JEQ",
            "ret",
            "0",
            "1"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_DW",
            "ret",
            "ret",
            "0"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_REG",
          "args": [
            "BPF_ADD",
            "ret",
            "map_ptr"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_MUL",
            "ret",
            "elem_size"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_LSH",
            "ret",
            "ilog2(elem_size)"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "elem_size"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "elem_size"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JGE",
            "ret",
            "map->max_entries",
            "5"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_IMM",
          "args": [
            "BPF_AND",
            "ret",
            "array->index_mask"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JGE",
            "ret",
            "map->max_entries",
            "6"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_W",
            "ret",
            "index",
            "0"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_ADD",
            "map_ptr",
            "offsetof(struct bpf_array, value)"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_of_map_gen_lookup(struct bpf_map *map,\n\t\t\t\t   struct bpf_insn *insn_buf)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 elem_size = round_up(map->value_size, 8);\n\tstruct bpf_insn *insn = insn_buf;\n\tconst int ret = BPF_REG_0;\n\tconst int map_ptr = BPF_REG_1;\n\tconst int index = BPF_REG_2;\n\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, map_ptr, offsetof(struct bpf_array, value));\n\t*insn++ = BPF_LDX_MEM(BPF_W, ret, index, 0);\n\tif (!map->bypass_spec_v1) {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 6);\n\t\t*insn++ = BPF_ALU32_IMM(BPF_AND, ret, array->index_mask);\n\t} else {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 5);\n\t}\n\tif (is_power_of_2(elem_size))\n\t\t*insn++ = BPF_ALU64_IMM(BPF_LSH, ret, ilog2(elem_size));\n\telse\n\t\t*insn++ = BPF_ALU64_IMM(BPF_MUL, ret, elem_size);\n\t*insn++ = BPF_ALU64_REG(BPF_ADD, ret, map_ptr);\n\t*insn++ = BPF_LDX_MEM(BPF_DW, ret, ret, 0);\n\t*insn++ = BPF_JMP_IMM(BPF_JEQ, ret, 0, 1);\n\t*insn++ = BPF_JMP_IMM(BPF_JA, 0, 0, 1);\n\t*insn++ = BPF_MOV64_IMM(ret, 0);\n\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "array_of_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1296-1304",
    "snippet": "static void *array_of_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_map **inner_map = array_map_lookup_elem(map, key);\n\n\tif (!inner_map)\n\t\treturn NULL;\n\n\treturn READ_ONCE(*inner_map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*inner_map"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "753-756",
          "snippet": "static void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_of_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_map **inner_map = array_map_lookup_elem(map, key);\n\n\tif (!inner_map)\n\t\treturn NULL;\n\n\treturn READ_ONCE(*inner_map);\n}"
  },
  {
    "function_name": "array_of_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1286-1294",
    "snippet": "static void array_of_map_free(struct bpf_map *map)\n{\n\t/* map->inner_map_meta is only accessed by syscall which\n\t * is protected by fdget/fdput.\n\t */\n\tbpf_map_meta_free(map->inner_map_meta);\n\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_array_map_free",
          "args": [
            "map"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_fd_array_map_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1206-1211",
          "snippet": "static void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_clear",
          "args": [
            "map"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "865-872",
          "snippet": "static void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_meta_free",
          "args": [
            "map->inner_map_meta"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/map_in_map.c",
          "lines": "72-76",
          "snippet": "void bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tbtf_put(map_meta->btf);\n\tkfree(map_meta);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tbtf_put(map_meta->btf);\n\tkfree(map_meta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void array_of_map_free(struct bpf_map *map)\n{\n\t/* map->inner_map_meta is only accessed by syscall which\n\t * is protected by fdget/fdput.\n\t */\n\tbpf_map_meta_free(map->inner_map_meta);\n\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}"
  },
  {
    "function_name": "array_of_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1267-1284",
    "snippet": "static struct bpf_map *array_of_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_map *map, *inner_map_meta;\n\n\tinner_map_meta = bpf_map_meta_alloc(attr->inner_map_fd);\n\tif (IS_ERR(inner_map_meta))\n\t\treturn inner_map_meta;\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tbpf_map_meta_free(inner_map_meta);\n\t\treturn map;\n\t}\n\n\tmap->inner_map_meta = inner_map_meta;\n\n\treturn map;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_meta_free",
          "args": [
            "inner_map_meta"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/map_in_map.c",
          "lines": "72-76",
          "snippet": "void bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tbtf_put(map_meta->btf);\n\tkfree(map_meta);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nvoid bpf_map_meta_free(struct bpf_map *map_meta)\n{\n\tbtf_put(map_meta->btf);\n\tkfree(map_meta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_map_alloc",
          "args": [
            "attr"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "prog_array_map_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1062-1086",
          "snippet": "static struct bpf_map *prog_array_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_array_aux *aux;\n\tstruct bpf_map *map;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL_ACCOUNT);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&aux->work, prog_array_map_clear_deferred);\n\tINIT_LIST_HEAD(&aux->poke_progs);\n\tmutex_init(&aux->poke_mutex);\n\tspin_lock_init(&aux->owner.lock);\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tkfree(aux);\n\t\treturn map;\n\t}\n\n\tcontainer_of(map, struct bpf_array, map)->aux = aux;\n\taux->map = map;\n\n\treturn map;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *prog_array_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_array_aux *aux;\n\tstruct bpf_map *map;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL_ACCOUNT);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&aux->work, prog_array_map_clear_deferred);\n\tINIT_LIST_HEAD(&aux->poke_progs);\n\tmutex_init(&aux->poke_mutex);\n\tspin_lock_init(&aux->owner.lock);\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tkfree(aux);\n\t\treturn map;\n\t}\n\n\tcontainer_of(map, struct bpf_array, map)->aux = aux;\n\taux->map = map;\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inner_map_meta"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_meta_alloc",
          "args": [
            "attr->inner_map_fd"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/map_in_map.c",
          "lines": "10-70",
          "snippet": "struct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tu32 inner_map_meta_size;\n\tstruct fd f;\n\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\t/* Does not support >1 level map-in-map */\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!inner_map->ops->map_meta_equal) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\tif (map_value_has_spin_lock(inner_map)) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\tinner_map_meta_size = sizeof(*inner_map_meta);\n\t/* In some cases verifier needs to access beyond just base map. */\n\tif (inner_map->ops == &array_map_ops)\n\t\tinner_map_meta_size = sizeof(struct bpf_array);\n\n\tinner_map_meta = kzalloc(inner_map_meta_size, GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\tinner_map_meta->spin_lock_off = inner_map->spin_lock_off;\n\tinner_map_meta->timer_off = inner_map->timer_off;\n\tif (inner_map->btf) {\n\t\tbtf_get(inner_map->btf);\n\t\tinner_map_meta->btf = inner_map->btf;\n\t}\n\n\t/* Misc members not needed in bpf_map_meta_equal() check. */\n\tinner_map_meta->ops = inner_map->ops;\n\tif (inner_map->ops == &array_map_ops) {\n\t\tinner_map_meta->bypass_spec_v1 = inner_map->bypass_spec_v1;\n\t\tcontainer_of(inner_map_meta, struct bpf_array, map)->index_mask =\n\t\t     container_of(inner_map, struct bpf_array, map)->index_mask;\n\t}\n\n\tfdput(f);\n\treturn inner_map_meta;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nstruct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tu32 inner_map_meta_size;\n\tstruct fd f;\n\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\n\t/* Does not support >1 level map-in-map */\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!inner_map->ops->map_meta_equal) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\tif (map_value_has_spin_lock(inner_map)) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\n\tinner_map_meta_size = sizeof(*inner_map_meta);\n\t/* In some cases verifier needs to access beyond just base map. */\n\tif (inner_map->ops == &array_map_ops)\n\t\tinner_map_meta_size = sizeof(struct bpf_array);\n\n\tinner_map_meta = kzalloc(inner_map_meta_size, GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\tinner_map_meta->spin_lock_off = inner_map->spin_lock_off;\n\tinner_map_meta->timer_off = inner_map->timer_off;\n\tif (inner_map->btf) {\n\t\tbtf_get(inner_map->btf);\n\t\tinner_map_meta->btf = inner_map->btf;\n\t}\n\n\t/* Misc members not needed in bpf_map_meta_equal() check. */\n\tinner_map_meta->ops = inner_map->ops;\n\tif (inner_map->ops == &array_map_ops) {\n\t\tinner_map_meta->bypass_spec_v1 = inner_map->bypass_spec_v1;\n\t\tcontainer_of(inner_map_meta, struct bpf_array, map)->index_mask =\n\t\t     container_of(inner_map, struct bpf_array, map)->index_mask;\n\t}\n\n\tfdput(f);\n\treturn inner_map_meta;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *array_of_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_map *map, *inner_map_meta;\n\n\tinner_map_meta = bpf_map_meta_alloc(attr->inner_map_fd);\n\tif (IS_ERR(inner_map_meta))\n\t\treturn inner_map_meta;\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tbpf_map_meta_free(inner_map_meta);\n\t\treturn map;\n\t}\n\n\tmap->inner_map_meta = inner_map_meta;\n\n\treturn map;\n}"
  },
  {
    "function_name": "cgroup_fd_array_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1244-1248",
    "snippet": "static void cgroup_fd_array_free(struct bpf_map *map)\n{\n\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_array_map_free",
          "args": [
            "map"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_fd_array_map_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1206-1211",
          "snippet": "static void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_clear",
          "args": [
            "map"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "865-872",
          "snippet": "static void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void cgroup_fd_array_free(struct bpf_map *map)\n{\n\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}"
  },
  {
    "function_name": "cgroup_fd_array_put_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1238-1242",
    "snippet": "static void cgroup_fd_array_put_ptr(void *ptr)\n{\n\t/* cgroup_put free cgrp after a rcu grace period */\n\tcgroup_put(ptr);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_put",
          "args": [
            "ptr"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void cgroup_fd_array_put_ptr(void *ptr)\n{\n\t/* cgroup_put free cgrp after a rcu grace period */\n\tcgroup_put(ptr);\n}"
  },
  {
    "function_name": "cgroup_fd_array_get_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1231-1236",
    "snippet": "static void *cgroup_fd_array_get_ptr(struct bpf_map *map,\n\t\t\t\t     struct file *map_file /* not used */,\n\t\t\t\t     int fd)\n{\n\treturn cgroup_get_from_fd(fd);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_get_from_fd",
          "args": [
            "fd"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "6577-6589",
          "snippet": "struct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nstruct cgroup *cgroup_get_from_fd(int fd)\n{\n\tstruct cgroup *cgrp;\n\tstruct file *f;\n\n\tf = fget_raw(fd);\n\tif (!f)\n\t\treturn ERR_PTR(-EBADF);\n\n\tcgrp = cgroup_get_from_file(f);\n\tfput(f);\n\treturn cgrp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *cgroup_fd_array_get_ptr(struct bpf_map *map,\n\t\t\t\t     struct file *map_file /* not used */,\n\t\t\t\t     int fd)\n{\n\treturn cgroup_get_from_fd(fd);\n}"
  },
  {
    "function_name": "perf_event_fd_array_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1206-1211",
    "snippet": "static void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_array_map_free",
          "args": [
            "map"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_fd_array_map_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1206-1211",
          "snippet": "static void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_clear",
          "args": [
            "map"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "865-872",
          "snippet": "static void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}"
  },
  {
    "function_name": "perf_event_fd_array_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1187-1204",
    "snippet": "static void perf_event_fd_array_release(struct bpf_map *map,\n\t\t\t\t\tstruct file *map_file)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tstruct bpf_event_entry *ee;\n\tint i;\n\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tee = READ_ONCE(array->ptrs[i]);\n\t\tif (ee && ee->map_file == map_file)\n\t\t\tfd_array_map_delete_elem(map, &i);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_array_map_delete_elem",
          "args": [
            "map",
            "&i"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "811-835",
          "snippet": "static int fd_array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *old_ptr;\n\tu32 index = *(u32 *)key;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, NULL);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t}\n\n\tif (old_ptr) {\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *old_ptr;\n\tu32 index = *(u32 *)key;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, NULL);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t}\n\n\tif (old_ptr) {\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "array->ptrs[i]"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void perf_event_fd_array_release(struct bpf_map *map,\n\t\t\t\t\tstruct file *map_file)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tstruct bpf_event_entry *ee;\n\tint i;\n\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tee = READ_ONCE(array->ptrs[i]);\n\t\tif (ee && ee->map_file == map_file)\n\t\t\tfd_array_map_delete_elem(map, &i);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "perf_event_fd_array_put_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1182-1185",
    "snippet": "static void perf_event_fd_array_put_ptr(void *ptr)\n{\n\tbpf_event_entry_free_rcu(ptr);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_event_entry_free_rcu",
          "args": [
            "ptr"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_event_entry_free_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1151-1154",
          "snippet": "static void bpf_event_entry_free_rcu(struct bpf_event_entry *ee)\n{\n\tcall_rcu(&ee->rcu, __bpf_event_entry_free);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_event_entry_free_rcu(struct bpf_event_entry *ee)\n{\n\tcall_rcu(&ee->rcu, __bpf_event_entry_free);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void perf_event_fd_array_put_ptr(void *ptr)\n{\n\tbpf_event_entry_free_rcu(ptr);\n}"
  },
  {
    "function_name": "perf_event_fd_array_get_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1156-1180",
    "snippet": "static void *perf_event_fd_array_get_ptr(struct bpf_map *map,\n\t\t\t\t\t struct file *map_file, int fd)\n{\n\tstruct bpf_event_entry *ee;\n\tstruct perf_event *event;\n\tstruct file *perf_file;\n\tu64 value;\n\n\tperf_file = perf_event_get(fd);\n\tif (IS_ERR(perf_file))\n\t\treturn perf_file;\n\n\tee = ERR_PTR(-EOPNOTSUPP);\n\tevent = perf_file->private_data;\n\tif (perf_event_read_local(event, &value, NULL, NULL) == -EOPNOTSUPP)\n\t\tgoto err_out;\n\n\tee = bpf_event_entry_gen(perf_file, map_file);\n\tif (ee)\n\t\treturn ee;\n\tee = ERR_PTR(-ENOMEM);\nerr_out:\n\tfput(perf_file);\n\treturn ee;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "perf_file"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_event_entry_gen",
          "args": [
            "perf_file",
            "map_file"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_event_entry_gen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1127-1140",
          "snippet": "static struct bpf_event_entry *bpf_event_entry_gen(struct file *perf_file,\n\t\t\t\t\t\t   struct file *map_file)\n{\n\tstruct bpf_event_entry *ee;\n\n\tee = kzalloc(sizeof(*ee), GFP_ATOMIC);\n\tif (ee) {\n\t\tee->event = perf_file->private_data;\n\t\tee->perf_file = perf_file;\n\t\tee->map_file = map_file;\n\t}\n\n\treturn ee;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_event_entry *bpf_event_entry_gen(struct file *perf_file,\n\t\t\t\t\t\t   struct file *map_file)\n{\n\tstruct bpf_event_entry *ee;\n\n\tee = kzalloc(sizeof(*ee), GFP_ATOMIC);\n\tif (ee) {\n\t\tee->event = perf_file->private_data;\n\t\tee->perf_file = perf_file;\n\t\tee->map_file = map_file;\n\t}\n\n\treturn ee;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_read_local",
          "args": [
            "event",
            "&value",
            "NULL",
            "NULL"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_read_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "4429-4493",
          "snippet": "int perf_event_read_local(struct perf_event *event, u64 *value,\n\t\t\t  u64 *enabled, u64 *running)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\t/*\n\t * Disabling interrupts avoids all counter scheduling (context\n\t * switches, timer based rotation and IPIs).\n\t */\n\tlocal_irq_save(flags);\n\n\t/*\n\t * It must not be an event with inherit set, we cannot read\n\t * all child counters from atomic context.\n\t */\n\tif (event->attr.inherit) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-task event, it must be for current */\n\tif ((event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->hw.target != current) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-CPU event, it must be for this CPU */\n\tif (!(event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->cpu != smp_processor_id()) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a pinned event it must be running on this CPU */\n\tif (event->attr.pinned && event->oncpu != smp_processor_id()) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the event is currently on this CPU, its either a per-task event,\n\t * or local to this CPU. Furthermore it means its ACTIVE (otherwise\n\t * oncpu == -1).\n\t */\n\tif (event->oncpu == smp_processor_id())\n\t\tevent->pmu->read(event);\n\n\t*value = local64_read(&event->count);\n\tif (enabled || running) {\n\t\tu64 now = event->shadow_ctx_time + perf_clock();\n\t\tu64 __enabled, __running;\n\n\t\t__perf_update_times(event, now, &__enabled, &__running);\n\t\tif (enabled)\n\t\t\t*enabled = __enabled;\n\t\tif (running)\n\t\t\t*running = __running;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nint perf_event_read_local(struct perf_event *event, u64 *value,\n\t\t\t  u64 *enabled, u64 *running)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\t/*\n\t * Disabling interrupts avoids all counter scheduling (context\n\t * switches, timer based rotation and IPIs).\n\t */\n\tlocal_irq_save(flags);\n\n\t/*\n\t * It must not be an event with inherit set, we cannot read\n\t * all child counters from atomic context.\n\t */\n\tif (event->attr.inherit) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-task event, it must be for current */\n\tif ((event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->hw.target != current) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a per-CPU event, it must be for this CPU */\n\tif (!(event->attach_state & PERF_ATTACH_TASK) &&\n\t    event->cpu != smp_processor_id()) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* If this is a pinned event it must be running on this CPU */\n\tif (event->attr.pinned && event->oncpu != smp_processor_id()) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If the event is currently on this CPU, its either a per-task event,\n\t * or local to this CPU. Furthermore it means its ACTIVE (otherwise\n\t * oncpu == -1).\n\t */\n\tif (event->oncpu == smp_processor_id())\n\t\tevent->pmu->read(event);\n\n\t*value = local64_read(&event->count);\n\tif (enabled || running) {\n\t\tu64 now = event->shadow_ctx_time + perf_clock();\n\t\tu64 __enabled, __running;\n\n\t\t__perf_update_times(event, now, &__enabled, &__running);\n\t\tif (enabled)\n\t\t\t*enabled = __enabled;\n\t\tif (running)\n\t\t\t*running = __running;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "perf_file"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_get",
          "args": [
            "fd"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "12898-12910",
          "snippet": "struct file *perf_event_get(unsigned int fd)\n{\n\tstruct file *file = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &perf_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn file;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static const struct file_operations perf_fops;",
            "static const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic const struct file_operations perf_fops;\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\nstruct file *perf_event_get(unsigned int fd)\n{\n\tstruct file *file = fget(fd);\n\tif (!file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (file->f_op != &perf_fops) {\n\t\tfput(file);\n\t\treturn ERR_PTR(-EBADF);\n\t}\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *perf_event_fd_array_get_ptr(struct bpf_map *map,\n\t\t\t\t\t struct file *map_file, int fd)\n{\n\tstruct bpf_event_entry *ee;\n\tstruct perf_event *event;\n\tstruct file *perf_file;\n\tu64 value;\n\n\tperf_file = perf_event_get(fd);\n\tif (IS_ERR(perf_file))\n\t\treturn perf_file;\n\n\tee = ERR_PTR(-EOPNOTSUPP);\n\tevent = perf_file->private_data;\n\tif (perf_event_read_local(event, &value, NULL, NULL) == -EOPNOTSUPP)\n\t\tgoto err_out;\n\n\tee = bpf_event_entry_gen(perf_file, map_file);\n\tif (ee)\n\t\treturn ee;\n\tee = ERR_PTR(-ENOMEM);\nerr_out:\n\tfput(perf_file);\n\treturn ee;\n}"
  },
  {
    "function_name": "bpf_event_entry_free_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1151-1154",
    "snippet": "static void bpf_event_entry_free_rcu(struct bpf_event_entry *ee)\n{\n\tcall_rcu(&ee->rcu, __bpf_event_entry_free);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ee->rcu",
            "__bpf_event_entry_free"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_event_entry_free_rcu(struct bpf_event_entry *ee)\n{\n\tcall_rcu(&ee->rcu, __bpf_event_entry_free);\n}"
  },
  {
    "function_name": "__bpf_event_entry_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1142-1149",
    "snippet": "static void __bpf_event_entry_free(struct rcu_head *rcu)\n{\n\tstruct bpf_event_entry *ee;\n\n\tee = container_of(rcu, struct bpf_event_entry, rcu);\n\tfput(ee->perf_file);\n\tkfree(ee);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ee"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "ee->perf_file"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_event_entry",
            "rcu"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_event_entry_free(struct rcu_head *rcu)\n{\n\tstruct bpf_event_entry *ee;\n\n\tee = container_of(rcu, struct bpf_event_entry, rcu);\n\tfput(ee->perf_file);\n\tkfree(ee);\n}"
  },
  {
    "function_name": "bpf_event_entry_gen",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1127-1140",
    "snippet": "static struct bpf_event_entry *bpf_event_entry_gen(struct file *perf_file,\n\t\t\t\t\t\t   struct file *map_file)\n{\n\tstruct bpf_event_entry *ee;\n\n\tee = kzalloc(sizeof(*ee), GFP_ATOMIC);\n\tif (ee) {\n\t\tee->event = perf_file->private_data;\n\t\tee->perf_file = perf_file;\n\t\tee->map_file = map_file;\n\t}\n\n\treturn ee;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ee)",
            "GFP_ATOMIC"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_event_entry *bpf_event_entry_gen(struct file *perf_file,\n\t\t\t\t\t\t   struct file *map_file)\n{\n\tstruct bpf_event_entry *ee;\n\n\tee = kzalloc(sizeof(*ee), GFP_ATOMIC);\n\tif (ee) {\n\t\tee->event = perf_file->private_data;\n\t\tee->perf_file = perf_file;\n\t\tee->map_file = map_file;\n\t}\n\n\treturn ee;\n}"
  },
  {
    "function_name": "prog_array_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1088-1100",
    "snippet": "static void prog_array_map_free(struct bpf_map *map)\n{\n\tstruct prog_poke_elem *elem, *tmp;\n\tstruct bpf_array_aux *aux;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tlist_for_each_entry_safe(elem, tmp, &aux->poke_progs, list) {\n\t\tlist_del_init(&elem->list);\n\t\tkfree(elem);\n\t}\n\tkfree(aux);\n\tfd_array_map_free(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_array_map_free",
          "args": [
            "map"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_fd_array_map_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1206-1211",
          "snippet": "static void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void perf_event_fd_array_map_free(struct bpf_map *map)\n{\n\tif (map->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\tbpf_fd_array_map_clear(map);\n\tfd_array_map_free(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&elem->list"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "elem",
            "tmp",
            "&aux->poke_progs",
            "list"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_array_map_free(struct bpf_map *map)\n{\n\tstruct prog_poke_elem *elem, *tmp;\n\tstruct bpf_array_aux *aux;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tlist_for_each_entry_safe(elem, tmp, &aux->poke_progs, list) {\n\t\tlist_del_init(&elem->list);\n\t\tkfree(elem);\n\t}\n\tkfree(aux);\n\tfd_array_map_free(map);\n}"
  },
  {
    "function_name": "prog_array_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1062-1086",
    "snippet": "static struct bpf_map *prog_array_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_array_aux *aux;\n\tstruct bpf_map *map;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL_ACCOUNT);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&aux->work, prog_array_map_clear_deferred);\n\tINIT_LIST_HEAD(&aux->poke_progs);\n\tmutex_init(&aux->poke_mutex);\n\tspin_lock_init(&aux->owner.lock);\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tkfree(aux);\n\t\treturn map;\n\t}\n\n\tcontainer_of(map, struct bpf_array, map)->aux = aux;\n\taux->map = map;\n\n\treturn map;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_map_alloc",
          "args": [
            "attr"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "prog_array_map_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "1062-1086",
          "snippet": "static struct bpf_map *prog_array_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_array_aux *aux;\n\tstruct bpf_map *map;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL_ACCOUNT);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&aux->work, prog_array_map_clear_deferred);\n\tINIT_LIST_HEAD(&aux->poke_progs);\n\tmutex_init(&aux->poke_mutex);\n\tspin_lock_init(&aux->owner.lock);\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tkfree(aux);\n\t\treturn map;\n\t}\n\n\tcontainer_of(map, struct bpf_array, map)->aux = aux;\n\taux->map = map;\n\n\treturn map;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&aux->owner.lock"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&aux->poke_mutex"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&aux->poke_progs"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&aux->work",
            "prog_array_map_clear_deferred"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*aux)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *prog_array_map_alloc(union bpf_attr *attr)\n{\n\tstruct bpf_array_aux *aux;\n\tstruct bpf_map *map;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL_ACCOUNT);\n\tif (!aux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&aux->work, prog_array_map_clear_deferred);\n\tINIT_LIST_HEAD(&aux->poke_progs);\n\tmutex_init(&aux->poke_mutex);\n\tspin_lock_init(&aux->owner.lock);\n\n\tmap = array_map_alloc(attr);\n\tif (IS_ERR(map)) {\n\t\tkfree(aux);\n\t\treturn map;\n\t}\n\n\tcontainer_of(map, struct bpf_array, map)->aux = aux;\n\taux->map = map;\n\n\treturn map;\n}"
  },
  {
    "function_name": "prog_array_map_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1054-1060",
    "snippet": "static void prog_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array_aux *aux = container_of(map, struct bpf_array,\n\t\t\t\t\t\t map)->aux;\n\tbpf_map_inc(map);\n\tschedule_work(&aux->work);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&aux->work"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc",
          "args": [
            "map"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1019-1026",
          "snippet": "struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstruct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map)\n{\n\tspin_lock_bh(&map_idr_lock);\n\tmap = __bpf_map_inc_not_zero(map, false);\n\tspin_unlock_bh(&map_idr_lock);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array_aux *aux = container_of(map, struct bpf_array,\n\t\t\t\t\t\t map)->aux;\n\tbpf_map_inc(map);\n\tschedule_work(&aux->work);\n}"
  },
  {
    "function_name": "prog_array_map_clear_deferred",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "1046-1052",
    "snippet": "static void prog_array_map_clear_deferred(struct work_struct *work)\n{\n\tstruct bpf_map *map = container_of(work, struct bpf_array_aux,\n\t\t\t\t\t   work)->map;\n\tbpf_fd_array_map_clear(map);\n\tbpf_map_put(map);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_clear",
          "args": [
            "map"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "865-872",
          "snippet": "static void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_array_aux",
            "work"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_array_map_clear_deferred(struct work_struct *work)\n{\n\tstruct bpf_map *map = container_of(work, struct bpf_array_aux,\n\t\t\t\t\t   work)->map;\n\tbpf_fd_array_map_clear(map);\n\tbpf_map_put(map);\n}"
  },
  {
    "function_name": "prog_array_map_poke_run",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "953-1044",
    "snippet": "static void prog_array_map_poke_run(struct bpf_map *map, u32 key,\n\t\t\t\t    struct bpf_prog *old,\n\t\t\t\t    struct bpf_prog *new)\n{\n\tu8 *old_addr, *new_addr, *old_bypass_addr;\n\tstruct prog_poke_elem *elem;\n\tstruct bpf_array_aux *aux;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tWARN_ON_ONCE(!mutex_is_locked(&aux->poke_mutex));\n\n\tlist_for_each_entry(elem, &aux->poke_progs, list) {\n\t\tstruct bpf_jit_poke_descriptor *poke;\n\t\tint i, ret;\n\n\t\tfor (i = 0; i < elem->aux->size_poke_tab; i++) {\n\t\t\tpoke = &elem->aux->poke_tab[i];\n\n\t\t\t/* Few things to be aware of:\n\t\t\t *\n\t\t\t * 1) We can only ever access aux in this context, but\n\t\t\t *    not aux->prog since it might not be stable yet and\n\t\t\t *    there could be danger of use after free otherwise.\n\t\t\t * 2) Initially when we start tracking aux, the program\n\t\t\t *    is not JITed yet and also does not have a kallsyms\n\t\t\t *    entry. We skip these as poke->tailcall_target_stable\n\t\t\t *    is not active yet. The JIT will do the final fixup\n\t\t\t *    before setting it stable. The various\n\t\t\t *    poke->tailcall_target_stable are successively\n\t\t\t *    activated, so tail call updates can arrive from here\n\t\t\t *    while JIT is still finishing its final fixup for\n\t\t\t *    non-activated poke entries.\n\t\t\t * 3) On program teardown, the program's kallsym entry gets\n\t\t\t *    removed out of RCU callback, but we can only untrack\n\t\t\t *    from sleepable context, therefore bpf_arch_text_poke()\n\t\t\t *    might not see that this is in BPF text section and\n\t\t\t *    bails out with -EINVAL. As these are unreachable since\n\t\t\t *    RCU grace period already passed, we simply skip them.\n\t\t\t * 4) Also programs reaching refcount of zero while patching\n\t\t\t *    is in progress is okay since we're protected under\n\t\t\t *    poke_mutex and untrack the programs before the JIT\n\t\t\t *    buffer is freed. When we're still in the middle of\n\t\t\t *    patching and suddenly kallsyms entry of the program\n\t\t\t *    gets evicted, we just skip the rest which is fine due\n\t\t\t *    to point 3).\n\t\t\t * 5) Any other error happening below from bpf_arch_text_poke()\n\t\t\t *    is a unexpected bug.\n\t\t\t */\n\t\t\tif (!READ_ONCE(poke->tailcall_target_stable))\n\t\t\t\tcontinue;\n\t\t\tif (poke->reason != BPF_POKE_REASON_TAIL_CALL)\n\t\t\t\tcontinue;\n\t\t\tif (poke->tail_call.map != map ||\n\t\t\t    poke->tail_call.key != key)\n\t\t\t\tcontinue;\n\n\t\t\told_bypass_addr = old ? NULL : poke->bypass_addr;\n\t\t\told_addr = old ? (u8 *)old->bpf_func + poke->adj_off : NULL;\n\t\t\tnew_addr = new ? (u8 *)new->bpf_func + poke->adj_off : NULL;\n\n\t\t\tif (new) {\n\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_target,\n\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t old_addr, new_addr);\n\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t\tif (!old) {\n\t\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_bypass,\n\t\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t\t poke->bypass_addr,\n\t\t\t\t\t\t\t\t NULL);\n\t\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_bypass,\n\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t old_bypass_addr,\n\t\t\t\t\t\t\t poke->bypass_addr);\n\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t\t/* let other CPUs finish the execution of program\n\t\t\t\t * so that it will not possible to expose them\n\t\t\t\t * to invalid nop, stack unwind, nop state\n\t\t\t\t */\n\t\t\t\tif (!ret)\n\t\t\t\t\tsynchronize_rcu();\n\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_target,\n\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t old_addr, NULL);\n\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0 && ret != -EINVAL"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_arch_text_poke",
          "args": [
            "poke->tailcall_target",
            "BPF_MOD_JUMP",
            "old_addr",
            "NULL"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_arch_text_poke",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "2450-2454",
          "snippet": "int __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct bpf_func_proto bpf_map_lookup_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_update_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_delete_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_push_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_pop_elem_proto __weak;",
            "const struct bpf_func_proto bpf_map_peek_elem_proto __weak;",
            "const struct bpf_func_proto bpf_spin_lock_proto __weak;",
            "const struct bpf_func_proto bpf_spin_unlock_proto __weak;",
            "const struct bpf_func_proto bpf_jiffies64_proto __weak;",
            "const struct bpf_func_proto bpf_get_prandom_u32_proto __weak;",
            "const struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_numa_node_id_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;",
            "const struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_comm_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;",
            "const struct bpf_func_proto bpf_get_local_storage_proto __weak;",
            "const struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;",
            "const struct bpf_func_proto bpf_snprintf_btf_proto __weak;",
            "const struct bpf_func_proto bpf_seq_printf_btf_proto __weak;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nconst struct bpf_func_proto bpf_map_lookup_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_update_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_delete_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_push_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_pop_elem_proto __weak;\nconst struct bpf_func_proto bpf_map_peek_elem_proto __weak;\nconst struct bpf_func_proto bpf_spin_lock_proto __weak;\nconst struct bpf_func_proto bpf_spin_unlock_proto __weak;\nconst struct bpf_func_proto bpf_jiffies64_proto __weak;\nconst struct bpf_func_proto bpf_get_prandom_u32_proto __weak;\nconst struct bpf_func_proto bpf_get_smp_processor_id_proto __weak;\nconst struct bpf_func_proto bpf_get_numa_node_id_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_boot_ns_proto __weak;\nconst struct bpf_func_proto bpf_ktime_get_coarse_ns_proto __weak;\nconst struct bpf_func_proto bpf_get_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_uid_gid_proto __weak;\nconst struct bpf_func_proto bpf_get_current_comm_proto __weak;\nconst struct bpf_func_proto bpf_get_current_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_current_ancestor_cgroup_id_proto __weak;\nconst struct bpf_func_proto bpf_get_local_storage_proto __weak;\nconst struct bpf_func_proto bpf_get_ns_current_pid_tgid_proto __weak;\nconst struct bpf_func_proto bpf_snprintf_btf_proto __weak;\nconst struct bpf_func_proto bpf_seq_printf_btf_proto __weak;\n\nint __weak bpf_arch_text_poke(void *ip, enum bpf_text_poke_type t,\n\t\t\t      void *addr1, void *addr2)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0 && ret != -EINVAL"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0 && ret != -EINVAL"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0 && ret != -EINVAL"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "poke->tailcall_target_stable"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "elem",
            "&aux->poke_progs",
            "list"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!mutex_is_locked(&aux->poke_mutex)"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&aux->poke_mutex"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_is_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "86-89",
          "snippet": "bool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nbool mutex_is_locked(struct mutex *lock)\n{\n\treturn __mutex_owner(lock) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_array_map_poke_run(struct bpf_map *map, u32 key,\n\t\t\t\t    struct bpf_prog *old,\n\t\t\t\t    struct bpf_prog *new)\n{\n\tu8 *old_addr, *new_addr, *old_bypass_addr;\n\tstruct prog_poke_elem *elem;\n\tstruct bpf_array_aux *aux;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tWARN_ON_ONCE(!mutex_is_locked(&aux->poke_mutex));\n\n\tlist_for_each_entry(elem, &aux->poke_progs, list) {\n\t\tstruct bpf_jit_poke_descriptor *poke;\n\t\tint i, ret;\n\n\t\tfor (i = 0; i < elem->aux->size_poke_tab; i++) {\n\t\t\tpoke = &elem->aux->poke_tab[i];\n\n\t\t\t/* Few things to be aware of:\n\t\t\t *\n\t\t\t * 1) We can only ever access aux in this context, but\n\t\t\t *    not aux->prog since it might not be stable yet and\n\t\t\t *    there could be danger of use after free otherwise.\n\t\t\t * 2) Initially when we start tracking aux, the program\n\t\t\t *    is not JITed yet and also does not have a kallsyms\n\t\t\t *    entry. We skip these as poke->tailcall_target_stable\n\t\t\t *    is not active yet. The JIT will do the final fixup\n\t\t\t *    before setting it stable. The various\n\t\t\t *    poke->tailcall_target_stable are successively\n\t\t\t *    activated, so tail call updates can arrive from here\n\t\t\t *    while JIT is still finishing its final fixup for\n\t\t\t *    non-activated poke entries.\n\t\t\t * 3) On program teardown, the program's kallsym entry gets\n\t\t\t *    removed out of RCU callback, but we can only untrack\n\t\t\t *    from sleepable context, therefore bpf_arch_text_poke()\n\t\t\t *    might not see that this is in BPF text section and\n\t\t\t *    bails out with -EINVAL. As these are unreachable since\n\t\t\t *    RCU grace period already passed, we simply skip them.\n\t\t\t * 4) Also programs reaching refcount of zero while patching\n\t\t\t *    is in progress is okay since we're protected under\n\t\t\t *    poke_mutex and untrack the programs before the JIT\n\t\t\t *    buffer is freed. When we're still in the middle of\n\t\t\t *    patching and suddenly kallsyms entry of the program\n\t\t\t *    gets evicted, we just skip the rest which is fine due\n\t\t\t *    to point 3).\n\t\t\t * 5) Any other error happening below from bpf_arch_text_poke()\n\t\t\t *    is a unexpected bug.\n\t\t\t */\n\t\t\tif (!READ_ONCE(poke->tailcall_target_stable))\n\t\t\t\tcontinue;\n\t\t\tif (poke->reason != BPF_POKE_REASON_TAIL_CALL)\n\t\t\t\tcontinue;\n\t\t\tif (poke->tail_call.map != map ||\n\t\t\t    poke->tail_call.key != key)\n\t\t\t\tcontinue;\n\n\t\t\told_bypass_addr = old ? NULL : poke->bypass_addr;\n\t\t\told_addr = old ? (u8 *)old->bpf_func + poke->adj_off : NULL;\n\t\t\tnew_addr = new ? (u8 *)new->bpf_func + poke->adj_off : NULL;\n\n\t\t\tif (new) {\n\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_target,\n\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t old_addr, new_addr);\n\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t\tif (!old) {\n\t\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_bypass,\n\t\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t\t poke->bypass_addr,\n\t\t\t\t\t\t\t\t NULL);\n\t\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_bypass,\n\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t old_bypass_addr,\n\t\t\t\t\t\t\t poke->bypass_addr);\n\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t\t/* let other CPUs finish the execution of program\n\t\t\t\t * so that it will not possible to expose them\n\t\t\t\t * to invalid nop, stack unwind, nop state\n\t\t\t\t */\n\t\t\t\tif (!ret)\n\t\t\t\t\tsynchronize_rcu();\n\t\t\t\tret = bpf_arch_text_poke(poke->tailcall_target,\n\t\t\t\t\t\t\t BPF_MOD_JUMP,\n\t\t\t\t\t\t\t old_addr, NULL);\n\t\t\t\tBUG_ON(ret < 0 && ret != -EINVAL);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "prog_array_map_poke_untrack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "935-951",
    "snippet": "static void prog_array_map_poke_untrack(struct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog_aux *prog_aux)\n{\n\tstruct prog_poke_elem *elem, *tmp;\n\tstruct bpf_array_aux *aux;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tmutex_lock(&aux->poke_mutex);\n\tlist_for_each_entry_safe(elem, tmp, &aux->poke_progs, list) {\n\t\tif (elem->aux == prog_aux) {\n\t\t\tlist_del_init(&elem->list);\n\t\t\tkfree(elem);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&aux->poke_mutex);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&aux->poke_mutex"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elem"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&elem->list"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "elem",
            "tmp",
            "&aux->poke_progs",
            "list"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&aux->poke_mutex"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_array_map_poke_untrack(struct bpf_map *map,\n\t\t\t\t\tstruct bpf_prog_aux *prog_aux)\n{\n\tstruct prog_poke_elem *elem, *tmp;\n\tstruct bpf_array_aux *aux;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tmutex_lock(&aux->poke_mutex);\n\tlist_for_each_entry_safe(elem, tmp, &aux->poke_progs, list) {\n\t\tif (elem->aux == prog_aux) {\n\t\t\tlist_del_init(&elem->list);\n\t\t\tkfree(elem);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&aux->poke_mutex);\n}"
  },
  {
    "function_name": "prog_array_map_poke_track",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "902-933",
    "snippet": "static int prog_array_map_poke_track(struct bpf_map *map,\n\t\t\t\t     struct bpf_prog_aux *prog_aux)\n{\n\tstruct prog_poke_elem *elem;\n\tstruct bpf_array_aux *aux;\n\tint ret = 0;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tmutex_lock(&aux->poke_mutex);\n\tlist_for_each_entry(elem, &aux->poke_progs, list) {\n\t\tif (elem->aux == prog_aux)\n\t\t\tgoto out;\n\t}\n\n\telem = kmalloc(sizeof(*elem), GFP_KERNEL);\n\tif (!elem) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&elem->list);\n\t/* We must track the program's aux info at this point in time\n\t * since the program pointer itself may not be stable yet, see\n\t * also comment in prog_array_map_poke_run().\n\t */\n\telem->aux = prog_aux;\n\n\tlist_add_tail(&elem->list, &aux->poke_progs);\nout:\n\tmutex_unlock(&aux->poke_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&aux->poke_mutex"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&elem->list",
            "&aux->poke_progs"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&elem->list"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*elem)",
            "GFP_KERNEL"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "elem",
            "&aux->poke_progs",
            "list"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&aux->poke_mutex"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int prog_array_map_poke_track(struct bpf_map *map,\n\t\t\t\t     struct bpf_prog_aux *prog_aux)\n{\n\tstruct prog_poke_elem *elem;\n\tstruct bpf_array_aux *aux;\n\tint ret = 0;\n\n\taux = container_of(map, struct bpf_array, map)->aux;\n\tmutex_lock(&aux->poke_mutex);\n\tlist_for_each_entry(elem, &aux->poke_progs, list) {\n\t\tif (elem->aux == prog_aux)\n\t\t\tgoto out;\n\t}\n\n\telem = kmalloc(sizeof(*elem), GFP_KERNEL);\n\tif (!elem) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&elem->list);\n\t/* We must track the program's aux info at this point in time\n\t * since the program pointer itself may not be stable yet, see\n\t * also comment in prog_array_map_poke_run().\n\t */\n\telem->aux = prog_aux;\n\n\tlist_add_tail(&elem->list, &aux->poke_progs);\nout:\n\tmutex_unlock(&aux->poke_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "prog_array_map_seq_show_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "874-895",
    "snippet": "static void prog_array_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t struct seq_file *m)\n{\n\tvoid **elem, *ptr;\n\tu32 prog_id;\n\n\trcu_read_lock();\n\n\telem = array_map_lookup_elem(map, key);\n\tif (elem) {\n\t\tptr = READ_ONCE(*elem);\n\t\tif (ptr) {\n\t\t\tseq_printf(m, \"%u: \", *(u32 *)key);\n\t\t\tprog_id = prog_fd_array_sys_lookup_elem(ptr);\n\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t\t  &prog_id, m);\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "map->btf",
            "map->btf_value_type_id",
            "&prog_id",
            "m"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5958-5964",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog_fd_array_sys_lookup_elem",
          "args": [
            "ptr"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "prog_fd_array_sys_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "859-862",
          "snippet": "static u32 prog_fd_array_sys_lookup_elem(void *ptr)\n{\n\treturn ((struct bpf_prog *)ptr)->aux->id;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 prog_fd_array_sys_lookup_elem(void *ptr)\n{\n\treturn ((struct bpf_prog *)ptr)->aux->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%u: \"",
            "*(u32 *)key"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*elem"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "753-756",
          "snippet": "static void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_array_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t struct seq_file *m)\n{\n\tvoid **elem, *ptr;\n\tu32 prog_id;\n\n\trcu_read_lock();\n\n\telem = array_map_lookup_elem(map, key);\n\tif (elem) {\n\t\tptr = READ_ONCE(*elem);\n\t\tif (ptr) {\n\t\t\tseq_printf(m, \"%u: \", *(u32 *)key);\n\t\t\tprog_id = prog_fd_array_sys_lookup_elem(ptr);\n\t\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t\t  &prog_id, m);\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "bpf_fd_array_map_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "865-872",
    "snippet": "static void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_array_map_delete_elem",
          "args": [
            "map",
            "&i"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_delete_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "811-835",
          "snippet": "static int fd_array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *old_ptr;\n\tu32 index = *(u32 *)key;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, NULL);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t}\n\n\tif (old_ptr) {\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *old_ptr;\n\tu32 index = *(u32 *)key;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, NULL);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t}\n\n\tif (old_ptr) {\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_fd_array_map_clear(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tfd_array_map_delete_elem(map, &i);\n}"
  },
  {
    "function_name": "prog_fd_array_sys_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "859-862",
    "snippet": "static u32 prog_fd_array_sys_lookup_elem(void *ptr)\n{\n\treturn ((struct bpf_prog *)ptr)->aux->id;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic u32 prog_fd_array_sys_lookup_elem(void *ptr)\n{\n\treturn ((struct bpf_prog *)ptr)->aux->id;\n}"
  },
  {
    "function_name": "prog_fd_array_put_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "854-857",
    "snippet": "static void prog_fd_array_put_ptr(void *ptr)\n{\n\tbpf_prog_put(ptr);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "ptr"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void prog_fd_array_put_ptr(void *ptr)\n{\n\tbpf_prog_put(ptr);\n}"
  },
  {
    "function_name": "prog_fd_array_get_ptr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "837-852",
    "snippet": "static void *prog_fd_array_get_ptr(struct bpf_map *map,\n\t\t\t\t   struct file *map_file, int fd)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tstruct bpf_prog *prog = bpf_prog_get(fd);\n\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tif (!bpf_prog_array_compatible(array, prog)) {\n\t\tbpf_prog_put(prog);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn prog;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_array_compatible",
          "args": [
            "array",
            "prog"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_compatible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/core.c",
          "lines": "1832-1855",
          "snippet": "bool bpf_prog_array_compatible(struct bpf_array *array,\n\t\t\t       const struct bpf_prog *fp)\n{\n\tbool ret;\n\n\tif (fp->kprobe_override)\n\t\treturn false;\n\n\tspin_lock(&array->aux->owner.lock);\n\n\tif (!array->aux->owner.type) {\n\t\t/* There's no owner yet where we could check for\n\t\t * compatibility.\n\t\t */\n\t\tarray->aux->owner.type  = fp->type;\n\t\tarray->aux->owner.jited = fp->jited;\n\t\tret = true;\n\t} else {\n\t\tret = array->aux->owner.type  == fp->type &&\n\t\t      array->aux->owner.jited == fp->jited;\n\t}\n\tspin_unlock(&array->aux->owner.lock);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/barrier.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/log2.h>",
            "#include <linux/extable.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/objtool.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <asm/barrier.h>\n#include <linux/bpf_verifier.h>\n#include <linux/log2.h>\n#include <linux/extable.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/objtool.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n#include <uapi/linux/btf.h>\n\nbool bpf_prog_array_compatible(struct bpf_array *array,\n\t\t\t       const struct bpf_prog *fp)\n{\n\tbool ret;\n\n\tif (fp->kprobe_override)\n\t\treturn false;\n\n\tspin_lock(&array->aux->owner.lock);\n\n\tif (!array->aux->owner.type) {\n\t\t/* There's no owner yet where we could check for\n\t\t * compatibility.\n\t\t */\n\t\tarray->aux->owner.type  = fp->type;\n\t\tarray->aux->owner.jited = fp->jited;\n\t\tret = true;\n\t} else {\n\t\tret = array->aux->owner.type  == fp->type &&\n\t\t      array->aux->owner.jited == fp->jited;\n\t}\n\tspin_unlock(&array->aux->owner.lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "fd"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *prog_fd_array_get_ptr(struct bpf_map *map,\n\t\t\t\t   struct file *map_file, int fd)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tstruct bpf_prog *prog = bpf_prog_get(fd);\n\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tif (!bpf_prog_array_compatible(array, prog)) {\n\t\tbpf_prog_put(prog);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn prog;\n}"
  },
  {
    "function_name": "fd_array_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "811-835",
    "snippet": "static int fd_array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *old_ptr;\n\tu32 index = *(u32 *)key;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, NULL);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t}\n\n\tif (old_ptr) {\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_fd_put_ptr",
          "args": [
            "old_ptr"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "array->ptrs + index",
            "NULL"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&array->aux->poke_mutex"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_poke_run",
          "args": [
            "map",
            "index",
            "old_ptr",
            "NULL"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&array->aux->poke_mutex"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *old_ptr;\n\tu32 index = *(u32 *)key;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, NULL);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, NULL);\n\t}\n\n\tif (old_ptr) {\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\t\treturn 0;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n}"
  },
  {
    "function_name": "bpf_fd_array_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "779-809",
    "snippet": "int bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *new_ptr, *old_ptr;\n\tu32 index = *(u32 *)key, ufd;\n\n\tif (map_flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tufd = *(u32 *)value;\n\tnew_ptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(new_ptr))\n\t\treturn PTR_ERR(new_ptr);\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, new_ptr);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t}\n\n\tif (old_ptr)\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_fd_put_ptr",
          "args": [
            "old_ptr"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "array->ptrs + index",
            "new_ptr"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&array->aux->poke_mutex"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_poke_run",
          "args": [
            "map",
            "index",
            "old_ptr",
            "new_ptr"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&array->aux->poke_mutex"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_ptr"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_ptr"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_fd_get_ptr",
          "args": [
            "map",
            "map_file",
            "ufd"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *new_ptr, *old_ptr;\n\tu32 index = *(u32 *)key, ufd;\n\n\tif (map_flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tufd = *(u32 *)value;\n\tnew_ptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(new_ptr))\n\t\treturn PTR_ERR(new_ptr);\n\n\tif (map->ops->map_poke_run) {\n\t\tmutex_lock(&array->aux->poke_mutex);\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t\tmap->ops->map_poke_run(map, index, old_ptr, new_ptr);\n\t\tmutex_unlock(&array->aux->poke_mutex);\n\t} else {\n\t\told_ptr = xchg(array->ptrs + index, new_ptr);\n\t}\n\n\tif (old_ptr)\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_fd_array_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "759-776",
    "snippet": "int bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **elem, *ptr;\n\tint ret =  0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\telem = array_map_lookup_elem(map, key);\n\tif (elem && (ptr = READ_ONCE(*elem)))\n\t\t*value = map->ops->map_fd_sys_lookup_elem(ptr);\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_fd_sys_lookup_elem",
          "args": [
            "ptr"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*elem"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "753-756",
          "snippet": "static void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **elem, *ptr;\n\tint ret =  0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\telem = array_map_lookup_elem(map, key);\n\tif (elem && (ptr = READ_ONCE(*elem)))\n\t\t*value = map->ops->map_fd_sys_lookup_elem(ptr);\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fd_array_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "753-756",
    "snippet": "static void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
  },
  {
    "function_name": "fd_array_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "741-751",
    "snippet": "static void fd_array_map_free(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\t/* make sure it's empty */\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tBUG_ON(array->ptrs[i] != NULL);\n\n\tbpf_map_area_free(array);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "array"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "array->ptrs[i] != NULL"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void fd_array_map_free(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\t/* make sure it's empty */\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tBUG_ON(array->ptrs[i] != NULL);\n\n\tbpf_map_area_free(array);\n}"
  },
  {
    "function_name": "fd_array_map_alloc_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "730-739",
    "snippet": "static int fd_array_map_alloc_check(union bpf_attr *attr)\n{\n\t/* only file descriptors can be stored in this type of map */\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\t/* Program read-only/write-only not supported for special maps yet. */\n\tif (attr->map_flags & (BPF_F_RDONLY_PROG | BPF_F_WRONLY_PROG))\n\t\treturn -EINVAL;\n\treturn array_map_alloc_check(attr);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_map_alloc_check",
          "args": [
            "attr"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_alloc_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "730-739",
          "snippet": "static int fd_array_map_alloc_check(union bpf_attr *attr)\n{\n\t/* only file descriptors can be stored in this type of map */\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\t/* Program read-only/write-only not supported for special maps yet. */\n\tif (attr->map_flags & (BPF_F_RDONLY_PROG | BPF_F_WRONLY_PROG))\n\t\treturn -EINVAL;\n\treturn array_map_alloc_check(attr);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int fd_array_map_alloc_check(union bpf_attr *attr)\n{\n\t/* only file descriptors can be stored in this type of map */\n\tif (attr->value_size != sizeof(u32))\n\t\treturn -EINVAL;\n\t/* Program read-only/write-only not supported for special maps yet. */\n\tif (attr->map_flags & (BPF_F_RDONLY_PROG | BPF_F_WRONLY_PROG))\n\t\treturn -EINVAL;\n\treturn array_map_alloc_check(attr);\n}"
  },
  {
    "function_name": "bpf_for_each_array_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "648-681",
    "snippet": "static int bpf_for_each_array_elem(struct bpf_map *map, bpf_callback_t callback_fn,\n\t\t\t\t   void *callback_ctx, u64 flags)\n{\n\tu32 i, key, num_elems = 0;\n\tstruct bpf_array *array;\n\tbool is_percpu;\n\tu64 ret = 0;\n\tvoid *val;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\tis_percpu = map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY;\n\tarray = container_of(map, struct bpf_array, map);\n\tif (is_percpu)\n\t\tmigrate_disable();\n\tfor (i = 0; i < map->max_entries; i++) {\n\t\tif (is_percpu)\n\t\t\tval = this_cpu_ptr(array->pptrs[i]);\n\t\telse\n\t\t\tval = array->value + array->elem_size * i;\n\t\tnum_elems++;\n\t\tkey = i;\n\t\tret = callback_fn((u64)(long)map, (u64)(long)&key,\n\t\t\t\t  (u64)(long)val, (u64)(long)callback_ctx, 0);\n\t\t/* return value: 0 - continue, 1 - stop and return */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_percpu)\n\t\tmigrate_enable();\n\treturn num_elems;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "migrate_enable",
          "args": [],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2178-2206",
          "snippet": "void migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_enable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled > 1) {\n\t\tp->migration_disabled--;\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(!p->migration_disabled))\n\t\treturn;\n\n\t/*\n\t * Ensure stop_task runs either before or after this, and that\n\t * __set_cpus_allowed_ptr(SCA_MIGRATE_ENABLE) doesn't schedule().\n\t */\n\tpreempt_disable();\n\tif (p->cpus_ptr != &p->cpus_mask)\n\t\t__set_cpus_allowed_ptr(p, &p->cpus_mask, SCA_MIGRATE_ENABLE);\n\t/*\n\t * Mustn't clear migration_disabled() until cpus_ptr points back at the\n\t * regular cpus_mask, otherwise things that race (eg.\n\t * select_fallback_rq) get confused.\n\t */\n\tbarrier();\n\tp->migration_disabled = 0;\n\tthis_rq()->nr_pinned--;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "callback_fn",
          "args": [
            "(u64)(long)map",
            "(u64)(long)&key",
            "(u64)(long)val",
            "(u64)(long)callback_ctx",
            "0"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "long"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "array->pptrs[i]"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "migrate_disable",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2162-2175",
          "snippet": "void migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid migrate_disable(void)\n{\n\tstruct task_struct *p = current;\n\n\tif (p->migration_disabled) {\n\t\tp->migration_disabled++;\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tthis_rq()->nr_pinned++;\n\tp->migration_disabled = 1;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_for_each_array_elem(struct bpf_map *map, bpf_callback_t callback_fn,\n\t\t\t\t   void *callback_ctx, u64 flags)\n{\n\tu32 i, key, num_elems = 0;\n\tstruct bpf_array *array;\n\tbool is_percpu;\n\tu64 ret = 0;\n\tvoid *val;\n\n\tif (flags != 0)\n\t\treturn -EINVAL;\n\n\tis_percpu = map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY;\n\tarray = container_of(map, struct bpf_array, map);\n\tif (is_percpu)\n\t\tmigrate_disable();\n\tfor (i = 0; i < map->max_entries; i++) {\n\t\tif (is_percpu)\n\t\t\tval = this_cpu_ptr(array->pptrs[i]);\n\t\telse\n\t\t\tval = array->value + array->elem_size * i;\n\t\tnum_elems++;\n\t\tkey = i;\n\t\tret = callback_fn((u64)(long)map, (u64)(long)&key,\n\t\t\t\t  (u64)(long)val, (u64)(long)callback_ctx, 0);\n\t\t/* return value: 0 - continue, 1 - stop and return */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (is_percpu)\n\t\tmigrate_enable();\n\treturn num_elems;\n}"
  },
  {
    "function_name": "bpf_iter_fini_array_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "627-632",
    "snippet": "static void bpf_iter_fini_array_map(void *priv_data)\n{\n\tstruct bpf_iter_seq_array_map_info *seq_info = priv_data;\n\n\tkfree(seq_info->percpu_value_buf);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "seq_info->percpu_value_buf"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_iter_fini_array_map(void *priv_data)\n{\n\tstruct bpf_iter_seq_array_map_info *seq_info = priv_data;\n\n\tkfree(seq_info->percpu_value_buf);\n}"
  },
  {
    "function_name": "bpf_iter_init_array_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "606-625",
    "snippet": "static int bpf_iter_init_array_map(void *priv_data,\n\t\t\t\t   struct bpf_iter_aux_info *aux)\n{\n\tstruct bpf_iter_seq_array_map_info *seq_info = priv_data;\n\tstruct bpf_map *map = aux->map;\n\tvoid *value_buf;\n\tu32 buf_size;\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\tbuf_size = round_up(map->value_size, 8) * num_possible_cpus();\n\t\tvalue_buf = kmalloc(buf_size, GFP_USER | __GFP_NOWARN);\n\t\tif (!value_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tseq_info->percpu_value_buf = value_buf;\n\t}\n\n\tseq_info->map = map;\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "buf_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_iter_init_array_map(void *priv_data,\n\t\t\t\t   struct bpf_iter_aux_info *aux)\n{\n\tstruct bpf_iter_seq_array_map_info *seq_info = priv_data;\n\tstruct bpf_map *map = aux->map;\n\tvoid *value_buf;\n\tu32 buf_size;\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\tbuf_size = round_up(map->value_size, 8) * num_possible_cpus();\n\t\tvalue_buf = kmalloc(buf_size, GFP_USER | __GFP_NOWARN);\n\t\tif (!value_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tseq_info->percpu_value_buf = value_buf;\n\t}\n\n\tseq_info->map = map;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_array_map_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "600-604",
    "snippet": "static void bpf_array_map_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!v)\n\t\t(void)__bpf_array_map_seq_show(seq, NULL);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_array_map_seq_show",
          "args": [
            "seq",
            "NULL"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_array_map_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "556-593",
          "snippet": "static int __bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_iter__bpf_map_elem ctx = {};\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint off = 0, cpu = 0;\n\tvoid __percpu **pptr;\n\tu32 size;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, v == NULL);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.map = info->map;\n\tif (v) {\n\t\tctx.key = &info->index;\n\n\t\tif (!info->percpu_value_buf) {\n\t\t\tctx.value = v;\n\t\t} else {\n\t\t\tpptr = v;\n\t\t\tsize = round_up(map->value_size, 8);\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tbpf_long_memcpy(info->percpu_value_buf + off,\n\t\t\t\t\t\tper_cpu_ptr(pptr, cpu),\n\t\t\t\t\t\tsize);\n\t\t\t\toff += size;\n\t\t\t}\n\t\t\tctx.value = info->percpu_value_buf;\n\t\t}\n\t}\n\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_iter__bpf_map_elem ctx = {};\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint off = 0, cpu = 0;\n\tvoid __percpu **pptr;\n\tu32 size;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, v == NULL);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.map = info->map;\n\tif (v) {\n\t\tctx.key = &info->index;\n\n\t\tif (!info->percpu_value_buf) {\n\t\t\tctx.value = v;\n\t\t} else {\n\t\t\tpptr = v;\n\t\t\tsize = round_up(map->value_size, 8);\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tbpf_long_memcpy(info->percpu_value_buf + off,\n\t\t\t\t\t\tper_cpu_ptr(pptr, cpu),\n\t\t\t\t\t\tsize);\n\t\t\t\toff += size;\n\t\t\t}\n\t\t\tctx.value = info->percpu_value_buf;\n\t\t}\n\t}\n\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_map_seq_stop(struct seq_file *seq, void *v)\n{\n\tif (!v)\n\t\t(void)__bpf_array_map_seq_show(seq, NULL);\n}"
  },
  {
    "function_name": "bpf_array_map_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "595-598",
    "snippet": "static int bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __bpf_array_map_seq_show(seq, v);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_array_map_seq_show",
          "args": [
            "seq",
            "v"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_array_map_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "556-593",
          "snippet": "static int __bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_iter__bpf_map_elem ctx = {};\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint off = 0, cpu = 0;\n\tvoid __percpu **pptr;\n\tu32 size;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, v == NULL);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.map = info->map;\n\tif (v) {\n\t\tctx.key = &info->index;\n\n\t\tif (!info->percpu_value_buf) {\n\t\t\tctx.value = v;\n\t\t} else {\n\t\t\tpptr = v;\n\t\t\tsize = round_up(map->value_size, 8);\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tbpf_long_memcpy(info->percpu_value_buf + off,\n\t\t\t\t\t\tper_cpu_ptr(pptr, cpu),\n\t\t\t\t\t\tsize);\n\t\t\t\toff += size;\n\t\t\t}\n\t\t\tctx.value = info->percpu_value_buf;\n\t\t}\n\t}\n\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_iter__bpf_map_elem ctx = {};\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint off = 0, cpu = 0;\n\tvoid __percpu **pptr;\n\tu32 size;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, v == NULL);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.map = info->map;\n\tif (v) {\n\t\tctx.key = &info->index;\n\n\t\tif (!info->percpu_value_buf) {\n\t\t\tctx.value = v;\n\t\t} else {\n\t\t\tpptr = v;\n\t\t\tsize = round_up(map->value_size, 8);\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tbpf_long_memcpy(info->percpu_value_buf + off,\n\t\t\t\t\t\tper_cpu_ptr(pptr, cpu),\n\t\t\t\t\t\tsize);\n\t\t\t\toff += size;\n\t\t\t}\n\t\t\tctx.value = info->percpu_value_buf;\n\t\t}\n\t}\n\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\treturn __bpf_array_map_seq_show(seq, v);\n}"
  },
  {
    "function_name": "__bpf_array_map_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "556-593",
    "snippet": "static int __bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_iter__bpf_map_elem ctx = {};\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint off = 0, cpu = 0;\n\tvoid __percpu **pptr;\n\tu32 size;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, v == NULL);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.map = info->map;\n\tif (v) {\n\t\tctx.key = &info->index;\n\n\t\tif (!info->percpu_value_buf) {\n\t\t\tctx.value = v;\n\t\t} else {\n\t\t\tpptr = v;\n\t\t\tsize = round_up(map->value_size, 8);\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tbpf_long_memcpy(info->percpu_value_buf + off,\n\t\t\t\t\t\tper_cpu_ptr(pptr, cpu),\n\t\t\t\t\t\tsize);\n\t\t\t\toff += size;\n\t\t\t}\n\t\t\tctx.value = info->percpu_value_buf;\n\t\t}\n\t}\n\n\treturn bpf_iter_run_prog(prog, &ctx);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_iter_run_prog",
          "args": [
            "prog",
            "&ctx"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_run_prog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "683-700",
          "snippet": "int bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nint bpf_iter_run_prog(struct bpf_prog *prog, void *ctx)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tmigrate_disable();\n\tret = bpf_prog_run(prog, ctx);\n\tmigrate_enable();\n\trcu_read_unlock();\n\n\t/* bpf program can only return 0 or 1:\n\t *  0 : okay\n\t *  1 : retry the same object\n\t * The bpf_iter_run_prog() return value\n\t * will be seq_ops->show() return value.\n\t */\n\treturn ret == 0 ? 0 : -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "info->percpu_value_buf + off",
            "per_cpu_ptr(pptr, cpu)",
            "size"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_iter_get_info",
          "args": [
            "&meta",
            "v == NULL"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_get_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "660-681",
          "snippet": "struct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic64_t session_id;",
            "const struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic atomic64_t session_id;\nconst struct file_operations bpf_iter_fops = {\n\t.open\t\t= iter_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= bpf_seq_read,\n\t.release\t= iter_release,\n};\n\nstruct bpf_prog *bpf_iter_get_info(struct bpf_iter_meta *meta, bool in_stop)\n{\n\tstruct bpf_iter_priv_data *iter_priv;\n\tstruct seq_file *seq;\n\tvoid *seq_priv;\n\n\tseq = meta->seq;\n\tif (seq->file->f_op != &bpf_iter_fops)\n\t\treturn NULL;\n\n\tseq_priv = seq->private;\n\titer_priv = container_of(seq_priv, struct bpf_iter_priv_data,\n\t\t\t\t target_private);\n\n\tif (in_stop && iter_priv->done_stop)\n\t\treturn NULL;\n\n\tmeta->session_id = iter_priv->session_id;\n\tmeta->seq_num = iter_priv->seq_num;\n\n\treturn iter_priv->prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int __bpf_array_map_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_iter__bpf_map_elem ctx = {};\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_iter_meta meta;\n\tstruct bpf_prog *prog;\n\tint off = 0, cpu = 0;\n\tvoid __percpu **pptr;\n\tu32 size;\n\n\tmeta.seq = seq;\n\tprog = bpf_iter_get_info(&meta, v == NULL);\n\tif (!prog)\n\t\treturn 0;\n\n\tctx.meta = &meta;\n\tctx.map = info->map;\n\tif (v) {\n\t\tctx.key = &info->index;\n\n\t\tif (!info->percpu_value_buf) {\n\t\t\tctx.value = v;\n\t\t} else {\n\t\t\tpptr = v;\n\t\t\tsize = round_up(map->value_size, 8);\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\tbpf_long_memcpy(info->percpu_value_buf + off,\n\t\t\t\t\t\tper_cpu_ptr(pptr, cpu),\n\t\t\t\t\t\tsize);\n\t\t\t\toff += size;\n\t\t\t}\n\t\t\tctx.value = info->percpu_value_buf;\n\t\t}\n\t}\n\n\treturn bpf_iter_run_prog(prog, &ctx);\n}"
  },
  {
    "function_name": "bpf_array_map_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "537-554",
    "snippet": "static void *bpf_array_map_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_array *array;\n\tu32 index;\n\n\t++*pos;\n\t++info->index;\n\tif (info->index >= map->max_entries)\n\t\treturn NULL;\n\n\tarray = container_of(map, struct bpf_array, map);\n\tindex = info->index & array->index_mask;\n\tif (info->percpu_value_buf)\n\t       return array->pptrs[index];\n\treturn array->value + array->elem_size * index;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *bpf_array_map_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_array *array;\n\tu32 index;\n\n\t++*pos;\n\t++info->index;\n\tif (info->index >= map->max_entries)\n\t\treturn NULL;\n\n\tarray = container_of(map, struct bpf_array, map);\n\tindex = info->index & array->index_mask;\n\tif (info->percpu_value_buf)\n\t       return array->pptrs[index];\n\treturn array->value + array->elem_size * index;\n}"
  },
  {
    "function_name": "bpf_array_map_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "518-535",
    "snippet": "static void *bpf_array_map_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_array *array;\n\tu32 index;\n\n\tif (info->index >= map->max_entries)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\t++*pos;\n\tarray = container_of(map, struct bpf_array, map);\n\tindex = info->index & array->index_mask;\n\tif (info->percpu_value_buf)\n\t       return array->pptrs[index];\n\treturn array->value + array->elem_size * index;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *bpf_array_map_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\tstruct bpf_iter_seq_array_map_info *info = seq->private;\n\tstruct bpf_map *map = info->map;\n\tstruct bpf_array *array;\n\tu32 index;\n\n\tif (info->index >= map->max_entries)\n\t\treturn NULL;\n\n\tif (*pos == 0)\n\t\t++*pos;\n\tarray = container_of(map, struct bpf_array, map);\n\tindex = info->index & array->index_mask;\n\tif (info->percpu_value_buf)\n\t       return array->pptrs[index];\n\treturn array->value + array->elem_size * index;\n}"
  },
  {
    "function_name": "array_map_meta_equal",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "503-510",
    "snippet": "static bool array_map_meta_equal(const struct bpf_map *meta0,\n\t\t\t\t const struct bpf_map *meta1)\n{\n\tif (!bpf_map_meta_equal(meta0, meta1))\n\t\treturn false;\n\treturn meta0->map_flags & BPF_F_INNER_MAP ? true :\n\t       meta0->max_entries == meta1->max_entries;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_meta_equal",
          "args": [
            "meta0",
            "meta1"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_meta_equal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/map_in_map.c",
          "lines": "78-87",
          "snippet": "bool bpf_map_meta_equal(const struct bpf_map *meta0,\n\t\t\tconst struct bpf_map *meta1)\n{\n\t/* No need to compare ops because it is covered by map_type */\n\treturn meta0->map_type == meta1->map_type &&\n\t\tmeta0->key_size == meta1->key_size &&\n\t\tmeta0->value_size == meta1->value_size &&\n\t\tmeta0->timer_off == meta1->timer_off &&\n\t\tmeta0->map_flags == meta1->map_flags;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n\nbool bpf_map_meta_equal(const struct bpf_map *meta0,\n\t\t\tconst struct bpf_map *meta1)\n{\n\t/* No need to compare ops because it is covered by map_type */\n\treturn meta0->map_type == meta1->map_type &&\n\t\tmeta0->key_size == meta1->key_size &&\n\t\tmeta0->value_size == meta1->value_size &&\n\t\tmeta0->timer_off == meta1->timer_off &&\n\t\tmeta0->map_flags == meta1->map_flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic bool array_map_meta_equal(const struct bpf_map *meta0,\n\t\t\t\t const struct bpf_map *meta1)\n{\n\tif (!bpf_map_meta_equal(meta0, meta1))\n\t\treturn false;\n\treturn meta0->map_flags & BPF_F_INNER_MAP ? true :\n\t       meta0->max_entries == meta1->max_entries;\n}"
  },
  {
    "function_name": "array_map_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "487-501",
    "snippet": "static int array_map_mmap(struct bpf_map *map, struct vm_area_struct *vma)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tpgoff_t pgoff = PAGE_ALIGN(sizeof(*array)) >> PAGE_SHIFT;\n\n\tif (!(map->map_flags & BPF_F_MMAPABLE))\n\t\treturn -EINVAL;\n\n\tif (vma->vm_pgoff * PAGE_SIZE + (vma->vm_end - vma->vm_start) >\n\t    PAGE_ALIGN((u64)array->map.max_entries * array->elem_size))\n\t\treturn -EINVAL;\n\n\treturn remap_vmalloc_range(vma, array_map_vmalloc_addr(array),\n\t\t\t\t   vma->vm_pgoff + pgoff);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_vmalloc_range",
          "args": [
            "vma",
            "array_map_vmalloc_addr(array)",
            "vma->vm_pgoff + pgoff"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_map_vmalloc_addr",
          "args": [
            "array"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "(u64)array->map.max_entries * array->elem_size"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(*array)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_mmap(struct bpf_map *map, struct vm_area_struct *vma)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tpgoff_t pgoff = PAGE_ALIGN(sizeof(*array)) >> PAGE_SHIFT;\n\n\tif (!(map->map_flags & BPF_F_MMAPABLE))\n\t\treturn -EINVAL;\n\n\tif (vma->vm_pgoff * PAGE_SIZE + (vma->vm_end - vma->vm_start) >\n\t    PAGE_ALIGN((u64)array->map.max_entries * array->elem_size))\n\t\treturn -EINVAL;\n\n\treturn remap_vmalloc_range(vma, array_map_vmalloc_addr(array),\n\t\t\t\t   vma->vm_pgoff + pgoff);\n}"
  },
  {
    "function_name": "array_map_check_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "455-485",
    "snippet": "static int array_map_check_btf(const struct bpf_map *map,\n\t\t\t       const struct btf *btf,\n\t\t\t       const struct btf_type *key_type,\n\t\t\t       const struct btf_type *value_type)\n{\n\tu32 int_data;\n\n\t/* One exception for keyless BTF: .bss/.data/.rodata map */\n\tif (btf_type_is_void(key_type)) {\n\t\tif (map->map_type != BPF_MAP_TYPE_ARRAY ||\n\t\t    map->max_entries != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (BTF_INFO_KIND(value_type->info) != BTF_KIND_DATASEC)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\treturn -EINVAL;\n\n\tint_data = *(u32 *)(key_type + 1);\n\t/* bpf array can only take a u32 key. This check makes sure\n\t * that the btf matches the attr used during map_create.\n\t */\n\tif (BTF_INT_BITS(int_data) != 32 || BTF_INT_OFFSET(int_data))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INT_OFFSET",
          "args": [
            "int_data"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INT_BITS",
          "args": [
            "int_data"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "key_type->info"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "value_type->info"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_is_void",
          "args": [
            "key_type"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_is_void",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "430-433",
          "snippet": "bool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct btf_type btf_void;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic struct btf_type btf_void;\n\nbool btf_type_is_void(const struct btf_type *t)\n{\n\treturn t == &btf_void;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_check_btf(const struct bpf_map *map,\n\t\t\t       const struct btf *btf,\n\t\t\t       const struct btf_type *key_type,\n\t\t\t       const struct btf_type *value_type)\n{\n\tu32 int_data;\n\n\t/* One exception for keyless BTF: .bss/.data/.rodata map */\n\tif (btf_type_is_void(key_type)) {\n\t\tif (map->map_type != BPF_MAP_TYPE_ARRAY ||\n\t\t    map->max_entries != 1)\n\t\t\treturn -EINVAL;\n\n\t\tif (BTF_INFO_KIND(value_type->info) != BTF_KIND_DATASEC)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tif (BTF_INFO_KIND(key_type->info) != BTF_KIND_INT)\n\t\treturn -EINVAL;\n\n\tint_data = *(u32 *)(key_type + 1);\n\t/* bpf array can only take a u32 key. This check makes sure\n\t * that the btf matches the attr used during map_create.\n\t */\n\tif (BTF_INT_BITS(int_data) != 32 || BTF_INT_OFFSET(int_data))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "percpu_array_map_seq_show_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "432-453",
    "snippet": "static void percpu_array_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t   struct seq_file *m)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu;\n\n\trcu_read_lock();\n\n\tseq_printf(m, \"%u: {\\n\", *(u32 *)key);\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  per_cpu_ptr(pptr, cpu), m);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"}\\n\");\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"}\\n\""
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "map->btf",
            "map->btf_value_type_id",
            "per_cpu_ptr(pptr, cpu)",
            "m"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5958-5964",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\tcpu%d: \"",
            "cpu"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void percpu_array_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t\t   struct seq_file *m)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu;\n\n\trcu_read_lock();\n\n\tseq_printf(m, \"%u: {\\n\", *(u32 *)key);\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tseq_printf(m, \"\\tcpu%d: \", cpu);\n\t\tbtf_type_seq_show(map->btf, map->btf_value_type_id,\n\t\t\t\t  per_cpu_ptr(pptr, cpu), m);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"}\\n\");\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "array_map_seq_show_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "411-430",
    "snippet": "static void array_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t    struct seq_file *m)\n{\n\tvoid *value;\n\n\trcu_read_lock();\n\n\tvalue = array_map_lookup_elem(map, key);\n\tif (!value) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (map->btf_key_type_id)\n\t\tseq_printf(m, \"%u: \", *(u32 *)key);\n\tbtf_type_seq_show(map->btf, map->btf_value_type_id, value, m);\n\tseq_puts(m, \"\\n\");\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btf_type_seq_show",
          "args": [
            "map->btf",
            "map->btf_value_type_id",
            "value",
            "m"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_seq_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5958-5964",
          "snippet": "void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic int btf_resolve(struct btf_verifier_env *env,\n\t\t       const struct btf_type *t, u32 type_id);\n\nvoid btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,\n\t\t       struct seq_file *m)\n{\n\t(void) btf_type_seq_show_flags(btf, type_id, obj, m,\n\t\t\t\t       BTF_SHOW_NONAME | BTF_SHOW_COMPACT |\n\t\t\t\t       BTF_SHOW_ZERO | BTF_SHOW_UNSAFE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%u: \"",
            "*(u32 *)key"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "fd_array_map_lookup_elem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "753-756",
          "snippet": "static void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void array_map_seq_show_elem(struct bpf_map *map, void *key,\n\t\t\t\t    struct seq_file *m)\n{\n\tvoid *value;\n\n\trcu_read_lock();\n\n\tvalue = array_map_lookup_elem(map, key);\n\tif (!value) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (map->btf_key_type_id)\n\t\tseq_printf(m, \"%u: \", *(u32 *)key);\n\tbtf_type_seq_show(map->btf, map->btf_value_type_id, value, m);\n\tseq_puts(m, \"\\n\");\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "array_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "398-409",
    "snippet": "static void array_map_free(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\n\tif (array->map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY)\n\t\tbpf_array_free_percpu(array);\n\n\tif (array->map.map_flags & BPF_F_MMAPABLE)\n\t\tbpf_map_area_free(array_map_vmalloc_addr(array));\n\telse\n\t\tbpf_map_area_free(array);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "array"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_map_vmalloc_addr",
          "args": [
            "array"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "array_map_vmalloc_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "379-382",
          "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_array_free_percpu",
          "args": [
            "array"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void array_map_free(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\n\tif (array->map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY)\n\t\tbpf_array_free_percpu(array);\n\n\tif (array->map.map_flags & BPF_F_MMAPABLE)\n\t\tbpf_map_area_free(array_map_vmalloc_addr(array));\n\telse\n\t\tbpf_map_area_free(array);\n}"
  },
  {
    "function_name": "array_map_free_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "384-395",
    "snippet": "static void array_map_free_timers(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tif (likely(!map_value_has_timer(map)))\n\t\treturn;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tbpf_timer_cancel_and_free(array->value + array->elem_size * i +\n\t\t\t\t\t  map->timer_off);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_timer_cancel_and_free",
          "args": [
            "array->value + array->elem_size * i +\n\t\t\t\t\t  map->timer_off"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_timer_cancel_and_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "1302-1344",
          "snippet": "void bpf_timer_cancel_and_free(void *val)\n{\n\tstruct bpf_timer_kern *timer = val;\n\tstruct bpf_hrtimer *t;\n\n\t/* Performance optimization: read timer->timer without lock first. */\n\tif (!READ_ONCE(timer->timer))\n\t\treturn;\n\n\t__bpf_spin_lock_irqsave(&timer->lock);\n\t/* re-read it under lock */\n\tt = timer->timer;\n\tif (!t)\n\t\tgoto out;\n\tdrop_prog_refcnt(t);\n\t/* The subsequent bpf_timer_start/cancel() helpers won't be able to use\n\t * this timer, since it won't be initialized.\n\t */\n\ttimer->timer = NULL;\nout:\n\t__bpf_spin_unlock_irqrestore(&timer->lock);\n\tif (!t)\n\t\treturn;\n\t/* Cancel the timer and wait for callback to complete if it was running.\n\t * If hrtimer_cancel() can be safely called it's safe to call kfree(t)\n\t * right after for both preallocated and non-preallocated maps.\n\t * The timer->timer = NULL was already done and no code path can\n\t * see address 't' anymore.\n\t *\n\t * Check that bpf_map_delete/update_elem() wasn't called from timer\n\t * callback_fn. In such case don't call hrtimer_cancel() (since it will\n\t * deadlock) and don't call hrtimer_try_to_cancel() (since it will just\n\t * return -1). Though callback_fn is still running on this cpu it's\n\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed\n\t * from 't'. The bpf subprog callback_fn won't be able to access 't',\n\t * since timer->timer = NULL was already done. The timer will be\n\t * effectively cancelled because bpf_timer_cb() will return\n\t * HRTIMER_NORESTART.\n\t */\n\tif (this_cpu_read(hrtimer_running) != t)\n\t\thrtimer_cancel(&t->timer);\n\tkfree(t);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);\n\nvoid bpf_timer_cancel_and_free(void *val)\n{\n\tstruct bpf_timer_kern *timer = val;\n\tstruct bpf_hrtimer *t;\n\n\t/* Performance optimization: read timer->timer without lock first. */\n\tif (!READ_ONCE(timer->timer))\n\t\treturn;\n\n\t__bpf_spin_lock_irqsave(&timer->lock);\n\t/* re-read it under lock */\n\tt = timer->timer;\n\tif (!t)\n\t\tgoto out;\n\tdrop_prog_refcnt(t);\n\t/* The subsequent bpf_timer_start/cancel() helpers won't be able to use\n\t * this timer, since it won't be initialized.\n\t */\n\ttimer->timer = NULL;\nout:\n\t__bpf_spin_unlock_irqrestore(&timer->lock);\n\tif (!t)\n\t\treturn;\n\t/* Cancel the timer and wait for callback to complete if it was running.\n\t * If hrtimer_cancel() can be safely called it's safe to call kfree(t)\n\t * right after for both preallocated and non-preallocated maps.\n\t * The timer->timer = NULL was already done and no code path can\n\t * see address 't' anymore.\n\t *\n\t * Check that bpf_map_delete/update_elem() wasn't called from timer\n\t * callback_fn. In such case don't call hrtimer_cancel() (since it will\n\t * deadlock) and don't call hrtimer_try_to_cancel() (since it will just\n\t * return -1). Though callback_fn is still running on this cpu it's\n\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed\n\t * from 't'. The bpf subprog callback_fn won't be able to access 't',\n\t * since timer->timer = NULL was already done. The timer will be\n\t * effectively cancelled because bpf_timer_cb() will return\n\t * HRTIMER_NORESTART.\n\t */\n\tif (this_cpu_read(hrtimer_running) != t)\n\t\thrtimer_cancel(&t->timer);\n\tkfree(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!map_value_has_timer(map)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_timer",
          "args": [
            "map"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void array_map_free_timers(struct bpf_map *map)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tint i;\n\n\tif (likely(!map_value_has_timer(map)))\n\t\treturn;\n\n\tfor (i = 0; i < array->map.max_entries; i++)\n\t\tbpf_timer_cancel_and_free(array->value + array->elem_size * i +\n\t\t\t\t\t  map->timer_off);\n}"
  },
  {
    "function_name": "array_map_vmalloc_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "379-382",
    "snippet": "static void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "(unsigned long)array",
            "PAGE_SIZE"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_vmalloc_addr(struct bpf_array *array)\n{\n\treturn (void *)round_down((unsigned long)array, PAGE_SIZE);\n}"
  },
  {
    "function_name": "array_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "374-377",
    "snippet": "static int array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_percpu_array_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "335-371",
    "snippet": "int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,\n\t\t\t    u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu), value + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "per_cpu_ptr(pptr, cpu)",
            "value + off",
            "size"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags == BPF_NOEXIST"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags > BPF_EXIST"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,\n\t\t\t    u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu), value + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "array_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "297-333",
    "snippet": "static int array_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tchar *val;\n\n\tif (unlikely((map_flags & ~BPF_F_LOCK) > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags & BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\tif (unlikely((map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(map)))\n\t\treturn -EINVAL;\n\n\tif (array->map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\tmemcpy(this_cpu_ptr(array->pptrs[index & array->index_mask]),\n\t\t       value, map->value_size);\n\t} else {\n\t\tval = array->value +\n\t\t\tarray->elem_size * (index & array->index_mask);\n\t\tif (map_flags & BPF_F_LOCK)\n\t\t\tcopy_map_value_locked(map, val, value, false);\n\t\telse\n\t\t\tcopy_map_value(map, val, value);\n\t\tcheck_and_free_timer_in_array(array, val);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_and_free_timer_in_array",
          "args": [
            "array",
            "val"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_free_timer_in_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "290-294",
          "snippet": "static void check_and_free_timer_in_array(struct bpf_array *arr, void *val)\n{\n\tif (unlikely(map_value_has_timer(&arr->map)))\n\t\tbpf_timer_cancel_and_free(val + arr->map.timer_off);\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void check_and_free_timer_in_array(struct bpf_array *arr, void *val)\n{\n\tif (unlikely(map_value_has_timer(&arr->map)))\n\t\tbpf_timer_cancel_and_free(val + arr->map.timer_off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_map_value",
          "args": [
            "map",
            "val",
            "value"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_map_value_locked",
          "args": [
            "map",
            "val",
            "value",
            "false"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "copy_map_value_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "337-351",
          "snippet": "void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid copy_map_value_locked(struct bpf_map *map, void *dst, void *src,\n\t\t\t   bool lock_src)\n{\n\tstruct bpf_spin_lock *lock;\n\n\tif (lock_src)\n\t\tlock = src + map->spin_lock_off;\n\telse\n\t\tlock = dst + map->spin_lock_off;\n\tpreempt_disable();\n\t__bpf_spin_lock_irqsave(lock);\n\tcopy_map_value(map, dst, src);\n\t__bpf_spin_unlock_irqrestore(lock);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(array->pptrs[index & array->index_mask])",
            "value",
            "map->value_size"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "array->pptrs[index & array->index_mask]"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(map)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_spin_lock",
          "args": [
            "map"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_flags & BPF_NOEXIST"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(map_flags & ~BPF_F_LOCK) > BPF_EXIST"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_update_elem(struct bpf_map *map, void *key, void *value,\n\t\t\t\t u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tchar *val;\n\n\tif (unlikely((map_flags & ~BPF_F_LOCK) > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags & BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\tif (unlikely((map_flags & BPF_F_LOCK) &&\n\t\t     !map_value_has_spin_lock(map)))\n\t\treturn -EINVAL;\n\n\tif (array->map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\tmemcpy(this_cpu_ptr(array->pptrs[index & array->index_mask]),\n\t\t       value, map->value_size);\n\t} else {\n\t\tval = array->value +\n\t\t\tarray->elem_size * (index & array->index_mask);\n\t\tif (map_flags & BPF_F_LOCK)\n\t\t\tcopy_map_value_locked(map, val, value, false);\n\t\telse\n\t\t\tcopy_map_value(map, val, value);\n\t\tcheck_and_free_timer_in_array(array, val);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_and_free_timer_in_array",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "290-294",
    "snippet": "static void check_and_free_timer_in_array(struct bpf_array *arr, void *val)\n{\n\tif (unlikely(map_value_has_timer(&arr->map)))\n\t\tbpf_timer_cancel_and_free(val + arr->map.timer_off);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_timer_cancel_and_free",
          "args": [
            "val + arr->map.timer_off"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_timer_cancel_and_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "1302-1344",
          "snippet": "void bpf_timer_cancel_and_free(void *val)\n{\n\tstruct bpf_timer_kern *timer = val;\n\tstruct bpf_hrtimer *t;\n\n\t/* Performance optimization: read timer->timer without lock first. */\n\tif (!READ_ONCE(timer->timer))\n\t\treturn;\n\n\t__bpf_spin_lock_irqsave(&timer->lock);\n\t/* re-read it under lock */\n\tt = timer->timer;\n\tif (!t)\n\t\tgoto out;\n\tdrop_prog_refcnt(t);\n\t/* The subsequent bpf_timer_start/cancel() helpers won't be able to use\n\t * this timer, since it won't be initialized.\n\t */\n\ttimer->timer = NULL;\nout:\n\t__bpf_spin_unlock_irqrestore(&timer->lock);\n\tif (!t)\n\t\treturn;\n\t/* Cancel the timer and wait for callback to complete if it was running.\n\t * If hrtimer_cancel() can be safely called it's safe to call kfree(t)\n\t * right after for both preallocated and non-preallocated maps.\n\t * The timer->timer = NULL was already done and no code path can\n\t * see address 't' anymore.\n\t *\n\t * Check that bpf_map_delete/update_elem() wasn't called from timer\n\t * callback_fn. In such case don't call hrtimer_cancel() (since it will\n\t * deadlock) and don't call hrtimer_try_to_cancel() (since it will just\n\t * return -1). Though callback_fn is still running on this cpu it's\n\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed\n\t * from 't'. The bpf subprog callback_fn won't be able to access 't',\n\t * since timer->timer = NULL was already done. The timer will be\n\t * effectively cancelled because bpf_timer_cb() will return\n\t * HRTIMER_NORESTART.\n\t */\n\tif (this_cpu_read(hrtimer_running) != t)\n\t\thrtimer_cancel(&t->timer);\n\tkfree(t);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(struct bpf_hrtimer *, hrtimer_running);\n\nvoid bpf_timer_cancel_and_free(void *val)\n{\n\tstruct bpf_timer_kern *timer = val;\n\tstruct bpf_hrtimer *t;\n\n\t/* Performance optimization: read timer->timer without lock first. */\n\tif (!READ_ONCE(timer->timer))\n\t\treturn;\n\n\t__bpf_spin_lock_irqsave(&timer->lock);\n\t/* re-read it under lock */\n\tt = timer->timer;\n\tif (!t)\n\t\tgoto out;\n\tdrop_prog_refcnt(t);\n\t/* The subsequent bpf_timer_start/cancel() helpers won't be able to use\n\t * this timer, since it won't be initialized.\n\t */\n\ttimer->timer = NULL;\nout:\n\t__bpf_spin_unlock_irqrestore(&timer->lock);\n\tif (!t)\n\t\treturn;\n\t/* Cancel the timer and wait for callback to complete if it was running.\n\t * If hrtimer_cancel() can be safely called it's safe to call kfree(t)\n\t * right after for both preallocated and non-preallocated maps.\n\t * The timer->timer = NULL was already done and no code path can\n\t * see address 't' anymore.\n\t *\n\t * Check that bpf_map_delete/update_elem() wasn't called from timer\n\t * callback_fn. In such case don't call hrtimer_cancel() (since it will\n\t * deadlock) and don't call hrtimer_try_to_cancel() (since it will just\n\t * return -1). Though callback_fn is still running on this cpu it's\n\t * safe to do kfree(t) because bpf_timer_cb() read everything it needed\n\t * from 't'. The bpf subprog callback_fn won't be able to access 't',\n\t * since timer->timer = NULL was already done. The timer will be\n\t * effectively cancelled because bpf_timer_cb() will return\n\t * HRTIMER_NORESTART.\n\t */\n\tif (this_cpu_read(hrtimer_running) != t)\n\t\thrtimer_cancel(&t->timer);\n\tkfree(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "map_value_has_timer(&arr->map)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_value_has_timer",
          "args": [
            "&arr->map"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void check_and_free_timer_in_array(struct bpf_array *arr, void *val)\n{\n\tif (unlikely(map_value_has_timer(&arr->map)))\n\t\tbpf_timer_cancel_and_free(val + arr->map.timer_off);\n}"
  },
  {
    "function_name": "array_map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "272-288",
    "snippet": "static int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = (u32 *)next_key;\n\n\tif (index >= array->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == array->map.max_entries - 1)\n\t\treturn -ENOENT;\n\n\t*next = index + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = key ? *(u32 *)key : U32_MAX;\n\tu32 *next = (u32 *)next_key;\n\n\tif (index >= array->map.max_entries) {\n\t\t*next = 0;\n\t\treturn 0;\n\t}\n\n\tif (index == array->map.max_entries - 1)\n\t\treturn -ENOENT;\n\n\t*next = index + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_percpu_array_copy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "245-269",
    "snippet": "int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -ENOENT;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off, per_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_long_memcpy",
          "args": [
            "value + off",
            "per_cpu_ptr(pptr, cpu)",
            "size"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "pptr",
            "cpu"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -ENOENT;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off, per_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "percpu_array_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "234-243",
    "snippet": "static void *percpu_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn this_cpu_ptr(array->pptrs[index & array->index_mask]);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "array->pptrs[index & array->index_mask]"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *percpu_array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn this_cpu_ptr(array->pptrs[index & array->index_mask]);\n}"
  },
  {
    "function_name": "array_map_gen_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "201-231",
    "snippet": "static int array_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tstruct bpf_insn *insn = insn_buf;\n\tu32 elem_size = round_up(map->value_size, 8);\n\tconst int ret = BPF_REG_0;\n\tconst int map_ptr = BPF_REG_1;\n\tconst int index = BPF_REG_2;\n\n\tif (map->map_flags & BPF_F_INNER_MAP)\n\t\treturn -EOPNOTSUPP;\n\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, map_ptr, offsetof(struct bpf_array, value));\n\t*insn++ = BPF_LDX_MEM(BPF_W, ret, index, 0);\n\tif (!map->bypass_spec_v1) {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 4);\n\t\t*insn++ = BPF_ALU32_IMM(BPF_AND, ret, array->index_mask);\n\t} else {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 3);\n\t}\n\n\tif (is_power_of_2(elem_size)) {\n\t\t*insn++ = BPF_ALU64_IMM(BPF_LSH, ret, ilog2(elem_size));\n\t} else {\n\t\t*insn++ = BPF_ALU64_IMM(BPF_MUL, ret, elem_size);\n\t}\n\t*insn++ = BPF_ALU64_REG(BPF_ADD, ret, map_ptr);\n\t*insn++ = BPF_JMP_IMM(BPF_JA, 0, 0, 1);\n\t*insn++ = BPF_MOV64_IMM(ret, 0);\n\treturn insn - insn_buf;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BPF_MOV64_IMM",
          "args": [
            "ret",
            "0"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JA",
            "0",
            "0",
            "1"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_REG",
          "args": [
            "BPF_ADD",
            "ret",
            "map_ptr"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_MUL",
            "ret",
            "elem_size"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_LSH",
            "ret",
            "ilog2(elem_size)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "elem_size"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "elem_size"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JGE",
            "ret",
            "map->max_entries",
            "3"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU32_IMM",
          "args": [
            "BPF_AND",
            "ret",
            "array->index_mask"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_JMP_IMM",
          "args": [
            "BPF_JGE",
            "ret",
            "map->max_entries",
            "4"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_LDX_MEM",
          "args": [
            "BPF_W",
            "ret",
            "index",
            "0"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_ALU64_IMM",
          "args": [
            "BPF_ADD",
            "map_ptr",
            "offsetof(struct bpf_array, value)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_gen_lookup(struct bpf_map *map, struct bpf_insn *insn_buf)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tstruct bpf_insn *insn = insn_buf;\n\tu32 elem_size = round_up(map->value_size, 8);\n\tconst int ret = BPF_REG_0;\n\tconst int map_ptr = BPF_REG_1;\n\tconst int index = BPF_REG_2;\n\n\tif (map->map_flags & BPF_F_INNER_MAP)\n\t\treturn -EOPNOTSUPP;\n\n\t*insn++ = BPF_ALU64_IMM(BPF_ADD, map_ptr, offsetof(struct bpf_array, value));\n\t*insn++ = BPF_LDX_MEM(BPF_W, ret, index, 0);\n\tif (!map->bypass_spec_v1) {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 4);\n\t\t*insn++ = BPF_ALU32_IMM(BPF_AND, ret, array->index_mask);\n\t} else {\n\t\t*insn++ = BPF_JMP_IMM(BPF_JGE, ret, map->max_entries, 3);\n\t}\n\n\tif (is_power_of_2(elem_size)) {\n\t\t*insn++ = BPF_ALU64_IMM(BPF_LSH, ret, ilog2(elem_size));\n\t} else {\n\t\t*insn++ = BPF_ALU64_IMM(BPF_MUL, ret, elem_size);\n\t}\n\t*insn++ = BPF_ALU64_REG(BPF_ADD, ret, map_ptr);\n\t*insn++ = BPF_JMP_IMM(BPF_JA, 0, 0, 1);\n\t*insn++ = BPF_MOV64_IMM(ret, 0);\n\treturn insn - insn_buf;\n}"
  },
  {
    "function_name": "array_map_direct_value_meta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "184-198",
    "snippet": "static int array_map_direct_value_meta(const struct bpf_map *map, u64 imm,\n\t\t\t\t       u32 *off)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu64 base = (unsigned long)array->value;\n\tu64 range = array->elem_size;\n\n\tif (map->max_entries != 1)\n\t\treturn -ENOTSUPP;\n\tif (imm < base || imm >= base + range)\n\t\treturn -ENOENT;\n\n\t*off = imm - base;\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_direct_value_meta(const struct bpf_map *map, u64 imm,\n\t\t\t\t       u32 *off)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu64 base = (unsigned long)array->value;\n\tu64 range = array->elem_size;\n\n\tif (map->max_entries != 1)\n\t\treturn -ENOTSUPP;\n\tif (imm < base || imm >= base + range)\n\t\treturn -ENOENT;\n\n\t*off = imm - base;\n\treturn 0;\n}"
  },
  {
    "function_name": "array_map_direct_value_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "170-182",
    "snippet": "static int array_map_direct_value_addr(const struct bpf_map *map, u64 *imm,\n\t\t\t\t       u32 off)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\n\tif (map->max_entries != 1)\n\t\treturn -ENOTSUPP;\n\tif (off >= map->value_size)\n\t\treturn -EINVAL;\n\n\t*imm = (unsigned long)array->value;\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int array_map_direct_value_addr(const struct bpf_map *map, u64 *imm,\n\t\t\t\t       u32 off)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\n\tif (map->max_entries != 1)\n\t\treturn -ENOTSUPP;\n\tif (off >= map->value_size)\n\t\treturn -EINVAL;\n\n\t*imm = (unsigned long)array->value;\n\treturn 0;\n}"
  },
  {
    "function_name": "array_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "159-168",
    "snippet": "static void *array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn array->value + array->elem_size * (index & array->index_mask);\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= array->map.max_entries"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void *array_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn NULL;\n\n\treturn array->value + array->elem_size * (index & array->index_mask);\n}"
  },
  {
    "function_name": "array_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "81-156",
    "snippet": "static struct bpf_map *array_map_alloc(union bpf_attr *attr)\n{\n\tbool percpu = attr->map_type == BPF_MAP_TYPE_PERCPU_ARRAY;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tu32 elem_size, index_mask, max_entries;\n\tbool bypass_spec_v1 = bpf_bypass_spec_v1();\n\tu64 array_size, mask64;\n\tstruct bpf_array *array;\n\n\telem_size = round_up(attr->value_size, 8);\n\n\tmax_entries = attr->max_entries;\n\n\t/* On 32 bit archs roundup_pow_of_two() with max_entries that has\n\t * upper most bit set in u32 space is undefined behavior due to\n\t * resulting 1U << 32, so do it manually here in u64 space.\n\t */\n\tmask64 = fls_long(max_entries - 1);\n\tmask64 = 1ULL << mask64;\n\tmask64 -= 1;\n\n\tindex_mask = mask64;\n\tif (!bypass_spec_v1) {\n\t\t/* round up array size to nearest power of 2,\n\t\t * since cpu will speculate within index_mask limits\n\t\t */\n\t\tmax_entries = index_mask + 1;\n\t\t/* Check for overflows. */\n\t\tif (max_entries < attr->max_entries)\n\t\t\treturn ERR_PTR(-E2BIG);\n\t}\n\n\tarray_size = sizeof(*array);\n\tif (percpu) {\n\t\tarray_size += (u64) max_entries * sizeof(void *);\n\t} else {\n\t\t/* rely on vmalloc() to return page-aligned memory and\n\t\t * ensure array->value is exactly page-aligned\n\t\t */\n\t\tif (attr->map_flags & BPF_F_MMAPABLE) {\n\t\t\tarray_size = PAGE_ALIGN(array_size);\n\t\t\tarray_size += PAGE_ALIGN((u64) max_entries * elem_size);\n\t\t} else {\n\t\t\tarray_size += (u64) max_entries * elem_size;\n\t\t}\n\t}\n\n\t/* allocate all map elements and zero-initialize them */\n\tif (attr->map_flags & BPF_F_MMAPABLE) {\n\t\tvoid *data;\n\n\t\t/* kmalloc'ed memory can't be mmap'ed, use explicit vmalloc */\n\t\tdata = bpf_map_area_mmapable_alloc(array_size, numa_node);\n\t\tif (!data)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tarray = data + PAGE_ALIGN(sizeof(struct bpf_array))\n\t\t\t- offsetof(struct bpf_array, value);\n\t} else {\n\t\tarray = bpf_map_area_alloc(array_size, numa_node);\n\t}\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\tarray->index_mask = index_mask;\n\tarray->map.bypass_spec_v1 = bypass_spec_v1;\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\tarray->elem_size = elem_size;\n\n\tif (percpu && bpf_array_alloc_percpu(array)) {\n\t\tbpf_map_area_free(array);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &array->map;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "array"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_array_alloc_percpu",
          "args": [
            "array"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&array->map",
            "attr"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "array_size",
            "numa_node"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "sizeof(struct bpf_array)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_mmapable_alloc",
          "args": [
            "array_size",
            "numa_node"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_mmapable_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "339-342",
          "snippet": "void *bpf_map_area_mmapable_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_mmapable_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "(u64) max_entries * elem_size"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "array_size"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-E2BIG"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls_long",
          "args": [
            "max_entries - 1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "attr->value_size",
            "8"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_bypass_spec_v1",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *array_map_alloc(union bpf_attr *attr)\n{\n\tbool percpu = attr->map_type == BPF_MAP_TYPE_PERCPU_ARRAY;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tu32 elem_size, index_mask, max_entries;\n\tbool bypass_spec_v1 = bpf_bypass_spec_v1();\n\tu64 array_size, mask64;\n\tstruct bpf_array *array;\n\n\telem_size = round_up(attr->value_size, 8);\n\n\tmax_entries = attr->max_entries;\n\n\t/* On 32 bit archs roundup_pow_of_two() with max_entries that has\n\t * upper most bit set in u32 space is undefined behavior due to\n\t * resulting 1U << 32, so do it manually here in u64 space.\n\t */\n\tmask64 = fls_long(max_entries - 1);\n\tmask64 = 1ULL << mask64;\n\tmask64 -= 1;\n\n\tindex_mask = mask64;\n\tif (!bypass_spec_v1) {\n\t\t/* round up array size to nearest power of 2,\n\t\t * since cpu will speculate within index_mask limits\n\t\t */\n\t\tmax_entries = index_mask + 1;\n\t\t/* Check for overflows. */\n\t\tif (max_entries < attr->max_entries)\n\t\t\treturn ERR_PTR(-E2BIG);\n\t}\n\n\tarray_size = sizeof(*array);\n\tif (percpu) {\n\t\tarray_size += (u64) max_entries * sizeof(void *);\n\t} else {\n\t\t/* rely on vmalloc() to return page-aligned memory and\n\t\t * ensure array->value is exactly page-aligned\n\t\t */\n\t\tif (attr->map_flags & BPF_F_MMAPABLE) {\n\t\t\tarray_size = PAGE_ALIGN(array_size);\n\t\t\tarray_size += PAGE_ALIGN((u64) max_entries * elem_size);\n\t\t} else {\n\t\t\tarray_size += (u64) max_entries * elem_size;\n\t\t}\n\t}\n\n\t/* allocate all map elements and zero-initialize them */\n\tif (attr->map_flags & BPF_F_MMAPABLE) {\n\t\tvoid *data;\n\n\t\t/* kmalloc'ed memory can't be mmap'ed, use explicit vmalloc */\n\t\tdata = bpf_map_area_mmapable_alloc(array_size, numa_node);\n\t\tif (!data)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tarray = data + PAGE_ALIGN(sizeof(struct bpf_array))\n\t\t\t- offsetof(struct bpf_array, value);\n\t} else {\n\t\tarray = bpf_map_area_alloc(array_size, numa_node);\n\t}\n\tif (!array)\n\t\treturn ERR_PTR(-ENOMEM);\n\tarray->index_mask = index_mask;\n\tarray->map.bypass_spec_v1 = bypass_spec_v1;\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&array->map, attr);\n\tarray->elem_size = elem_size;\n\n\tif (percpu && bpf_array_alloc_percpu(array)) {\n\t\tbpf_map_area_free(array);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn &array->map;\n}"
  },
  {
    "function_name": "array_map_alloc_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "51-79",
    "snippet": "int array_map_alloc_check(union bpf_attr *attr)\n{\n\tbool percpu = attr->map_type == BPF_MAP_TYPE_PERCPU_ARRAY;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    attr->value_size == 0 ||\n\t    attr->map_flags & ~ARRAY_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    (percpu && numa_node != NUMA_NO_NODE))\n\t\treturn -EINVAL;\n\n\tif (attr->map_type != BPF_MAP_TYPE_ARRAY &&\n\t    attr->map_flags & (BPF_F_MMAPABLE | BPF_F_INNER_MAP))\n\t\treturn -EINVAL;\n\n\tif (attr->map_type != BPF_MAP_TYPE_PERF_EVENT_ARRAY &&\n\t    attr->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\treturn -EINVAL;\n\n\tif (attr->value_size > KMALLOC_MAX_SIZE)\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements.\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define ARRAY_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_MMAPABLE | BPF_F_ACCESS_MASK | \\\n\t BPF_F_PRESERVE_ELEMS | BPF_F_INNER_MAP)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_flags_access_ok",
          "args": [
            "attr->map_flags"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define ARRAY_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_MMAPABLE | BPF_F_ACCESS_MASK | \\\n\t BPF_F_PRESERVE_ELEMS | BPF_F_INNER_MAP)\n\nint array_map_alloc_check(union bpf_attr *attr)\n{\n\tbool percpu = attr->map_type == BPF_MAP_TYPE_PERCPU_ARRAY;\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 4 ||\n\t    attr->value_size == 0 ||\n\t    attr->map_flags & ~ARRAY_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    (percpu && numa_node != NUMA_NO_NODE))\n\t\treturn -EINVAL;\n\n\tif (attr->map_type != BPF_MAP_TYPE_ARRAY &&\n\t    attr->map_flags & (BPF_F_MMAPABLE | BPF_F_INNER_MAP))\n\t\treturn -EINVAL;\n\n\tif (attr->map_type != BPF_MAP_TYPE_PERF_EVENT_ARRAY &&\n\t    attr->map_flags & BPF_F_PRESERVE_ELEMS)\n\t\treturn -EINVAL;\n\n\tif (attr->value_size > KMALLOC_MAX_SIZE)\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements.\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_array_alloc_percpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "31-48",
    "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_array_free_percpu",
          "args": [
            "array"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_alloc_percpu",
          "args": [
            "&array->map",
            "array->elem_size",
            "8",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "452-463",
          "snippet": "void __percpu *bpf_map_alloc_percpu(const struct bpf_map *map, size_t size,\n\t\t\t\t    size_t align, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid __percpu *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = __alloc_percpu_gfp(size, align, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid __percpu *bpf_map_alloc_percpu(const struct bpf_map *map, size_t size,\n\t\t\t\t    size_t align, gfp_t flags)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid __percpu *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = __alloc_percpu_gfp(size, align, flags | __GFP_ACCOUNT);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_array_free_percpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
    "lines": "21-29",
    "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"map_in_map.h\"",
      "#include <linux/rcupdate_trace.h>",
      "#include <uapi/linux/btf.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/filter.h>",
      "#include <linux/mm.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "array->pptrs[i]"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
  }
]