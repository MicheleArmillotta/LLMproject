[
  {
    "function_name": "vdso_update_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
    "lines": "163-170",
    "snippet": "void vdso_update_end(unsigned long flags)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdso_write_end(vdata);\n\t__arch_sync_vdso_data(vdata);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include <vdso/vsyscall.h>",
      "#include <vdso/helpers.h>",
      "#include <vdso/datapage.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/hrtimer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__arch_sync_vdso_data",
          "args": [
            "vdata"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdso_write_end",
          "args": [
            "vdata"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__arch_get_k_vdso_data",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nvoid vdso_update_end(unsigned long flags)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdso_write_end(vdata);\n\t__arch_sync_vdso_data(vdata);\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n}"
  },
  {
    "function_name": "vdso_update_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
    "lines": "145-153",
    "snippet": "unsigned long vdso_update_begin(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tvdso_write_begin(vdata);\n\treturn flags;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include <vdso/vsyscall.h>",
      "#include <vdso/helpers.h>",
      "#include <vdso/datapage.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/hrtimer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vdso_write_begin",
          "args": [
            "vdata"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&timekeeper_lock",
            "flags"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__arch_get_k_vdso_data",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nunsigned long vdso_update_begin(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&timekeeper_lock, flags);\n\tvdso_write_begin(vdata);\n\treturn flags;\n}"
  },
  {
    "function_name": "update_vsyscall_tz",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
    "lines": "123-131",
    "snippet": "void update_vsyscall_tz(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdata[CS_HRES_COARSE].tz_minuteswest = sys_tz.tz_minuteswest;\n\tvdata[CS_HRES_COARSE].tz_dsttime = sys_tz.tz_dsttime;\n\n\t__arch_sync_vdso_data(vdata);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include <vdso/vsyscall.h>",
      "#include <vdso/helpers.h>",
      "#include <vdso/datapage.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/hrtimer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__arch_sync_vdso_data",
          "args": [
            "vdata"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__arch_get_k_vdso_data",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nvoid update_vsyscall_tz(void)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\n\tvdata[CS_HRES_COARSE].tz_minuteswest = sys_tz.tz_minuteswest;\n\tvdata[CS_HRES_COARSE].tz_dsttime = sys_tz.tz_dsttime;\n\n\t__arch_sync_vdso_data(vdata);\n}"
  },
  {
    "function_name": "update_vsyscall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
    "lines": "72-121",
    "snippet": "void update_vsyscall(struct timekeeper *tk)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tstruct vdso_timestamp *vdso_ts;\n\ts32 clock_mode;\n\tu64 nsec;\n\n\t/* copy vsyscall data */\n\tvdso_write_begin(vdata);\n\n\tclock_mode = tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata[CS_HRES_COARSE].clock_mode\t= clock_mode;\n\tvdata[CS_RAW].clock_mode\t\t= clock_mode;\n\n\t/* CLOCK_REALTIME also required for time() */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n\n\t/* CLOCK_REALTIME_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t/* CLOCK_MONOTONIC_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\tnsec\t\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\tnsec\t\t= nsec + tk->wall_to_monotonic.tv_nsec;\n\tvdso_ts->sec\t+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);\n\n\t/*\n\t * Read without the seqlock held by clock_getres().\n\t * Note: No need to have a second copy.\n\t */\n\tWRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);\n\n\t/*\n\t * If the current clocksource is not VDSO capable, then spare the\n\t * update of the high resolution parts.\n\t */\n\tif (clock_mode != VDSO_CLOCKMODE_NONE)\n\t\tupdate_vdso_data(vdata, tk);\n\n\t__arch_update_vsyscall(vdata, tk);\n\n\tvdso_write_end(vdata);\n\n\t__arch_sync_vdso_data(vdata);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include <vdso/vsyscall.h>",
      "#include <vdso/helpers.h>",
      "#include <vdso/datapage.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/hrtimer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__arch_sync_vdso_data",
          "args": [
            "vdata"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdso_write_end",
          "args": [
            "vdata"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__arch_update_vsyscall",
          "args": [
            "vdata",
            "tk"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_vdso_data",
          "args": [
            "vdata",
            "tk"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "update_vdso_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
          "lines": "18-70",
          "snippet": "static inline void update_vdso_data(struct vdso_data *vdata,\n\t\t\t\t    struct timekeeper *tk)\n{\n\tstruct vdso_timestamp *vdso_ts;\n\tu64 nsec, sec;\n\n\tvdata[CS_HRES_COARSE].cycle_last\t= tk->tkr_mono.cycle_last;\n\tvdata[CS_HRES_COARSE].mask\t\t= tk->tkr_mono.mask;\n\tvdata[CS_HRES_COARSE].mult\t\t= tk->tkr_mono.mult;\n\tvdata[CS_HRES_COARSE].shift\t\t= tk->tkr_mono.shift;\n\tvdata[CS_RAW].cycle_last\t\t= tk->tkr_raw.cycle_last;\n\tvdata[CS_RAW].mask\t\t\t= tk->tkr_raw.mask;\n\tvdata[CS_RAW].mult\t\t\t= tk->tkr_raw.mult;\n\tvdata[CS_RAW].shift\t\t\t= tk->tkr_raw.shift;\n\n\t/* CLOCK_MONOTONIC */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\n\tnsec = tk->tkr_mono.xtime_nsec;\n\tnsec += ((u64)tk->wall_to_monotonic.tv_nsec << tk->tkr_mono.shift);\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* Copy MONOTONIC time for BOOTTIME */\n\tsec\t= vdso_ts->sec;\n\t/* Add the boot offset */\n\tsec\t+= tk->monotonic_to_boot.tv_sec;\n\tnsec\t+= (u64)tk->monotonic_to_boot.tv_nsec << tk->tkr_mono.shift;\n\n\t/* CLOCK_BOOTTIME */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_BOOTTIME];\n\tvdso_ts->sec\t= sec;\n\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* CLOCK_MONOTONIC_RAW */\n\tvdso_ts\t\t= &vdata[CS_RAW].basetime[CLOCK_MONOTONIC_RAW];\n\tvdso_ts->sec\t= tk->raw_sec;\n\tvdso_ts->nsec\t= tk->tkr_raw.xtime_nsec;\n\n\t/* CLOCK_TAI */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_TAI];\n\tvdso_ts->sec\t= tk->xtime_sec + (s64)tk->tai_offset;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include <vdso/vsyscall.h>",
            "#include <vdso/helpers.h>",
            "#include <vdso/datapage.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nstatic inline void update_vdso_data(struct vdso_data *vdata,\n\t\t\t\t    struct timekeeper *tk)\n{\n\tstruct vdso_timestamp *vdso_ts;\n\tu64 nsec, sec;\n\n\tvdata[CS_HRES_COARSE].cycle_last\t= tk->tkr_mono.cycle_last;\n\tvdata[CS_HRES_COARSE].mask\t\t= tk->tkr_mono.mask;\n\tvdata[CS_HRES_COARSE].mult\t\t= tk->tkr_mono.mult;\n\tvdata[CS_HRES_COARSE].shift\t\t= tk->tkr_mono.shift;\n\tvdata[CS_RAW].cycle_last\t\t= tk->tkr_raw.cycle_last;\n\tvdata[CS_RAW].mask\t\t\t= tk->tkr_raw.mask;\n\tvdata[CS_RAW].mult\t\t\t= tk->tkr_raw.mult;\n\tvdata[CS_RAW].shift\t\t\t= tk->tkr_raw.shift;\n\n\t/* CLOCK_MONOTONIC */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\n\tnsec = tk->tkr_mono.xtime_nsec;\n\tnsec += ((u64)tk->wall_to_monotonic.tv_nsec << tk->tkr_mono.shift);\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* Copy MONOTONIC time for BOOTTIME */\n\tsec\t= vdso_ts->sec;\n\t/* Add the boot offset */\n\tsec\t+= tk->monotonic_to_boot.tv_sec;\n\tnsec\t+= (u64)tk->monotonic_to_boot.tv_nsec << tk->tkr_mono.shift;\n\n\t/* CLOCK_BOOTTIME */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_BOOTTIME];\n\tvdso_ts->sec\t= sec;\n\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* CLOCK_MONOTONIC_RAW */\n\tvdso_ts\t\t= &vdata[CS_RAW].basetime[CLOCK_MONOTONIC_RAW];\n\tvdso_ts->sec\t= tk->raw_sec;\n\tvdso_ts->nsec\t= tk->tkr_raw.xtime_nsec;\n\n\t/* CLOCK_TAI */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_TAI];\n\tvdso_ts->sec\t= tk->xtime_sec + (s64)tk->tai_offset;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "vdata[CS_HRES_COARSE].hrtimer_res",
            "hrtimer_resolution"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__iter_div_u64_rem",
          "args": [
            "nsec",
            "NSEC_PER_SEC",
            "&vdso_ts->nsec"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vdso_write_begin",
          "args": [
            "vdata"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__arch_get_k_vdso_data",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nvoid update_vsyscall(struct timekeeper *tk)\n{\n\tstruct vdso_data *vdata = __arch_get_k_vdso_data();\n\tstruct vdso_timestamp *vdso_ts;\n\ts32 clock_mode;\n\tu64 nsec;\n\n\t/* copy vsyscall data */\n\tvdso_write_begin(vdata);\n\n\tclock_mode = tk->tkr_mono.clock->vdso_clock_mode;\n\tvdata[CS_HRES_COARSE].clock_mode\t= clock_mode;\n\tvdata[CS_RAW].clock_mode\t\t= clock_mode;\n\n\t/* CLOCK_REALTIME also required for time() */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n\n\t/* CLOCK_REALTIME_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_REALTIME_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\n\t/* CLOCK_MONOTONIC_COARSE */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC_COARSE];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\tnsec\t\t= tk->tkr_mono.xtime_nsec >> tk->tkr_mono.shift;\n\tnsec\t\t= nsec + tk->wall_to_monotonic.tv_nsec;\n\tvdso_ts->sec\t+= __iter_div_u64_rem(nsec, NSEC_PER_SEC, &vdso_ts->nsec);\n\n\t/*\n\t * Read without the seqlock held by clock_getres().\n\t * Note: No need to have a second copy.\n\t */\n\tWRITE_ONCE(vdata[CS_HRES_COARSE].hrtimer_res, hrtimer_resolution);\n\n\t/*\n\t * If the current clocksource is not VDSO capable, then spare the\n\t * update of the high resolution parts.\n\t */\n\tif (clock_mode != VDSO_CLOCKMODE_NONE)\n\t\tupdate_vdso_data(vdata, tk);\n\n\t__arch_update_vsyscall(vdata, tk);\n\n\tvdso_write_end(vdata);\n\n\t__arch_sync_vdso_data(vdata);\n}"
  },
  {
    "function_name": "update_vdso_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/vsyscall.c",
    "lines": "18-70",
    "snippet": "static inline void update_vdso_data(struct vdso_data *vdata,\n\t\t\t\t    struct timekeeper *tk)\n{\n\tstruct vdso_timestamp *vdso_ts;\n\tu64 nsec, sec;\n\n\tvdata[CS_HRES_COARSE].cycle_last\t= tk->tkr_mono.cycle_last;\n\tvdata[CS_HRES_COARSE].mask\t\t= tk->tkr_mono.mask;\n\tvdata[CS_HRES_COARSE].mult\t\t= tk->tkr_mono.mult;\n\tvdata[CS_HRES_COARSE].shift\t\t= tk->tkr_mono.shift;\n\tvdata[CS_RAW].cycle_last\t\t= tk->tkr_raw.cycle_last;\n\tvdata[CS_RAW].mask\t\t\t= tk->tkr_raw.mask;\n\tvdata[CS_RAW].mult\t\t\t= tk->tkr_raw.mult;\n\tvdata[CS_RAW].shift\t\t\t= tk->tkr_raw.shift;\n\n\t/* CLOCK_MONOTONIC */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\n\tnsec = tk->tkr_mono.xtime_nsec;\n\tnsec += ((u64)tk->wall_to_monotonic.tv_nsec << tk->tkr_mono.shift);\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* Copy MONOTONIC time for BOOTTIME */\n\tsec\t= vdso_ts->sec;\n\t/* Add the boot offset */\n\tsec\t+= tk->monotonic_to_boot.tv_sec;\n\tnsec\t+= (u64)tk->monotonic_to_boot.tv_nsec << tk->tkr_mono.shift;\n\n\t/* CLOCK_BOOTTIME */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_BOOTTIME];\n\tvdso_ts->sec\t= sec;\n\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* CLOCK_MONOTONIC_RAW */\n\tvdso_ts\t\t= &vdata[CS_RAW].basetime[CLOCK_MONOTONIC_RAW];\n\tvdso_ts->sec\t= tk->raw_sec;\n\tvdso_ts->nsec\t= tk->tkr_raw.xtime_nsec;\n\n\t/* CLOCK_TAI */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_TAI];\n\tvdso_ts->sec\t= tk->xtime_sec + (s64)tk->tai_offset;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include <vdso/vsyscall.h>",
      "#include <vdso/helpers.h>",
      "#include <vdso/datapage.h>",
      "#include <linux/timekeeper_internal.h>",
      "#include <linux/hrtimer.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include <vdso/vsyscall.h>\n#include <vdso/helpers.h>\n#include <vdso/datapage.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/hrtimer.h>\n\nstatic inline void update_vdso_data(struct vdso_data *vdata,\n\t\t\t\t    struct timekeeper *tk)\n{\n\tstruct vdso_timestamp *vdso_ts;\n\tu64 nsec, sec;\n\n\tvdata[CS_HRES_COARSE].cycle_last\t= tk->tkr_mono.cycle_last;\n\tvdata[CS_HRES_COARSE].mask\t\t= tk->tkr_mono.mask;\n\tvdata[CS_HRES_COARSE].mult\t\t= tk->tkr_mono.mult;\n\tvdata[CS_HRES_COARSE].shift\t\t= tk->tkr_mono.shift;\n\tvdata[CS_RAW].cycle_last\t\t= tk->tkr_raw.cycle_last;\n\tvdata[CS_RAW].mask\t\t\t= tk->tkr_raw.mask;\n\tvdata[CS_RAW].mult\t\t\t= tk->tkr_raw.mult;\n\tvdata[CS_RAW].shift\t\t\t= tk->tkr_raw.shift;\n\n\t/* CLOCK_MONOTONIC */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_MONOTONIC];\n\tvdso_ts->sec\t= tk->xtime_sec + tk->wall_to_monotonic.tv_sec;\n\n\tnsec = tk->tkr_mono.xtime_nsec;\n\tnsec += ((u64)tk->wall_to_monotonic.tv_nsec << tk->tkr_mono.shift);\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* Copy MONOTONIC time for BOOTTIME */\n\tsec\t= vdso_ts->sec;\n\t/* Add the boot offset */\n\tsec\t+= tk->monotonic_to_boot.tv_sec;\n\tnsec\t+= (u64)tk->monotonic_to_boot.tv_nsec << tk->tkr_mono.shift;\n\n\t/* CLOCK_BOOTTIME */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_BOOTTIME];\n\tvdso_ts->sec\t= sec;\n\n\twhile (nsec >= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift)) {\n\t\tnsec -= (((u64)NSEC_PER_SEC) << tk->tkr_mono.shift);\n\t\tvdso_ts->sec++;\n\t}\n\tvdso_ts->nsec\t= nsec;\n\n\t/* CLOCK_MONOTONIC_RAW */\n\tvdso_ts\t\t= &vdata[CS_RAW].basetime[CLOCK_MONOTONIC_RAW];\n\tvdso_ts->sec\t= tk->raw_sec;\n\tvdso_ts->nsec\t= tk->tkr_raw.xtime_nsec;\n\n\t/* CLOCK_TAI */\n\tvdso_ts\t\t= &vdata[CS_HRES_COARSE].basetime[CLOCK_TAI];\n\tvdso_ts->sec\t= tk->xtime_sec + (s64)tk->tai_offset;\n\tvdso_ts->nsec\t= tk->tkr_mono.xtime_nsec;\n}"
  }
]