[
  {
    "function_name": "trace_selftest_startup_branch",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "1256-1284",
    "snippet": "int\ntrace_selftest_startup_branch(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->array_buffer",
            "&count"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_branch(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "1178-1252",
    "snippet": "int\ntrace_selftest_startup_wakeup(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tstruct task_struct *p;\n\tstruct wakeup_test_data data;\n\tunsigned long count;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tinit_completion(&data.is_ready);\n\n\t/* create a -deadline thread */\n\tp = kthread_run(trace_wakeup_test_thread, &data, \"ftrace-test\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_CONT \"Failed to create ftrace wakeup test thread \");\n\t\treturn -1;\n\t}\n\n\t/* make sure the thread is running at -deadline policy */\n\twait_for_completion(&data.is_ready);\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\twhile (p->on_rq) {\n\t\t/*\n\t\t * Sleep to make sure the -deadline thread is asleep too.\n\t\t * On virtual machines we can't rely on timings,\n\t\t * but we want to make sure this test still works.\n\t\t */\n\t\tmsleep(100);\n\t}\n\n\tinit_completion(&data.is_ready);\n\n\tdata.go = 1;\n\t/* memory barrier is in the wake_up_process() */\n\n\twake_up_process(p);\n\n\t/* Wait for the task to wake up */\n\twait_for_completion(&data.is_ready);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\ttr->max_latency = save_max;\n\n\t/* kill the thread */\n\tkthread_stop(p);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "p"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&data.is_ready"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&data.is_ready"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "trace_wakeup_test_thread",
            "&data",
            "\"ftrace-test\""
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&data.is_ready"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_wakeup(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tstruct task_struct *p;\n\tstruct wakeup_test_data data;\n\tunsigned long count;\n\tint ret;\n\n\tmemset(&data, 0, sizeof(data));\n\n\tinit_completion(&data.is_ready);\n\n\t/* create a -deadline thread */\n\tp = kthread_run(trace_wakeup_test_thread, &data, \"ftrace-test\");\n\tif (IS_ERR(p)) {\n\t\tprintk(KERN_CONT \"Failed to create ftrace wakeup test thread \");\n\t\treturn -1;\n\t}\n\n\t/* make sure the thread is running at -deadline policy */\n\twait_for_completion(&data.is_ready);\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\twhile (p->on_rq) {\n\t\t/*\n\t\t * Sleep to make sure the -deadline thread is asleep too.\n\t\t * On virtual machines we can't rely on timings,\n\t\t * but we want to make sure this test still works.\n\t\t */\n\t\tmsleep(100);\n\t}\n\n\tinit_completion(&data.is_ready);\n\n\tdata.go = 1;\n\t/* memory barrier is in the wake_up_process() */\n\n\twake_up_process(p);\n\n\t/* Wait for the task to wake up */\n\twait_for_completion(&data.is_ready);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\n\ttrace->reset(tr);\n\ttracing_start();\n\n\ttr->max_latency = save_max;\n\n\t/* kill the thread */\n\tkthread_stop(p);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_wakeup_test_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "1141-1177",
    "snippet": "static int trace_wakeup_test_thread(void *data)\n{\n\t/* Make this a -deadline thread */\n\tstatic const struct sched_attr attr = {\n\t\t.sched_policy = SCHED_DEADLINE,\n\t\t.sched_runtime = 100000ULL,\n\t\t.sched_deadline = 10000000ULL,\n\t\t.sched_period = 10000000ULL\n\t};\n\tstruct wakeup_test_data *x = data;\n\n\tsched_setattr(current, &attr);\n\n\t/* Make it know we have a new prio */\n\tcomplete(&x->is_ready);\n\n\t/* now go to sleep and let the test wake us up */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!x->go) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\tcomplete(&x->is_ready);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t/* we are awake, now wait to disappear */\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&x->is_ready"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_setattr",
          "args": [
            "current",
            "&attr"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setattr_nocheck",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7546-7549",
          "snippet": "int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_wakeup_test_thread(void *data)\n{\n\t/* Make this a -deadline thread */\n\tstatic const struct sched_attr attr = {\n\t\t.sched_policy = SCHED_DEADLINE,\n\t\t.sched_runtime = 100000ULL,\n\t\t.sched_deadline = 10000000ULL,\n\t\t.sched_period = 10000000ULL\n\t};\n\tstruct wakeup_test_data *x = data;\n\n\tsched_setattr(current, &attr);\n\n\t/* Make it know we have a new prio */\n\tcomplete(&x->is_ready);\n\n\t/* now go to sleep and let the test wake us up */\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile (!x->go) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\tcomplete(&x->is_ready);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t/* we are awake, now wait to disappear */\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\n\t__set_current_state(TASK_RUNNING);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_selftest_startup_nop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "1126-1131",
    "snippet": "int\ntrace_selftest_startup_nop(struct tracer *trace, struct trace_array *tr)\n{\n\t/* What could possibly go wrong? */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_nop(struct tracer *trace, struct trace_array *tr)\n{\n\t/* What could possibly go wrong? */\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_selftest_startup_preemptirqsoff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "1025-1122",
    "snippet": "int\ntrace_selftest_startup_preemptirqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptible,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out_no_start;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\t/* disable preemption and interrupts for a bit */\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs/preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* do the test by disabling interrupts first this time */\n\ttr->max_latency = 0;\n\ttracing_start();\n\ttrace->start(tr);\n\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\ttracing_start();\nout_no_start:\n\ttrace->reset(tr);\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->start",
          "args": [
            "tr"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_preemptirqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptible,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out_no_start;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\n\t/* disable preemption and interrupts for a bit */\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs/preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* do the test by disabling interrupts first this time */\n\ttr->max_latency = 0;\n\ttracing_start();\n\ttrace->start(tr);\n\n\tpreempt_disable();\n\tlocal_irq_disable();\n\tudelay(100);\n\tpreempt_enable();\n\t/* reverse the order of preempt vs irqs */\n\tlocal_irq_enable();\n\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_test_buffer(&tr->max_buffer, &count);\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\ttracing_start();\nout_no_start:\n\ttrace->reset(tr);\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_preemptoff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "963-1021",
    "snippet": "int\ntrace_selftest_startup_preemptoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptible,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable preemption for a bit */\n\tpreempt_disable();\n\tudelay(100);\n\tpreempt_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_preemptoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/*\n\t * Now that the big kernel lock is no longer preemptible,\n\t * and this is called with the BKL held, it will always\n\t * fail. If preemption is already disabled, simply\n\t * pass the test. When the BKL is removed, or becomes\n\t * preemptible again, we will once again test this,\n\t * so keep it in.\n\t */\n\tif (preempt_count()) {\n\t\tprintk(KERN_CONT \"can not test ... force \");\n\t\treturn 0;\n\t}\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable preemption for a bit */\n\tpreempt_disable();\n\tudelay(100);\n\tpreempt_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max preempt off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_irqsoff",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "914-959",
    "snippet": "int\ntrace_selftest_startup_irqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable interrupts for a bit */\n\tlocal_irq_disable();\n\tudelay(100);\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->max_buffer",
            "&count"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->stop",
          "args": [
            "tr"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "100"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nint\ntrace_selftest_startup_irqsoff(struct tracer *trace, struct trace_array *tr)\n{\n\tunsigned long save_max = tr->max_latency;\n\tunsigned long count;\n\tint ret;\n\n\t/* start the tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\treturn ret;\n\t}\n\n\t/* reset the max latency */\n\ttr->max_latency = 0;\n\t/* disable interrupts for a bit */\n\tlocal_irq_disable();\n\tudelay(100);\n\tlocal_irq_enable();\n\n\t/*\n\t * Stop the tracer to avoid a warning subsequent\n\t * to buffer flipping failure because tracing_stop()\n\t * disables the tr and max buffers, making flipping impossible\n\t * in case of parallels max irqs off latencies.\n\t */\n\ttrace->stop(tr);\n\t/* stop the tracing. */\n\ttracing_stop();\n\t/* check both trace buffers */\n\tret = trace_test_buffer(&tr->array_buffer, NULL);\n\tif (!ret)\n\t\tret = trace_test_buffer(&tr->max_buffer, &count);\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t}\n\n\ttr->max_latency = save_max;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_startup_function_graph",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "797-909",
    "snippet": "__init int\ntrace_selftest_startup_function_graph(struct tracer *trace,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tint ret;\n\tunsigned long count;\n\tchar *func_name __maybe_unused;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/*\n\t * Simulate the init() callback but we attach a watchdog callback\n\t * to detect and recover from possible hangs\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\tset_graph_array(tr);\n\tret = register_ftrace_graph(&fgraph_ops);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\ttracing_start_cmdline_record();\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* Have we just recovered from a hang? */\n\tif (graph_hang_thresh > GRAPH_MAX_FUNC_TEST) {\n\t\tdisable_tracing_selftest(\"recovering from a hang\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\ttracing_stop();\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\t/* Need to also simulate the tr->reset to remove this fgraph_ops */\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph(&fgraph_ops);\n\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n#ifdef TEST_DIRECT_TRAMP\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\tset_graph_array(tr);\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/*\n\t * Register direct function together with graph tracer\n\t * and make sure we get graph trace.\n\t */\n\tret = register_ftrace_direct((unsigned long) DYN_FTRACE_TEST_NAME,\n\t\t\t\t     (unsigned long) trace_direct_tramp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = register_ftrace_graph(&fgraph_ops);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tcount = 0;\n\n\ttracing_stop();\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tunregister_ftrace_graph(&fgraph_ops);\n\n\tret = unregister_ftrace_direct((unsigned long) DYN_FTRACE_TEST_NAME,\n\t\t\t\t       (unsigned long) trace_direct_tramp);\n\tif (ret)\n\t\tgoto out;\n\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n#endif\n\n\t/* Don't test dynamic tracing, the function tracer already did */\nout:\n\t/* Stop it if we failed */\n\tif (ret)\n\t\tftrace_graph_stop();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [
      "#define TEST_DIRECT_TRAMP",
      "#define GRAPH_MAX_FUNC_TEST\t100000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_graph_stop",
          "args": [],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "52-55",
          "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_direct",
          "args": [
            "(unsigned long) DYN_FTRACE_TEST_NAME",
            "(unsigned long) trace_direct_tramp"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_direct_multi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5531-5550",
          "snippet": "int unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_direct_multi(struct ftrace_ops *ops, unsigned long addr)\n{\n\tstruct ftrace_hash *hash = ops->func_hash->filter_hash;\n\tint err;\n\n\tif (check_direct_multi(ops))\n\t\treturn -EINVAL;\n\tif (!(ops->flags & FTRACE_OPS_FL_ENABLED))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&direct_mutex);\n\terr = unregister_ftrace_function(ops);\n\tremove_direct_functions_hash(hash, addr);\n\tmutex_unlock(&direct_mutex);\n\n\t/* cleanup for possible another register call */\n\tops->func = NULL;\n\tops->trampoline = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_graph",
          "args": [
            "&fgraph_ops"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_graph",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "636-653",
          "snippet": "void unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_graph_active;",
            "static struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};",
            "static struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};",
            "trace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;",
            "trace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;",
            "static trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nint ftrace_graph_active;\nstatic struct notifier_block ftrace_suspend_notifier = {\n\t.notifier_call = ftrace_suspend_notifier_call,\n};\nstatic struct ftrace_ops graph_ops = {\n\t.func\t\t\t= ftrace_graph_func,\n\t.flags\t\t\t= FTRACE_OPS_FL_INITIALIZED |\n\t\t\t\t   FTRACE_OPS_FL_PID |\n\t\t\t\t   FTRACE_OPS_GRAPH_STUB,\n#ifdef FTRACE_GRAPH_TRAMP_ADDR\n\t.trampoline\t\t= FTRACE_GRAPH_TRAMP_ADDR,\n\t/* trampoline_size is only needed for dynamically allocated tramps */\n#endif\n\tASSIGN_OPS_HASH(graph_ops, &global_ops.local_hash)\n};\ntrace_func_graph_ret_t ftrace_graph_return = ftrace_stub_graph;\ntrace_func_graph_ent_t ftrace_graph_entry = ftrace_graph_entry_stub;\nstatic trace_func_graph_ent_t __ftrace_graph_entry = ftrace_graph_entry_stub;\n\nvoid unregister_ftrace_graph(struct fgraph_ops *gops)\n{\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(!ftrace_graph_active))\n\t\tgoto out;\n\n\tftrace_graph_active--;\n\tftrace_graph_return = ftrace_stub_graph;\n\tftrace_graph_entry = ftrace_graph_entry_stub;\n\t__ftrace_graph_entry = ftrace_graph_entry_stub;\n\tftrace_shutdown(&graph_ops, FTRACE_STOP_FUNC_RET);\n\tunregister_pm_notifier(&ftrace_suspend_notifier);\n\tunregister_trace_sched_switch(ftrace_graph_probe_sched_switch, NULL);\n\n out:\n\tmutex_unlock(&ftrace_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->array_buffer",
            "&count"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_global_filter",
          "args": [
            "func_name",
            "strlen(func_name)",
            "1"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_global_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5710-5713",
          "snippet": "void ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops global_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_graph_array",
          "args": [
            "tr"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "set_graph_array",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_functions_graph.c",
          "lines": "263-270",
          "snippet": "void set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array *graph_array;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n\nstatic struct trace_array *graph_array;\n\nvoid set_graph_array(struct trace_array *tr)\n{\n\tgraph_array = tr;\n\n\t/* Make graph_array visible before we start tracing */\n\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_reset_online_cpus",
          "args": [
            "&tr->array_buffer"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_reset_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2138-2155",
          "snippet": "void tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nvoid tracing_reset_online_cpus(struct array_buffer *buf)\n{\n\tstruct trace_buffer *buffer = buf->buffer;\n\n\tif (!buffer)\n\t\treturn;\n\n\tring_buffer_record_disable(buffer);\n\n\t/* Make sure all commits have finished */\n\tsynchronize_rcu();\n\n\tbuf->time_start = buffer_ftrace_now(buf, buf->cpu);\n\n\tring_buffer_reset_online_cpus(buffer);\n\n\tring_buffer_record_enable(buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop_cmdline_record",
          "args": [],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "136-139",
          "snippet": "void tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_stop_cmdline_record(void)\n{\n\ttracing_stop_sched_switch(RECORD_CMDLINE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_tracing_selftest",
          "args": [
            "\"recovering from a hang\""
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "disable_tracing_selftest",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "78-84",
          "snippet": "void __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nvoid __init disable_tracing_selftest(const char *reason)\n{\n\tif (!tracing_selftest_disabled) {\n\t\ttracing_selftest_disabled = true;\n\t\tpr_info(\"Ftrace startup test is disabled due to %s\\n\", reason);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start_cmdline_record",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start_cmdline_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_sched_switch.c",
          "lines": "131-134",
          "snippet": "void tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define RECORD_CMDLINE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/sched.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define RECORD_CMDLINE\t1\n\nvoid tracing_start_cmdline_record(void)\n{\n\ttracing_start_sched_switch(RECORD_CMDLINE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\n#define TEST_DIRECT_TRAMP\n#define GRAPH_MAX_FUNC_TEST\t100000000\n\n__init int\ntrace_selftest_startup_function_graph(struct tracer *trace,\n\t\t\t\t\tstruct trace_array *tr)\n{\n\tint ret;\n\tunsigned long count;\n\tchar *func_name __maybe_unused;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/*\n\t * Simulate the init() callback but we attach a watchdog callback\n\t * to detect and recover from possible hangs\n\t */\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\tset_graph_array(tr);\n\tret = register_ftrace_graph(&fgraph_ops);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\ttracing_start_cmdline_record();\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* Have we just recovered from a hang? */\n\tif (graph_hang_thresh > GRAPH_MAX_FUNC_TEST) {\n\t\tdisable_tracing_selftest(\"recovering from a hang\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\ttracing_stop();\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\t/* Need to also simulate the tr->reset to remove this fgraph_ops */\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph(&fgraph_ops);\n\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n#ifdef TEST_DIRECT_TRAMP\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\tset_graph_array(tr);\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/*\n\t * Register direct function together with graph tracer\n\t * and make sure we get graph trace.\n\t */\n\tret = register_ftrace_direct((unsigned long) DYN_FTRACE_TEST_NAME,\n\t\t\t\t     (unsigned long) trace_direct_tramp);\n\tif (ret)\n\t\tgoto out;\n\n\tret = register_ftrace_graph(&fgraph_ops);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tcount = 0;\n\n\ttracing_stop();\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tunregister_ftrace_graph(&fgraph_ops);\n\n\tret = unregister_ftrace_direct((unsigned long) DYN_FTRACE_TEST_NAME,\n\t\t\t\t       (unsigned long) trace_direct_tramp);\n\tif (ret)\n\t\tgoto out;\n\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n#endif\n\n\t/* Don't test dynamic tracing, the function tracer already did */\nout:\n\t/* Stop it if we failed */\n\tif (ret)\n\t\tftrace_graph_stop();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_direct_tramp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "790-790",
    "snippet": "static void trace_direct_tramp(void) { }",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_direct_tramp(void) { }"
  },
  {
    "function_name": "trace_graph_entry_watchdog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "765-780",
    "snippet": "static int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t/* This is harmlessly racy, we want to approximately detect a hang */\n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t/* ftrace_dump() disables tracing */\n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [
      "#define GRAPH_MAX_FUNC_TEST\t100000000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_graph_entry",
          "args": [
            "trace"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "trace_graph_entry_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "765-780",
          "snippet": "static int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t/* This is harmlessly racy, we want to approximately detect a hang */\n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t/* ftrace_dump() disables tracing */\n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "965-968",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_dump",
          "args": [
            "DUMP_ALL"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9808-9917",
          "snippet": "void ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define STATIC_TEMP_BUF_SIZE\t128",
            "#define STATIC_FMT_BUF_SIZE\t128"
          ],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static char static_fmt_buf[STATIC_FMT_BUF_SIZE];",
            "static char static_temp_buf[STATIC_TEMP_BUF_SIZE]",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define STATIC_TEMP_BUF_SIZE\t128\n#define STATIC_FMT_BUF_SIZE\t128\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic char static_fmt_buf[STATIC_FMT_BUF_SIZE];\nstatic char static_temp_buf[STATIC_TEMP_BUF_SIZE];\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t/* use static because iter can be a bit big for the stack */\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tstruct trace_array *tr = &global_trace;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t/* Only allow one dump user at a time. */\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t/*\n\t * Always turn off tracing when we dump.\n\t * We don't need to show trace output of what happens\n\t * between multiple crashes.\n\t *\n\t * If the user does a sysrq-z, then they can re-enable\n\t * tracing with echo 1 > tracing_on.\n\t */\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t/* Simulate the iterator */\n\ttrace_init_global_iter(&iter);\n\t/* Can not use kmalloc for iter.temp and iter.fmt */\n\titer.temp = static_temp_buf;\n\titer.temp_size = STATIC_TEMP_BUF_SIZE;\n\titer.fmt = static_fmt_buf;\n\titer.fmt_size = STATIC_FMT_BUF_SIZE;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\n\told_userobj = tr->trace_flags & TRACE_ITER_SYM_USEROBJ;\n\n\t/* don't look at user memory in panic mode */\n\ttr->trace_flags &= ~TRACE_ITER_SYM_USEROBJ;\n\n\tswitch (oops_dump_mode) {\n\tcase DUMP_ALL:\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t\tbreak;\n\tcase DUMP_ORIG:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase DUMP_NONE:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(KERN_TRACE \"Bad dumping mode, switching to all CPUs dump\\n\");\n\t\titer.cpu_file = RING_BUFFER_ALL_CPUS;\n\t}\n\n\tprintk(KERN_TRACE \"Dumping ftrace buffer:\\n\");\n\n\t/* Did function tracer already get disabled? */\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"# WARNING: FUNCTION TRACING IS CORRUPTED\\n\");\n\t\tprintk(\"#          MAY BE MISSING FUNCTION EVENTS\\n\");\n\t}\n\n\t/*\n\t * We need to stop all tracing on all CPUS to read\n\t * the next buffer. This is a bit expensive, but is\n\t * not done often. We fill all what we can read,\n\t * and then release the locks again.\n\t */\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n\t\tcnt++;\n\n\t\ttrace_iterator_reset(&iter);\n\t\titer.iter_flags |= TRACE_FILE_LAT_FMT;\n\n\t\tif (trace_find_next_entry_inc(&iter) != NULL) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != TRACE_TYPE_NO_CONSUME)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(KERN_TRACE \"   (ftrace buffer empty)\\n\");\n\telse\n\t\tprintk(KERN_TRACE \"---------------------------------\\n\");\n\n out_enable:\n\ttr->trace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.array_buffer->data, cpu)->disabled);\n\t}\n\tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"BUG: Function graph tracer hang!\\n\""
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_graph_stop",
          "args": [],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_graph_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/fgraph.c",
          "lines": "52-55",
          "snippet": "void ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}",
          "includes": [
            "#include \"ftrace_internal.h\"",
            "#include <trace/events/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kill_ftrace_graph;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ftrace_internal.h\"\n#include <trace/events/sched.h>\n#include <linux/slab.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n\nstatic bool kill_ftrace_graph;\n\nvoid ftrace_graph_stop(void)\n{\n\tkill_ftrace_graph = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++graph_hang_thresh > GRAPH_MAX_FUNC_TEST"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\n#define GRAPH_MAX_FUNC_TEST\t100000000\n\nstatic int trace_graph_entry_watchdog(struct ftrace_graph_ent *trace)\n{\n\t/* This is harmlessly racy, we want to approximately detect a hang */\n\tif (unlikely(++graph_hang_thresh > GRAPH_MAX_FUNC_TEST)) {\n\t\tftrace_graph_stop();\n\t\tprintk(KERN_WARNING \"BUG: Function graph tracer hang!\\n\");\n\t\tif (ftrace_dump_on_oops) {\n\t\t\tftrace_dump(DUMP_ALL);\n\t\t\t/* ftrace_dump() disables tracing */\n\t\t\ttracing_on();\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn trace_graph_entry(trace);\n}"
  },
  {
    "function_name": "trace_selftest_startup_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "690-753",
    "snippet": "__init int\ntrace_selftest_startup_function(struct tracer *trace, struct trace_array *tr)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/* make sure msleep has been recorded */\n\tmsleep(1);\n\n\t/* start the tracing */\n\tftrace_enabled = 1;\n\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = trace_selftest_startup_dynamic_tracing(trace, tr,\n\t\t\t\t\t\t     DYN_FTRACE_TEST_NAME);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_recursion();\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_regs();\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* kill ftrace totally if we failed */\n\tif (ret)\n\t\tftrace_kill();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_kill",
          "args": [],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_kill",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7775-7780",
          "snippet": "void ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ftrace_enabled",
            "static int ftrace_disabled",
            "ftrace_func_t ftrace_trace_function"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nint ftrace_enabled;\nstatic int ftrace_disabled;\nftrace_func_t ftrace_trace_function;\n\nvoid ftrace_kill(void)\n{\n\tftrace_disabled = 1;\n\tftrace_enabled = 0;\n\tftrace_trace_function = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_selftest_function_regs",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_function_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "600-683",
          "snippet": "static int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_selftest_function_recursion",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_function_recursion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "489-570",
          "snippet": "static int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\t/*\n\t * Recursion allows for transitions between context,\n\t * and may call the callback twice.\n\t */\n\tif (trace_selftest_recursion_cnt != 1 &&\n\t    trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called once (or twice) (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\t/*\n\t * Recursion allows for transitions between context,\n\t * and may call the callback twice.\n\t */\n\tif (trace_selftest_recursion_cnt != 1 &&\n\t    trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called once (or twice) (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_selftest_startup_dynamic_tracing",
          "args": [
            "trace",
            "tr",
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_startup_dynamic_tracing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "356-445",
          "snippet": "static int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. no entries found ..\""
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->array_buffer",
            "&count"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\n__init int\ntrace_selftest_startup_function(struct tracer *trace, struct trace_array *tr)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tint ret;\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (ftrace_filter_param) {\n\t\tprintk(KERN_CONT \" ... kernel command line filter set: force PASS ... \");\n\t\treturn 0;\n\t}\n#endif\n\n\t/* make sure msleep has been recorded */\n\tmsleep(1);\n\n\t/* start the tracing */\n\tftrace_enabled = 1;\n\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttrace->reset(tr);\n\ttracing_start();\n\n\tif (!ret && !count) {\n\t\tprintk(KERN_CONT \".. no entries found ..\");\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\tret = trace_selftest_startup_dynamic_tracing(trace, tr,\n\t\t\t\t\t\t     DYN_FTRACE_TEST_NAME);\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_recursion();\n\tif (ret)\n\t\tgoto out;\n\n\tret = trace_selftest_function_regs();\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* kill ftrace totally if we failed */\n\tif (ret)\n\t\tftrace_kill();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_function_regs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "600-683",
    "snippet": "static int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"*callback received NULL regs* \""
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&test_regs_probe"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "&test_regs_probe",
            "func_name",
            "len",
            "1"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5675-5680",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing ftrace regs%s: \"",
            "!supported ? \"(no arch support)\" : \"\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_test_regs_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "582-593",
    "snippet": "static void trace_selftest_test_regs_func(unsigned long ip,\n\t\t\t\t\t  unsigned long pip,\n\t\t\t\t\t  struct ftrace_ops *op,\n\t\t\t\t\t  struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\n\tif (regs)\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_FOUND;\n\telse\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_NOT_FOUND;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_get_regs",
          "args": [
            "fregs"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_regs_func(unsigned long ip,\n\t\t\t\t\t  unsigned long pip,\n\t\t\t\t\t  struct ftrace_ops *op,\n\t\t\t\t\t  struct ftrace_regs *fregs)\n{\n\tstruct pt_regs *regs = ftrace_get_regs(fregs);\n\n\tif (regs)\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_FOUND;\n\telse\n\t\ttrace_selftest_regs_stat = TRACE_SELFTEST_REGS_NOT_FOUND;\n}"
  },
  {
    "function_name": "trace_selftest_function_recursion",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "489-570",
    "snippet": "static int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\t/*\n\t * Recursion allows for transitions between context,\n\t * and may call the callback twice.\n\t */\n\tif (trace_selftest_recursion_cnt != 1 &&\n\t    trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called once (or twice) (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"*callback not called expected 2 times (%d)* \"",
            "trace_selftest_recursion_cnt"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "&test_recsafe_probe"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"*could not register callback* \""
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "&test_recsafe_probe",
            "func_name",
            "len",
            "1"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5675-5680",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing ftrace recursion safe: \""
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing ftrace recursion: \""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_recursion(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion: \");\n\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_rec_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_rec_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_rec_probe);\n\n\tret = -1;\n\t/*\n\t * Recursion allows for transitions between context,\n\t * and may call the callback twice.\n\t */\n\tif (trace_selftest_recursion_cnt != 1 &&\n\t    trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called once (or twice) (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\ttrace_selftest_recursion_cnt = 1;\n\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace recursion safe: \");\n\n\tret = ftrace_set_filter(&test_recsafe_probe, func_name, len, 1);\n\tif (ret) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_recsafe_probe);\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_recsafe_probe);\n\n\tret = -1;\n\tif (trace_selftest_recursion_cnt != 2) {\n\t\tpr_cont(\"*callback not called expected 2 times (%d)* \",\n\t\t\ttrace_selftest_recursion_cnt);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_test_recursion_safe_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "463-478",
    "snippet": "static void trace_selftest_test_recursion_safe_func(unsigned long ip,\n\t\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\t/*\n\t * We said we would provide our own recursion. By calling\n\t * this function again, we should recurse back into this function\n\t * and count again. But this only happens if the arch supports\n\t * all of ftrace features and nothing else is using the function\n\t * tracing utility.\n\t */\n\tif (trace_selftest_recursion_cnt++)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_recursion_safe_func(unsigned long ip,\n\t\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\t/*\n\t * We said we would provide our own recursion. By calling\n\t * this function again, we should recurse back into this function\n\t * and count again. But this only happens if the arch supports\n\t * all of ftrace features and nothing else is using the function\n\t * tracing utility.\n\t */\n\tif (trace_selftest_recursion_cnt++)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}"
  },
  {
    "function_name": "trace_selftest_test_recursion_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "448-461",
    "snippet": "static void trace_selftest_test_recursion_func(unsigned long ip,\n\t\t\t\t\t       unsigned long pip,\n\t\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t\t       struct ftrace_regs *fregs)\n{\n\t/*\n\t * This function is registered without the recursion safe flag.\n\t * The ftrace infrastructure should provide the recursion\n\t * protection. If not, this will crash the kernel!\n\t */\n\tif (trace_selftest_recursion_cnt++ > 10)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_recursion_func(unsigned long ip,\n\t\t\t\t\t       unsigned long pip,\n\t\t\t\t\t       struct ftrace_ops *op,\n\t\t\t\t\t       struct ftrace_regs *fregs)\n{\n\t/*\n\t * This function is registered without the recursion safe flag.\n\t * The ftrace infrastructure should provide the recursion\n\t * protection. If not, this will crash the kernel!\n\t */\n\tif (trace_selftest_recursion_cnt++ > 10)\n\t\treturn;\n\tDYN_FTRACE_TEST_NAME();\n}"
  },
  {
    "function_name": "trace_selftest_startup_dynamic_tracing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "356-445",
    "snippet": "static int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_selftest_ops",
          "args": [
            "tr",
            "2"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "182-353",
          "snippet": "static int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\t/* Remove trace function from probe 3 */\n\tfunc1_name = \"!\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen1 = strlen(func1_name);\n\n\tftrace_set_filter(&test_probe3, func1_name, len1, 0);\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 5)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\t/* Remove trace function from probe 3 */\n\tfunc1_name = \"!\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen1 = strlen(func1_name);\n\n\tftrace_set_filter(&test_probe3, func1_name, len1, 0);\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 5)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_global_filter",
          "args": [
            "NULL",
            "0",
            "1"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_global_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5710-5713",
          "snippet": "void ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ftrace_ops global_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstruct ftrace_ops global_ops;\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. filter failed count=%ld ..\"",
            "count"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace->reset",
          "args": [
            "tr"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_start",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2258-2293",
          "snippet": "void tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_start(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t/* Someone screwed up their debugging */\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer",
          "args": [
            "&tr->array_buffer",
            "&count"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "63-95",
          "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_stop",
          "args": [],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "2332-2358",
          "snippet": "void tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nvoid tracing_stop(void)\n{\n\tstruct trace_buffer *buffer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (global_trace.stop_count++)\n\t\tgoto out;\n\n\t/* Prevent the buffers from switching */\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.array_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_disable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "trace_selftest_function_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "600-683",
          "snippet": "static int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int\ntrace_selftest_function_regs(void)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tchar *func_name;\n\tint len;\n\tint ret;\n\tint supported = 0;\n\n#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS\n\tsupported = 1;\n#endif\n\n\t/* The previous test PASSED */\n\tpr_cont(\"PASSED\\n\");\n\tpr_info(\"Testing ftrace regs%s: \",\n\t\t!supported ? \"(no arch support)\" : \"\");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* Handle PPC64 '.' name */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen = strlen(func_name);\n\n\tret = ftrace_set_filter(&test_regs_probe, func_name, len, 1);\n\t/*\n\t * If DYNAMIC_FTRACE is not set, then we just trace all functions.\n\t * This test really doesn't care.\n\t */\n\tif (ret && ret != -ENODEV) {\n\t\tpr_cont(\"*Could not set filter* \");\n\t\tgoto out;\n\t}\n\n\tret = register_ftrace_function(&test_regs_probe);\n\t/*\n\t * Now if the arch does not support passing regs, then this should\n\t * have failed.\n\t */\n\tif (!supported) {\n\t\tif (!ret) {\n\t\t\tpr_cont(\"*registered save-regs without arch support* \");\n\t\t\tgoto out;\n\t\t}\n\t\ttest_regs_probe.flags |= FTRACE_OPS_FL_SAVE_REGS_IF_SUPPORTED;\n\t\tret = register_ftrace_function(&test_regs_probe);\n\t}\n\tif (ret) {\n\t\tpr_cont(\"*could not register callback* \");\n\t\tgoto out;\n\t}\n\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tunregister_ftrace_function(&test_regs_probe);\n\n\tret = -1;\n\n\tswitch (trace_selftest_regs_stat) {\n\tcase TRACE_SELFTEST_REGS_START:\n\t\tpr_cont(\"*callback never called* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_FOUND:\n\t\tif (supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received regs without arch support* \");\n\t\tgoto out;\n\n\tcase TRACE_SELFTEST_REGS_NOT_FOUND:\n\t\tif (!supported)\n\t\t\tbreak;\n\t\tpr_cont(\"*callback received NULL regs* \");\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. filter did not filter .. \""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_failed_init_tracer",
          "args": [
            "trace",
            "ret"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "warn_failed_init_tracer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "97-101",
          "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracer_init",
          "args": [
            "trace",
            "tr"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "6135-6139",
          "snippet": "int tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->array_buffer);\n\treturn t->init(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func_name"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing dynamic ftrace: \""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_startup_dynamic_tracing(struct tracer *trace,\n\t\t\t\t\t\t  struct trace_array *tr,\n\t\t\t\t\t\t  int (*func)(void))\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tunsigned long count;\n\tchar *func_name;\n\tint ret;\n\n\t/* The ftrace test PASSED */\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace: \");\n\n\t/* enable tracing, and record the filter function */\n\tftrace_enabled = 1;\n\n\t/* passed in by parameter to fool gcc from optimizing */\n\tfunc();\n\n\t/*\n\t * Some archs *cough*PowerPC*cough* add characters to the\n\t * start of the function names. We simply put a '*' to\n\t * accommodate them.\n\t */\n\tfunc_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\n\t/* filter only on our function */\n\tftrace_set_global_filter(func_name, strlen(func_name), 1);\n\n\t/* enable tracing */\n\tret = tracer_init(trace, tr);\n\tif (ret) {\n\t\twarn_failed_init_tracer(trace, ret);\n\t\tgoto out;\n\t}\n\n\t/* Sleep for a 1/10 of a second */\n\tmsleep(100);\n\n\t/* we should have nothing in the buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\tif (ret)\n\t\tgoto out;\n\n\tif (count) {\n\t\tret = -1;\n\t\tprintk(KERN_CONT \".. filter did not filter .. \");\n\t\tgoto out;\n\t}\n\n\t/* call our function again */\n\tfunc();\n\n\t/* sleep again */\n\tmsleep(100);\n\n\t/* stop the tracing. */\n\ttracing_stop();\n\tftrace_enabled = 0;\n\n\t/* check the trace buffer */\n\tret = trace_test_buffer(&tr->array_buffer, &count);\n\n\tftrace_enabled = 1;\n\ttracing_start();\n\n\t/* we should only have one item */\n\tif (!ret && count != 1) {\n\t\ttrace->reset(tr);\n\t\tprintk(KERN_CONT \".. filter failed count=%ld ..\", count);\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n\t/* Test the ops with global tracing running */\n\tret = trace_selftest_ops(tr, 1);\n\ttrace->reset(tr);\n\n out:\n\tftrace_enabled = save_ftrace_enabled;\n\n\t/* Enable tracing on all functions again */\n\tftrace_set_global_filter(NULL, 0, 1);\n\n\t/* Test the ops with global tracing off */\n\tif (!ret)\n\t\tret = trace_selftest_ops(tr, 2);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_selftest_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "182-353",
    "snippet": "static int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\t/* Remove trace function from probe 3 */\n\tfunc1_name = \"!\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen1 = strlen(func1_name);\n\n\tftrace_set_filter(&test_probe3, func1_name, len1, 0);\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 5)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DYN_FTRACE_TEST_NAME",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "DYN_FTRACE_TEST_NAME2",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest_dynamic.c",
          "lines": "11-15",
          "snippet": "int DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/compiler.h>\n\nint DYN_FTRACE_TEST_NAME2(void)\n{\n\t/* used to call mcount */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_counts",
          "args": [],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "reset_counts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "173-180",
          "snippet": "static void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_reset_array_ops",
          "args": [
            "tr"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_reset_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7225-7228",
          "snippet": "void ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_reset_array_ops(struct trace_array *tr)\n{\n\ttr->ops->func = ftrace_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "tr->ops"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dyn_ops"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_counts",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "print_counts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "163-171",
          "snippet": "static void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter",
          "args": [
            "&test_probe3",
            "func1_name",
            "len1",
            "0"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5675-5680",
          "snippet": "int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "func1_name"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"!\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"MEMORY ERROR \""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*dyn_ops)",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_init_array_ops",
          "args": [
            "tr",
            "trace_selftest_test_global_func"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_init_array_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7213-7223",
          "snippet": "void ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func)\n{\n\t/* If we filter on pids, update to use the pid function */\n\tif (tr->flags & TRACE_ARRAY_FL_GLOBAL) {\n\t\tif (WARN_ON(tr->ops->func != ftrace_stub))\n\t\t\tprintk(\"ftrace ops had %pS for function\\n\",\n\t\t\t       tr->ops->func);\n\t}\n\ttr->ops->func = func;\n\ttr->ops->private = tr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME2"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"*\" __stringify",
          "args": [
            "DYN_FTRACE_TEST_NAME"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Testing dynamic ftrace ops #%d: \"",
            "cnt"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_selftest_ops(struct trace_array *tr, int cnt)\n{\n\tint save_ftrace_enabled = ftrace_enabled;\n\tstruct ftrace_ops *dyn_ops;\n\tchar *func1_name;\n\tchar *func2_name;\n\tint len1;\n\tint len2;\n\tint ret = -1;\n\n\tprintk(KERN_CONT \"PASSED\\n\");\n\tpr_info(\"Testing dynamic ftrace ops #%d: \", cnt);\n\n\tftrace_enabled = 1;\n\treset_counts();\n\n\t/* Handle PPC64 '.' name */\n\tfunc1_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME);\n\tfunc2_name = \"*\" __stringify(DYN_FTRACE_TEST_NAME2);\n\tlen1 = strlen(func1_name);\n\tlen2 = strlen(func2_name);\n\n\t/*\n\t * Probe 1 will trace function 1.\n\t * Probe 2 will trace function 2.\n\t * Probe 3 will trace functions 1 and 2.\n\t */\n\tftrace_set_filter(&test_probe1, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe2, func2_name, len2, 1);\n\tftrace_set_filter(&test_probe3, func1_name, len1, 1);\n\tftrace_set_filter(&test_probe3, func2_name, len2, 0);\n\n\tregister_ftrace_function(&test_probe1);\n\tregister_ftrace_function(&test_probe2);\n\tregister_ftrace_function(&test_probe3);\n\t/* First time we are running with main function */\n\tif (cnt > 1) {\n\t\tftrace_init_array_ops(tr, trace_selftest_test_global_func);\n\t\tregister_ftrace_function(tr->ops);\n\t}\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 0)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 1)\n\t\tgoto out;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out;\n\t}\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out;\n\tif (trace_selftest_test_probe3_cnt != 2)\n\t\tgoto out;\n\n\t/* Add a dynamic probe */\n\tdyn_ops = kzalloc(sizeof(*dyn_ops), GFP_KERNEL);\n\tif (!dyn_ops) {\n\t\tprintk(\"MEMORY ERROR \");\n\t\tgoto out;\n\t}\n\n\tdyn_ops->func = trace_selftest_test_dyn_func;\n\n\tregister_ftrace_function(dyn_ops);\n\n\ttrace_selftest_test_global_cnt = 0;\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 1)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 3)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\n\t/* Remove trace function from probe 3 */\n\tfunc1_name = \"!\" __stringify(DYN_FTRACE_TEST_NAME);\n\tlen1 = strlen(func1_name);\n\n\tftrace_set_filter(&test_probe3, func1_name, len1, 0);\n\n\tDYN_FTRACE_TEST_NAME();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 2)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 4)\n\t\tgoto out_free;\n\tif (cnt > 1) {\n\t\tif (trace_selftest_test_global_cnt == 0)\n\t\t\tgoto out_free;\n\t}\n\tif (trace_selftest_test_dyn_cnt == 0)\n\t\tgoto out_free;\n\n\tDYN_FTRACE_TEST_NAME2();\n\n\tprint_counts();\n\n\tif (trace_selftest_test_probe1_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe2_cnt != 3)\n\t\tgoto out_free;\n\tif (trace_selftest_test_probe3_cnt != 5)\n\t\tgoto out_free;\n\n\tret = 0;\n out_free:\n\tunregister_ftrace_function(dyn_ops);\n\tkfree(dyn_ops);\n\n out:\n\t/* Purposely unregister in the same order */\n\tunregister_ftrace_function(&test_probe1);\n\tunregister_ftrace_function(&test_probe2);\n\tunregister_ftrace_function(&test_probe3);\n\tif (cnt > 1)\n\t\tunregister_ftrace_function(tr->ops);\n\tftrace_reset_array_ops(tr);\n\n\t/* Make sure everything is off */\n\treset_counts();\n\tDYN_FTRACE_TEST_NAME();\n\tDYN_FTRACE_TEST_NAME();\n\n\tif (trace_selftest_test_probe1_cnt ||\n\t    trace_selftest_test_probe2_cnt ||\n\t    trace_selftest_test_probe3_cnt ||\n\t    trace_selftest_test_global_cnt ||\n\t    trace_selftest_test_dyn_cnt)\n\t\tret = -1;\n\n\tftrace_enabled = save_ftrace_enabled;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "reset_counts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "173-180",
    "snippet": "static void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void reset_counts(void)\n{\n\ttrace_selftest_test_probe1_cnt = 0;\n\ttrace_selftest_test_probe2_cnt = 0;\n\ttrace_selftest_test_probe3_cnt = 0;\n\ttrace_selftest_test_global_cnt = 0;\n\ttrace_selftest_test_dyn_cnt = 0;\n}"
  },
  {
    "function_name": "print_counts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "163-171",
    "snippet": "static void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"(%d %d %d %d %d) \"",
            "trace_selftest_test_probe1_cnt",
            "trace_selftest_test_probe2_cnt",
            "trace_selftest_test_probe3_cnt",
            "trace_selftest_test_global_cnt",
            "trace_selftest_test_dyn_cnt"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "230-242",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void print_counts(void)\n{\n\tprintk(\"(%d %d %d %d %d) \",\n\t       trace_selftest_test_probe1_cnt,\n\t       trace_selftest_test_probe2_cnt,\n\t       trace_selftest_test_probe3_cnt,\n\t       trace_selftest_test_global_cnt,\n\t       trace_selftest_test_dyn_cnt);\n}"
  },
  {
    "function_name": "trace_selftest_test_dyn_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "143-149",
    "snippet": "static void trace_selftest_test_dyn_func(unsigned long ip,\n\t\t\t\t\t unsigned long pip,\n\t\t\t\t\t struct ftrace_ops *op,\n\t\t\t\t\t struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_dyn_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_dyn_func(unsigned long ip,\n\t\t\t\t\t unsigned long pip,\n\t\t\t\t\t struct ftrace_ops *op,\n\t\t\t\t\t struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_dyn_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_global_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "134-140",
    "snippet": "static void trace_selftest_test_global_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_global_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_global_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_global_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_probe3_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "125-131",
    "snippet": "static void trace_selftest_test_probe3_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe3_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_probe3_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe3_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_probe2_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "116-122",
    "snippet": "static void trace_selftest_test_probe2_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe2_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_probe2_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe2_cnt++;\n}"
  },
  {
    "function_name": "trace_selftest_test_probe1_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "107-113",
    "snippet": "static void trace_selftest_test_probe1_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe1_cnt++;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic void trace_selftest_test_probe1_func(unsigned long ip,\n\t\t\t\t\t    unsigned long pip,\n\t\t\t\t\t    struct ftrace_ops *op,\n\t\t\t\t\t    struct ftrace_regs *fregs)\n{\n\ttrace_selftest_test_probe1_cnt++;\n}"
  },
  {
    "function_name": "warn_failed_init_tracer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "97-101",
    "snippet": "static inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\"",
            "trace->name",
            "init_ret"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "__trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_printk.c",
          "lines": "230-242",
          "snippet": "int __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n\nint __trace_printk(unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!trace_printk_enabled)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_vprintk(ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline void warn_failed_init_tracer(struct tracer *trace, int init_ret)\n{\n\tprintk(KERN_WARNING \"Failed to init %s tracer, init returned %d\\n\",\n\t\ttrace->name, init_ret);\n}"
  },
  {
    "function_name": "trace_test_buffer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "63-95",
    "snippet": "static int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&buf->tr->max_lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_on",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "965-968",
          "snippet": "void tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_on(void)\n{\n\ttracer_tracing_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_test_buffer_cpu",
          "args": [
            "buf",
            "cpu"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "trace_test_buffer_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "26-57",
          "snippet": "static int trace_test_buffer_cpu(struct array_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_test_buffer_cpu(struct array_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_off",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1429-1432",
          "snippet": "void tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nvoid tracing_off(void)\n{\n\ttracer_tracing_off(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_entries",
          "args": [
            "buf->buffer"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_entries",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4222-4235",
          "snippet": "unsigned long ring_buffer_entries(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long entries = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tentries += rb_num_of_entries(cpu_buffer);\n\t}\n\n\treturn entries;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nunsigned long ring_buffer_entries(struct trace_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long entries = 0;\n\tint cpu;\n\n\t/* if you care about this being correct, lock the buffer */\n\tfor_each_buffer_cpu(buffer, cpu) {\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\tentries += rb_num_of_entries(cpu_buffer);\n\t}\n\n\treturn entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&buf->tr->max_lock"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int __maybe_unused trace_test_buffer(struct array_buffer *buf, unsigned long *count)\n{\n\tunsigned long flags, cnt = 0;\n\tint cpu, ret = 0;\n\n\t/* Don't allow flipping of max traces now */\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&buf->tr->max_lock);\n\n\tcnt = ring_buffer_entries(buf->buffer);\n\n\t/*\n\t * The trace_test_buffer_cpu runs a while loop to consume all data.\n\t * If the calling tracer is broken, and is constantly filling\n\t * the buffer, this will run forever, and hard lock the box.\n\t * We disable the ring buffer while we do this test to prevent\n\t * a hard lock up.\n\t */\n\ttracing_off();\n\tfor_each_possible_cpu(cpu) {\n\t\tret = trace_test_buffer_cpu(buf, cpu);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\ttracing_on();\n\tarch_spin_unlock(&buf->tr->max_lock);\n\tlocal_irq_restore(flags);\n\n\tif (count)\n\t\t*count = cnt;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_test_buffer_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "26-57",
    "snippet": "static int trace_test_buffer_cpu(struct array_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. corrupted trace buffer .. \""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "trace_printk_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9766-9787",
          "snippet": "void\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define KERN_TRACE\t\tKERN_EMERG",
            "#define TRACE_MAX_PRINT\t\t1000"
          ],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define KERN_TRACE\t\tKERN_EMERG\n#define TRACE_MAX_PRINT\t\t1000\n\nstatic __always_inline struct;\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t/* Probably should print a warning here. */\n\tif (s->seq.len >= TRACE_MAX_PRINT)\n\t\ts->seq.len = TRACE_MAX_PRINT;\n\n\t/*\n\t * More paranoid code. Although the buffer size is set to\n\t * PAGE_SIZE, and TRACE_MAX_PRINT is 1000, this is just\n\t * an extra layer of protection.\n\t */\n\tif (WARN_ON_ONCE(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t/* should be zero ended, but we are paranoid. */\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(KERN_TRACE \"%s\", s->buffer);\n\n\ttrace_seq_init(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \".. invalid entry %d \"",
            "entry->type"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_trace_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_mmiotrace.c",
          "lines": "359-362",
          "snippet": "int mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/pci.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/atomic.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/mmiotrace.h>\n#include <linux/kernel.h>\n\nint mmio_trace_printk(const char *fmt, va_list args)\n{\n\treturn trace_vprintk(0, fmt, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_valid_entry",
          "args": [
            "entry"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "trace_valid_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
          "lines": "10-24",
          "snippet": "static inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/stringify.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_data",
          "args": [
            "event"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "274-277",
          "snippet": "void *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic __always_inline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid *ring_buffer_event_data(struct ring_buffer_event *event)\n{\n\treturn rb_event_data(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_consume",
          "args": [
            "buf->buffer",
            "cpu",
            "NULL",
            "NULL"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_consume",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "4887-4923",
          "snippet": "struct ring_buffer_event *\nring_buffer_consume(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline u64 rb_time_stamp(struct trace_buffer *buffer);",
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic inline u64 rb_time_stamp(struct trace_buffer *buffer);\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic __always_inline struct;\n\nstruct ring_buffer_event *\nring_buffer_consume(struct trace_buffer *buffer, int cpu, u64 *ts,\n\t\t    unsigned long *lost_events)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event = NULL;\n\tunsigned long flags;\n\tbool dolock;\n\n again:\n\t/* might be called in atomic */\n\tpreempt_disable();\n\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\tgoto out;\n\n\tcpu_buffer = buffer->buffers[cpu];\n\tlocal_irq_save(flags);\n\tdolock = rb_reader_lock(cpu_buffer);\n\n\tevent = rb_buffer_peek(cpu_buffer, ts, lost_events);\n\tif (event) {\n\t\tcpu_buffer->lost_events = 0;\n\t\trb_advance_reader(cpu_buffer);\n\t}\n\n\trb_reader_unlock(cpu_buffer, dolock);\n\tlocal_irq_restore(flags);\n\n out:\n\tpreempt_enable();\n\n\tif (event && event->type_len == RINGBUF_TYPE_PADDING)\n\t\tgoto again;\n\n\treturn event;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic int trace_test_buffer_cpu(struct array_buffer *buf, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct trace_entry *entry;\n\tunsigned int loops = 0;\n\n\twhile ((event = ring_buffer_consume(buf->buffer, cpu, NULL, NULL))) {\n\t\tentry = ring_buffer_event_data(event);\n\n\t\t/*\n\t\t * The ring buffer is a size of trace_buf_size, if\n\t\t * we loop more than the size, there's something wrong\n\t\t * with the ring buffer.\n\t\t */\n\t\tif (loops++ > trace_buf_size) {\n\t\t\tprintk(KERN_CONT \".. bad ring buffer \");\n\t\t\tgoto failed;\n\t\t}\n\t\tif (!trace_valid_entry(entry)) {\n\t\t\tprintk(KERN_CONT \".. invalid entry %d \",\n\t\t\t\tentry->type);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\treturn 0;\n\n failed:\n\t/* disable tracing */\n\ttracing_disabled = 1;\n\tprintk(KERN_CONT \".. corrupted trace buffer .. \");\n\treturn -1;\n}"
  },
  {
    "function_name": "trace_valid_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_selftest.c",
    "lines": "10-24",
    "snippet": "static inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/stringify.h>",
      "#include <uapi/linux/sched/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/stringify.h>\n#include <uapi/linux/sched/types.h>\n\nstatic inline int trace_valid_entry(struct trace_entry *entry)\n{\n\tswitch (entry->type) {\n\tcase TRACE_FN:\n\tcase TRACE_CTX:\n\tcase TRACE_WAKE:\n\tcase TRACE_STACK:\n\tcase TRACE_PRINT:\n\tcase TRACE_BRANCH:\n\tcase TRACE_GRAPH_ENT:\n\tcase TRACE_GRAPH_RET:\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  }
]