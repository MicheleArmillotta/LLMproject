[
  {
    "function_name": "ref_scale_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "787-875",
    "snippet": "static int __init\nref_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tstatic struct ref_scale_ops *scale_ops[] = {\n\t\t&rcu_ops, &srcu_ops, &rcu_trace_ops, &rcu_tasks_ops, &refcnt_ops, &rwlock_ops,\n\t\t&rwsem_ops, &lock_ops, &lock_irq_ops, &acqrel_ops, &clock_ops,\n\t};\n\n\tif (!torture_init_begin(scale_type, verbose))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {\n\t\tcur_ops = scale_ops[i];\n\t\tif (strcmp(scale_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(scale_ops)) {\n\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);\n\t\tpr_alert(\"rcu-scale types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)\n\t\t\tpr_cont(\" %s\", scale_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tcur_ops = NULL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tref_scale_print_module_parms(cur_ops, \"Start of test\");\n\n\t// Shutdown task\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(ref_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\t// Reader tasks (default to ~75% of online CPUs).\n\tif (nreaders < 0)\n\t\tnreaders = (num_online_cpus() >> 1) + (num_online_cpus() >> 2);\n\tif (WARN_ONCE(loops <= 0, \"%s: loops = %ld, adjusted to 1\\n\", __func__, loops))\n\t\tloops = 1;\n\tif (WARN_ONCE(nreaders <= 0, \"%s: nreaders = %d, adjusted to 1\\n\", __func__, nreaders))\n\t\tnreaders = 1;\n\tif (WARN_ONCE(nruns <= 0, \"%s: nruns = %d, adjusted to 1\\n\", __func__, nruns))\n\t\tnruns = 1;\n\treader_tasks = kcalloc(nreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!reader_tasks) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tVERBOSE_SCALEOUT(\"Starting %d reader threads\", nreaders);\n\n\tfor (i = 0; i < nreaders; i++) {\n\t\tfirsterr = torture_create_kthread(ref_scale_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i].task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\n\t\tinit_waitqueue_head(&(reader_tasks[i].wq));\n\t}\n\n\t// Main Task\n\tinit_waitqueue_head(&main_wq);\n\tfirsterr = torture_create_kthread(main_func, NULL, main_task);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tref_scale_cleanup();\n\tif (shutdown) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_REF_SCALE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *scale_type = \"rcu\";",
      "static struct task_struct *shutdown_task;",
      "static wait_queue_head_t shutdown_wq;",
      "static struct task_struct *main_task;",
      "static wait_queue_head_t main_wq;",
      "static struct reader_task *reader_tasks;",
      "static struct ref_scale_ops *cur_ops;",
      "static struct ref_scale_ops rcu_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= ref_rcu_read_section,\n\t.delaysection\t= ref_rcu_delay_section,\n\t.name\t\t= \"rcu\"\n};",
      "static struct ref_scale_ops srcu_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= srcu_ref_scale_read_section,\n\t.delaysection\t= srcu_ref_scale_delay_section,\n\t.name\t\t= \"srcu\"\n};",
      "static struct ref_scale_ops rcu_tasks_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= rcu_tasks_ref_scale_read_section,\n\t.delaysection\t= rcu_tasks_ref_scale_delay_section,\n\t.name\t\t= \"rcu-tasks\"\n};",
      "static struct ref_scale_ops rcu_trace_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= rcu_trace_ref_scale_read_section,\n\t.delaysection\t= rcu_trace_ref_scale_delay_section,\n\t.name\t\t= \"rcu-trace\"\n};",
      "static struct ref_scale_ops refcnt_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= ref_refcnt_section,\n\t.delaysection\t= ref_refcnt_delay_section,\n\t.name\t\t= \"refcnt\"\n};",
      "static struct ref_scale_ops rwlock_ops = {\n\t.init\t\t= ref_rwlock_init,\n\t.readsection\t= ref_rwlock_section,\n\t.delaysection\t= ref_rwlock_delay_section,\n\t.name\t\t= \"rwlock\"\n};",
      "static struct ref_scale_ops rwsem_ops = {\n\t.init\t\t= ref_rwsem_init,\n\t.readsection\t= ref_rwsem_section,\n\t.delaysection\t= ref_rwsem_delay_section,\n\t.name\t\t= \"rwsem\"\n};",
      "static struct ref_scale_ops lock_ops = {\n\t.readsection\t= ref_lock_section,\n\t.delaysection\t= ref_lock_delay_section,\n\t.name\t\t= \"lock\"\n};",
      "static struct ref_scale_ops lock_irq_ops = {\n\t.readsection\t= ref_lock_irq_section,\n\t.delaysection\t= ref_lock_irq_delay_section,\n\t.name\t\t= \"lock-irq\"\n};",
      "static struct ref_scale_ops acqrel_ops = {\n\t.readsection\t= ref_acqrel_section,\n\t.delaysection\t= ref_acqrel_delay_section,\n\t.name\t\t= \"acqrel\"\n};",
      "static struct ref_scale_ops clock_ops = {\n\t.readsection\t= ref_clock_section,\n\t.delaysection\t= ref_clock_delay_section,\n\t.name\t\t= \"clock\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_MODULE(CONFIG_RCU_REF_SCALE_TEST)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_RCU_REF_SCALE_TEST"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref_scale_cleanup",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "ref_scale_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "744-772",
          "snippet": "static void\nref_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nreaders; i++)\n\t\t\ttorture_stop_kthread(\"ref_scale_reader\",\n\t\t\t\t\t     reader_tasks[i].task);\n\t}\n\tkfree(reader_tasks);\n\n\ttorture_stop_kthread(\"main_task\", main_task);\n\tkfree(main_task);\n\n\t// Do scale-type-specific cleanup operations.\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *main_task;",
            "static struct reader_task *reader_tasks;",
            "static struct ref_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct task_struct *main_task;\nstatic struct reader_task *reader_tasks;\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void\nref_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nreaders; i++)\n\t\t\ttorture_stop_kthread(\"ref_scale_reader\",\n\t\t\t\t\t     reader_tasks[i].task);\n\t}\n\tkfree(reader_tasks);\n\n\ttorture_stop_kthread(\"main_task\", main_task);\n\tkfree(main_task);\n\n\t// Do scale-type-specific cleanup operations.\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "main_func",
            "NULL",
            "main_task"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&main_wq"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&(reader_tasks[i].wq)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "ref_scale_reader",
            "(void *)i",
            "reader_tasks[i].task"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT",
          "args": [
            "\"Starting %d reader threads\"",
            "nreaders"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nreaders",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nruns <= 0",
            "\"%s: nruns = %d, adjusted to 1\\n\"",
            "__func__",
            "nruns"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "nreaders <= 0",
            "\"%s: nreaders = %d, adjusted to 1\\n\"",
            "__func__",
            "nreaders"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "loops <= 0",
            "\"%s: loops = %ld, adjusted to 1\\n\"",
            "__func__",
            "loops"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "ref_scale_shutdown",
            "NULL",
            "shutdown_task"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&shutdown_wq"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref_scale_print_module_parms",
          "args": [
            "cur_ops",
            "\"Start of test\""
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "ref_scale_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "736-742",
          "snippet": "static void\nref_scale_print_module_parms(struct ref_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\", scale_type, tag,\n\t\t verbose, shutdown, holdoff, loops, nreaders, nruns, readdelay);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define SCALE_FLAG \"-ref-scale: \""
          ],
          "globals_used": [
            "static char *scale_type = \"rcu\";",
            "static struct ref_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCALE_FLAG \"-ref-scale: \"\n\nstatic char *scale_type = \"rcu\";\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void\nref_scale_print_module_parms(struct ref_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\", scale_type, tag,\n\t\t verbose, shutdown, holdoff, loops, nreaders, nruns, readdelay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->init",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %s\"",
            "scale_ops[i]->name"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scale_ops"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-scale types:\""
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\"",
            "scale_type"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scale_ops"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "scale_type",
            "cur_ops->name"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scale_ops"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "scale_type",
            "verbose"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "815-829",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic char *scale_type = \"rcu\";\nstatic struct task_struct *shutdown_task;\nstatic wait_queue_head_t shutdown_wq;\nstatic struct task_struct *main_task;\nstatic wait_queue_head_t main_wq;\nstatic struct reader_task *reader_tasks;\nstatic struct ref_scale_ops *cur_ops;\nstatic struct ref_scale_ops rcu_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= ref_rcu_read_section,\n\t.delaysection\t= ref_rcu_delay_section,\n\t.name\t\t= \"rcu\"\n};\nstatic struct ref_scale_ops srcu_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= srcu_ref_scale_read_section,\n\t.delaysection\t= srcu_ref_scale_delay_section,\n\t.name\t\t= \"srcu\"\n};\nstatic struct ref_scale_ops rcu_tasks_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= rcu_tasks_ref_scale_read_section,\n\t.delaysection\t= rcu_tasks_ref_scale_delay_section,\n\t.name\t\t= \"rcu-tasks\"\n};\nstatic struct ref_scale_ops rcu_trace_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= rcu_trace_ref_scale_read_section,\n\t.delaysection\t= rcu_trace_ref_scale_delay_section,\n\t.name\t\t= \"rcu-trace\"\n};\nstatic struct ref_scale_ops refcnt_ops = {\n\t.init\t\t= rcu_sync_scale_init,\n\t.readsection\t= ref_refcnt_section,\n\t.delaysection\t= ref_refcnt_delay_section,\n\t.name\t\t= \"refcnt\"\n};\nstatic struct ref_scale_ops rwlock_ops = {\n\t.init\t\t= ref_rwlock_init,\n\t.readsection\t= ref_rwlock_section,\n\t.delaysection\t= ref_rwlock_delay_section,\n\t.name\t\t= \"rwlock\"\n};\nstatic struct ref_scale_ops rwsem_ops = {\n\t.init\t\t= ref_rwsem_init,\n\t.readsection\t= ref_rwsem_section,\n\t.delaysection\t= ref_rwsem_delay_section,\n\t.name\t\t= \"rwsem\"\n};\nstatic struct ref_scale_ops lock_ops = {\n\t.readsection\t= ref_lock_section,\n\t.delaysection\t= ref_lock_delay_section,\n\t.name\t\t= \"lock\"\n};\nstatic struct ref_scale_ops lock_irq_ops = {\n\t.readsection\t= ref_lock_irq_section,\n\t.delaysection\t= ref_lock_irq_delay_section,\n\t.name\t\t= \"lock-irq\"\n};\nstatic struct ref_scale_ops acqrel_ops = {\n\t.readsection\t= ref_acqrel_section,\n\t.delaysection\t= ref_acqrel_delay_section,\n\t.name\t\t= \"acqrel\"\n};\nstatic struct ref_scale_ops clock_ops = {\n\t.readsection\t= ref_clock_section,\n\t.delaysection\t= ref_clock_delay_section,\n\t.name\t\t= \"clock\"\n};\n\nstatic int __init\nref_scale_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tstatic struct ref_scale_ops *scale_ops[] = {\n\t\t&rcu_ops, &srcu_ops, &rcu_trace_ops, &rcu_tasks_ops, &refcnt_ops, &rwlock_ops,\n\t\t&rwsem_ops, &lock_ops, &lock_irq_ops, &acqrel_ops, &clock_ops,\n\t};\n\n\tif (!torture_init_begin(scale_type, verbose))\n\t\treturn -EBUSY;\n\n\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++) {\n\t\tcur_ops = scale_ops[i];\n\t\tif (strcmp(scale_type, cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(scale_ops)) {\n\t\tpr_alert(\"rcu-scale: invalid scale type: \\\"%s\\\"\\n\", scale_type);\n\t\tpr_alert(\"rcu-scale types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(scale_ops); i++)\n\t\t\tpr_cont(\" %s\", scale_ops[i]->name);\n\t\tpr_cont(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tcur_ops = NULL;\n\t\tgoto unwind;\n\t}\n\tif (cur_ops->init)\n\t\tcur_ops->init();\n\n\tref_scale_print_module_parms(cur_ops, \"Start of test\");\n\n\t// Shutdown task\n\tif (shutdown) {\n\t\tinit_waitqueue_head(&shutdown_wq);\n\t\tfirsterr = torture_create_kthread(ref_scale_shutdown, NULL,\n\t\t\t\t\t\t  shutdown_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\n\t// Reader tasks (default to ~75% of online CPUs).\n\tif (nreaders < 0)\n\t\tnreaders = (num_online_cpus() >> 1) + (num_online_cpus() >> 2);\n\tif (WARN_ONCE(loops <= 0, \"%s: loops = %ld, adjusted to 1\\n\", __func__, loops))\n\t\tloops = 1;\n\tif (WARN_ONCE(nreaders <= 0, \"%s: nreaders = %d, adjusted to 1\\n\", __func__, nreaders))\n\t\tnreaders = 1;\n\tif (WARN_ONCE(nruns <= 0, \"%s: nruns = %d, adjusted to 1\\n\", __func__, nruns))\n\t\tnruns = 1;\n\treader_tasks = kcalloc(nreaders, sizeof(reader_tasks[0]),\n\t\t\t       GFP_KERNEL);\n\tif (!reader_tasks) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tVERBOSE_SCALEOUT(\"Starting %d reader threads\", nreaders);\n\n\tfor (i = 0; i < nreaders; i++) {\n\t\tfirsterr = torture_create_kthread(ref_scale_reader, (void *)i,\n\t\t\t\t\t\t  reader_tasks[i].task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\n\t\tinit_waitqueue_head(&(reader_tasks[i].wq));\n\t}\n\n\t// Main Task\n\tinit_waitqueue_head(&main_wq);\n\tfirsterr = torture_create_kthread(main_func, NULL, main_task);\n\tif (torture_init_error(firsterr))\n\t\tgoto unwind;\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tref_scale_cleanup();\n\tif (shutdown) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_RCU_REF_SCALE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}"
  },
  {
    "function_name": "ref_scale_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "775-785",
    "snippet": "static int\nref_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq, shutdown_start);\n\n\tsmp_mb(); // Wake before output.\n\tref_scale_cleanup();\n\tkernel_power_off();\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static wait_queue_head_t shutdown_wq;",
      "static int shutdown_start;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_scale_cleanup",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ref_scale_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "744-772",
          "snippet": "static void\nref_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nreaders; i++)\n\t\t\ttorture_stop_kthread(\"ref_scale_reader\",\n\t\t\t\t\t     reader_tasks[i].task);\n\t}\n\tkfree(reader_tasks);\n\n\ttorture_stop_kthread(\"main_task\", main_task);\n\tkfree(main_task);\n\n\t// Do scale-type-specific cleanup operations.\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *main_task;",
            "static struct reader_task *reader_tasks;",
            "static struct ref_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct task_struct *main_task;\nstatic struct reader_task *reader_tasks;\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void\nref_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nreaders; i++)\n\t\t\ttorture_stop_kthread(\"ref_scale_reader\",\n\t\t\t\t\t     reader_tasks[i].task);\n\t}\n\tkfree(reader_tasks);\n\n\ttorture_stop_kthread(\"main_task\", main_task);\n\tkfree(main_task);\n\n\t// Do scale-type-specific cleanup operations.\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "shutdown_wq",
            "shutdown_start"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int shutdown_start;\n\nstatic int\nref_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq, shutdown_start);\n\n\tsmp_mb(); // Wake before output.\n\tref_scale_cleanup();\n\tkernel_power_off();\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "ref_scale_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "744-772",
    "snippet": "static void\nref_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nreaders; i++)\n\t\t\ttorture_stop_kthread(\"ref_scale_reader\",\n\t\t\t\t\t     reader_tasks[i].task);\n\t}\n\tkfree(reader_tasks);\n\n\ttorture_stop_kthread(\"main_task\", main_task);\n\tkfree(main_task);\n\n\t// Do scale-type-specific cleanup operations.\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *main_task;",
      "static struct reader_task *reader_tasks;",
      "static struct ref_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur_ops->cleanup",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "main_task"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "\"main_task\"",
            "main_task"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct task_struct *main_task;\nstatic struct reader_task *reader_tasks;\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void\nref_scale_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tif (!cur_ops) {\n\t\ttorture_cleanup_end();\n\t\treturn;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < nreaders; i++)\n\t\t\ttorture_stop_kthread(\"ref_scale_reader\",\n\t\t\t\t\t     reader_tasks[i].task);\n\t}\n\tkfree(reader_tasks);\n\n\ttorture_stop_kthread(\"main_task\", main_task);\n\tkfree(main_task);\n\n\t// Do scale-type-specific cleanup operations.\n\tif (cur_ops->cleanup != NULL)\n\t\tcur_ops->cleanup();\n\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "ref_scale_print_module_parms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "736-742",
    "snippet": "static void\nref_scale_print_module_parms(struct ref_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\", scale_type, tag,\n\t\t verbose, shutdown, holdoff, loops, nreaders, nruns, readdelay);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define SCALE_FLAG \"-ref-scale: \""
    ],
    "globals_used": [
      "static char *scale_type = \"rcu\";",
      "static struct ref_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" SCALE_FLAG\n\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\"",
            "scale_type",
            "tag",
            "verbose",
            "shutdown",
            "holdoff",
            "loops",
            "nreaders",
            "nruns",
            "readdelay"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCALE_FLAG \"-ref-scale: \"\n\nstatic char *scale_type = \"rcu\";\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void\nref_scale_print_module_parms(struct ref_scale_ops *cur_ops, const char *tag)\n{\n\tpr_alert(\"%s\" SCALE_FLAG\n\t\t \"--- %s:  verbose=%d shutdown=%d holdoff=%d loops=%ld nreaders=%d nruns=%d readdelay=%d\\n\", scale_type, tag,\n\t\t verbose, shutdown, holdoff, loops, nreaders, nruns, readdelay);\n}"
  },
  {
    "function_name": "main_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "642-734",
    "snippet": "static int main_func(void *arg)\n{\n\tint exp, r;\n\tchar buf1[64];\n\tchar *buf;\n\tu64 *result_avg;\n\n\tset_cpus_allowed_ptr(current, cpumask_of(nreaders % nr_cpu_ids));\n\tset_user_nice(current, MAX_NICE);\n\n\tVERBOSE_SCALEOUT(\"main_func task started\");\n\tresult_avg = kzalloc(nruns * sizeof(*result_avg), GFP_KERNEL);\n\tbuf = kzalloc(800 + 64, GFP_KERNEL);\n\tif (!result_avg || !buf) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tgoto oom_exit;\n\t}\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\n\n\t// Wait for all threads to start.\n\tatomic_inc(&n_init);\n\twhile (atomic_read(&n_init) < nreaders + 1)\n\t\tschedule_timeout_uninterruptible(1);\n\n\t// Start exp readers up per experiment\n\tfor (exp = 0; exp < nruns && !torture_must_stop(); exp++) {\n\t\tif (torture_must_stop())\n\t\t\tgoto end;\n\n\t\treset_readers();\n\t\tatomic_set(&nreaders_exp, nreaders);\n\t\tatomic_set(&n_started, nreaders);\n\t\tatomic_set(&n_warmedup, nreaders);\n\t\tatomic_set(&n_cooleddown, nreaders);\n\n\t\texp_idx = exp;\n\n\t\tfor (r = 0; r < nreaders; r++) {\n\t\t\tsmp_store_release(&reader_tasks[r].start_reader, 1);\n\t\t\twake_up(&reader_tasks[r].wq);\n\t\t}\n\n\t\tVERBOSE_SCALEOUT(\"main_func: experiment started, waiting for %d readers\",\n\t\t\t\tnreaders);\n\n\t\twait_event(main_wq,\n\t\t\t   !atomic_read(&nreaders_exp) || torture_must_stop());\n\n\t\tVERBOSE_SCALEOUT(\"main_func: experiment ended\");\n\n\t\tif (torture_must_stop())\n\t\t\tgoto end;\n\n\t\tresult_avg[exp] = div_u64(1000 * process_durations(nreaders), nreaders * loops);\n\t}\n\n\t// Print the average of all experiments\n\tSCALEOUT(\"END OF TEST. Calculating average duration per loop (nanoseconds)...\\n\");\n\n\tpr_alert(\"Runs\\tTime(ns)\\n\");\n\tfor (exp = 0; exp < nruns; exp++) {\n\t\tu64 avg;\n\t\tu32 rem;\n\n\t\tavg = div_u64_rem(result_avg[exp], 1000, &rem);\n\t\tsprintf(buf1, \"%d\\t%llu.%03u\\n\", exp + 1, avg, rem);\n\t\tstrcat(buf, buf1);\n\t\tif (strlen(buf) >= 800) {\n\t\t\tpr_alert(\"%s\", buf);\n\t\t\tbuf[0] = 0;\n\t\t}\n\t}\n\n\tpr_alert(\"%s\", buf);\n\noom_exit:\n\t// This will shutdown everything including us.\n\tif (shutdown) {\n\t\tshutdown_start = 1;\n\t\twake_up(&shutdown_wq);\n\t}\n\n\t// Wait for torture to stop us\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n\nend:\n\ttorture_kthread_stopping(\"main_func\");\n\tkfree(result_avg);\n\tkfree(buf);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static wait_queue_head_t shutdown_wq;",
      "static wait_queue_head_t main_wq;",
      "static int shutdown_start;",
      "static struct reader_task *reader_tasks;",
      "static atomic_t nreaders_exp;",
      "static atomic_t n_init;",
      "static atomic_t n_started;",
      "static atomic_t n_warmedup;",
      "static atomic_t n_cooleddown;",
      "static int exp_idx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"main_func\""
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&shutdown_wq"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "buf1"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf1",
            "\"%d\\t%llu.%03u\\n\"",
            "exp + 1",
            "avg",
            "rem"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "result_avg[exp]",
            "1000",
            "&rem"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"Runs\\tTime(ns)\\n\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCALEOUT",
          "args": [
            "\"END OF TEST. Calculating average duration per loop (nanoseconds)...\\n\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "1000 * process_durations(nreaders)",
            "nreaders * loops"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_durations",
          "args": [
            "nreaders"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "process_durations",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "601-634",
          "snippet": "static u64 process_durations(int n)\n{\n\tint i;\n\tstruct reader_task *rt;\n\tchar buf1[64];\n\tchar *buf;\n\tu64 sum = 0;\n\n\tbuf = kmalloc(800 + 64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\tbuf[0] = 0;\n\tsprintf(buf, \"Experiment #%d (Format: <THREAD-NUM>:<Total loop time in ns>)\",\n\t\texp_idx);\n\n\tfor (i = 0; i < n && !torture_must_stop(); i++) {\n\t\trt = &(reader_tasks[i]);\n\t\tsprintf(buf1, \"%d: %llu\\t\", i, rt->last_duration_ns);\n\n\t\tif (i % 5 == 0)\n\t\t\tstrcat(buf, \"\\n\");\n\t\tif (strlen(buf) >= 800) {\n\t\t\tpr_alert(\"%s\", buf);\n\t\t\tbuf[0] = 0;\n\t\t}\n\t\tstrcat(buf, buf1);\n\n\t\tsum += rt->last_duration_ns;\n\t}\n\tpr_alert(\"%s\\n\", buf);\n\n\tkfree(buf);\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct reader_task *reader_tasks;",
            "static int exp_idx;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct reader_task *reader_tasks;\nstatic int exp_idx;\n\nstatic u64 process_durations(int n)\n{\n\tint i;\n\tstruct reader_task *rt;\n\tchar buf1[64];\n\tchar *buf;\n\tu64 sum = 0;\n\n\tbuf = kmalloc(800 + 64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\tbuf[0] = 0;\n\tsprintf(buf, \"Experiment #%d (Format: <THREAD-NUM>:<Total loop time in ns>)\",\n\t\texp_idx);\n\n\tfor (i = 0; i < n && !torture_must_stop(); i++) {\n\t\trt = &(reader_tasks[i]);\n\t\tsprintf(buf1, \"%d: %llu\\t\", i, rt->last_duration_ns);\n\n\t\tif (i % 5 == 0)\n\t\t\tstrcat(buf, \"\\n\");\n\t\tif (strlen(buf) >= 800) {\n\t\t\tpr_alert(\"%s\", buf);\n\t\t\tbuf[0] = 0;\n\t\t}\n\t\tstrcat(buf, buf1);\n\n\t\tsum += rt->last_duration_ns;\n\t}\n\tpr_alert(\"%s\\n\", buf);\n\n\tkfree(buf);\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT",
          "args": [
            "\"main_func: experiment ended\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "main_wq",
            "!atomic_read(&nreaders_exp) || torture_must_stop()"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nreaders_exp"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT",
          "args": [
            "\"main_func: experiment started, waiting for %d readers\"",
            "nreaders"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&reader_tasks[r].start_reader",
            "1"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_cooleddown",
            "nreaders"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_warmedup",
            "nreaders"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_started",
            "nreaders"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&nreaders_exp",
            "nreaders"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_readers",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "reset_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "588-598",
          "snippet": "static void reset_readers(void)\n{\n\tint i;\n\tstruct reader_task *rt;\n\n\tfor (i = 0; i < nreaders; i++) {\n\t\trt = &(reader_tasks[i]);\n\n\t\trt->last_duration_ns = 0;\n\t}\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct reader_task *reader_tasks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct reader_task *reader_tasks;\n\nstatic void reset_readers(void)\n{\n\tint i;\n\tstruct reader_task *rt;\n\n\tfor (i = 0; i < nreaders; i++) {\n\t\trt = &(reader_tasks[i]);\n\n\t\trt->last_duration_ns = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_init"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_init"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "holdoff * HZ"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCALEOUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "800 + 64",
            "GFP_KERNEL"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nruns * sizeof(*result_avg)",
            "GFP_KERNEL"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT",
          "args": [
            "\"main_func task started\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(nreaders % nr_cpu_ids)"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "nreaders % nr_cpu_ids"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic wait_queue_head_t main_wq;\nstatic int shutdown_start;\nstatic struct reader_task *reader_tasks;\nstatic atomic_t nreaders_exp;\nstatic atomic_t n_init;\nstatic atomic_t n_started;\nstatic atomic_t n_warmedup;\nstatic atomic_t n_cooleddown;\nstatic int exp_idx;\n\nstatic int main_func(void *arg)\n{\n\tint exp, r;\n\tchar buf1[64];\n\tchar *buf;\n\tu64 *result_avg;\n\n\tset_cpus_allowed_ptr(current, cpumask_of(nreaders % nr_cpu_ids));\n\tset_user_nice(current, MAX_NICE);\n\n\tVERBOSE_SCALEOUT(\"main_func task started\");\n\tresult_avg = kzalloc(nruns * sizeof(*result_avg), GFP_KERNEL);\n\tbuf = kzalloc(800 + 64, GFP_KERNEL);\n\tif (!result_avg || !buf) {\n\t\tSCALEOUT_ERRSTRING(\"out of memory\");\n\t\tgoto oom_exit;\n\t}\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\n\n\t// Wait for all threads to start.\n\tatomic_inc(&n_init);\n\twhile (atomic_read(&n_init) < nreaders + 1)\n\t\tschedule_timeout_uninterruptible(1);\n\n\t// Start exp readers up per experiment\n\tfor (exp = 0; exp < nruns && !torture_must_stop(); exp++) {\n\t\tif (torture_must_stop())\n\t\t\tgoto end;\n\n\t\treset_readers();\n\t\tatomic_set(&nreaders_exp, nreaders);\n\t\tatomic_set(&n_started, nreaders);\n\t\tatomic_set(&n_warmedup, nreaders);\n\t\tatomic_set(&n_cooleddown, nreaders);\n\n\t\texp_idx = exp;\n\n\t\tfor (r = 0; r < nreaders; r++) {\n\t\t\tsmp_store_release(&reader_tasks[r].start_reader, 1);\n\t\t\twake_up(&reader_tasks[r].wq);\n\t\t}\n\n\t\tVERBOSE_SCALEOUT(\"main_func: experiment started, waiting for %d readers\",\n\t\t\t\tnreaders);\n\n\t\twait_event(main_wq,\n\t\t\t   !atomic_read(&nreaders_exp) || torture_must_stop());\n\n\t\tVERBOSE_SCALEOUT(\"main_func: experiment ended\");\n\n\t\tif (torture_must_stop())\n\t\t\tgoto end;\n\n\t\tresult_avg[exp] = div_u64(1000 * process_durations(nreaders), nreaders * loops);\n\t}\n\n\t// Print the average of all experiments\n\tSCALEOUT(\"END OF TEST. Calculating average duration per loop (nanoseconds)...\\n\");\n\n\tpr_alert(\"Runs\\tTime(ns)\\n\");\n\tfor (exp = 0; exp < nruns; exp++) {\n\t\tu64 avg;\n\t\tu32 rem;\n\n\t\tavg = div_u64_rem(result_avg[exp], 1000, &rem);\n\t\tsprintf(buf1, \"%d\\t%llu.%03u\\n\", exp + 1, avg, rem);\n\t\tstrcat(buf, buf1);\n\t\tif (strlen(buf) >= 800) {\n\t\t\tpr_alert(\"%s\", buf);\n\t\t\tbuf[0] = 0;\n\t\t}\n\t}\n\n\tpr_alert(\"%s\", buf);\n\noom_exit:\n\t// This will shutdown everything including us.\n\tif (shutdown) {\n\t\tshutdown_start = 1;\n\t\twake_up(&shutdown_wq);\n\t}\n\n\t// Wait for torture to stop us\n\twhile (!torture_must_stop())\n\t\tschedule_timeout_uninterruptible(1);\n\nend:\n\ttorture_kthread_stopping(\"main_func\");\n\tkfree(result_avg);\n\tkfree(buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "process_durations",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "601-634",
    "snippet": "static u64 process_durations(int n)\n{\n\tint i;\n\tstruct reader_task *rt;\n\tchar buf1[64];\n\tchar *buf;\n\tu64 sum = 0;\n\n\tbuf = kmalloc(800 + 64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\tbuf[0] = 0;\n\tsprintf(buf, \"Experiment #%d (Format: <THREAD-NUM>:<Total loop time in ns>)\",\n\t\texp_idx);\n\n\tfor (i = 0; i < n && !torture_must_stop(); i++) {\n\t\trt = &(reader_tasks[i]);\n\t\tsprintf(buf1, \"%d: %llu\\t\", i, rt->last_duration_ns);\n\n\t\tif (i % 5 == 0)\n\t\t\tstrcat(buf, \"\\n\");\n\t\tif (strlen(buf) >= 800) {\n\t\t\tpr_alert(\"%s\", buf);\n\t\t\tbuf[0] = 0;\n\t\t}\n\t\tstrcat(buf, buf1);\n\n\t\tsum += rt->last_duration_ns;\n\t}\n\tpr_alert(\"%s\\n\", buf);\n\n\tkfree(buf);\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct reader_task *reader_tasks;",
      "static int exp_idx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_scale_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcuscale.c",
          "lines": "736-747",
          "snippet": "static int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static wait_queue_head_t shutdown_wq;",
            "static int kfree_nrealthreads;",
            "static atomic_t n_kfree_scale_thread_ended;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic wait_queue_head_t shutdown_wq;\nstatic int kfree_nrealthreads;\nstatic atomic_t n_kfree_scale_thread_ended;\n\nstatic int\nkfree_scale_shutdown(void *arg)\n{\n\twait_event(shutdown_wq,\n\t\t   atomic_read(&n_kfree_scale_thread_ended) >= kfree_nrealthreads);\n\n\tsmp_mb(); /* Wake before output. */\n\n\tkfree_scale_cleanup();\n\tkernel_power_off();\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\\n\"",
            "buf"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "buf1"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "buf",
            "\"\\n\""
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf1",
            "\"%d: %llu\\t\"",
            "i",
            "rt->last_duration_ns"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"Experiment #%d (Format: <THREAD-NUM>:<Total loop time in ns>)\"",
            "exp_idx"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "800 + 64",
            "GFP_KERNEL"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct reader_task *reader_tasks;\nstatic int exp_idx;\n\nstatic u64 process_durations(int n)\n{\n\tint i;\n\tstruct reader_task *rt;\n\tchar buf1[64];\n\tchar *buf;\n\tu64 sum = 0;\n\n\tbuf = kmalloc(800 + 64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\n\tbuf[0] = 0;\n\tsprintf(buf, \"Experiment #%d (Format: <THREAD-NUM>:<Total loop time in ns>)\",\n\t\texp_idx);\n\n\tfor (i = 0; i < n && !torture_must_stop(); i++) {\n\t\trt = &(reader_tasks[i]);\n\t\tsprintf(buf1, \"%d: %llu\\t\", i, rt->last_duration_ns);\n\n\t\tif (i % 5 == 0)\n\t\t\tstrcat(buf, \"\\n\");\n\t\tif (strlen(buf) >= 800) {\n\t\t\tpr_alert(\"%s\", buf);\n\t\t\tbuf[0] = 0;\n\t\t}\n\t\tstrcat(buf, buf1);\n\n\t\tsum += rt->last_duration_ns;\n\t}\n\tpr_alert(\"%s\\n\", buf);\n\n\tkfree(buf);\n\treturn sum;\n}"
  },
  {
    "function_name": "reset_readers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "588-598",
    "snippet": "static void reset_readers(void)\n{\n\tint i;\n\tstruct reader_task *rt;\n\n\tfor (i = 0; i < nreaders; i++) {\n\t\trt = &(reader_tasks[i]);\n\n\t\trt->last_duration_ns = 0;\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct reader_task *reader_tasks;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct reader_task *reader_tasks;\n\nstatic void reset_readers(void)\n{\n\tint i;\n\tstruct reader_task *rt;\n\n\tfor (i = 0; i < nreaders; i++) {\n\t\trt = &(reader_tasks[i]);\n\n\t\trt->last_duration_ns = 0;\n\t}\n}"
  },
  {
    "function_name": "ref_scale_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "516-586",
    "snippet": "static int\nref_scale_reader(void *arg)\n{\n\tunsigned long flags;\n\tlong me = (long)arg;\n\tstruct reader_task *rt = &(reader_tasks[me]);\n\tu64 start;\n\ts64 duration;\n\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: task started\", me);\n\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids)));\n\tset_user_nice(current, MAX_NICE);\n\tatomic_inc(&n_init);\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\nrepeat:\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: waiting to start next experiment on cpu %d\", me, raw_smp_processor_id());\n\n\t// Wait for signal that this reader can start.\n\twait_event(rt->wq, (atomic_read(&nreaders_exp) && smp_load_acquire(&rt->start_reader)) ||\n\t\t\t   torture_must_stop());\n\n\tif (torture_must_stop())\n\t\tgoto end;\n\n\t// Make sure that the CPU is affinitized appropriately during testing.\n\tWARN_ON_ONCE(raw_smp_processor_id() != me);\n\n\tWRITE_ONCE(rt->start_reader, 0);\n\tif (!atomic_dec_return(&n_started))\n\t\twhile (atomic_read_acquire(&n_started))\n\t\t\tcpu_relax();\n\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d started\", me, exp_idx);\n\n\n\t// To reduce noise, do an initial cache-warming invocation, check\n\t// in, and then keep warming until everyone has checked in.\n\trcu_scale_one_reader();\n\tif (!atomic_dec_return(&n_warmedup))\n\t\twhile (atomic_read_acquire(&n_warmedup))\n\t\t\trcu_scale_one_reader();\n\t// Also keep interrupts disabled.  This also has the effect\n\t// of preventing entries into slow path for rcu_read_unlock().\n\tlocal_irq_save(flags);\n\tstart = ktime_get_mono_fast_ns();\n\n\trcu_scale_one_reader();\n\n\tduration = ktime_get_mono_fast_ns() - start;\n\tlocal_irq_restore(flags);\n\n\trt->last_duration_ns = WARN_ON_ONCE(duration < 0) ? 0 : duration;\n\t// To reduce runtime-skew noise, do maintain-load invocations until\n\t// everyone is done.\n\tif (!atomic_dec_return(&n_cooleddown))\n\t\twhile (atomic_read_acquire(&n_cooleddown))\n\t\t\trcu_scale_one_reader();\n\n\tif (atomic_dec_and_test(&nreaders_exp))\n\t\twake_up(&main_wq);\n\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d ended, (readers remaining=%d)\",\n\t\t\t\tme, exp_idx, atomic_read(&nreaders_exp));\n\n\tif (!torture_must_stop())\n\t\tgoto repeat;\nend:\n\ttorture_kthread_stopping(\"ref_scale_reader\");\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static wait_queue_head_t main_wq;",
      "static struct reader_task *reader_tasks;",
      "static atomic_t nreaders_exp;",
      "static atomic_t n_init;",
      "static atomic_t n_started;",
      "static atomic_t n_warmedup;",
      "static atomic_t n_cooleddown;",
      "static int exp_idx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"ref_scale_reader\""
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_BATCH",
          "args": [
            "\"ref_scale_reader %ld: experiment %d ended, (readers remaining=%d)\"",
            "me",
            "exp_idx",
            "atomic_read(&nreaders_exp)"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nreaders_exp"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&main_wq"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&nreaders_exp"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_scale_one_reader",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_scale_one_reader",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "506-512",
          "snippet": "static void rcu_scale_one_reader(void)\n{\n\tif (readdelay <= 0)\n\t\tcur_ops->readsection(loops);\n\telse\n\t\tcur_ops->delaysection(loops, readdelay / 1000, readdelay % 1000);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ref_scale_ops *cur_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void rcu_scale_one_reader(void)\n{\n\tif (readdelay <= 0)\n\t\tcur_ops->readsection(loops);\n\telse\n\t\tcur_ops->delaysection(loops, readdelay / 1000, readdelay % 1000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&n_cooleddown"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&n_cooleddown"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "duration < 0"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&n_warmedup"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&n_warmedup"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_BATCH",
          "args": [
            "\"ref_scale_reader %ld: experiment %d started\"",
            "me",
            "exp_idx"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&n_started"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&n_started"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rt->start_reader",
            "0"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "raw_smp_processor_id() != me"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rt->wq",
            "(atomic_read(&nreaders_exp) && smp_load_acquire(&rt->start_reader)) ||\n\t\t\t   torture_must_stop()"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&rt->start_reader"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nreaders_exp"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_BATCH",
          "args": [
            "\"ref_scale_reader %ld: waiting to start next experiment on cpu %d\"",
            "me",
            "raw_smp_processor_id()"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "holdoff * HZ"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_init"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids))"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(me % nr_cpu_ids)"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "me % nr_cpu_ids"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCALEOUT_BATCH",
          "args": [
            "\"ref_scale_reader %ld: task started\"",
            "me"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic wait_queue_head_t main_wq;\nstatic struct reader_task *reader_tasks;\nstatic atomic_t nreaders_exp;\nstatic atomic_t n_init;\nstatic atomic_t n_started;\nstatic atomic_t n_warmedup;\nstatic atomic_t n_cooleddown;\nstatic int exp_idx;\n\nstatic int\nref_scale_reader(void *arg)\n{\n\tunsigned long flags;\n\tlong me = (long)arg;\n\tstruct reader_task *rt = &(reader_tasks[me]);\n\tu64 start;\n\ts64 duration;\n\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: task started\", me);\n\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids)));\n\tset_user_nice(current, MAX_NICE);\n\tatomic_inc(&n_init);\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\nrepeat:\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: waiting to start next experiment on cpu %d\", me, raw_smp_processor_id());\n\n\t// Wait for signal that this reader can start.\n\twait_event(rt->wq, (atomic_read(&nreaders_exp) && smp_load_acquire(&rt->start_reader)) ||\n\t\t\t   torture_must_stop());\n\n\tif (torture_must_stop())\n\t\tgoto end;\n\n\t// Make sure that the CPU is affinitized appropriately during testing.\n\tWARN_ON_ONCE(raw_smp_processor_id() != me);\n\n\tWRITE_ONCE(rt->start_reader, 0);\n\tif (!atomic_dec_return(&n_started))\n\t\twhile (atomic_read_acquire(&n_started))\n\t\t\tcpu_relax();\n\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d started\", me, exp_idx);\n\n\n\t// To reduce noise, do an initial cache-warming invocation, check\n\t// in, and then keep warming until everyone has checked in.\n\trcu_scale_one_reader();\n\tif (!atomic_dec_return(&n_warmedup))\n\t\twhile (atomic_read_acquire(&n_warmedup))\n\t\t\trcu_scale_one_reader();\n\t// Also keep interrupts disabled.  This also has the effect\n\t// of preventing entries into slow path for rcu_read_unlock().\n\tlocal_irq_save(flags);\n\tstart = ktime_get_mono_fast_ns();\n\n\trcu_scale_one_reader();\n\n\tduration = ktime_get_mono_fast_ns() - start;\n\tlocal_irq_restore(flags);\n\n\trt->last_duration_ns = WARN_ON_ONCE(duration < 0) ? 0 : duration;\n\t// To reduce runtime-skew noise, do maintain-load invocations until\n\t// everyone is done.\n\tif (!atomic_dec_return(&n_cooleddown))\n\t\twhile (atomic_read_acquire(&n_cooleddown))\n\t\t\trcu_scale_one_reader();\n\n\tif (atomic_dec_and_test(&nreaders_exp))\n\t\twake_up(&main_wq);\n\n\tVERBOSE_SCALEOUT_BATCH(\"ref_scale_reader %ld: experiment %d ended, (readers remaining=%d)\",\n\t\t\t\tme, exp_idx, atomic_read(&nreaders_exp));\n\n\tif (!torture_must_stop())\n\t\tgoto repeat;\nend:\n\ttorture_kthread_stopping(\"ref_scale_reader\");\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_scale_one_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "506-512",
    "snippet": "static void rcu_scale_one_reader(void)\n{\n\tif (readdelay <= 0)\n\t\tcur_ops->readsection(loops);\n\telse\n\t\tcur_ops->delaysection(loops, readdelay / 1000, readdelay % 1000);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ref_scale_ops *cur_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cur_ops->delaysection",
          "args": [
            "loops",
            "readdelay / 1000",
            "readdelay % 1000"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur_ops->readsection",
          "args": [
            "loops"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct ref_scale_ops *cur_ops;\n\nstatic void rcu_scale_one_reader(void)\n{\n\tif (readdelay <= 0)\n\t\tcur_ops->readsection(loops);\n\telse\n\t\tcur_ops->delaysection(loops, readdelay / 1000, readdelay % 1000);\n}"
  },
  {
    "function_name": "ref_clock_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "486-498",
    "snippet": "static void ref_clock_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tu64 x = 0;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tx += ktime_get_real_fast_ns();\n\t\tun_delay(udl, ndl);\n\t}\n\tpreempt_enable();\n\tstopopts = x;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile u64 stopopts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_fast_ns",
          "args": [],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "562-565",
          "snippet": "u64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic volatile u64 stopopts;\n\nstatic void ref_clock_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tu64 x = 0;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tx += ktime_get_real_fast_ns();\n\t\tun_delay(udl, ndl);\n\t}\n\tpreempt_enable();\n\tstopopts = x;\n}"
  },
  {
    "function_name": "ref_clock_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "474-484",
    "snippet": "static void ref_clock_section(const int nloops)\n{\n\tu64 x = 0;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--)\n\t\tx += ktime_get_real_fast_ns();\n\tpreempt_enable();\n\tstopopts = x;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static volatile u64 stopopts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_fast_ns",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "562-565",
          "snippet": "u64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_real_fast_ns(void)\n{\n\treturn __ktime_get_real_fast(&tk_fast_mono, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic volatile u64 stopopts;\n\nstatic void ref_clock_section(const int nloops)\n{\n\tu64 x = 0;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--)\n\t\tx += ktime_get_real_fast_ns();\n\tpreempt_enable();\n\tstopopts = x;\n}"
  },
  {
    "function_name": "ref_acqrel_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "452-464",
    "snippet": "static void ref_acqrel_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tunsigned long x;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));\n\t\tun_delay(udl, ndl);\n\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, test_acqrel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "this_cpu_ptr(&test_acqrel)",
            "x + 1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&test_acqrel"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "this_cpu_ptr(&test_acqrel)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&test_acqrel"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(unsigned long, test_acqrel);\n\nstatic void ref_acqrel_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tunsigned long x;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));\n\t\tun_delay(udl, ndl);\n\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "ref_acqrel_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "439-450",
    "snippet": "static void ref_acqrel_section(const int nloops)\n{\n\tunsigned long x;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));\n\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, test_acqrel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "this_cpu_ptr(&test_acqrel)",
            "x + 1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&test_acqrel"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "this_cpu_ptr(&test_acqrel)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&test_acqrel"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(unsigned long, test_acqrel);\n\nstatic void ref_acqrel_section(const int nloops)\n{\n\tunsigned long x;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tx = smp_load_acquire(this_cpu_ptr(&test_acqrel));\n\t\tsmp_store_release(this_cpu_ptr(&test_acqrel), x + 1);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "ref_lock_irq_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "416-428",
    "snippet": "static void ref_lock_irq_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tunsigned long flags;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock_irqsave(&test_lock, flags);\n\t\tun_delay(udl, ndl);\n\t\tspin_unlock_irqrestore(&test_lock, flags);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(test_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&test_lock",
            "flags"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&test_lock",
            "flags"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(test_lock);\n\nstatic void ref_lock_irq_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tunsigned long flags;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock_irqsave(&test_lock, flags);\n\t\tun_delay(udl, ndl);\n\t\tspin_unlock_irqrestore(&test_lock, flags);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "ref_lock_irq_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "403-414",
    "snippet": "static void ref_lock_irq_section(const int nloops)\n{\n\tunsigned long flags;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock_irqsave(&test_lock, flags);\n\t\tspin_unlock_irqrestore(&test_lock, flags);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(test_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&test_lock",
            "flags"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&test_lock",
            "flags"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(test_lock);\n\nstatic void ref_lock_irq_section(const int nloops)\n{\n\tunsigned long flags;\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock_irqsave(&test_lock, flags);\n\t\tspin_unlock_irqrestore(&test_lock, flags);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "ref_lock_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "382-393",
    "snippet": "static void ref_lock_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock(&test_lock);\n\t\tun_delay(udl, ndl);\n\t\tspin_unlock(&test_lock);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(test_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&test_lock"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&test_lock"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(test_lock);\n\nstatic void ref_lock_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock(&test_lock);\n\t\tun_delay(udl, ndl);\n\t\tspin_unlock(&test_lock);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "ref_lock_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "370-380",
    "snippet": "static void ref_lock_section(const int nloops)\n{\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock(&test_lock);\n\t\tspin_unlock(&test_lock);\n\t}\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(test_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&test_lock"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&test_lock"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(test_lock);\n\nstatic void ref_lock_section(const int nloops)\n{\n\tint i;\n\n\tpreempt_disable();\n\tfor (i = nloops; i >= 0; i--) {\n\t\tspin_lock(&test_lock);\n\t\tspin_unlock(&test_lock);\n\t}\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "ref_rwsem_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "349-358",
    "snippet": "static void ref_rwsem_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tdown_read(&test_rwsem);\n\t\tun_delay(udl, ndl);\n\t\tup_read(&test_rwsem);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rw_semaphore test_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&test_rwsem"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&test_rwsem"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct rw_semaphore test_rwsem;\n\nstatic void ref_rwsem_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tdown_read(&test_rwsem);\n\t\tun_delay(udl, ndl);\n\t\tup_read(&test_rwsem);\n\t}\n}"
  },
  {
    "function_name": "ref_rwsem_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "339-347",
    "snippet": "static void ref_rwsem_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tdown_read(&test_rwsem);\n\t\tup_read(&test_rwsem);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rw_semaphore test_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&test_rwsem"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&test_rwsem"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct rw_semaphore test_rwsem;\n\nstatic void ref_rwsem_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tdown_read(&test_rwsem);\n\t\tup_read(&test_rwsem);\n\t}\n}"
  },
  {
    "function_name": "ref_rwsem_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "334-337",
    "snippet": "static void ref_rwsem_init(void)\n{\n\tinit_rwsem(&test_rwsem);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rw_semaphore test_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&test_rwsem"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct rw_semaphore test_rwsem;\n\nstatic void ref_rwsem_init(void)\n{\n\tinit_rwsem(&test_rwsem);\n}"
  },
  {
    "function_name": "ref_rwlock_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "313-322",
    "snippet": "static void ref_rwlock_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tread_lock(&test_rwlock);\n\t\tun_delay(udl, ndl);\n\t\tread_unlock(&test_rwlock);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static rwlock_t test_rwlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&test_rwlock"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_trace_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1136-1149",
          "snippet": "void rcu_read_unlock_trace_special(struct task_struct *t)\n{\n\tint nq = READ_ONCE(t->trc_reader_special.b.need_qs);\n\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB) &&\n\t    t->trc_reader_special.b.need_mb)\n\t\tsmp_mb(); // Pairs with update-side barriers.\n\t// Update .need_qs before ->trc_reader_nesting for irq/NMI handlers.\n\tif (nq)\n\t\tWRITE_ONCE(t->trc_reader_special.b.need_qs, false);\n\tWRITE_ONCE(t->trc_reader_nesting, 0);\n\tif (nq && atomic_dec_and_test(&trc_n_readers_need_end))\n\t\tirq_work_queue(&rcu_tasks_trace_iw);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_read_unlock_trace_special(struct task_struct *t)\n{\n\tint nq = READ_ONCE(t->trc_reader_special.b.need_qs);\n\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB) &&\n\t    t->trc_reader_special.b.need_mb)\n\t\tsmp_mb(); // Pairs with update-side barriers.\n\t// Update .need_qs before ->trc_reader_nesting for irq/NMI handlers.\n\tif (nq)\n\t\tWRITE_ONCE(t->trc_reader_special.b.need_qs, false);\n\tWRITE_ONCE(t->trc_reader_nesting, 0);\n\tif (nq && atomic_dec_and_test(&trc_n_readers_need_end))\n\t\tirq_work_queue(&rcu_tasks_trace_iw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&test_rwlock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic rwlock_t test_rwlock;\n\nstatic void ref_rwlock_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tread_lock(&test_rwlock);\n\t\tun_delay(udl, ndl);\n\t\tread_unlock(&test_rwlock);\n\t}\n}"
  },
  {
    "function_name": "ref_rwlock_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "303-311",
    "snippet": "static void ref_rwlock_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tread_lock(&test_rwlock);\n\t\tread_unlock(&test_rwlock);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static rwlock_t test_rwlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&test_rwlock"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_trace_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1136-1149",
          "snippet": "void rcu_read_unlock_trace_special(struct task_struct *t)\n{\n\tint nq = READ_ONCE(t->trc_reader_special.b.need_qs);\n\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB) &&\n\t    t->trc_reader_special.b.need_mb)\n\t\tsmp_mb(); // Pairs with update-side barriers.\n\t// Update .need_qs before ->trc_reader_nesting for irq/NMI handlers.\n\tif (nq)\n\t\tWRITE_ONCE(t->trc_reader_special.b.need_qs, false);\n\tWRITE_ONCE(t->trc_reader_nesting, 0);\n\tif (nq && atomic_dec_and_test(&trc_n_readers_need_end))\n\t\tirq_work_queue(&rcu_tasks_trace_iw);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid rcu_read_unlock_trace_special(struct task_struct *t)\n{\n\tint nq = READ_ONCE(t->trc_reader_special.b.need_qs);\n\n\tif (IS_ENABLED(CONFIG_TASKS_TRACE_RCU_READ_MB) &&\n\t    t->trc_reader_special.b.need_mb)\n\t\tsmp_mb(); // Pairs with update-side barriers.\n\t// Update .need_qs before ->trc_reader_nesting for irq/NMI handlers.\n\tif (nq)\n\t\tWRITE_ONCE(t->trc_reader_special.b.need_qs, false);\n\tWRITE_ONCE(t->trc_reader_nesting, 0);\n\tif (nq && atomic_dec_and_test(&trc_n_readers_need_end))\n\t\tirq_work_queue(&rcu_tasks_trace_iw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&test_rwlock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic rwlock_t test_rwlock;\n\nstatic void ref_rwlock_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tread_lock(&test_rwlock);\n\t\tread_unlock(&test_rwlock);\n\t}\n}"
  },
  {
    "function_name": "ref_rwlock_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "298-301",
    "snippet": "static void ref_rwlock_init(void)\n{\n\trwlock_init(&test_rwlock);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static rwlock_t test_rwlock;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&test_rwlock"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic rwlock_t test_rwlock;\n\nstatic void ref_rwlock_init(void)\n{\n\trwlock_init(&test_rwlock);\n}"
  },
  {
    "function_name": "ref_refcnt_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "277-286",
    "snippet": "static void ref_refcnt_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tatomic_inc(&refcnt);\n\t\tun_delay(udl, ndl);\n\t\tatomic_dec(&refcnt);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t refcnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&refcnt"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&refcnt"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic atomic_t refcnt;\n\nstatic void ref_refcnt_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tatomic_inc(&refcnt);\n\t\tun_delay(udl, ndl);\n\t\tatomic_dec(&refcnt);\n\t}\n}"
  },
  {
    "function_name": "ref_refcnt_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "267-275",
    "snippet": "static void ref_refcnt_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tatomic_inc(&refcnt);\n\t\tatomic_dec(&refcnt);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t refcnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&refcnt"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&refcnt"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic atomic_t refcnt;\n\nstatic void ref_refcnt_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tatomic_inc(&refcnt);\n\t\tatomic_dec(&refcnt);\n\t}\n}"
  },
  {
    "function_name": "rcu_trace_ref_scale_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "246-255",
    "snippet": "static void rcu_trace_ref_scale_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock_trace();\n\t\tun_delay(udl, ndl);\n\t\trcu_read_unlock_trace();\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_trace",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_trace",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void rcu_trace_ref_scale_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock_trace();\n\t\tun_delay(udl, ndl);\n\t\trcu_read_unlock_trace();\n\t}\n}"
  },
  {
    "function_name": "rcu_trace_ref_scale_read_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "236-244",
    "snippet": "static void rcu_trace_ref_scale_read_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock_trace();\n\t\trcu_read_unlock_trace();\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_trace",
          "args": [],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_trace",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void rcu_trace_ref_scale_read_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock_trace();\n\t\trcu_read_unlock_trace();\n\t}\n}"
  },
  {
    "function_name": "rcu_tasks_ref_scale_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "220-226",
    "snippet": "static void rcu_tasks_ref_scale_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--)\n\t\tun_delay(udl, ndl);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void rcu_tasks_ref_scale_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--)\n\t\tun_delay(udl, ndl);\n}"
  },
  {
    "function_name": "rcu_tasks_ref_scale_read_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "212-218",
    "snippet": "static void rcu_tasks_ref_scale_read_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--)\n\t\tcontinue;\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void rcu_tasks_ref_scale_read_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--)\n\t\tcontinue;\n}"
  },
  {
    "function_name": "srcu_ref_scale_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "191-201",
    "snippet": "static void srcu_ref_scale_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\tint idx;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tidx = srcu_read_lock(srcu_ctlp);\n\t\tun_delay(udl, ndl);\n\t\tsrcu_read_unlock(srcu_ctlp, idx);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_refctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "srcu_ctlp",
            "idx"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "416-420",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "srcu_ctlp"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_refctl_scale;\n\nstatic void srcu_ref_scale_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\tint idx;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tidx = srcu_read_lock(srcu_ctlp);\n\t\tun_delay(udl, ndl);\n\t\tsrcu_read_unlock(srcu_ctlp, idx);\n\t}\n}"
  },
  {
    "function_name": "srcu_ref_scale_read_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "180-189",
    "snippet": "static void srcu_ref_scale_read_section(const int nloops)\n{\n\tint i;\n\tint idx;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tidx = srcu_read_lock(srcu_ctlp);\n\t\tsrcu_read_unlock(srcu_ctlp, idx);\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct srcu_struct *srcu_ctlp = &srcu_refctl_scale;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "srcu_ctlp",
            "idx"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "416-420",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "srcu_ctlp"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct srcu_struct *srcu_ctlp = &srcu_refctl_scale;\n\nstatic void srcu_ref_scale_read_section(const int nloops)\n{\n\tint i;\n\tint idx;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\tidx = srcu_read_lock(srcu_ctlp);\n\t\tsrcu_read_unlock(srcu_ctlp, idx);\n\t}\n}"
  },
  {
    "function_name": "rcu_sync_scale_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "165-167",
    "snippet": "static void rcu_sync_scale_init(void)\n{\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void rcu_sync_scale_init(void)\n{\n}"
  },
  {
    "function_name": "ref_rcu_delay_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "154-163",
    "snippet": "static void ref_rcu_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock();\n\t\tun_delay(udl, ndl);\n\t\trcu_read_unlock();\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "un_delay",
          "args": [
            "udl",
            "ndl"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "un_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
          "lines": "136-142",
          "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void ref_rcu_delay_section(const int nloops, const int udl, const int ndl)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock();\n\t\tun_delay(udl, ndl);\n\t\trcu_read_unlock();\n\t}\n}"
  },
  {
    "function_name": "ref_rcu_read_section",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "144-152",
    "snippet": "static void ref_rcu_read_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void ref_rcu_read_section(const int nloops)\n{\n\tint i;\n\n\tfor (i = nloops; i >= 0; i--) {\n\t\trcu_read_lock();\n\t\trcu_read_unlock();\n\t}\n}"
  },
  {
    "function_name": "un_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/refscale.c",
    "lines": "136-142",
    "snippet": "static void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}",
    "includes": [
      "#include \"rcu.h\"",
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndelay",
          "args": [
            "ndl"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "udl"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu.h\"\n#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void un_delay(const int udl, const int ndl)\n{\n\tif (udl)\n\t\tudelay(udl);\n\tif (ndl)\n\t\tndelay(ndl);\n}"
  }
]