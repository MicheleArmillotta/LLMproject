[
  {
    "function_name": "dma_common_free_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
    "lines": "84-93",
    "snippet": "void dma_common_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (ops->unmap_page)\n\t\tops->unmap_page(dev, dma_handle, size, dir,\n\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);\n\tdma_free_contiguous(dev, page, size);\n}",
    "includes": [
      "#include <linux/dma-map-ops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dma_free_contiguous",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "347-370",
          "snippet": "void dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nvoid dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->unmap_page",
          "args": [
            "dev",
            "dma_handle",
            "size",
            "dir",
            "DMA_ATTR_SKIP_CPU_SYNC"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nvoid dma_common_free_pages(struct device *dev, size_t size, struct page *page,\n\t\tdma_addr_t dma_handle, enum dma_data_direction dir)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tif (ops->unmap_page)\n\t\tops->unmap_page(dev, dma_handle, size, dir,\n\t\t\t\tDMA_ATTR_SKIP_CPU_SYNC);\n\tdma_free_contiguous(dev, page, size);\n}"
  },
  {
    "function_name": "dma_common_alloc_pages",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
    "lines": "61-82",
    "snippet": "struct page *dma_common_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tstruct page *page;\n\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (!page)\n\t\tpage = alloc_pages_node(dev_to_node(dev), gfp, get_order(size));\n\tif (!page)\n\t\treturn NULL;\n\n\t*dma_handle = ops->map_page(dev, page, 0, size, dir,\n\t\t\t\t    DMA_ATTR_SKIP_CPU_SYNC);\n\tif (*dma_handle == DMA_MAPPING_ERROR) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\tmemset(page_address(page), 0, size);\n\treturn page;\n}",
    "includes": [
      "#include <linux/dma-map-ops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page)",
            "0",
            "size"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_free_contiguous",
          "args": [
            "dev",
            "page",
            "size"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "dma_free_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "347-370",
          "snippet": "void dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nvoid dma_free_contiguous(struct device *dev, struct page *page, size_t size)\n{\n\tunsigned int count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\n\t/* if dev has its own cma, free page from there */\n\tif (dev->cma_area) {\n\t\tif (cma_release(dev->cma_area, page, count))\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * otherwise, page is from either per-numa cma or default cma\n\t\t */\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\t\tif (cma_release(dma_contiguous_pernuma_area[page_to_nid(page)],\n\t\t\t\t\tpage, count))\n\t\t\treturn;\n#endif\n\t\tif (cma_release(dma_contiguous_default_area, page, count))\n\t\t\treturn;\n\t}\n\n\t/* not in any cma, free from buddy */\n\t__free_pages(page, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->map_page",
          "args": [
            "dev",
            "page",
            "0",
            "size",
            "dir",
            "DMA_ATTR_SKIP_CPU_SYNC"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "dev_to_node(dev)",
            "gfp",
            "get_order(size)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_alloc_contiguous",
          "args": [
            "dev",
            "size",
            "gfp"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "dma_alloc_contiguous",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/contiguous.c",
          "lines": "304-334",
          "snippet": "struct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp)\n{\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tint nid = dev_to_node(dev);\n#endif\n\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (!gfpflags_allow_blocking(gfp))\n\t\treturn NULL;\n\tif (dev->cma_area)\n\t\treturn cma_alloc_aligned(dev->cma_area, size, gfp);\n\tif (size <= PAGE_SIZE)\n\t\treturn NULL;\n\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tif (nid != NUMA_NO_NODE && !(gfp & (GFP_DMA | GFP_DMA32))) {\n\t\tstruct cma *cma = dma_contiguous_pernuma_area[nid];\n\t\tstruct page *page;\n\n\t\tif (cma) {\n\t\t\tpage = cma_alloc_aligned(cma, size, gfp);\n\t\t\tif (page)\n\t\t\t\treturn page;\n\t\t}\n\t}\n#endif\n\tif (!dma_contiguous_default_area)\n\t\treturn NULL;\n\n\treturn cma_alloc_aligned(dma_contiguous_default_area, size, gfp);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/cma.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/sizes.h>",
            "#include <linux/err.h>",
            "#include <linux/memblock.h>",
            "#include <asm/page.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cma *dma_contiguous_default_area;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/cma.h>\n#include <linux/dma-map-ops.h>\n#include <linux/sizes.h>\n#include <linux/err.h>\n#include <linux/memblock.h>\n#include <asm/page.h>\n\nstruct cma *dma_contiguous_default_area;\n\nstruct page *dma_alloc_contiguous(struct device *dev, size_t size, gfp_t gfp)\n{\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tint nid = dev_to_node(dev);\n#endif\n\n\t/* CMA can be used only in the context which permits sleeping */\n\tif (!gfpflags_allow_blocking(gfp))\n\t\treturn NULL;\n\tif (dev->cma_area)\n\t\treturn cma_alloc_aligned(dev->cma_area, size, gfp);\n\tif (size <= PAGE_SIZE)\n\t\treturn NULL;\n\n#ifdef CONFIG_DMA_PERNUMA_CMA\n\tif (nid != NUMA_NO_NODE && !(gfp & (GFP_DMA | GFP_DMA32))) {\n\t\tstruct cma *cma = dma_contiguous_pernuma_area[nid];\n\t\tstruct page *page;\n\n\t\tif (cma) {\n\t\t\tpage = cma_alloc_aligned(cma, size, gfp);\n\t\t\tif (page)\n\t\t\t\treturn page;\n\t\t}\n\t}\n#endif\n\tif (!dma_contiguous_default_area)\n\t\treturn NULL;\n\n\treturn cma_alloc_aligned(dma_contiguous_default_area, size, gfp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dma_ops",
          "args": [
            "dev"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nstruct page *dma_common_alloc_pages(struct device *dev, size_t size,\n\t\tdma_addr_t *dma_handle, enum dma_data_direction dir, gfp_t gfp)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\tstruct page *page;\n\n\tpage = dma_alloc_contiguous(dev, size, gfp);\n\tif (!page)\n\t\tpage = alloc_pages_node(dev_to_node(dev), gfp, get_order(size));\n\tif (!page)\n\t\treturn NULL;\n\n\t*dma_handle = ops->map_page(dev, page, 0, size, dir,\n\t\t\t\t    DMA_ATTR_SKIP_CPU_SYNC);\n\tif (*dma_handle == DMA_MAPPING_ERROR) {\n\t\tdma_free_contiguous(dev, page, size);\n\t\treturn NULL;\n\t}\n\n\tmemset(page_address(page), 0, size);\n\treturn page;\n}"
  },
  {
    "function_name": "dma_common_mmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
    "lines": "34-59",
    "snippet": "int dma_common_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n#ifdef CONFIG_MMU\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long off = vma->vm_pgoff;\n\tstruct page *page = dma_common_vaddr_to_page(cpu_addr);\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (off >= count || user_count > count - off)\n\t\treturn -ENXIO;\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\tpage_to_pfn(page) + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n#else\n\treturn -ENXIO;\n#endif /* CONFIG_MMU */\n}",
    "includes": [
      "#include <linux/dma-map-ops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remap_pfn_range",
          "args": [
            "vma",
            "vma->vm_start",
            "page_to_pfn(page) + vma->vm_pgoff",
            "user_count << PAGE_SHIFT",
            "vma->vm_page_prot"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_mmap_from_dev_coherent",
          "args": [
            "dev",
            "vma",
            "cpu_addr",
            "size",
            "&ret"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "dma_mmap_from_dev_coherent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/coherent.c",
          "lines": "263-269",
          "snippet": "int dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t   void *vaddr, size_t size, int *ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);\n}",
          "includes": [
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\nint dma_mmap_from_dev_coherent(struct device *dev, struct vm_area_struct *vma,\n\t\t\t   void *vaddr, size_t size, int *ret)\n{\n\tstruct dma_coherent_mem *mem = dev_get_coherent_memory(dev);\n\n\treturn __dma_mmap_from_coherent(mem, vma, vaddr, size, ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_pgprot",
          "args": [
            "dev",
            "vma->vm_page_prot",
            "attrs"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "dma_pgprot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/mapping.c",
          "lines": "408-419",
          "snippet": "pgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include \"debug.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_device.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/acpi.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include \"debug.h\"\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/of_device.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/dma-map-ops.h>\n#include <linux/acpi.h>\n#include <linux/memblock.h> /* for max_pfn */\n\npgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)\n{\n\tif (force_dma_unencrypted(dev))\n\t\tprot = pgprot_decrypted(prot);\n\tif (dev_is_dma_coherent(dev))\n\t\treturn prot;\n#ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE\n\tif (attrs & DMA_ATTR_WRITE_COMBINE)\n\t\treturn pgprot_writecombine(prot);\n#endif\n\treturn pgprot_dmacoherent(prot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_common_vaddr_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "dma_common_vaddr_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
          "lines": "8-13",
          "snippet": "static struct page *dma_common_vaddr_to_page(void *cpu_addr)\n{\n\tif (is_vmalloc_addr(cpu_addr))\n\t\treturn vmalloc_to_page(cpu_addr);\n\treturn virt_to_page(cpu_addr);\n}",
          "includes": [
            "#include <linux/dma-map-ops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nstatic struct page *dma_common_vaddr_to_page(void *cpu_addr)\n{\n\tif (is_vmalloc_addr(cpu_addr))\n\t\treturn vmalloc_to_page(cpu_addr);\n\treturn virt_to_page(cpu_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_pages",
          "args": [
            "vma"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nint dma_common_mmap(struct device *dev, struct vm_area_struct *vma,\n\t\tvoid *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\tunsigned long attrs)\n{\n#ifdef CONFIG_MMU\n\tunsigned long user_count = vma_pages(vma);\n\tunsigned long count = PAGE_ALIGN(size) >> PAGE_SHIFT;\n\tunsigned long off = vma->vm_pgoff;\n\tstruct page *page = dma_common_vaddr_to_page(cpu_addr);\n\tint ret = -ENXIO;\n\n\tvma->vm_page_prot = dma_pgprot(dev, vma->vm_page_prot, attrs);\n\n\tif (dma_mmap_from_dev_coherent(dev, vma, cpu_addr, size, &ret))\n\t\treturn ret;\n\n\tif (off >= count || user_count > count - off)\n\t\treturn -ENXIO;\n\n\treturn remap_pfn_range(vma, vma->vm_start,\n\t\t\tpage_to_pfn(page) + vma->vm_pgoff,\n\t\t\tuser_count << PAGE_SHIFT, vma->vm_page_prot);\n#else\n\treturn -ENXIO;\n#endif /* CONFIG_MMU */\n}"
  },
  {
    "function_name": "dma_common_get_sgtable",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
    "lines": "18-29",
    "snippet": "int dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\t void *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\t unsigned long attrs)\n{\n\tstruct page *page = dma_common_vaddr_to_page(cpu_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/dma-map-ops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "sgt->sgl",
            "page",
            "PAGE_ALIGN(size)",
            "0"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "size"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_alloc_table",
          "args": [
            "sgt",
            "1",
            "GFP_KERNEL"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_common_vaddr_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "dma_common_vaddr_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
          "lines": "8-13",
          "snippet": "static struct page *dma_common_vaddr_to_page(void *cpu_addr)\n{\n\tif (is_vmalloc_addr(cpu_addr))\n\t\treturn vmalloc_to_page(cpu_addr);\n\treturn virt_to_page(cpu_addr);\n}",
          "includes": [
            "#include <linux/dma-map-ops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nstatic struct page *dma_common_vaddr_to_page(void *cpu_addr)\n{\n\tif (is_vmalloc_addr(cpu_addr))\n\t\treturn vmalloc_to_page(cpu_addr);\n\treturn virt_to_page(cpu_addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nint dma_common_get_sgtable(struct device *dev, struct sg_table *sgt,\n\t\t void *cpu_addr, dma_addr_t dma_addr, size_t size,\n\t\t unsigned long attrs)\n{\n\tstruct page *page = dma_common_vaddr_to_page(cpu_addr);\n\tint ret;\n\n\tret = sg_alloc_table(sgt, 1, GFP_KERNEL);\n\tif (!ret)\n\t\tsg_set_page(sgt->sgl, page, PAGE_ALIGN(size), 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "dma_common_vaddr_to_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/ops_helpers.c",
    "lines": "8-13",
    "snippet": "static struct page *dma_common_vaddr_to_page(void *cpu_addr)\n{\n\tif (is_vmalloc_addr(cpu_addr))\n\t\treturn vmalloc_to_page(cpu_addr);\n\treturn virt_to_page(cpu_addr);\n}",
    "includes": [
      "#include <linux/dma-map-ops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "cpu_addr"
          ],
          "line": 11
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_vmalloc_addr",
          "args": [
            "cpu_addr"
          ],
          "line": 10
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-map-ops.h>\n\nstatic struct page *dma_common_vaddr_to_page(void *cpu_addr)\n{\n\tif (is_vmalloc_addr(cpu_addr))\n\t\treturn vmalloc_to_page(cpu_addr);\n\treturn virt_to_page(cpu_addr);\n}"
  }
]