[
  {
    "function_name": "dynevent_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "482-485",
    "snippet": "int dynevent_create(struct dynevent_cmd *cmd)\n{\n\treturn cmd->run_command(cmd);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd->run_command",
          "args": [
            "cmd"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_create(struct dynevent_cmd *cmd)\n{\n\treturn cmd->run_command(cmd);\n}"
  },
  {
    "function_name": "dynevent_arg_pair_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "457-469",
    "snippet": "void dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,\n\t\t\t    char operator, char separator)\n{\n\tmemset(arg_pair, '\\0', sizeof(*arg_pair));\n\n\tif (!operator)\n\t\toperator = ' ';\n\targ_pair->operator = operator;\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ_pair->separator = separator;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "arg_pair",
            "'\\0'",
            "sizeof(*arg_pair)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_pair_init(struct dynevent_arg_pair *arg_pair,\n\t\t\t    char operator, char separator)\n{\n\tmemset(arg_pair, '\\0', sizeof(*arg_pair));\n\n\tif (!operator)\n\t\toperator = ' ';\n\targ_pair->operator = operator;\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ_pair->separator = separator;\n}"
  },
  {
    "function_name": "dynevent_arg_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "430-438",
    "snippet": "void dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "arg",
            "'\\0'",
            "sizeof(*arg)"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_arg_init(struct dynevent_arg *arg,\n\t\t       char separator)\n{\n\tmemset(arg, '\\0', sizeof(*arg));\n\n\tif (!separator)\n\t\tseparator = ' ';\n\targ->separator = separator;\n}"
  },
  {
    "function_name": "dynevent_cmd_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "407-416",
    "snippet": "void dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_buf_init",
          "args": [
            "&cmd->seq",
            "buf",
            "maxlen"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cmd",
            "'\\0'",
            "sizeof(*cmd)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dynevent_cmd_init(struct dynevent_cmd *cmd, char *buf, int maxlen,\n\t\t       enum dynevent_type type,\n\t\t       dynevent_create_fn_t run_command)\n{\n\tmemset(cmd, '\\0', sizeof(*cmd));\n\n\tseq_buf_init(&cmd->seq, buf, maxlen);\n\tcmd->type = type;\n\tcmd->run_command = run_command;\n}"
  },
  {
    "function_name": "dynevent_str_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "374-385",
    "snippet": "int dynevent_str_add(struct dynevent_cmd *cmd, const char *str)\n{\n\tint ret = 0;\n\n\tret = seq_buf_puts(&cmd->seq, str);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s\\n\", str);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"String is too long: %s\\n\"",
            "str"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_puts",
          "args": [
            "&cmd->seq",
            "str"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_str_add(struct dynevent_cmd *cmd, const char *str)\n{\n\tint ret = 0;\n\n\tret = seq_buf_puts(&cmd->seq, str);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s\\n\", str);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dynevent_arg_pair_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "339-362",
    "snippet": "int dynevent_arg_pair_add(struct dynevent_cmd *cmd,\n\t\t\t  struct dynevent_arg_pair *arg_pair,\n\t\t\t  dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg_pair);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c%s%c\", arg_pair->lhs,\n\t\t\t     arg_pair->operator, arg_pair->rhs,\n\t\t\t     arg_pair->separator);\n\tif (ret) {\n\t\tpr_err(\"field string is too long: %s%c%s%c\\n\", arg_pair->lhs,\n\t\t       arg_pair->operator, arg_pair->rhs,\n\t\t       arg_pair->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"field string is too long: %s%c%s%c\\n\"",
            "arg_pair->lhs",
            "arg_pair->operator",
            "arg_pair->rhs",
            "arg_pair->separator"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&cmd->seq",
            "\" %s%c%s%c\"",
            "arg_pair->lhs",
            "arg_pair->operator",
            "arg_pair->rhs",
            "arg_pair->separator"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_arg",
          "args": [
            "arg_pair"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_check_arg_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "908-920",
          "snippet": "static int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_pair_add(struct dynevent_cmd *cmd,\n\t\t\t  struct dynevent_arg_pair *arg_pair,\n\t\t\t  dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg_pair);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c%s%c\", arg_pair->lhs,\n\t\t\t     arg_pair->operator, arg_pair->rhs,\n\t\t\t     arg_pair->separator);\n\tif (ret) {\n\t\tpr_err(\"field string is too long: %s%c%s%c\\n\", arg_pair->lhs,\n\t\t       arg_pair->operator, arg_pair->rhs,\n\t\t       arg_pair->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dynevent_arg_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "294-313",
    "snippet": "int dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"String is too long: %s%c\\n\"",
            "arg->str",
            "arg->separator"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_buf_printf",
          "args": [
            "&cmd->seq",
            "\" %s%c\"",
            "arg->str",
            "arg->separator"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_arg",
          "args": [
            "arg"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "synth_event_check_arg_fn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_events_synth.c",
          "lines": "908-920",
          "snippet": "static int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}",
          "includes": [
            "#include \"trace_synth.h\"",
            "#include <trace/events/mmflags.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_synth.h\"\n#include <trace/events/mmflags.h>\n#include <linux/trace_events.h>\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_event_check_arg_fn(void *data)\n{\n\tstruct dynevent_arg_pair *arg_pair = data;\n\tint size;\n\n\tsize = synth_field_size((char *)arg_pair->lhs);\n\tif (size == 0) {\n\t\tif (strstr((char *)arg_pair->lhs, \"[\"))\n\t\t\treturn 0;\n\t}\n\n\treturn size ? 0 : -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dynevent_arg_add(struct dynevent_cmd *cmd,\n\t\t     struct dynevent_arg *arg,\n\t\t     dynevent_check_arg_fn_t check_arg)\n{\n\tint ret = 0;\n\n\tif (check_arg) {\n\t\tret = check_arg(arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = seq_buf_printf(&cmd->seq, \" %s%c\", arg->str, arg->separator);\n\tif (ret) {\n\t\tpr_err(\"String is too long: %s%c\\n\", arg->str, arg->separator);\n\t\treturn -E2BIG;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_dynamic_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "256-273",
    "snippet": "static __init int init_dynamic_event(void)\n{\n\tstruct dentry *entry;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"dynamic_events\", TRACE_MODE_WRITE, NULL,\n\t\t\t\t    NULL, &dynamic_events_ops);\n\n\t/* Event list interface */\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'dynamic_events' entry\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations dynamic_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = dyn_event_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= dyn_event_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'dynamic_events' entry\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"dynamic_events\"",
            "TRACE_MODE_WRITE",
            "NULL",
            "NULL",
            "&dynamic_events_ops"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9527-9553",
          "snippet": "int tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nint tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\tif (security_locked_down(LOCKDOWN_TRACEFS)) {\n\t\tpr_warn(\"Tracing disabled due to lockdown\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn 0;\n\n\tif (WARN_ON(!tracefs_initialized()))\n\t\treturn -ENODEV;\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kernel.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic const struct file_operations dynamic_events_ops = {\n\t.owner          = THIS_MODULE,\n\t.open           = dyn_event_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= dyn_event_write,\n};\n\nstatic __init int init_dynamic_event(void)\n{\n\tstruct dentry *entry;\n\tint ret;\n\n\tret = tracing_init_dentry();\n\tif (ret)\n\t\treturn 0;\n\n\tentry = tracefs_create_file(\"dynamic_events\", TRACE_MODE_WRITE, NULL,\n\t\t\t\t    NULL, &dynamic_events_ops);\n\n\t/* Event list interface */\n\tif (!entry)\n\t\tpr_warn(\"Could not create tracefs 'dynamic_events' entry\\n\");\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dyn_event_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "239-244",
    "snippet": "static ssize_t dyn_event_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_dyn_event);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_dyn_event"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "9922-9985",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nint tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(const char *))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = createfn(buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic ssize_t dyn_event_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_dyn_event);\n}"
  },
  {
    "function_name": "dyn_event_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "222-237",
    "snippet": "static int dyn_event_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &dyn_event_seq_op);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations dyn_event_seq_op = {\n\t.start\t= dyn_event_seq_start,\n\t.next\t= dyn_event_seq_next,\n\t.stop\t= dyn_event_seq_stop,\n\t.show\t= dyn_event_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&dyn_event_seq_op"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_events_release_all",
          "args": [
            "NULL"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_events_release_all",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "195-220",
          "snippet": "int dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_check_open_get_tr",
          "args": [
            "NULL"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_check_open_get_tr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "485-500",
          "snippet": "int tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tracing_disabled = 1;",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic int tracing_disabled = 1;\nstatic __always_inline struct;\n\nint tracing_check_open_get_tr(struct trace_array *tr)\n{\n\tint ret;\n\n\tret = security_locked_down(LOCKDOWN_TRACEFS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tif (tr && trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic const struct seq_operations dyn_event_seq_op = {\n\t.start\t= dyn_event_seq_start,\n\t.next\t= dyn_event_seq_next,\n\t.stop\t= dyn_event_seq_stop,\n\t.show\t= dyn_event_seq_show\n};\n\nstatic int dyn_event_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tret = tracing_check_open_get_tr(NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = dyn_events_release_all(NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &dyn_event_seq_op);\n}"
  },
  {
    "function_name": "dyn_events_release_all",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "195-220",
    "snippet": "int dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ev->ops->free",
          "args": [
            "ev"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_dyn_event_safe",
          "args": [
            "ev",
            "tmp"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev->ops->is_busy",
          "args": [
            "ev"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_events_release_all(struct dyn_event_operations *type)\n{\n\tstruct dyn_event *ev, *tmp;\n\tint ret = 0;\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event(ev) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tif (ev->ops->is_busy(ev)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tfor_each_dyn_event_safe(ev, tmp) {\n\t\tif (type && ev->ops != type)\n\t\t\tcontinue;\n\t\tret = ev->ops->free(ev);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dyn_event_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "167-175",
    "snippet": "static int dyn_event_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (ev && ev->ops)\n\t\treturn ev->ops->show(m, ev);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev->ops->show",
          "args": [
            "m",
            "ev"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic int dyn_event_seq_show(struct seq_file *m, void *v)\n{\n\tstruct dyn_event *ev = v;\n\n\tif (ev && ev->ops)\n\t\treturn ev->ops->show(m, ev);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dyn_event_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "162-165",
    "snippet": "void dyn_event_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid dyn_event_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "dyn_event_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "157-160",
    "snippet": "void *dyn_event_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &dyn_event_list, pos);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&dyn_event_list",
            "pos"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid *dyn_event_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &dyn_event_list, pos);\n}"
  },
  {
    "function_name": "dyn_event_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "151-155",
    "snippet": "void *dyn_event_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&event_mutex);\n\treturn seq_list_start(&dyn_event_list, *pos);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&dyn_event_list",
            "*pos"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid *dyn_event_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&event_mutex);\n\treturn seq_list_start(&dyn_event_list, *pos);\n}"
  },
  {
    "function_name": "create_dyn_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "127-146",
    "snippet": "static int create_dyn_event(const char *raw_command)\n{\n\tstruct dyn_event_operations *ops;\n\tint ret = -ENODEV;\n\n\tif (raw_command[0] == '-' || raw_command[0] == '!')\n\t\treturn dyn_event_release(raw_command, NULL);\n\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_for_each_entry(ops, &dyn_event_ops_list, list) {\n\t\tret = ops->create(raw_command);\n\t\tif (!ret || ret != -ECANCELED)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&dyn_event_ops_mutex);\n\tif (ret == -ECANCELED)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(dyn_event_ops_mutex);",
      "static LIST_HEAD(dyn_event_ops_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dyn_event_ops_mutex"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->create",
          "args": [
            "raw_command"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ops",
            "&dyn_event_ops_list",
            "list"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dyn_event_ops_mutex"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dyn_event_release",
          "args": [
            "raw_command",
            "NULL"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "dyn_event_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
          "lines": "72-125",
          "snippet": "int dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_dynevent.h\"",
            "#include \"trace_output.h\"\t/* for trace_event_sem */",
            "#include \"trace.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/debugfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nstatic int create_dyn_event(const char *raw_command)\n{\n\tstruct dyn_event_operations *ops;\n\tint ret = -ENODEV;\n\n\tif (raw_command[0] == '-' || raw_command[0] == '!')\n\t\treturn dyn_event_release(raw_command, NULL);\n\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_for_each_entry(ops, &dyn_event_ops_list, list) {\n\t\tret = ops->create(raw_command);\n\t\tif (!ret || ret != -ECANCELED)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&dyn_event_ops_mutex);\n\tif (ret == -ECANCELED)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dyn_event_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "72-125",
    "snippet": "int dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "argv"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos->ops->free",
          "args": [
            "pos"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pos->ops->match",
          "args": [
            "system",
            "event",
            "argc - 1",
            "(const char **)argv + 1",
            "pos"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_dyn_event_safe",
          "args": [
            "pos",
            "n"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "event",
            "'/'"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "argv[0]",
            "':'"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "raw_command",
            "&argc"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nint dyn_event_release(const char *raw_command, struct dyn_event_operations *type)\n{\n\tstruct dyn_event *pos, *n;\n\tchar *system = NULL, *event, *p;\n\tint argc, ret = -ENOENT;\n\tchar **argv;\n\n\targv = argv_split(GFP_KERNEL, raw_command, &argc);\n\tif (!argv)\n\t\treturn -ENOMEM;\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] != ':') {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = &argv[0][2];\n\t} else {\n\t\tevent = strchr(argv[0], ':');\n\t\tif (!event) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent++;\n\t}\n\n\tp = strchr(event, '/');\n\tif (p) {\n\t\tsystem = event;\n\t\tevent = p + 1;\n\t\t*p = '\\0';\n\t}\n\tif (event[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&event_mutex);\n\tfor_each_dyn_event_safe(pos, n) {\n\t\tif (type && type != pos->ops)\n\t\t\tcontinue;\n\t\tif (!pos->ops->match(system, event,\n\t\t\t\targc - 1, (const char **)argv + 1, pos))\n\t\t\tcontinue;\n\n\t\tret = pos->ops->free(pos);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&event_mutex);\nout:\n\targv_free(argv);\n\treturn ret;\n}"
  },
  {
    "function_name": "dyn_event_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "59-70",
    "snippet": "int dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(dyn_event_ops_mutex);",
      "static LIST_HEAD(dyn_event_ops_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dyn_event_ops_mutex"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ops->list",
            "&dyn_event_ops_list"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dyn_event_ops_mutex"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ops->list"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nstatic DEFINE_MUTEX(dyn_event_ops_mutex);\nstatic LIST_HEAD(dyn_event_ops_list);\n\nint dyn_event_register(struct dyn_event_operations *ops)\n{\n\tif (!ops || !ops->create || !ops->show || !ops->is_busy ||\n\t    !ops->free || !ops->match)\n\t\treturn -EINVAL;\n\n\tINIT_LIST_HEAD(&ops->list);\n\tmutex_lock(&dyn_event_ops_mutex);\n\tlist_add_tail(&ops->list, &dyn_event_ops_list);\n\tmutex_unlock(&dyn_event_ops_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_event_dyn_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "54-57",
    "snippet": "bool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&call->refcnt"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nbool trace_event_dyn_busy(struct trace_event_call *call)\n{\n\treturn atomic_read(&call->refcnt) != 0;\n}"
  },
  {
    "function_name": "trace_event_dyn_put_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "41-52",
    "snippet": "void trace_event_dyn_put_ref(struct trace_event_call *call)\n{\n\tif (WARN_ON_ONCE(!(call->flags & TRACE_EVENT_FL_DYNAMIC)))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(atomic_read(&call->refcnt) <= 0)) {\n\t\tatomic_set(&call->refcnt, 0);\n\t\treturn;\n\t}\n\n\tatomic_dec(&call->refcnt);\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&call->refcnt"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&call->refcnt",
            "0"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&call->refcnt) <= 0"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&call->refcnt"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(call->flags & TRACE_EVENT_FL_DYNAMIC)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nvoid trace_event_dyn_put_ref(struct trace_event_call *call)\n{\n\tif (WARN_ON_ONCE(!(call->flags & TRACE_EVENT_FL_DYNAMIC)))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(atomic_read(&call->refcnt) <= 0)) {\n\t\tatomic_set(&call->refcnt, 0);\n\t\treturn;\n\t}\n\n\tatomic_dec(&call->refcnt);\n}"
  },
  {
    "function_name": "trace_event_dyn_try_get_ref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_dynevent.c",
    "lines": "22-39",
    "snippet": "bool trace_event_dyn_try_get_ref(struct trace_event_call *dyn_call)\n{\n\tstruct trace_event_call *call;\n\tbool ret = false;\n\n\tif (WARN_ON_ONCE(!(dyn_call->flags & TRACE_EVENT_FL_DYNAMIC)))\n\t\treturn false;\n\n\tdown_read(&trace_event_sem);\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tif (call == dyn_call) {\n\t\t\tatomic_inc(&dyn_call->refcnt);\n\t\t\tret = true;\n\t\t}\n\t}\n\tup_read(&trace_event_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_dynevent.h\"",
      "#include \"trace_output.h\"\t/* for trace_event_sem */",
      "#include \"trace.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/debugfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&trace_event_sem"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dyn_call->refcnt"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "call",
            "&ftrace_events",
            "list"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&trace_event_sem"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(dyn_call->flags & TRACE_EVENT_FL_DYNAMIC)"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_dynevent.h\"\n#include \"trace_output.h\"\t/* for trace_event_sem */\n#include \"trace.h\"\n#include <linux/tracefs.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n\nbool trace_event_dyn_try_get_ref(struct trace_event_call *dyn_call)\n{\n\tstruct trace_event_call *call;\n\tbool ret = false;\n\n\tif (WARN_ON_ONCE(!(dyn_call->flags & TRACE_EVENT_FL_DYNAMIC)))\n\t\treturn false;\n\n\tdown_read(&trace_event_sem);\n\tlist_for_each_entry(call, &ftrace_events, list) {\n\t\tif (call == dyn_call) {\n\t\t\tatomic_inc(&dyn_call->refcnt);\n\t\t\tret = true;\n\t\t}\n\t}\n\tup_read(&trace_event_sem);\n\treturn ret;\n}"
  }
]