[
  {
    "function_name": "klp_force_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "627-645",
    "snippet": "void klp_force_transition(void)\n{\n\tstruct klp_patch *patch;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_warn(\"forcing remaining tasks to the patched state\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tklp_update_patch_state(task);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tklp_update_patch_state(idle_task(cpu));\n\n\tklp_for_each_patch(patch)\n\t\tpatch->forced = true;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_update_patch_state",
          "args": [
            "task"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "klp_update_patch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "162-186",
          "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"forcing remaining tasks to the patched state\\n\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nvoid klp_force_transition(void)\n{\n\tstruct klp_patch *patch;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_warn(\"forcing remaining tasks to the patched state\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tklp_update_patch_state(task);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tklp_update_patch_state(idle_task(cpu));\n\n\tklp_for_each_patch(patch)\n\t\tpatch->forced = true;\n}"
  },
  {
    "function_name": "klp_copy_process",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "611-616",
    "snippet": "void klp_copy_process(struct task_struct *child)\n{\n\tchild->patch_state = current->patch_state;\n\n\t/* TIF_PATCH_PENDING gets copied in setup_thread_stack() */\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nvoid klp_copy_process(struct task_struct *child)\n{\n\tchild->patch_state = current->patch_state;\n\n\t/* TIF_PATCH_PENDING gets copied in setup_thread_stack() */\n}"
  },
  {
    "function_name": "klp_reverse_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "577-608",
    "snippet": "void klp_reverse_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\n\tpr_debug(\"'%s': reversing transition from %s\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\");\n\n\tklp_transition_patch->enabled = !klp_transition_patch->enabled;\n\n\tklp_target_state = !klp_target_state;\n\n\t/*\n\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by\n\t * klp_update_patch_state() running in parallel with\n\t * klp_start_transition().\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);\n\n\t/* Let any remaining calls to klp_update_patch_state() complete */\n\tklp_synchronize_transition();\n\n\tklp_start_transition();\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_start_transition",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "klp_start_transition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "462-496",
          "snippet": "void klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n\n\tklp_signals_cnt = 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;",
            "static unsigned int klp_signals_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic unsigned int klp_signals_cnt;\n\nvoid klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n\n\tklp_signals_cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_synchronize_transition",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "klp_synchronize_transition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "59-62",
          "snippet": "static void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': reversing transition from %s\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_reverse_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\n\tpr_debug(\"'%s': reversing transition from %s\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching to unpatching\" :\n\t\t\t\t\t\t   \"unpatching to patching\");\n\n\tklp_transition_patch->enabled = !klp_transition_patch->enabled;\n\n\tklp_target_state = !klp_target_state;\n\n\t/*\n\t * Clear all TIF_PATCH_PENDING flags to prevent races caused by\n\t * klp_update_patch_state() running in parallel with\n\t * klp_start_transition().\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu)\n\t\tclear_tsk_thread_flag(idle_task(cpu), TIF_PATCH_PENDING);\n\n\t/* Let any remaining calls to klp_update_patch_state() complete */\n\tklp_synchronize_transition();\n\n\tklp_start_transition();\n}"
  },
  {
    "function_name": "klp_init_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "503-569",
    "snippet": "void klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "patch",
            "obj"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->patch_state != KLP_UNDEFINED"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7058-7061",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->patch_state != KLP_UNDEFINED"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': initializing %s transition\\n\"",
            "patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state != KLP_UNDEFINED"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_init_transition(struct klp_patch *patch, int state)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint initial_state = !state;\n\n\tWARN_ON_ONCE(klp_target_state != KLP_UNDEFINED);\n\n\tklp_transition_patch = patch;\n\n\t/*\n\t * Set the global target patch state which tasks will switch to.  This\n\t * has no effect until the TIF_PATCH_PENDING flags get set later.\n\t */\n\tklp_target_state = state;\n\n\tpr_debug(\"'%s': initializing %s transition\\n\", patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Initialize all tasks to the initial patch state to prepare them for\n\t * switching to the target state.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(task->patch_state != KLP_UNDEFINED);\n\t\ttask->patch_state = initial_state;\n\t}\n\n\t/*\n\t * Enforce the order of the task->patch_state initializations and the\n\t * func->transition updates to ensure that klp_ftrace_handler() doesn't\n\t * see a func in transition with a task->patch_state of KLP_UNDEFINED.\n\t *\n\t * Also enforce the order of the klp_target_state write and future\n\t * TIF_PATCH_PENDING writes to ensure klp_update_patch_state() doesn't\n\t * set a task->patch_state to KLP_UNDEFINED.\n\t */\n\tsmp_wmb();\n\n\t/*\n\t * Set the func transition states so klp_ftrace_handler() will know to\n\t * switch to the transition logic.\n\t *\n\t * When patching, the funcs aren't yet in the func_stack and will be\n\t * made visible to the ftrace handler shortly by the calls to\n\t * klp_patch_object().\n\t *\n\t * When unpatching, the funcs are already in the func_stack and so are\n\t * already visible to the ftrace handler.\n\t */\n\tklp_for_each_object(patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = true;\n}"
  },
  {
    "function_name": "klp_start_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "462-496",
    "snippet": "void klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n\n\tklp_signals_cnt = 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;",
      "static unsigned int klp_signals_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7058-7061",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"'%s': starting %s transition\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state == KLP_UNDEFINED"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic unsigned int klp_signals_cnt;\n\nvoid klp_start_transition(void)\n{\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\tpr_notice(\"'%s': starting %s transition\\n\",\n\t\t  klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\t/*\n\t * Mark all normal tasks as needing a patch state update.  They'll\n\t * switch either in klp_try_complete_transition() or as they exit the\n\t * kernel.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Mark all idle tasks as needing a patch state update.  They'll switch\n\t * either in klp_try_complete_transition() or at the idle loop switch\n\t * point.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (task->patch_state != klp_target_state)\n\t\t\tset_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t}\n\n\tklp_signals_cnt = 0;\n}"
  },
  {
    "function_name": "klp_try_complete_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "384-456",
    "snippet": "void klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tstruct klp_patch *patch;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tcpus_read_lock();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task)) {\n\t\t\t\tcomplete = false;\n\t\t\t\t/* Make idle task go through the main loop. */\n\t\t\t\twake_up_if_idle(cpu);\n\t\t\t}\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\tif (!complete) {\n\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))\n\t\t\tklp_send_signals();\n\t\tklp_signals_cnt++;\n\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tpatch = klp_transition_patch;\n\tklp_complete_transition();\n\n\t/*\n\t * It would make more sense to free the unused patches in\n\t * klp_complete_transition() but it is called also\n\t * from klp_cancel_transition().\n\t */\n\tif (!patch->enabled)\n\t\tklp_free_patch_async(patch);\n\telse if (patch->replace)\n\t\tklp_free_replaced_patches_async(patch);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define SIGNALS_TIMEOUT 15"
    ],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;",
      "static unsigned int klp_signals_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_free_replaced_patches_async",
          "args": [
            "patch"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_replaced_patches_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.c",
          "lines": "707-716",
          "snippet": "void klp_free_replaced_patches_async(struct klp_patch *new_patch)\n{\n\tstruct klp_patch *old_patch, *tmp_patch;\n\n\tklp_for_each_patch_safe(old_patch, tmp_patch) {\n\t\tif (old_patch == new_patch)\n\t\t\treturn;\n\t\tklp_free_patch_async(old_patch);\n\t}\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/memory.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/memory.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nvoid klp_free_replaced_patches_async(struct klp_patch *new_patch)\n{\n\tstruct klp_patch *old_patch, *tmp_patch;\n\n\tklp_for_each_patch_safe(old_patch, tmp_patch) {\n\t\tif (old_patch == new_patch)\n\t\t\treturn;\n\t\tklp_free_patch_async(old_patch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_free_patch_async",
          "args": [
            "patch"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "klp_free_patch_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.c",
          "lines": "701-705",
          "snippet": "void klp_free_patch_async(struct klp_patch *patch)\n{\n\tklp_free_patch_start(patch);\n\tschedule_work(&patch->free_work);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/memory.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __klp_disable_patch(struct klp_patch *patch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/memory.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic int __klp_disable_patch(struct klp_patch *patch);\n\nvoid klp_free_patch_async(struct klp_patch *patch)\n{\n\tklp_free_patch_start(patch);\n\tschedule_work(&patch->free_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_complete_transition",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "klp_complete_transition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "68-135",
          "snippet": "static void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {\n\t\tklp_unpatch_replaced_patches(klp_transition_patch);\n\t\tklp_discard_nops(klp_transition_patch);\n\t}\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {\n\t\tklp_unpatch_replaced_patches(klp_transition_patch);\n\t\tklp_discard_nops(klp_transition_patch);\n\t}\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&klp_transition_work",
            "round_jiffies_relative(HZ)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_jiffies_relative",
          "args": [
            "HZ"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_relative",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "406-409",
          "snippet": "unsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_send_signals",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "klp_send_signals",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "341-374",
          "snippet": "static void klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tif (klp_signals_cnt == SIGNALS_TIMEOUT)\n\t\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tset_notify_signal(task);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define SIGNALS_TIMEOUT 15"
          ],
          "globals_used": [
            "static unsigned int klp_signals_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define SIGNALS_TIMEOUT 15\n\nstatic unsigned int klp_signals_cnt;\n\nstatic void klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tif (klp_signals_cnt == SIGNALS_TIMEOUT)\n\t\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tset_notify_signal(task);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_if_idle",
          "args": [
            "cpu"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_if_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3721-3739",
          "snippet": "void wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\trq_lock_irqsave(rq, &rf);\n\tif (is_idle_task(rq->curr))\n\t\tresched_curr(rq);\n\t/* Else CPU is not idle, do nothing here: */\n\trq_unlock_irqrestore(rq, &rf);\n\nout:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\trq_lock_irqsave(rq, &rf);\n\tif (is_idle_task(rq->curr))\n\t\tresched_curr(rq);\n\t/* Else CPU is not idle, do nothing here: */\n\trq_unlock_irqrestore(rq, &rf);\n\nout:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_try_switch_task",
          "args": [
            "task"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "klp_try_switch_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "289-335",
          "snippet": "static bool klp_try_switch_task(struct task_struct *task)\n{\n\tconst char *old_name;\n\tint ret;\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * For arches which don't have reliable stack traces, we have to rely\n\t * on other methods (e.g., switching tasks at kernel exit).\n\t */\n\tif (!klp_have_reliable_stack())\n\t\treturn false;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\tret = task_call_func(task, klp_check_and_switch_task, &old_name);\n\tswitch (ret) {\n\tcase 0:\t\t/* success */\n\t\tbreak;\n\n\tcase -EBUSY:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is running\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EINVAL:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EADDRINUSE: /* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t __func__, task->comm, task->pid, old_name);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",\n\t\t\t __func__, ret, task->comm, task->pid);\n\t\tbreak;\n\t}\n\n\treturn !ret;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic bool klp_try_switch_task(struct task_struct *task)\n{\n\tconst char *old_name;\n\tint ret;\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * For arches which don't have reliable stack traces, we have to rely\n\t * on other methods (e.g., switching tasks at kernel exit).\n\t */\n\tif (!klp_have_reliable_stack())\n\t\treturn false;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\tret = task_call_func(task, klp_check_and_switch_task, &old_name);\n\tswitch (ret) {\n\tcase 0:\t\t/* success */\n\t\tbreak;\n\n\tcase -EBUSY:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is running\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EINVAL:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EADDRINUSE: /* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t __func__, task->comm, task->pid, old_name);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",\n\t\t\t __func__, ret, task->comm, task->pid);\n\t\tbreak;\n\t}\n\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7058-7061",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state == KLP_UNDEFINED"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define SIGNALS_TIMEOUT 15\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic unsigned int klp_signals_cnt;\n\nvoid klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tstruct klp_patch *patch;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tcpus_read_lock();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task)) {\n\t\t\t\tcomplete = false;\n\t\t\t\t/* Make idle task go through the main loop. */\n\t\t\t\twake_up_if_idle(cpu);\n\t\t\t}\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\tif (!complete) {\n\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))\n\t\t\tklp_send_signals();\n\t\tklp_signals_cnt++;\n\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tpatch = klp_transition_patch;\n\tklp_complete_transition();\n\n\t/*\n\t * It would make more sense to free the unused patches in\n\t * klp_complete_transition() but it is called also\n\t * from klp_cancel_transition().\n\t */\n\tif (!patch->enabled)\n\t\tklp_free_patch_async(patch);\n\telse if (patch->replace)\n\t\tklp_free_replaced_patches_async(patch);\n}"
  },
  {
    "function_name": "klp_send_signals",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "341-374",
    "snippet": "static void klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tif (klp_signals_cnt == SIGNALS_TIMEOUT)\n\t\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tset_notify_signal(task);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define SIGNALS_TIMEOUT 15"
    ],
    "globals_used": [
      "static unsigned int klp_signals_cnt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_notify_signal",
          "args": [
            "task"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "task",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "763-775",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_patch_pending",
          "args": [
            "task"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"signaling remaining tasks\\n\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define SIGNALS_TIMEOUT 15\n\nstatic unsigned int klp_signals_cnt;\n\nstatic void klp_send_signals(void)\n{\n\tstruct task_struct *g, *task;\n\n\tif (klp_signals_cnt == SIGNALS_TIMEOUT)\n\t\tpr_notice(\"signaling remaining tasks\\n\");\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tif (!klp_patch_pending(task))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * There is a small race here. We could see TIF_PATCH_PENDING\n\t\t * set and decide to wake up a kthread or send a fake signal.\n\t\t * Meanwhile the task could migrate itself and the action\n\t\t * would be meaningless. It is not serious though.\n\t\t */\n\t\tif (task->flags & PF_KTHREAD) {\n\t\t\t/*\n\t\t\t * Wake up a kthread which sleeps interruptedly and\n\t\t\t * still has not been migrated.\n\t\t\t */\n\t\t\twake_up_state(task, TASK_INTERRUPTIBLE);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Send fake signal to all non-kthread tasks which are\n\t\t\t * still not migrated.\n\t\t\t */\n\t\t\tset_notify_signal(task);\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n}"
  },
  {
    "function_name": "klp_try_switch_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "289-335",
    "snippet": "static bool klp_try_switch_task(struct task_struct *task)\n{\n\tconst char *old_name;\n\tint ret;\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * For arches which don't have reliable stack traces, we have to rely\n\t * on other methods (e.g., switching tasks at kernel exit).\n\t */\n\tif (!klp_have_reliable_stack())\n\t\treturn false;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\tret = task_call_func(task, klp_check_and_switch_task, &old_name);\n\tswitch (ret) {\n\tcase 0:\t\t/* success */\n\t\tbreak;\n\n\tcase -EBUSY:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is running\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EINVAL:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EADDRINUSE: /* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t __func__, task->comm, task->pid, old_name);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",\n\t\t\t __func__, ret, task->comm, task->pid);\n\t\tbreak;\n\t}\n\n\treturn !ret;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\"",
            "__func__",
            "ret",
            "task->comm",
            "task->pid"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: %s:%d is sleeping on function %s\\n\"",
            "__func__",
            "task->comm",
            "task->pid",
            "old_name"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: %s:%d has an unreliable stack\\n\"",
            "__func__",
            "task->comm",
            "task->pid"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: %s:%d is running\\n\"",
            "__func__",
            "task->comm",
            "task->pid"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_call_func",
          "args": [
            "task",
            "klp_check_and_switch_task",
            "&old_name"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "task_call_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4158-4202",
          "snippet": "int task_call_func(struct task_struct *p, task_call_f func, void *arg)\n{\n\tstruct rq *rq = NULL;\n\tunsigned int state;\n\tstruct rq_flags rf;\n\tint ret;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\n\tstate = READ_ONCE(p->__state);\n\n\t/*\n\t * Ensure we load p->on_rq after p->__state, otherwise it would be\n\t * possible to, falsely, observe p->on_rq == 0.\n\t *\n\t * See try_to_wake_up() for a longer comment.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * Since pi->lock blocks try_to_wake_up(), we don't need rq->lock when\n\t * the task is blocked. Make sure to check @state since ttwu() can drop\n\t * locks at the end, see ttwu_queue_wakelist().\n\t */\n\tif (state == TASK_RUNNING || state == TASK_WAKING || p->on_rq)\n\t\trq = __task_rq_lock(p, &rf);\n\n\t/*\n\t * At this point the task is pinned; either:\n\t *  - blocked and we're holding off wakeups\t (pi->lock)\n\t *  - woken, and we're holding off enqueue\t (rq->lock)\n\t *  - queued, and we're holding off schedule\t (rq->lock)\n\t *  - running, and we're holding off de-schedule (rq->lock)\n\t *\n\t * The called function (@func) can use: task_curr(), p->on_rq and\n\t * p->__state to differentiate between these states.\n\t */\n\tret = func(p, arg);\n\n\tif (rq)\n\t\trq_unlock(rq, &rf);\n\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint task_call_func(struct task_struct *p, task_call_f func, void *arg)\n{\n\tstruct rq *rq = NULL;\n\tunsigned int state;\n\tstruct rq_flags rf;\n\tint ret;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\n\tstate = READ_ONCE(p->__state);\n\n\t/*\n\t * Ensure we load p->on_rq after p->__state, otherwise it would be\n\t * possible to, falsely, observe p->on_rq == 0.\n\t *\n\t * See try_to_wake_up() for a longer comment.\n\t */\n\tsmp_rmb();\n\n\t/*\n\t * Since pi->lock blocks try_to_wake_up(), we don't need rq->lock when\n\t * the task is blocked. Make sure to check @state since ttwu() can drop\n\t * locks at the end, see ttwu_queue_wakelist().\n\t */\n\tif (state == TASK_RUNNING || state == TASK_WAKING || p->on_rq)\n\t\trq = __task_rq_lock(p, &rf);\n\n\t/*\n\t * At this point the task is pinned; either:\n\t *  - blocked and we're holding off wakeups\t (pi->lock)\n\t *  - woken, and we're holding off enqueue\t (rq->lock)\n\t *  - queued, and we're holding off schedule\t (rq->lock)\n\t *  - running, and we're holding off de-schedule (rq->lock)\n\t *\n\t * The called function (@func) can use: task_curr(), p->on_rq and\n\t * p->__state to differentiate between these states.\n\t */\n\tret = func(p, arg);\n\n\tif (rq)\n\t\trq_unlock(rq, &rf);\n\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_have_reliable_stack",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic bool klp_try_switch_task(struct task_struct *task)\n{\n\tconst char *old_name;\n\tint ret;\n\n\t/* check if this task has already switched over */\n\tif (task->patch_state == klp_target_state)\n\t\treturn true;\n\n\t/*\n\t * For arches which don't have reliable stack traces, we have to rely\n\t * on other methods (e.g., switching tasks at kernel exit).\n\t */\n\tif (!klp_have_reliable_stack())\n\t\treturn false;\n\n\t/*\n\t * Now try to check the stack for any to-be-patched or to-be-unpatched\n\t * functions.  If all goes well, switch the task to the target patch\n\t * state.\n\t */\n\tret = task_call_func(task, klp_check_and_switch_task, &old_name);\n\tswitch (ret) {\n\tcase 0:\t\t/* success */\n\t\tbreak;\n\n\tcase -EBUSY:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is running\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EINVAL:\t/* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d has an unreliable stack\\n\",\n\t\t\t __func__, task->comm, task->pid);\n\t\tbreak;\n\tcase -EADDRINUSE: /* klp_check_and_switch_task() */\n\t\tpr_debug(\"%s: %s:%d is sleeping on function %s\\n\",\n\t\t\t __func__, task->comm, task->pid, old_name);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_debug(\"%s: Unknown error code (%d) when trying to switch %s:%d\\n\",\n\t\t\t __func__, ret, task->comm, task->pid);\n\t\tbreak;\n\t}\n\n\treturn !ret;\n}"
  },
  {
    "function_name": "klp_check_and_switch_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "268-282",
    "snippet": "static int klp_check_and_switch_task(struct task_struct *task, void *arg)\n{\n\tint ret;\n\n\tif (task_curr(task) && task != current)\n\t\treturn -EBUSY;\n\n\tret = klp_check_stack(task, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\ttask->patch_state = klp_target_state;\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_check_stack",
          "args": [
            "task",
            "arg"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "klp_check_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "241-266",
          "snippet": "static int klp_check_stack(struct task_struct *task, const char **oldname)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret, nr_entries;\n\n\tret = stack_trace_save_tsk_reliable(task, entries, ARRAY_SIZE(entries));\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tnr_entries = ret;\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, entries, nr_entries);\n\t\t\tif (ret) {\n\t\t\t\t*oldname = func->old_name;\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define MAX_STACK_ENTRIES  100"
          ],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define MAX_STACK_ENTRIES  100\n\nstruct klp_patch *klp_transition_patch;\n\nstatic int klp_check_stack(struct task_struct *task, const char **oldname)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret, nr_entries;\n\n\tret = stack_trace_save_tsk_reliable(task, entries, ARRAY_SIZE(entries));\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tnr_entries = ret;\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, entries, nr_entries);\n\t\t\tif (ret) {\n\t\t\t\t*oldname = func->old_name;\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "task"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2099-2102",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic int klp_check_and_switch_task(struct task_struct *task, void *arg)\n{\n\tint ret;\n\n\tif (task_curr(task) && task != current)\n\t\treturn -EBUSY;\n\n\tret = klp_check_stack(task, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\ttask->patch_state = klp_target_state;\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_check_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "241-266",
    "snippet": "static int klp_check_stack(struct task_struct *task, const char **oldname)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret, nr_entries;\n\n\tret = stack_trace_save_tsk_reliable(task, entries, ARRAY_SIZE(entries));\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tnr_entries = ret;\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, entries, nr_entries);\n\t\t\tif (ret) {\n\t\t\t\t*oldname = func->old_name;\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define MAX_STACK_ENTRIES  100"
    ],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_check_stack_func",
          "args": [
            "func",
            "entries",
            "nr_entries"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "klp_check_stack_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "192-235",
          "snippet": "static int klp_check_stack_func(struct klp_func *func, unsigned long *entries,\n\t\t\t\tunsigned int nr_entries)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\taddress = entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_func);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = (unsigned long)func->old_func;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic int klp_check_stack_func(struct klp_func *func, unsigned long *entries,\n\t\t\t\tunsigned int nr_entries)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\taddress = entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_func);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = (unsigned long)func->old_func;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "klp_transition_patch",
            "obj"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack_trace_save_tsk_reliable",
          "args": [
            "task",
            "entries",
            "ARRAY_SIZE(entries)"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "stack_trace_save_tsk_reliable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stacktrace.c",
          "lines": "343-353",
          "snippet": "int stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}",
          "includes": [
            "#include <linux/interrupt.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/task_stack.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/interrupt.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task_stack.h>\n\nint stack_trace_save_tsk_reliable(struct task_struct *tsk, unsigned long *store,\n\t\t\t\t  unsigned int size)\n{\n\tstruct stack_trace trace = {\n\t\t.entries\t= store,\n\t\t.max_entries\t= size,\n\t};\n\tint ret = save_stack_trace_tsk_reliable(tsk, &trace);\n\n\treturn ret ? ret : trace.nr_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "entries"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define MAX_STACK_ENTRIES  100\n\nstruct klp_patch *klp_transition_patch;\n\nstatic int klp_check_stack(struct task_struct *task, const char **oldname)\n{\n\tstatic unsigned long entries[MAX_STACK_ENTRIES];\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tint ret, nr_entries;\n\n\tret = stack_trace_save_tsk_reliable(task, entries, ARRAY_SIZE(entries));\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tnr_entries = ret;\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!obj->patched)\n\t\t\tcontinue;\n\t\tklp_for_each_func(obj, func) {\n\t\t\tret = klp_check_stack_func(func, entries, nr_entries);\n\t\t\tif (ret) {\n\t\t\t\t*oldname = func->old_name;\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_check_stack_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "192-235",
    "snippet": "static int klp_check_stack_func(struct klp_func *func, unsigned long *entries,\n\t\t\t\tunsigned int nr_entries)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\taddress = entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_func);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = (unsigned long)func->old_func;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "func",
            "stack_node"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&ops->func_stack"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_find_ops",
          "args": [
            "func->old_func"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "klp_find_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "25-38",
          "snippet": "struct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(klp_ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nstatic LIST_HEAD(klp_ops);\n\nstruct klp_ops *klp_find_ops(void *old_func)\n{\n\tstruct klp_ops *ops;\n\tstruct klp_func *func;\n\n\tlist_for_each_entry(ops, &klp_ops, node) {\n\t\tfunc = list_first_entry(&ops->func_stack, struct klp_func,\n\t\t\t\t\tstack_node);\n\t\tif (func->old_func == old_func)\n\t\t\treturn ops;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic int klp_check_stack_func(struct klp_func *func, unsigned long *entries,\n\t\t\t\tunsigned int nr_entries)\n{\n\tunsigned long func_addr, func_size, address;\n\tstruct klp_ops *ops;\n\tint i;\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\taddress = entries[i];\n\n\t\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t\t /*\n\t\t\t  * Check for the to-be-unpatched function\n\t\t\t  * (the func itself).\n\t\t\t  */\n\t\t\tfunc_addr = (unsigned long)func->new_func;\n\t\t\tfunc_size = func->new_size;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check for the to-be-patched function\n\t\t\t * (the previous func).\n\t\t\t */\n\t\t\tops = klp_find_ops(func->old_func);\n\n\t\t\tif (list_is_singular(&ops->func_stack)) {\n\t\t\t\t/* original function */\n\t\t\t\tfunc_addr = (unsigned long)func->old_func;\n\t\t\t\tfunc_size = func->old_size;\n\t\t\t} else {\n\t\t\t\t/* previously patched function */\n\t\t\t\tstruct klp_func *prev;\n\n\t\t\t\tprev = list_next_entry(func, stack_node);\n\t\t\t\tfunc_addr = (unsigned long)prev->new_func;\n\t\t\t\tfunc_size = prev->new_size;\n\t\t\t}\n\t\t}\n\n\t\tif (address >= func_addr && address < func_addr + func_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "klp_update_patch_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "162-186",
    "snippet": "void klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "klp_target_state"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_update_patch_state(struct task_struct *task)\n{\n\t/*\n\t * A variant of synchronize_rcu() is used to allow patching functions\n\t * where RCU is not watching, see klp_synchronize_transition().\n\t */\n\tpreempt_disable_notrace();\n\n\t/*\n\t * This test_and_clear_tsk_thread_flag() call also serves as a read\n\t * barrier (smp_rmb) for two cases:\n\t *\n\t * 1) Enforce the order of the TIF_PATCH_PENDING read and the\n\t *    klp_target_state read.  The corresponding write barrier is in\n\t *    klp_init_transition().\n\t *\n\t * 2) Enforce the order of the TIF_PATCH_PENDING read and a future read\n\t *    of func->transition, if klp_ftrace_handler() is called later on\n\t *    the same CPU.  See __klp_disable_patch().\n\t */\n\tif (test_and_clear_tsk_thread_flag(task, TIF_PATCH_PENDING))\n\t\ttask->patch_state = READ_ONCE(klp_target_state);\n\n\tpreempt_enable_notrace();\n}"
  },
  {
    "function_name": "klp_cancel_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "143-153",
    "snippet": "void klp_cancel_transition(void)\n{\n\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))\n\t\treturn;\n\n\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",\n\t\t klp_transition_patch->mod->name);\n\n\tklp_target_state = KLP_UNPATCHED;\n\tklp_complete_transition();\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "klp_complete_transition",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "klp_complete_transition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "68-135",
          "snippet": "static void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {\n\t\tklp_unpatch_replaced_patches(klp_transition_patch);\n\t\tklp_discard_nops(klp_transition_patch);\n\t}\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {\n\t\tklp_unpatch_replaced_patches(klp_transition_patch);\n\t\tklp_discard_nops(klp_transition_patch);\n\t}\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': canceling patching transition, going to unpatch\\n\"",
            "klp_transition_patch->mod->name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "klp_target_state != KLP_PATCHED"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nvoid klp_cancel_transition(void)\n{\n\tif (WARN_ON_ONCE(klp_target_state != KLP_PATCHED))\n\t\treturn;\n\n\tpr_debug(\"'%s': canceling patching transition, going to unpatch\\n\",\n\t\t klp_transition_patch->mod->name);\n\n\tklp_target_state = KLP_UNPATCHED;\n\tklp_complete_transition();\n}"
  },
  {
    "function_name": "klp_complete_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "68-135",
    "snippet": "static void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {\n\t\tklp_unpatch_replaced_patches(klp_transition_patch);\n\t\tklp_discard_nops(klp_transition_patch);\n\t}\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static int klp_target_state = KLP_UNDEFINED;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"'%s': %s complete\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_post_unpatch_callback",
          "args": [
            "obj"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_unpatch_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.h",
          "lines": "50-57",
          "snippet": "static inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_unpatch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_unpatch_enabled &&\n\t    obj->callbacks.post_unpatch)\n\t\t(*obj->callbacks.post_unpatch)(obj);\n\n\tobj->callbacks.post_unpatch_enabled = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_post_patch_callback",
          "args": [
            "obj"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "klp_post_patch_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.h",
          "lines": "38-42",
          "snippet": "static inline void klp_post_patch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_patch)\n\t\t(*obj->callbacks.post_patch)(obj);\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline void klp_post_patch_callback(struct klp_object *obj)\n{\n\tif (obj->callbacks.post_patch)\n\t\t(*obj->callbacks.post_patch)(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_is_object_loaded",
          "args": [
            "obj"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "klp_is_object_loaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.h",
          "lines": "21-24",
          "snippet": "static inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}",
          "includes": [
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/livepatch.h>\n\nstatic inline bool klp_is_object_loaded(struct klp_object *obj)\n{\n\treturn !obj->name || obj->mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "klp_transition_patch",
            "obj"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_tsk_thread_flag(task, TIF_PATCH_PENDING)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "cpu"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7058-7061",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_tsk_thread_flag(task, TIF_PATCH_PENDING)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "task",
            "TIF_PATCH_PENDING"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "task"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_synchronize_transition",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "klp_synchronize_transition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "59-62",
          "snippet": "static void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_for_each_func",
          "args": [
            "obj",
            "func"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_for_each_object",
          "args": [
            "klp_transition_patch",
            "obj"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_unpatch_objects",
          "args": [
            "klp_transition_patch"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_objects_dynamic",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/patch.c",
          "lines": "301-304",
          "snippet": "void klp_unpatch_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, true);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/printk.h>",
            "#include <linux/bug.h>",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/list.h>",
            "#include <linux/livepatch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/printk.h>\n#include <linux/bug.h>\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/ftrace.h>\n#include <linux/list.h>\n#include <linux/livepatch.h>\n\nvoid klp_unpatch_objects_dynamic(struct klp_patch *patch)\n{\n\t__klp_unpatch_objects(patch, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_discard_nops",
          "args": [
            "klp_transition_patch"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "klp_discard_nops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.c",
          "lines": "1124-1128",
          "snippet": "void klp_discard_nops(struct klp_patch *new_patch)\n{\n\tklp_unpatch_objects_dynamic(klp_transition_patch);\n\tklp_free_objects_dynamic(klp_transition_patch);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/memory.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/memory.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nvoid klp_discard_nops(struct klp_patch *new_patch)\n{\n\tklp_unpatch_objects_dynamic(klp_transition_patch);\n\tklp_free_objects_dynamic(klp_transition_patch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_unpatch_replaced_patches",
          "args": [
            "klp_transition_patch"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "klp_unpatch_replaced_patches",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/core.c",
          "lines": "1095-1106",
          "snippet": "void klp_unpatch_replaced_patches(struct klp_patch *new_patch)\n{\n\tstruct klp_patch *old_patch;\n\n\tklp_for_each_patch(old_patch) {\n\t\tif (old_patch == new_patch)\n\t\t\treturn;\n\n\t\told_patch->enabled = false;\n\t\tklp_unpatch_objects(old_patch);\n\t}\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"state.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <asm/cacheflush.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/memory.h>",
            "#include <linux/completion.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"state.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <asm/cacheflush.h>\n#include <linux/rcupdate.h>\n#include <linux/memory.h>\n#include <linux/completion.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/livepatch.h>\n#include <linux/kallsyms.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nvoid klp_unpatch_replaced_patches(struct klp_patch *new_patch)\n{\n\tstruct klp_patch *old_patch;\n\n\tklp_for_each_patch(old_patch) {\n\t\tif (old_patch == new_patch)\n\t\t\treturn;\n\n\t\told_patch->enabled = false;\n\t\tklp_unpatch_objects(old_patch);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"'%s': completing %s transition\\n\"",
            "klp_transition_patch->mod->name",
            "klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\n\nstatic void klp_complete_transition(void)\n{\n\tstruct klp_object *obj;\n\tstruct klp_func *func;\n\tstruct task_struct *g, *task;\n\tunsigned int cpu;\n\n\tpr_debug(\"'%s': completing %s transition\\n\",\n\t\t klp_transition_patch->mod->name,\n\t\t klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tif (klp_transition_patch->replace && klp_target_state == KLP_PATCHED) {\n\t\tklp_unpatch_replaced_patches(klp_transition_patch);\n\t\tklp_discard_nops(klp_transition_patch);\n\t}\n\n\tif (klp_target_state == KLP_UNPATCHED) {\n\t\t/*\n\t\t * All tasks have transitioned to KLP_UNPATCHED so we can now\n\t\t * remove the new functions from the func_stack.\n\t\t */\n\t\tklp_unpatch_objects(klp_transition_patch);\n\n\t\t/*\n\t\t * Make sure klp_ftrace_handler() can no longer see functions\n\t\t * from this patch on the ops->func_stack.  Otherwise, after\n\t\t * func->transition gets cleared, the handler may choose a\n\t\t * removed function.\n\t\t */\n\t\tklp_synchronize_transition();\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj)\n\t\tklp_for_each_func(obj, func)\n\t\t\tfunc->transition = false;\n\n\t/* Prevent klp_ftrace_handler() from seeing KLP_UNDEFINED state */\n\tif (klp_target_state == KLP_PATCHED)\n\t\tklp_synchronize_transition();\n\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task) {\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tWARN_ON_ONCE(test_tsk_thread_flag(task, TIF_PATCH_PENDING));\n\t\ttask->patch_state = KLP_UNDEFINED;\n\t}\n\n\tklp_for_each_object(klp_transition_patch, obj) {\n\t\tif (!klp_is_object_loaded(obj))\n\t\t\tcontinue;\n\t\tif (klp_target_state == KLP_PATCHED)\n\t\t\tklp_post_patch_callback(obj);\n\t\telse if (klp_target_state == KLP_UNPATCHED)\n\t\t\tklp_post_unpatch_callback(obj);\n\t}\n\n\tpr_notice(\"'%s': %s complete\\n\", klp_transition_patch->mod->name,\n\t\t  klp_target_state == KLP_PATCHED ? \"patching\" : \"unpatching\");\n\n\tklp_target_state = KLP_UNDEFINED;\n\tklp_transition_patch = NULL;\n}"
  },
  {
    "function_name": "klp_synchronize_transition",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "59-62",
    "snippet": "static void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_on_each_cpu",
          "args": [
            "klp_sync"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_on_each_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3327-3351",
          "snippet": "int schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tcpus_read_unlock();\n\tfree_percpu(works);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nint schedule_on_each_cpu(work_func_t func)\n{\n\tint cpu;\n\tstruct work_struct __percpu *works;\n\n\tworks = alloc_percpu(struct work_struct);\n\tif (!works)\n\t\treturn -ENOMEM;\n\n\tcpus_read_lock();\n\n\tfor_each_online_cpu(cpu) {\n\t\tstruct work_struct *work = per_cpu_ptr(works, cpu);\n\n\t\tINIT_WORK(work, func);\n\t\tschedule_work_on(cpu, work);\n\t}\n\n\tfor_each_online_cpu(cpu)\n\t\tflush_work(per_cpu_ptr(works, cpu));\n\n\tcpus_read_unlock();\n\tfree_percpu(works);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_synchronize_transition(void)\n{\n\tschedule_on_each_cpu(klp_sync);\n}"
  },
  {
    "function_name": "klp_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "47-49",
    "snippet": "static void klp_sync(struct work_struct *work)\n{\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstatic void klp_sync(struct work_struct *work)\n{\n}"
  },
  {
    "function_name": "klp_transition_work_fn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
    "lines": "31-39",
    "snippet": "static void klp_transition_work_fn(struct work_struct *work)\n{\n\tmutex_lock(&klp_mutex);\n\n\tif (klp_transition_patch)\n\t\tklp_try_complete_transition();\n\n\tmutex_unlock(&klp_mutex);\n}",
    "includes": [
      "#include \"transition.h\"",
      "#include \"patch.h\"",
      "#include \"core.h\"",
      "#include <linux/stacktrace.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct klp_patch *klp_transition_patch;",
      "static DECLARE_DELAYED_WORK(klp_transition_work, klp_transition_work_fn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&klp_mutex"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "klp_try_complete_transition",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "klp_try_complete_transition",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/livepatch/transition.c",
          "lines": "384-456",
          "snippet": "void klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tstruct klp_patch *patch;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tcpus_read_lock();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task)) {\n\t\t\t\tcomplete = false;\n\t\t\t\t/* Make idle task go through the main loop. */\n\t\t\t\twake_up_if_idle(cpu);\n\t\t\t}\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\tif (!complete) {\n\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))\n\t\t\tklp_send_signals();\n\t\tklp_signals_cnt++;\n\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tpatch = klp_transition_patch;\n\tklp_complete_transition();\n\n\t/*\n\t * It would make more sense to free the unused patches in\n\t * klp_complete_transition() but it is called also\n\t * from klp_cancel_transition().\n\t */\n\tif (!patch->enabled)\n\t\tklp_free_patch_async(patch);\n\telse if (patch->replace)\n\t\tklp_free_replaced_patches_async(patch);\n}",
          "includes": [
            "#include \"transition.h\"",
            "#include \"patch.h\"",
            "#include \"core.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define SIGNALS_TIMEOUT 15"
          ],
          "globals_used": [
            "struct klp_patch *klp_transition_patch;",
            "static int klp_target_state = KLP_UNDEFINED;",
            "static unsigned int klp_signals_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\n#define SIGNALS_TIMEOUT 15\n\nstruct klp_patch *klp_transition_patch;\nstatic int klp_target_state = KLP_UNDEFINED;\nstatic unsigned int klp_signals_cnt;\n\nvoid klp_try_complete_transition(void)\n{\n\tunsigned int cpu;\n\tstruct task_struct *g, *task;\n\tstruct klp_patch *patch;\n\tbool complete = true;\n\n\tWARN_ON_ONCE(klp_target_state == KLP_UNDEFINED);\n\n\t/*\n\t * Try to switch the tasks to the target patch state by walking their\n\t * stacks and looking for any to-be-patched or to-be-unpatched\n\t * functions.  If such functions are found on a stack, or if the stack\n\t * is deemed unreliable, the task can't be switched yet.\n\t *\n\t * Usually this will transition most (or all) of the tasks on a system\n\t * unless the patch includes changes to a very common function.\n\t */\n\tread_lock(&tasklist_lock);\n\tfor_each_process_thread(g, task)\n\t\tif (!klp_try_switch_task(task))\n\t\t\tcomplete = false;\n\tread_unlock(&tasklist_lock);\n\n\t/*\n\t * Ditto for the idle \"swapper\" tasks.\n\t */\n\tcpus_read_lock();\n\tfor_each_possible_cpu(cpu) {\n\t\ttask = idle_task(cpu);\n\t\tif (cpu_online(cpu)) {\n\t\t\tif (!klp_try_switch_task(task)) {\n\t\t\t\tcomplete = false;\n\t\t\t\t/* Make idle task go through the main loop. */\n\t\t\t\twake_up_if_idle(cpu);\n\t\t\t}\n\t\t} else if (task->patch_state != klp_target_state) {\n\t\t\t/* offline idle tasks can be switched immediately */\n\t\t\tclear_tsk_thread_flag(task, TIF_PATCH_PENDING);\n\t\t\ttask->patch_state = klp_target_state;\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\tif (!complete) {\n\t\tif (klp_signals_cnt && !(klp_signals_cnt % SIGNALS_TIMEOUT))\n\t\t\tklp_send_signals();\n\t\tklp_signals_cnt++;\n\n\t\t/*\n\t\t * Some tasks weren't able to be switched over.  Try again\n\t\t * later and/or wait for other methods like kernel exit\n\t\t * switching.\n\t\t */\n\t\tschedule_delayed_work(&klp_transition_work,\n\t\t\t\t      round_jiffies_relative(HZ));\n\t\treturn;\n\t}\n\n\t/* we're done, now cleanup the data structures */\n\tpatch = klp_transition_patch;\n\tklp_complete_transition();\n\n\t/*\n\t * It would make more sense to free the unused patches in\n\t * klp_complete_transition() but it is called also\n\t * from klp_cancel_transition().\n\t */\n\tif (!patch->enabled)\n\t\tklp_free_patch_async(patch);\n\telse if (patch->replace)\n\t\tklp_free_replaced_patches_async(patch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&klp_mutex"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"transition.h\"\n#include \"patch.h\"\n#include \"core.h\"\n#include <linux/stacktrace.h>\n#include <linux/cpu.h>\n\nstruct klp_patch *klp_transition_patch;\nstatic DECLARE_DELAYED_WORK(klp_transition_work, klp_transition_work_fn);\n\nstatic void klp_transition_work_fn(struct work_struct *work)\n{\n\tmutex_lock(&klp_mutex);\n\n\tif (klp_transition_patch)\n\t\tklp_try_complete_transition();\n\n\tmutex_unlock(&klp_mutex);\n}"
  }
]