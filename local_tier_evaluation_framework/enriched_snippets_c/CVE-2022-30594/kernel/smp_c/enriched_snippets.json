[
  {
    "function_name": "smp_call_on_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1218-1236",
    "snippet": "int smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tstruct smp_call_on_cpu_struct sscs = {\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK(sscs.done),\n\t\t.func = func,\n\t\t.data = par,\n\t\t.cpu  = phys ? cpu : -1,\n\t};\n\n\tINIT_WORK_ONSTACK(&sscs.work, smp_call_on_cpu_callback);\n\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\n\n\tqueue_work_on(cpu, system_wq, &sscs.work);\n\twait_for_completion(&sscs.done);\n\n\treturn sscs.ret;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&sscs.done"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "cpu",
            "system_wq",
            "&sscs.work"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1553-1568",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&sscs.work",
            "smp_call_on_cpu_callback"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPLETION_INITIALIZER_ONSTACK",
          "args": [
            "sscs.done"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nint smp_call_on_cpu(unsigned int cpu, int (*func)(void *), void *par, bool phys)\n{\n\tstruct smp_call_on_cpu_struct sscs = {\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK(sscs.done),\n\t\t.func = func,\n\t\t.data = par,\n\t\t.cpu  = phys ? cpu : -1,\n\t};\n\n\tINIT_WORK_ONSTACK(&sscs.work, smp_call_on_cpu_callback);\n\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\n\n\tqueue_work_on(cpu, system_wq, &sscs.work);\n\twait_for_completion(&sscs.done);\n\n\treturn sscs.ret;\n}"
  },
  {
    "function_name": "smp_call_on_cpu_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1204-1216",
    "snippet": "static void smp_call_on_cpu_callback(struct work_struct *work)\n{\n\tstruct smp_call_on_cpu_struct *sscs;\n\n\tsscs = container_of(work, struct smp_call_on_cpu_struct, work);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(sscs->cpu);\n\tsscs->ret = sscs->func(sscs->data);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(-1);\n\n\tcomplete(&sscs->done);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&sscs->done"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hypervisor_pin_vcpu",
          "args": [
            "-1"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscs->func",
          "args": [
            "sscs->data"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hypervisor_pin_vcpu",
          "args": [
            "sscs->cpu"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsmp_call_on_cpu_struct",
            "work"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void smp_call_on_cpu_callback(struct work_struct *work)\n{\n\tstruct smp_call_on_cpu_struct *sscs;\n\n\tsscs = container_of(work, struct smp_call_on_cpu_struct, work);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(sscs->cpu);\n\tsscs->ret = sscs->func(sscs->data);\n\tif (sscs->cpu >= 0)\n\t\thypervisor_pin_vcpu(-1);\n\n\tcomplete(&sscs->done);\n}"
  },
  {
    "function_name": "wake_up_all_idle_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1169-1179",
    "snippet": "void wake_up_all_idle_cpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpreempt_disable();\n\t\tif (cpu != smp_processor_id() && cpu_online(cpu))\n\t\t\twake_up_if_idle(cpu);\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_if_idle",
          "args": [
            "cpu"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_if_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3721-3739",
          "snippet": "void wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\trq_lock_irqsave(rq, &rf);\n\tif (is_idle_task(rq->curr))\n\t\tresched_curr(rq);\n\t/* Else CPU is not idle, do nothing here: */\n\trq_unlock_irqrestore(rq, &rf);\n\nout:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid wake_up_if_idle(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct rq_flags rf;\n\n\trcu_read_lock();\n\n\tif (!is_idle_task(rcu_dereference(rq->curr)))\n\t\tgoto out;\n\n\trq_lock_irqsave(rq, &rf);\n\tif (is_idle_task(rq->curr))\n\t\tresched_curr(rq);\n\t/* Else CPU is not idle, do nothing here: */\n\trq_unlock_irqrestore(rq, &rf);\n\nout:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid wake_up_all_idle_cpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpreempt_disable();\n\t\tif (cpu != smp_processor_id() && cpu_online(cpu))\n\t\t\twake_up_if_idle(cpu);\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "kick_all_cpus_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1155-1160",
    "snippet": "void kick_all_cpus_sync(void)\n{\n\t/* Make sure the change is visible before we kick the cpus */\n\tsmp_mb();\n\tsmp_call_function(do_nothing, NULL, 1);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "do_nothing",
            "NULL",
            "1"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1012-1017",
          "snippet": "void smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid kick_all_cpus_sync(void)\n{\n\t/* Make sure the change is visible before we kick the cpus */\n\tsmp_mb();\n\tsmp_call_function(do_nothing, NULL, 1);\n}"
  },
  {
    "function_name": "do_nothing",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1140-1142",
    "snippet": "static void do_nothing(void *unused)\n{\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void do_nothing(void *unused)\n{\n}"
  },
  {
    "function_name": "on_each_cpu_cond_mask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1126-1137",
    "snippet": "void on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,\n\t\t\t   void *info, bool wait, const struct cpumask *mask)\n{\n\tunsigned int scf_flags = SCF_RUN_LOCAL;\n\n\tif (wait)\n\t\tscf_flags |= SCF_WAIT;\n\n\tpreempt_disable();\n\tsmp_call_function_many_cond(mask, func, info, scf_flags, cond_func);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define SCF_RUN_LOCAL\t(1U << 1)",
      "#define SCF_WAIT\t(1U << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_many_cond",
          "args": [
            "mask",
            "func",
            "info",
            "scf_flags",
            "cond_func"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many_cond",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "864-972",
          "snippet": "static void smp_call_function_many_cond(const struct cpumask *mask,\n\t\t\t\t\tsmp_call_func_t func, void *info,\n\t\t\t\t\tunsigned int scf_flags,\n\t\t\t\t\tsmp_cond_func_t cond_func)\n{\n\tint cpu, last_cpu, this_cpu = smp_processor_id();\n\tstruct call_function_data *cfd;\n\tbool wait = scf_flags & SCF_WAIT;\n\tbool run_remote = false;\n\tbool run_local = false;\n\tint nr_cpus = 0;\n\n\tlockdep_assert_preemption_disabled();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tif (cpu_online(this_cpu) && !oops_in_progress &&\n\t    !early_boot_irqs_disabled)\n\t\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\t/* Check if we need local execution. */\n\tif ((scf_flags & SCF_RUN_LOCAL) && cpumask_test_cpu(this_cpu, mask))\n\t\trun_local = true;\n\n\t/* Check if we need remote execution, i.e., any CPU excluding this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (cpu < nr_cpu_ids)\n\t\trun_remote = true;\n\n\tif (run_remote) {\n\t\tcfd = this_cpu_ptr(&cfd_data);\n\t\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t\tcpumask_clear(cfd->cpumask_ipi);\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\t\t\tcall_single_data_t *csd = &pcpu->csd;\n\n\t\t\tif (cond_func && !cond_func(cpu, info))\n\t\t\t\tcontinue;\n\n\t\t\tcsd_lock(csd);\n\t\t\tif (wait)\n\t\t\t\tcsd->node.u_flags |= CSD_TYPE_SYNC;\n\t\t\tcsd->func = func;\n\t\t\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\t\t\tcsd->node.src = smp_processor_id();\n\t\t\tcsd->node.dst = cpu;\n#endif\n\t\t\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\t\t\tif (llist_add(&csd->node.llist, &per_cpu(call_single_queue, cpu))) {\n\t\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t\t\t\tnr_cpus++;\n\t\t\t\tlast_cpu = cpu;\n\n\t\t\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\t\t} else {\n\t\t\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t\t\t}\n\t\t}\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->ping, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PING);\n\n\t\t/*\n\t\t * Choose the most efficient way to send an IPI. Note that the\n\t\t * number of CPUs might be zero due to concurrent changes to the\n\t\t * provided mask.\n\t\t */\n\t\tif (nr_cpus == 1)\n\t\t\tsend_call_function_single_ipi(last_cpu);\n\t\telse if (likely(nr_cpus > 1))\n\t\t\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->pinged, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED);\n\t}\n\n\tif (run_local && (!cond_func || cond_func(this_cpu, info))) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tif (run_remote && wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = &per_cpu_ptr(cfd->pcpu, cpu)->csd;\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define SCF_RUN_LOCAL\t(1U << 1)",
            "#define SCF_WAIT\t(1U << 0)",
            "#define CFD_SEQ_PINGED\t4",
            "#define CFD_SEQ_PING\t3",
            "#define CFD_SEQ_NOIPI\t2",
            "#define CFD_SEQ_IPI\t1",
            "#define CFD_SEQ_QUEUE\t0",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_RUN_LOCAL\t(1U << 1)\n#define SCF_WAIT\t(1U << 0)\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nstatic void smp_call_function_many_cond(const struct cpumask *mask,\n\t\t\t\t\tsmp_call_func_t func, void *info,\n\t\t\t\t\tunsigned int scf_flags,\n\t\t\t\t\tsmp_cond_func_t cond_func)\n{\n\tint cpu, last_cpu, this_cpu = smp_processor_id();\n\tstruct call_function_data *cfd;\n\tbool wait = scf_flags & SCF_WAIT;\n\tbool run_remote = false;\n\tbool run_local = false;\n\tint nr_cpus = 0;\n\n\tlockdep_assert_preemption_disabled();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tif (cpu_online(this_cpu) && !oops_in_progress &&\n\t    !early_boot_irqs_disabled)\n\t\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\t/* Check if we need local execution. */\n\tif ((scf_flags & SCF_RUN_LOCAL) && cpumask_test_cpu(this_cpu, mask))\n\t\trun_local = true;\n\n\t/* Check if we need remote execution, i.e., any CPU excluding this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (cpu < nr_cpu_ids)\n\t\trun_remote = true;\n\n\tif (run_remote) {\n\t\tcfd = this_cpu_ptr(&cfd_data);\n\t\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t\tcpumask_clear(cfd->cpumask_ipi);\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\t\t\tcall_single_data_t *csd = &pcpu->csd;\n\n\t\t\tif (cond_func && !cond_func(cpu, info))\n\t\t\t\tcontinue;\n\n\t\t\tcsd_lock(csd);\n\t\t\tif (wait)\n\t\t\t\tcsd->node.u_flags |= CSD_TYPE_SYNC;\n\t\t\tcsd->func = func;\n\t\t\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\t\t\tcsd->node.src = smp_processor_id();\n\t\t\tcsd->node.dst = cpu;\n#endif\n\t\t\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\t\t\tif (llist_add(&csd->node.llist, &per_cpu(call_single_queue, cpu))) {\n\t\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t\t\t\tnr_cpus++;\n\t\t\t\tlast_cpu = cpu;\n\n\t\t\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\t\t} else {\n\t\t\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t\t\t}\n\t\t}\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->ping, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PING);\n\n\t\t/*\n\t\t * Choose the most efficient way to send an IPI. Note that the\n\t\t * number of CPUs might be zero due to concurrent changes to the\n\t\t * provided mask.\n\t\t */\n\t\tif (nr_cpus == 1)\n\t\t\tsend_call_function_single_ipi(last_cpu);\n\t\telse if (likely(nr_cpus > 1))\n\t\t\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->pinged, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED);\n\t}\n\n\tif (run_local && (!cond_func || cond_func(this_cpu, info))) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tif (run_remote && wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = &per_cpu_ptr(cfd->pcpu, cpu)->csd;\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_RUN_LOCAL\t(1U << 1)\n#define SCF_WAIT\t(1U << 0)\n\nvoid on_each_cpu_cond_mask(smp_cond_func_t cond_func, smp_call_func_t func,\n\t\t\t   void *info, bool wait, const struct cpumask *mask)\n{\n\tunsigned int scf_flags = SCF_RUN_LOCAL;\n\n\tif (wait)\n\t\tscf_flags |= SCF_WAIT;\n\n\tpreempt_disable();\n\tsmp_call_function_many_cond(mask, func, info, scf_flags, cond_func);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "smp_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1083-1102",
    "snippet": "void __init smp_init(void)\n{\n\tint num_nodes, num_cpus;\n\n\tidle_threads_init();\n\tcpuhp_threads_init();\n\n\tpr_info(\"Bringing up secondary CPUs ...\\n\");\n\n\tbringup_nonboot_cpus(setup_max_cpus);\n\n\tnum_nodes = num_online_nodes();\n\tnum_cpus  = num_online_cpus();\n\tpr_info(\"Brought up %d node%s, %d CPU%s\\n\",\n\t\tnum_nodes, (num_nodes > 1 ? \"s\" : \"\"),\n\t\tnum_cpus,  (num_cpus  > 1 ? \"s\" : \"\"));\n\n\t/* Any cleanup work */\n\tsmp_cpus_done(setup_max_cpus);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int setup_max_cpus = NR_CPUS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_cpus_done",
          "args": [
            "setup_max_cpus"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Brought up %d node%s, %d CPU%s\\n\"",
            "num_nodes",
            "(num_nodes > 1 ? \"s\" : \"\")",
            "num_cpus",
            "(num_cpus  > 1 ? \"s\" : \"\")"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_nodes",
          "args": [],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bringup_nonboot_cpus",
          "args": [
            "setup_max_cpus"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "bringup_nonboot_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "1469-1479",
          "snippet": "void bringup_nonboot_cpus(unsigned int setup_max_cpus)\n{\n\tunsigned int cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= setup_max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu, CPUHP_ONLINE);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid bringup_nonboot_cpus(unsigned int setup_max_cpus)\n{\n\tunsigned int cpu;\n\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >= setup_max_cpus)\n\t\t\tbreak;\n\t\tif (!cpu_online(cpu))\n\t\t\tcpu_up(cpu, CPUHP_ONLINE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Bringing up secondary CPUs ...\\n\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuhp_threads_init",
          "args": [],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "cpuhp_threads_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "892-896",
          "snippet": "void __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstatic DEFINE_PER_CPU(struct cpuhp_cpu_state, cpuhp_state) = {\n\t.fail = CPUHP_INVALID,\n};\n\nvoid __init cpuhp_threads_init(void)\n{\n\tBUG_ON(smpboot_register_percpu_thread(&cpuhp_threads));\n\tkthread_unpark(this_cpu_read(cpuhp_state.thread));\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_threads_init",
          "args": [],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "idle_threads_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smpboot.c",
          "lines": "66-76",
          "snippet": "void __init idle_threads_init(void)\n{\n\tunsigned int cpu, boot_cpu;\n\n\tboot_cpu = smp_processor_id();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu != boot_cpu)\n\t\t\tidle_init(cpu);\n\t}\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <linux/smpboot.h>",
            "#include <linux/kthread.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <linux/smpboot.h>\n#include <linux/kthread.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid __init idle_threads_init(void)\n{\n\tunsigned int cpu, boot_cpu;\n\n\tboot_cpu = smp_processor_id();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu != boot_cpu)\n\t\t\tidle_init(cpu);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int setup_max_cpus = NR_CPUS;\n\nvoid __init smp_init(void)\n{\n\tint num_nodes, num_cpus;\n\n\tidle_threads_init();\n\tcpuhp_threads_init();\n\n\tpr_info(\"Bringing up secondary CPUs ...\\n\");\n\n\tbringup_nonboot_cpus(setup_max_cpus);\n\n\tnum_nodes = num_online_nodes();\n\tnum_cpus  = num_online_cpus();\n\tpr_info(\"Brought up %d node%s, %d CPU%s\\n\",\n\t\tnum_nodes, (num_nodes > 1 ? \"s\" : \"\"),\n\t\tnum_cpus,  (num_cpus  > 1 ? \"s\" : \"\"));\n\n\t/* Any cleanup work */\n\tsmp_cpus_done(setup_max_cpus);\n}"
  },
  {
    "function_name": "setup_nr_cpu_ids",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1077-1080",
    "snippet": "void __init setup_nr_cpu_ids(void)\n{\n\tnr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_last_bit",
          "args": [
            "cpumask_bits(cpu_possible_mask)",
            "NR_CPUS"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "cpu_possible_mask"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nvoid __init setup_nr_cpu_ids(void)\n{\n\tnr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),NR_CPUS) + 1;\n}"
  },
  {
    "function_name": "maxcpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1061-1068",
    "snippet": "static int __init maxcpus(char *str)\n{\n\tget_option(&str, &setup_max_cpus);\n\tif (setup_max_cpus == 0)\n\t\tarch_disable_smp_support();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int setup_max_cpus = NR_CPUS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_disable_smp_support",
          "args": [],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "arch_disable_smp_support",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1036-1036",
          "snippet": "void __weak arch_disable_smp_support(void) { }",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid __weak arch_disable_smp_support(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&setup_max_cpus"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int setup_max_cpus = NR_CPUS;\n\nstatic int __init maxcpus(char *str)\n{\n\tget_option(&str, &setup_max_cpus);\n\tif (setup_max_cpus == 0)\n\t\tarch_disable_smp_support();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nrcpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1049-1057",
    "snippet": "static int __init nrcpus(char *str)\n{\n\tint nr_cpus;\n\n\tif (get_option(&str, &nr_cpus) && nr_cpus > 0 && nr_cpus < nr_cpu_ids)\n\t\tnr_cpu_ids = nr_cpus;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&nr_cpus"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nstatic int __init nrcpus(char *str)\n{\n\tint nr_cpus;\n\n\tif (get_option(&str, &nr_cpus) && nr_cpus > 0 && nr_cpus < nr_cpu_ids)\n\t\tnr_cpu_ids = nr_cpus;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nosmp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1038-1044",
    "snippet": "static int __init nosmp(char *str)\n{\n\tsetup_max_cpus = 0;\n\tarch_disable_smp_support();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int setup_max_cpus = NR_CPUS;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_disable_smp_support",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "arch_disable_smp_support",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1036-1036",
          "snippet": "void __weak arch_disable_smp_support(void) { }",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid __weak arch_disable_smp_support(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int setup_max_cpus = NR_CPUS;\n\nstatic int __init nosmp(char *str)\n{\n\tsetup_max_cpus = 0;\n\tarch_disable_smp_support();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_disable_smp_support",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1036-1036",
    "snippet": "void __weak arch_disable_smp_support(void) { }",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid __weak arch_disable_smp_support(void) { }"
  },
  {
    "function_name": "smp_call_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "1012-1017",
    "snippet": "void smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_many",
          "args": [
            "cpu_online_mask",
            "func",
            "info",
            "wait"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "990-994",
          "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define SCF_WAIT\t(1U << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_WAIT\t(1U << 0)\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "smp_call_function_many",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "990-994",
    "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define SCF_WAIT\t(1U << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_many_cond",
          "args": [
            "mask",
            "func",
            "info",
            "wait * SCF_WAIT",
            "NULL"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many_cond",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "864-972",
          "snippet": "static void smp_call_function_many_cond(const struct cpumask *mask,\n\t\t\t\t\tsmp_call_func_t func, void *info,\n\t\t\t\t\tunsigned int scf_flags,\n\t\t\t\t\tsmp_cond_func_t cond_func)\n{\n\tint cpu, last_cpu, this_cpu = smp_processor_id();\n\tstruct call_function_data *cfd;\n\tbool wait = scf_flags & SCF_WAIT;\n\tbool run_remote = false;\n\tbool run_local = false;\n\tint nr_cpus = 0;\n\n\tlockdep_assert_preemption_disabled();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tif (cpu_online(this_cpu) && !oops_in_progress &&\n\t    !early_boot_irqs_disabled)\n\t\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\t/* Check if we need local execution. */\n\tif ((scf_flags & SCF_RUN_LOCAL) && cpumask_test_cpu(this_cpu, mask))\n\t\trun_local = true;\n\n\t/* Check if we need remote execution, i.e., any CPU excluding this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (cpu < nr_cpu_ids)\n\t\trun_remote = true;\n\n\tif (run_remote) {\n\t\tcfd = this_cpu_ptr(&cfd_data);\n\t\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t\tcpumask_clear(cfd->cpumask_ipi);\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\t\t\tcall_single_data_t *csd = &pcpu->csd;\n\n\t\t\tif (cond_func && !cond_func(cpu, info))\n\t\t\t\tcontinue;\n\n\t\t\tcsd_lock(csd);\n\t\t\tif (wait)\n\t\t\t\tcsd->node.u_flags |= CSD_TYPE_SYNC;\n\t\t\tcsd->func = func;\n\t\t\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\t\t\tcsd->node.src = smp_processor_id();\n\t\t\tcsd->node.dst = cpu;\n#endif\n\t\t\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\t\t\tif (llist_add(&csd->node.llist, &per_cpu(call_single_queue, cpu))) {\n\t\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t\t\t\tnr_cpus++;\n\t\t\t\tlast_cpu = cpu;\n\n\t\t\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\t\t} else {\n\t\t\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t\t\t}\n\t\t}\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->ping, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PING);\n\n\t\t/*\n\t\t * Choose the most efficient way to send an IPI. Note that the\n\t\t * number of CPUs might be zero due to concurrent changes to the\n\t\t * provided mask.\n\t\t */\n\t\tif (nr_cpus == 1)\n\t\t\tsend_call_function_single_ipi(last_cpu);\n\t\telse if (likely(nr_cpus > 1))\n\t\t\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->pinged, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED);\n\t}\n\n\tif (run_local && (!cond_func || cond_func(this_cpu, info))) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tif (run_remote && wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = &per_cpu_ptr(cfd->pcpu, cpu)->csd;\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define SCF_RUN_LOCAL\t(1U << 1)",
            "#define SCF_WAIT\t(1U << 0)",
            "#define CFD_SEQ_PINGED\t4",
            "#define CFD_SEQ_PING\t3",
            "#define CFD_SEQ_NOIPI\t2",
            "#define CFD_SEQ_IPI\t1",
            "#define CFD_SEQ_QUEUE\t0",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_RUN_LOCAL\t(1U << 1)\n#define SCF_WAIT\t(1U << 0)\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nstatic void smp_call_function_many_cond(const struct cpumask *mask,\n\t\t\t\t\tsmp_call_func_t func, void *info,\n\t\t\t\t\tunsigned int scf_flags,\n\t\t\t\t\tsmp_cond_func_t cond_func)\n{\n\tint cpu, last_cpu, this_cpu = smp_processor_id();\n\tstruct call_function_data *cfd;\n\tbool wait = scf_flags & SCF_WAIT;\n\tbool run_remote = false;\n\tbool run_local = false;\n\tint nr_cpus = 0;\n\n\tlockdep_assert_preemption_disabled();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tif (cpu_online(this_cpu) && !oops_in_progress &&\n\t    !early_boot_irqs_disabled)\n\t\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\t/* Check if we need local execution. */\n\tif ((scf_flags & SCF_RUN_LOCAL) && cpumask_test_cpu(this_cpu, mask))\n\t\trun_local = true;\n\n\t/* Check if we need remote execution, i.e., any CPU excluding this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (cpu < nr_cpu_ids)\n\t\trun_remote = true;\n\n\tif (run_remote) {\n\t\tcfd = this_cpu_ptr(&cfd_data);\n\t\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t\tcpumask_clear(cfd->cpumask_ipi);\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\t\t\tcall_single_data_t *csd = &pcpu->csd;\n\n\t\t\tif (cond_func && !cond_func(cpu, info))\n\t\t\t\tcontinue;\n\n\t\t\tcsd_lock(csd);\n\t\t\tif (wait)\n\t\t\t\tcsd->node.u_flags |= CSD_TYPE_SYNC;\n\t\t\tcsd->func = func;\n\t\t\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\t\t\tcsd->node.src = smp_processor_id();\n\t\t\tcsd->node.dst = cpu;\n#endif\n\t\t\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\t\t\tif (llist_add(&csd->node.llist, &per_cpu(call_single_queue, cpu))) {\n\t\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t\t\t\tnr_cpus++;\n\t\t\t\tlast_cpu = cpu;\n\n\t\t\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\t\t} else {\n\t\t\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t\t\t}\n\t\t}\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->ping, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PING);\n\n\t\t/*\n\t\t * Choose the most efficient way to send an IPI. Note that the\n\t\t * number of CPUs might be zero due to concurrent changes to the\n\t\t * provided mask.\n\t\t */\n\t\tif (nr_cpus == 1)\n\t\t\tsend_call_function_single_ipi(last_cpu);\n\t\telse if (likely(nr_cpus > 1))\n\t\t\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->pinged, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED);\n\t}\n\n\tif (run_local && (!cond_func || cond_func(this_cpu, info))) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tif (run_remote && wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = &per_cpu_ptr(cfd->pcpu, cpu)->csd;\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_WAIT\t(1U << 0)\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}"
  },
  {
    "function_name": "smp_call_function_many_cond",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "864-972",
    "snippet": "static void smp_call_function_many_cond(const struct cpumask *mask,\n\t\t\t\t\tsmp_call_func_t func, void *info,\n\t\t\t\t\tunsigned int scf_flags,\n\t\t\t\t\tsmp_cond_func_t cond_func)\n{\n\tint cpu, last_cpu, this_cpu = smp_processor_id();\n\tstruct call_function_data *cfd;\n\tbool wait = scf_flags & SCF_WAIT;\n\tbool run_remote = false;\n\tbool run_local = false;\n\tint nr_cpus = 0;\n\n\tlockdep_assert_preemption_disabled();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tif (cpu_online(this_cpu) && !oops_in_progress &&\n\t    !early_boot_irqs_disabled)\n\t\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\t/* Check if we need local execution. */\n\tif ((scf_flags & SCF_RUN_LOCAL) && cpumask_test_cpu(this_cpu, mask))\n\t\trun_local = true;\n\n\t/* Check if we need remote execution, i.e., any CPU excluding this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (cpu < nr_cpu_ids)\n\t\trun_remote = true;\n\n\tif (run_remote) {\n\t\tcfd = this_cpu_ptr(&cfd_data);\n\t\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t\tcpumask_clear(cfd->cpumask_ipi);\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\t\t\tcall_single_data_t *csd = &pcpu->csd;\n\n\t\t\tif (cond_func && !cond_func(cpu, info))\n\t\t\t\tcontinue;\n\n\t\t\tcsd_lock(csd);\n\t\t\tif (wait)\n\t\t\t\tcsd->node.u_flags |= CSD_TYPE_SYNC;\n\t\t\tcsd->func = func;\n\t\t\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\t\t\tcsd->node.src = smp_processor_id();\n\t\t\tcsd->node.dst = cpu;\n#endif\n\t\t\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\t\t\tif (llist_add(&csd->node.llist, &per_cpu(call_single_queue, cpu))) {\n\t\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t\t\t\tnr_cpus++;\n\t\t\t\tlast_cpu = cpu;\n\n\t\t\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\t\t} else {\n\t\t\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t\t\t}\n\t\t}\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->ping, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PING);\n\n\t\t/*\n\t\t * Choose the most efficient way to send an IPI. Note that the\n\t\t * number of CPUs might be zero due to concurrent changes to the\n\t\t * provided mask.\n\t\t */\n\t\tif (nr_cpus == 1)\n\t\t\tsend_call_function_single_ipi(last_cpu);\n\t\telse if (likely(nr_cpus > 1))\n\t\t\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->pinged, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED);\n\t}\n\n\tif (run_local && (!cond_func || cond_func(this_cpu, info))) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tif (run_remote && wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = &per_cpu_ptr(cfd->pcpu, cpu)->csd;\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define SCF_RUN_LOCAL\t(1U << 1)",
      "#define SCF_WAIT\t(1U << 0)",
      "#define CFD_SEQ_PINGED\t4",
      "#define CFD_SEQ_PING\t3",
      "#define CFD_SEQ_NOIPI\t2",
      "#define CFD_SEQ_IPI\t1",
      "#define CFD_SEQ_QUEUE\t0",
      "#define CFD_SEQ_NOCPU\t0xffff"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "438-441",
          "snippet": "static __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cfd->pcpu",
            "cpu"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cfd->cpumask"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_func",
          "args": [
            "this_cpu",
            "info"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->pinged",
            "this_cpu",
            "CFD_SEQ_NOCPU",
            "CFD_SEQ_PINGED"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_send_call_function_ipi_mask",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nr_cpus > 1"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_call_function_single_ipi",
          "args": [
            "last_cpu"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "send_call_function_single_ipi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3695-3703",
          "snippet": "void send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->ping",
            "this_cpu",
            "CFD_SEQ_NOCPU",
            "CFD_SEQ_PING"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "pcpu->seq_noipi",
            "this_cpu",
            "cpu",
            "CFD_SEQ_NOIPI"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "pcpu->seq_ipi",
            "this_cpu",
            "cpu",
            "CFD_SEQ_IPI"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpumask_set_cpu",
          "args": [
            "cpu",
            "cfd->cpumask_ipi"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "&csd->node.llist",
            "&per_cpu(call_single_queue, cpu)"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "call_single_queue",
            "cpu"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "pcpu->seq_queue",
            "this_cpu",
            "cpu",
            "CFD_SEQ_QUEUE"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock",
          "args": [
            "csd"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "444-455",
          "snippet": "static __always_inline void csd_lock(struct __call_single_data *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->node.u_flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock(struct __call_single_data *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->node.u_flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_func",
          "args": [
            "cpu",
            "info"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cfd->pcpu",
            "cpu"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cfd->cpumask"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cpumask_clear_cpu",
          "args": [
            "this_cpu",
            "cfd->cpumask"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "cfd->cpumask",
            "mask",
            "cpu_online_mask"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_data"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "cpu",
            "mask",
            "cpu_online_mask"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "this_cpu",
            "mask"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!in_task()"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "this_cpu"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_preemption_disabled",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_RUN_LOCAL\t(1U << 1)\n#define SCF_WAIT\t(1U << 0)\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nunsigned int nr_cpu_ids;\n\nstatic void smp_call_function_many_cond(const struct cpumask *mask,\n\t\t\t\t\tsmp_call_func_t func, void *info,\n\t\t\t\t\tunsigned int scf_flags,\n\t\t\t\t\tsmp_cond_func_t cond_func)\n{\n\tint cpu, last_cpu, this_cpu = smp_processor_id();\n\tstruct call_function_data *cfd;\n\tbool wait = scf_flags & SCF_WAIT;\n\tbool run_remote = false;\n\tbool run_local = false;\n\tint nr_cpus = 0;\n\n\tlockdep_assert_preemption_disabled();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tif (cpu_online(this_cpu) && !oops_in_progress &&\n\t    !early_boot_irqs_disabled)\n\t\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\t/* Check if we need local execution. */\n\tif ((scf_flags & SCF_RUN_LOCAL) && cpumask_test_cpu(this_cpu, mask))\n\t\trun_local = true;\n\n\t/* Check if we need remote execution, i.e., any CPU excluding this one. */\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\tif (cpu < nr_cpu_ids)\n\t\trun_remote = true;\n\n\tif (run_remote) {\n\t\tcfd = this_cpu_ptr(&cfd_data);\n\t\tcpumask_and(cfd->cpumask, mask, cpu_online_mask);\n\t\t__cpumask_clear_cpu(this_cpu, cfd->cpumask);\n\n\t\tcpumask_clear(cfd->cpumask_ipi);\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\t\t\tcall_single_data_t *csd = &pcpu->csd;\n\n\t\t\tif (cond_func && !cond_func(cpu, info))\n\t\t\t\tcontinue;\n\n\t\t\tcsd_lock(csd);\n\t\t\tif (wait)\n\t\t\t\tcsd->node.u_flags |= CSD_TYPE_SYNC;\n\t\t\tcsd->func = func;\n\t\t\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\t\t\tcsd->node.src = smp_processor_id();\n\t\t\tcsd->node.dst = cpu;\n#endif\n\t\t\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\t\t\tif (llist_add(&csd->node.llist, &per_cpu(call_single_queue, cpu))) {\n\t\t\t\t__cpumask_set_cpu(cpu, cfd->cpumask_ipi);\n\t\t\t\tnr_cpus++;\n\t\t\t\tlast_cpu = cpu;\n\n\t\t\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\t\t} else {\n\t\t\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t\t\t}\n\t\t}\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->ping, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PING);\n\n\t\t/*\n\t\t * Choose the most efficient way to send an IPI. Note that the\n\t\t * number of CPUs might be zero due to concurrent changes to the\n\t\t * provided mask.\n\t\t */\n\t\tif (nr_cpus == 1)\n\t\t\tsend_call_function_single_ipi(last_cpu);\n\t\telse if (likely(nr_cpus > 1))\n\t\t\tarch_send_call_function_ipi_mask(cfd->cpumask_ipi);\n\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->pinged, this_cpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED);\n\t}\n\n\tif (run_local && (!cond_func || cond_func(this_cpu, info))) {\n\t\tunsigned long flags;\n\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tlocal_irq_restore(flags);\n\t}\n\n\tif (run_remote && wait) {\n\t\tfor_each_cpu(cpu, cfd->cpumask) {\n\t\t\tcall_single_data_t *csd;\n\n\t\t\tcsd = &per_cpu_ptr(cfd->pcpu, cpu)->csd;\n\t\t\tcsd_lock_wait(csd);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "smp_call_function_any",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "826-852",
    "snippet": "int smp_call_function_any(const struct cpumask *mask,\n\t\t\t  smp_call_func_t func, void *info, int wait)\n{\n\tunsigned int cpu;\n\tconst struct cpumask *nodemask;\n\tint ret;\n\n\t/* Try for same CPU (cheapest) */\n\tcpu = get_cpu();\n\tif (cpumask_test_cpu(cpu, mask))\n\t\tgoto call;\n\n\t/* Try for same node. */\n\tnodemask = cpumask_of_node(cpu_to_node(cpu));\n\tfor (cpu = cpumask_first_and(nodemask, mask); cpu < nr_cpu_ids;\n\t     cpu = cpumask_next_and(cpu, nodemask, mask)) {\n\t\tif (cpu_online(cpu))\n\t\t\tgoto call;\n\t}\n\n\t/* Any online will do: smp_call_function_single handles nr_cpu_ids. */\n\tcpu = cpumask_any_and(mask, cpu_online_mask);\ncall:\n\tret = smp_call_function_single(cpu, func, info, wait);\n\tput_cpu();\n\treturn ret;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "func",
            "info",
            "wait"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "709-763",
          "snippet": "int smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.node = { .u_flags = CSD_FLAG_LOCK | CSD_TYPE_SYNC, },\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tcsd->node.src = smp_processor_id();\n\tcsd->node.dst = cpu;\n#endif\n\n\terr = generic_exec_single(cpu, csd);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);\n\nint smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.node = { .u_flags = CSD_FLAG_LOCK | CSD_TYPE_SYNC, },\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tcsd->node.src = smp_processor_id();\n\tcsd->node.dst = cpu;\n#endif\n\n\terr = generic_exec_single(cpu, csd);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "mask",
            "cpu_online_mask"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_next_and",
          "args": [
            "cpu",
            "nodemask",
            "mask"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "nodemask",
            "mask"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of_node",
          "args": [
            "cpu_to_node(cpu)"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nint smp_call_function_any(const struct cpumask *mask,\n\t\t\t  smp_call_func_t func, void *info, int wait)\n{\n\tunsigned int cpu;\n\tconst struct cpumask *nodemask;\n\tint ret;\n\n\t/* Try for same CPU (cheapest) */\n\tcpu = get_cpu();\n\tif (cpumask_test_cpu(cpu, mask))\n\t\tgoto call;\n\n\t/* Try for same node. */\n\tnodemask = cpumask_of_node(cpu_to_node(cpu));\n\tfor (cpu = cpumask_first_and(nodemask, mask); cpu < nr_cpu_ids;\n\t     cpu = cpumask_next_and(cpu, nodemask, mask)) {\n\t\tif (cpu_online(cpu))\n\t\t\tgoto call;\n\t}\n\n\t/* Any online will do: smp_call_function_single handles nr_cpu_ids. */\n\tcpu = cpumask_any_and(mask, cpu_online_mask);\ncall:\n\tret = smp_call_function_single(cpu, func, info, wait);\n\tput_cpu();\n\treturn ret;\n}"
  },
  {
    "function_name": "smp_call_function_single_async",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "789-809",
    "snippet": "int smp_call_function_single_async(int cpu, struct __call_single_data *csd)\n{\n\tint err = 0;\n\n\tpreempt_disable();\n\n\tif (csd->node.u_flags & CSD_FLAG_LOCK) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcsd->node.u_flags = CSD_FLAG_LOCK;\n\tsmp_wmb();\n\n\terr = generic_exec_single(cpu, csd);\n\nout:\n\tpreempt_enable();\n\n\treturn err;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_exec_single",
          "args": [
            "cpu",
            "csd"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "generic_exec_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "504-532",
          "snippet": "static int generic_exec_single(int cpu, struct __call_single_data *csd)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_lock_record(csd);\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tcsd_lock_record(NULL);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\t__smp_call_single_queue(cpu, &csd->node.llist);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nstatic int generic_exec_single(int cpu, struct __call_single_data *csd)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_lock_record(csd);\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tcsd_lock_record(NULL);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\t__smp_call_single_queue(cpu, &csd->node.llist);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smp_call_function_single_async(int cpu, struct __call_single_data *csd)\n{\n\tint err = 0;\n\n\tpreempt_disable();\n\n\tif (csd->node.u_flags & CSD_FLAG_LOCK) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcsd->node.u_flags = CSD_FLAG_LOCK;\n\tsmp_wmb();\n\n\terr = generic_exec_single(cpu, csd);\n\nout:\n\tpreempt_enable();\n\n\treturn err;\n}"
  },
  {
    "function_name": "smp_call_function_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "709-763",
    "snippet": "int smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.node = { .u_flags = CSD_FLAG_LOCK | CSD_TYPE_SYNC, },\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tcsd->node.src = smp_processor_id();\n\tcsd->node.dst = cpu;\n#endif\n\n\terr = generic_exec_single(cpu, csd);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "438-441",
          "snippet": "static __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_exec_single",
          "args": [
            "cpu",
            "csd"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "generic_exec_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "504-532",
          "snippet": "static int generic_exec_single(int cpu, struct __call_single_data *csd)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_lock_record(csd);\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tcsd_lock_record(NULL);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\t__smp_call_single_queue(cpu, &csd->node.llist);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nstatic int generic_exec_single(int cpu, struct __call_single_data *csd)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_lock_record(csd);\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tcsd_lock_record(NULL);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\t__smp_call_single_queue(cpu, &csd->node.llist);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock",
          "args": [
            "csd"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "444-455",
          "snippet": "static __always_inline void csd_lock(struct __call_single_data *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->node.u_flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock(struct __call_single_data *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->node.u_flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&csd_data"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!in_task()"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_task",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "this_cpu"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpu_data",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_hwlat.c",
          "lines": "120-126",
          "snippet": "static struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hwlat_kthread_data hwlat_single_cpu_data;",
            "static DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);",
            "static struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/sched/clock.h>\n#include <linux/delay.h>\n#include <linux/cpumask.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n\nstatic struct hwlat_kthread_data hwlat_single_cpu_data;\nstatic DEFINE_PER_CPU(struct hwlat_kthread_data, hwlat_per_cpu_data);\nstatic struct hwlat_data {\n\n\tstruct mutex lock;\t\t/* protect changes */\n\n\tu64\tcount;\t\t\t/* total since reset */\n\n\tu64\tsample_window;\t\t/* total sampling window (on+off) */\n\tu64\tsample_width;\t\t/* active sampling portion of window */\n\n\tint\tthread_mode;\t\t/* thread mode */\n\n} hwlat_data = {\n\t.sample_window\t\t= DEFAULT_SAMPLE_WINDOW,\n\t.sample_width\t\t= DEFAULT_SAMPLE_WIDTH,\n\t.thread_mode\t\t= MODE_ROUND_ROBIN\n};\n\nstatic struct hwlat_kthread_data *get_cpu_data(void)\n{\n\tif (hwlat_data.thread_mode == MODE_PER_CPU)\n\t\treturn this_cpu_ptr(&hwlat_per_cpu_data);\n\telse\n\t\treturn &hwlat_single_cpu_data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(call_single_data_t, csd_data);\n\nint smp_call_function_single(int cpu, smp_call_func_t func, void *info,\n\t\t\t     int wait)\n{\n\tcall_single_data_t *csd;\n\tcall_single_data_t csd_stack = {\n\t\t.node = { .u_flags = CSD_FLAG_LOCK | CSD_TYPE_SYNC, },\n\t};\n\tint this_cpu;\n\tint err;\n\n\t/*\n\t * prevent preemption and reschedule on another processor,\n\t * as well as CPU removal\n\t */\n\tthis_cpu = get_cpu();\n\n\t/*\n\t * Can deadlock when called with interrupts disabled.\n\t * We allow cpu's that are not yet online though, as no one else can\n\t * send smp call function interrupt to this cpu and as such deadlocks\n\t * can't happen.\n\t */\n\tWARN_ON_ONCE(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress);\n\n\t/*\n\t * When @wait we can deadlock when we interrupt between llist_add() and\n\t * arch_send_call_function_ipi*(); when !@wait we can deadlock due to\n\t * csd_lock() on because the interrupt context uses the same csd\n\t * storage.\n\t */\n\tWARN_ON_ONCE(!in_task());\n\n\tcsd = &csd_stack;\n\tif (!wait) {\n\t\tcsd = this_cpu_ptr(&csd_data);\n\t\tcsd_lock(csd);\n\t}\n\n\tcsd->func = func;\n\tcsd->info = info;\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tcsd->node.src = smp_processor_id();\n\tcsd->node.dst = cpu;\n#endif\n\n\terr = generic_exec_single(cpu, csd);\n\n\tif (wait)\n\t\tcsd_lock_wait(csd);\n\n\tput_cpu();\n\n\treturn err;\n}"
  },
  {
    "function_name": "flush_smp_call_function_from_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "684-699",
    "snippet": "void flush_smp_call_function_from_idle(void)\n{\n\tunsigned long flags;\n\n\tif (llist_empty(this_cpu_ptr(&call_single_queue)))\n\t\treturn;\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->idle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_IDLE);\n\tlocal_irq_save(flags);\n\tflush_smp_call_function_queue(true);\n\tif (local_softirq_pending())\n\t\tdo_softirq();\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define CFD_SEQ_IDLE\t7",
      "#define CFD_SEQ_NOCPU\t0xffff"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_softirq",
          "args": [],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "do_softirq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "446-462",
          "snippet": "void do_softirq(void)\n{\n\t__u32 pending;\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpending = local_softirq_pending();\n\n\tif (pending && !ksoftirqd_running(pending))\n\t\tdo_softirq_own_stack();\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid do_softirq(void)\n{\n\t__u32 pending;\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tpending = local_softirq_pending();\n\n\tif (pending && !ksoftirqd_running(pending))\n\t\tdo_softirq_own_stack();\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_softirq_pending",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_smp_call_function_queue",
          "args": [
            "true"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->idle",
            "CFD_SEQ_NOCPU",
            "smp_processor_id()",
            "CFD_SEQ_IDLE"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "this_cpu_ptr(&call_single_queue)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&call_single_queue"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_IDLE\t7\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nvoid flush_smp_call_function_from_idle(void)\n{\n\tunsigned long flags;\n\n\tif (llist_empty(this_cpu_ptr(&call_single_queue)))\n\t\treturn;\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->idle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_IDLE);\n\tlocal_irq_save(flags);\n\tflush_smp_call_function_queue(true);\n\tif (local_softirq_pending())\n\t\tdo_softirq();\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "flush_smp_call_function_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "561-682",
    "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define CFD_SEQ_HDLEND\t9",
      "#define CFD_SEQ_DEQUEUE\t6",
      "#define CFD_SEQ_HANDLE\t5",
      "#define CFD_SEQ_NOCPU\t0xffff"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
      "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->hdlend",
            "CFD_SEQ_NOCPU",
            "smp_processor_id()",
            "CFD_SEQ_HDLEND"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_ttwu_pending",
          "args": [
            "entry"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "sched_ttwu_pending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3662-3693",
          "snippet": "void sched_ttwu_pending(void *arg)\n{\n\tstruct llist_node *llist = arg;\n\tstruct rq *rq = this_rq();\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\t/*\n\t * rq::ttwu_pending racy indication of out-standing wakeups.\n\t * Races such that false-negatives are possible, since they\n\t * are shorter lived that false-positives would be.\n\t */\n\tWRITE_ONCE(rq->ttwu_pending, 0);\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry.llist) {\n\t\tif (WARN_ON_ONCE(p->on_cpu))\n\t\t\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\t\tif (WARN_ON_ONCE(task_cpu(p) != cpu_of(rq)))\n\t\t\tset_task_cpu(p, cpu_of(rq));\n\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\t}\n\n\trq_unlock_irqrestore(rq, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_ttwu_pending(void *arg)\n{\n\tstruct llist_node *llist = arg;\n\tstruct rq *rq = this_rq();\n\tstruct task_struct *p, *t;\n\tstruct rq_flags rf;\n\n\tif (!llist)\n\t\treturn;\n\n\t/*\n\t * rq::ttwu_pending racy indication of out-standing wakeups.\n\t * Races such that false-negatives are possible, since they\n\t * are shorter lived that false-positives would be.\n\t */\n\tWRITE_ONCE(rq->ttwu_pending, 0);\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\tllist_for_each_entry_safe(p, t, llist, wake_entry.llist) {\n\t\tif (WARN_ON_ONCE(p->on_cpu))\n\t\t\tsmp_cond_load_acquire(&p->on_cpu, !VAL);\n\n\t\tif (WARN_ON_ONCE(task_cpu(p) != cpu_of(rq)))\n\t\t\tset_task_cpu(p, cpu_of(rq));\n\n\t\tttwu_do_activate(rq, p, p->sched_remote_wakeup ? WF_MIGRATED : 0, &rf);\n\t}\n\n\trq_unlock_irqrestore(rq, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_single",
          "args": [
            "csd"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "191-223",
          "snippet": "void irq_work_single(void *arg)\n{\n\tstruct irq_work *work = arg;\n\tint flags;\n\n\t/*\n\t * Clear the PENDING bit, after this point the @work can be re-used.\n\t * The PENDING bit acts as a lock, and we own it, so we can clear it\n\t * without atomic ops.\n\t */\n\tflags = atomic_read(&work->node.a_flags);\n\tflags &= ~IRQ_WORK_PENDING;\n\tatomic_set(&work->node.a_flags, flags);\n\n\t/*\n\t * See irq_work_claim().\n\t */\n\tsmp_mb();\n\n\tlockdep_irq_work_enter(flags);\n\twork->func(work);\n\tlockdep_irq_work_exit(flags);\n\n\t/*\n\t * Clear the BUSY bit, if set, and return to the free state if no-one\n\t * else claimed it meanwhile.\n\t */\n\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt())\n\t\trcuwait_wake_up(&work->irqwait);\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_single(void *arg)\n{\n\tstruct irq_work *work = arg;\n\tint flags;\n\n\t/*\n\t * Clear the PENDING bit, after this point the @work can be re-used.\n\t * The PENDING bit acts as a lock, and we own it, so we can clear it\n\t * without atomic ops.\n\t */\n\tflags = atomic_read(&work->node.a_flags);\n\tflags &= ~IRQ_WORK_PENDING;\n\tatomic_set(&work->node.a_flags, flags);\n\n\t/*\n\t * See irq_work_claim().\n\t */\n\tsmp_mb();\n\n\tlockdep_irq_work_enter(flags);\n\twork->func(work);\n\tlockdep_irq_work_exit(flags);\n\n\t/*\n\t * Clear the BUSY bit, if set, and return to the free state if no-one\n\t * else claimed it meanwhile.\n\t */\n\t(void)atomic_cmpxchg(&work->node.a_flags, flags, flags & ~IRQ_WORK_BUSY);\n\n\tif ((IS_ENABLED(CONFIG_PREEMPT_RT) && !irq_work_is_hard(work)) ||\n\t    !arch_irq_work_has_interrupt())\n\t\trcuwait_wake_up(&work->irqwait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "csd_lock_record",
          "args": [
            "NULL"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "434-436",
          "snippet": "static void csd_lock_record(struct __call_single_data *csd)\n{\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void csd_lock_record(struct __call_single_data *csd)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "csd_unlock",
          "args": [
            "csd"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "csd_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "457-465",
          "snippet": "static __always_inline void csd_unlock(struct __call_single_data *csd)\n{\n\tWARN_ON(!(csd->node.u_flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->node.u_flags, 0);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_unlock(struct __call_single_data *csd)\n{\n\tWARN_ON(!(csd->node.u_flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->node.u_flags, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSD_TYPE",
          "args": [
            "csd"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "csd",
            "csd_next",
            "entry",
            "node.llist"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->hdlend",
            "0",
            "smp_processor_id()",
            "CFD_SEQ_HDLEND"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSD_TYPE",
          "args": [
            "csd"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry_safe",
          "args": [
            "csd",
            "csd_next",
            "entry",
            "node.llist"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"IPI callback, unknown type %d, sent to offline CPU\\n\"",
            "CSD_TYPE(csd)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSD_TYPE",
          "args": [
            "csd"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"IPI task-wakeup sent to offline CPU\\n\""
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"IPI callback %pS sent to offline CPU\\n\"",
            "csd->func"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CSD_TYPE",
          "args": [
            "csd"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_for_each_entry",
          "args": [
            "csd",
            "entry",
            "node.llist"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"IPI on offline CPU %d\\n\"",
            "smp_processor_id()"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_empty",
          "args": [
            "head"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "smp_processor_id()"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_reverse_order",
          "args": [
            "entry"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->dequeue",
            "/* Special meaning of source cpu: 0 == queue empty */entry ? CFD_SEQ_NOCPU : 0",
            "smp_processor_id()",
            "CFD_SEQ_DEQUEUE"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_del_all",
          "args": [
            "head"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->handle",
            "CFD_SEQ_NOCPU",
            "smp_processor_id()",
            "CFD_SEQ_HANDLE"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&call_single_queue"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
  },
  {
    "function_name": "generic_smp_call_function_single_interrupt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "540-545",
    "snippet": "void generic_smp_call_function_single_interrupt(void)\n{\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->gotipi, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_GOTIPI);\n\tflush_smp_call_function_queue(true);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define CFD_SEQ_GOTIPI\t8",
      "#define CFD_SEQ_NOCPU\t0xffff"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_smp_call_function_queue",
          "args": [
            "true"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "this_cpu_ptr(&cfd_seq_local)->gotipi",
            "CFD_SEQ_NOCPU",
            "smp_processor_id()",
            "CFD_SEQ_GOTIPI"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_GOTIPI\t8\n#define CFD_SEQ_NOCPU\t0xffff\n\nvoid generic_smp_call_function_single_interrupt(void)\n{\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->gotipi, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_GOTIPI);\n\tflush_smp_call_function_queue(true);\n}"
  },
  {
    "function_name": "generic_exec_single",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "504-532",
    "snippet": "static int generic_exec_single(int cpu, struct __call_single_data *csd)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_lock_record(csd);\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tcsd_lock_record(NULL);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\t__smp_call_single_queue(cpu, &csd->node.llist);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__smp_call_single_queue",
          "args": [
            "cpu",
            "&csd->node.llist"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "__smp_call_single_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "469-497",
          "snippet": "void __smp_call_single_queue(int cpu, struct llist_node *node)\n{\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tif (static_branch_unlikely(&csdlock_debug_extended)) {\n\t\tunsigned int type;\n\n\t\ttype = CSD_TYPE(container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist));\n\t\tif (type == CSD_TYPE_SYNC || type == CSD_TYPE_ASYNC) {\n\t\t\t__smp_call_single_queue_debug(cpu, node);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu)))\n\t\tsend_call_function_single_ipi(cpu);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nvoid __smp_call_single_queue(int cpu, struct llist_node *node)\n{\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tif (static_branch_unlikely(&csdlock_debug_extended)) {\n\t\tunsigned int type;\n\n\t\ttype = CSD_TYPE(container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist));\n\t\tif (type == CSD_TYPE_SYNC || type == CSD_TYPE_ASYNC) {\n\t\t\t__smp_call_single_queue_debug(cpu, node);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu)))\n\t\tsend_call_function_single_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "csd_unlock",
          "args": [
            "csd"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "csd_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "457-465",
          "snippet": "static __always_inline void csd_unlock(struct __call_single_data *csd)\n{\n\tWARN_ON(!(csd->node.u_flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->node.u_flags, 0);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_unlock(struct __call_single_data *csd)\n{\n\tWARN_ON(!(csd->node.u_flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->node.u_flags, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "2616-2619",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_record",
          "args": [
            "NULL"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "434-436",
          "snippet": "static void csd_lock_record(struct __call_single_data *csd)\n{\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void csd_lock_record(struct __call_single_data *csd)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "info"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nunsigned int nr_cpu_ids;\n\nstatic int generic_exec_single(int cpu, struct __call_single_data *csd)\n{\n\tif (cpu == smp_processor_id()) {\n\t\tsmp_call_func_t func = csd->func;\n\t\tvoid *info = csd->info;\n\t\tunsigned long flags;\n\n\t\t/*\n\t\t * We can unlock early even for the synchronous on-stack case,\n\t\t * since we're doing this from the same CPU..\n\t\t */\n\t\tcsd_lock_record(csd);\n\t\tcsd_unlock(csd);\n\t\tlocal_irq_save(flags);\n\t\tfunc(info);\n\t\tcsd_lock_record(NULL);\n\t\tlocal_irq_restore(flags);\n\t\treturn 0;\n\t}\n\n\tif ((unsigned)cpu >= nr_cpu_ids || !cpu_online(cpu)) {\n\t\tcsd_unlock(csd);\n\t\treturn -ENXIO;\n\t}\n\n\t__smp_call_single_queue(cpu, &csd->node.llist);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__smp_call_single_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "469-497",
    "snippet": "void __smp_call_single_queue(int cpu, struct llist_node *node)\n{\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tif (static_branch_unlikely(&csdlock_debug_extended)) {\n\t\tunsigned int type;\n\n\t\ttype = CSD_TYPE(container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist));\n\t\tif (type == CSD_TYPE_SYNC || type == CSD_TYPE_ASYNC) {\n\t\t\t__smp_call_single_queue_debug(cpu, node);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu)))\n\t\tsend_call_function_single_ipi(cpu);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_call_function_single_ipi",
          "args": [
            "cpu"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "send_call_function_single_ipi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3695-3703",
          "snippet": "void send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "node",
            "&per_cpu(call_single_queue, cpu)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "call_single_queue",
            "cpu"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__smp_call_single_queue_debug",
          "args": [
            "cpu",
            "node"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__smp_call_single_queue_debug",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "414-430",
          "snippet": "static void __smp_call_single_queue_debug(int cpu, struct llist_node *node)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tstruct cfd_seq_local *seq = this_cpu_ptr(&cfd_seq_local);\n\tstruct call_function_data *cfd = this_cpu_ptr(&cfd_data);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\n\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu))) {\n\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\tcfd_seq_store(seq->ping, this_cpu, cpu, CFD_SEQ_PING);\n\t\tsend_call_function_single_ipi(cpu);\n\t\tcfd_seq_store(seq->pinged, this_cpu, cpu, CFD_SEQ_PINGED);\n\t} else {\n\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t}\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_PINGED\t4",
            "#define CFD_SEQ_PING\t3",
            "#define CFD_SEQ_NOIPI\t2",
            "#define CFD_SEQ_IPI\t1",
            "#define CFD_SEQ_QUEUE\t0"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);",
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nstatic void __smp_call_single_queue_debug(int cpu, struct llist_node *node)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tstruct cfd_seq_local *seq = this_cpu_ptr(&cfd_seq_local);\n\tstruct call_function_data *cfd = this_cpu_ptr(&cfd_data);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\n\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu))) {\n\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\tcfd_seq_store(seq->ping, this_cpu, cpu, CFD_SEQ_PING);\n\t\tsend_call_function_single_ipi(cpu);\n\t\tcfd_seq_store(seq->pinged, this_cpu, cpu, CFD_SEQ_PINGED);\n\t} else {\n\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSD_TYPE",
          "args": [
            "container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "call_single_data_t",
            "node.llist"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&csdlock_debug_extended"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nvoid __smp_call_single_queue(int cpu, struct llist_node *node)\n{\n#ifdef CONFIG_CSD_LOCK_WAIT_DEBUG\n\tif (static_branch_unlikely(&csdlock_debug_extended)) {\n\t\tunsigned int type;\n\n\t\ttype = CSD_TYPE(container_of(node, call_single_data_t,\n\t\t\t\t\t     node.llist));\n\t\tif (type == CSD_TYPE_SYNC || type == CSD_TYPE_ASYNC) {\n\t\t\t__smp_call_single_queue_debug(cpu, node);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * The list addition should be visible before sending the IPI\n\t * handler locks the list to pull the entry off it because of\n\t * normal cache coherency rules implied by spinlocks.\n\t *\n\t * If IPIs can go out of order to the cache coherency protocol\n\t * in an architecture, sufficient synchronisation should be added\n\t * to arch code to make it appear to obey cache coherency WRT\n\t * locking and barrier primitives. Generic code isn't really\n\t * equipped to do the right thing...\n\t */\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu)))\n\t\tsend_call_function_single_ipi(cpu);\n}"
  },
  {
    "function_name": "csd_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "457-465",
    "snippet": "static __always_inline void csd_unlock(struct __call_single_data *csd)\n{\n\tWARN_ON(!(csd->node.u_flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->node.u_flags, 0);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&csd->node.u_flags",
            "0"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(csd->node.u_flags & CSD_FLAG_LOCK)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_unlock(struct __call_single_data *csd)\n{\n\tWARN_ON(!(csd->node.u_flags & CSD_FLAG_LOCK));\n\n\t/*\n\t * ensure we're all done before releasing data:\n\t */\n\tsmp_store_release(&csd->node.u_flags, 0);\n}"
  },
  {
    "function_name": "csd_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "444-455",
    "snippet": "static __always_inline void csd_lock(struct __call_single_data *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->node.u_flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "438-441",
          "snippet": "static __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock(struct __call_single_data *csd)\n{\n\tcsd_lock_wait(csd);\n\tcsd->node.u_flags |= CSD_FLAG_LOCK;\n\n\t/*\n\t * prevent CPU from reordering the above assignment\n\t * to ->flags with any subsequent assignments to other\n\t * fields of the specified call_single_data_t structure:\n\t */\n\tsmp_wmb();\n}"
  },
  {
    "function_name": "csd_lock_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "438-441",
    "snippet": "static __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_cond_load_acquire",
          "args": [
            "&csd->node.u_flags",
            "!(VAL & CSD_FLAG_LOCK)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}"
  },
  {
    "function_name": "csd_lock_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "434-436",
    "snippet": "static void csd_lock_record(struct __call_single_data *csd)\n{\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void csd_lock_record(struct __call_single_data *csd)\n{\n}"
  },
  {
    "function_name": "__smp_call_single_queue_debug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "414-430",
    "snippet": "static void __smp_call_single_queue_debug(int cpu, struct llist_node *node)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tstruct cfd_seq_local *seq = this_cpu_ptr(&cfd_seq_local);\n\tstruct call_function_data *cfd = this_cpu_ptr(&cfd_data);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\n\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu))) {\n\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\tcfd_seq_store(seq->ping, this_cpu, cpu, CFD_SEQ_PING);\n\t\tsend_call_function_single_ipi(cpu);\n\t\tcfd_seq_store(seq->pinged, this_cpu, cpu, CFD_SEQ_PINGED);\n\t} else {\n\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t}\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define CFD_SEQ_PINGED\t4",
      "#define CFD_SEQ_PING\t3",
      "#define CFD_SEQ_NOIPI\t2",
      "#define CFD_SEQ_IPI\t1",
      "#define CFD_SEQ_QUEUE\t0"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);",
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "pcpu->seq_noipi",
            "this_cpu",
            "cpu",
            "CFD_SEQ_NOIPI"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "seq->pinged",
            "this_cpu",
            "cpu",
            "CFD_SEQ_PINGED"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_call_function_single_ipi",
          "args": [
            "cpu"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "send_call_function_single_ipi",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3695-3703",
          "snippet": "void send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid send_call_function_single_ipi(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\n\tif (!set_nr_if_polling(rq->idle))\n\t\tarch_send_call_function_single_ipi(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "seq->ping",
            "this_cpu",
            "cpu",
            "CFD_SEQ_PING"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "pcpu->seq_ipi",
            "this_cpu",
            "cpu",
            "CFD_SEQ_IPI"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llist_add",
          "args": [
            "node",
            "&per_cpu(call_single_queue, cpu)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "call_single_queue",
            "cpu"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfd_seq_store",
          "args": [
            "pcpu->seq_queue",
            "this_cpu",
            "cpu",
            "CFD_SEQ_QUEUE"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cfd->pcpu",
            "cpu"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_data"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cfd_seq_local"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nstatic void __smp_call_single_queue_debug(int cpu, struct llist_node *node)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tstruct cfd_seq_local *seq = this_cpu_ptr(&cfd_seq_local);\n\tstruct call_function_data *cfd = this_cpu_ptr(&cfd_data);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\n\tcfd_seq_store(pcpu->seq_queue, this_cpu, cpu, CFD_SEQ_QUEUE);\n\tif (llist_add(node, &per_cpu(call_single_queue, cpu))) {\n\t\tcfd_seq_store(pcpu->seq_ipi, this_cpu, cpu, CFD_SEQ_IPI);\n\t\tcfd_seq_store(seq->ping, this_cpu, cpu, CFD_SEQ_PING);\n\t\tsend_call_function_single_ipi(cpu);\n\t\tcfd_seq_store(seq->pinged, this_cpu, cpu, CFD_SEQ_PINGED);\n\t} else {\n\t\tcfd_seq_store(pcpu->seq_noipi, this_cpu, cpu, CFD_SEQ_NOIPI);\n\t}\n}"
  },
  {
    "function_name": "csd_lock_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "404-412",
    "snippet": "static __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tif (static_branch_unlikely(&csdlock_debug_enabled)) {\n\t\t__csd_lock_wait(csd);\n\t\treturn;\n\t}\n\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_cond_load_acquire",
          "args": [
            "&csd->node.u_flags",
            "!(VAL & CSD_FLAG_LOCK)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__csd_lock_wait",
          "args": [
            "csd"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__csd_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "390-402",
          "snippet": "static void __csd_lock_wait(struct __call_single_data *csd)\n{\n\tint bug_id = 0;\n\tu64 ts0, ts1;\n\n\tts1 = ts0 = sched_clock();\n\tfor (;;) {\n\t\tif (csd_lock_wait_toolong(csd, ts0, &ts1, &bug_id))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tsmp_acquire__after_ctrl_dep();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void __csd_lock_wait(struct __call_single_data *csd)\n{\n\tint bug_id = 0;\n\tu64 ts0, ts1;\n\n\tts1 = ts0 = sched_clock();\n\tfor (;;) {\n\t\tif (csd_lock_wait_toolong(csd, ts0, &ts1, &bug_id))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tsmp_acquire__after_ctrl_dep();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&csdlock_debug_enabled"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_wait(struct __call_single_data *csd)\n{\n\tif (static_branch_unlikely(&csdlock_debug_enabled)) {\n\t\t__csd_lock_wait(csd);\n\t\treturn;\n\t}\n\n\tsmp_cond_load_acquire(&csd->node.u_flags, !(VAL & CSD_FLAG_LOCK));\n}"
  },
  {
    "function_name": "__csd_lock_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "390-402",
    "snippet": "static void __csd_lock_wait(struct __call_single_data *csd)\n{\n\tint bug_id = 0;\n\tu64 ts0, ts1;\n\n\tts1 = ts0 = sched_clock();\n\tfor (;;) {\n\t\tif (csd_lock_wait_toolong(csd, ts0, &ts1, &bug_id))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tsmp_acquire__after_ctrl_dep();\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_acquire__after_ctrl_dep",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait_toolong",
          "args": [
            "csd",
            "ts0",
            "&ts1",
            "&bug_id"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait_toolong",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "324-381",
          "snippet": "static bool csd_lock_wait_toolong(struct __call_single_data *csd, u64 ts0, u64 *ts1, int *bug_id)\n{\n\tint cpu = -1;\n\tint cpux;\n\tbool firsttime;\n\tu64 ts2, ts_delta;\n\tcall_single_data_t *cpu_cur_csd;\n\tunsigned int flags = READ_ONCE(csd->node.u_flags);\n\n\tif (!(flags & CSD_FLAG_LOCK)) {\n\t\tif (!unlikely(*bug_id))\n\t\t\treturn true;\n\t\tcpu = csd_lock_wait_getcpu(csd);\n\t\tpr_alert(\"csd: CSD lock (#%d) got unstuck on CPU#%02d, CPU#%02d released the lock.\\n\",\n\t\t\t *bug_id, raw_smp_processor_id(), cpu);\n\t\treturn true;\n\t}\n\n\tts2 = sched_clock();\n\tts_delta = ts2 - *ts1;\n\tif (likely(ts_delta <= CSD_LOCK_TIMEOUT))\n\t\treturn false;\n\n\tfirsttime = !*bug_id;\n\tif (firsttime)\n\t\t*bug_id = atomic_inc_return(&csd_bug_count);\n\tcpu = csd_lock_wait_getcpu(csd);\n\tif (WARN_ONCE(cpu < 0 || cpu >= nr_cpu_ids, \"%s: cpu = %d\\n\", __func__, cpu))\n\t\tcpux = 0;\n\telse\n\t\tcpux = cpu;\n\tcpu_cur_csd = smp_load_acquire(&per_cpu(cur_csd, cpux)); /* Before func and info. */\n\tpr_alert(\"csd: %s non-responsive CSD lock (#%d) on CPU#%d, waiting %llu ns for CPU#%02d %pS(%ps).\\n\",\n\t\t firsttime ? \"Detected\" : \"Continued\", *bug_id, raw_smp_processor_id(), ts2 - ts0,\n\t\t cpu, csd->func, csd->info);\n\tif (cpu_cur_csd && csd != cpu_cur_csd) {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) handling prior %pS(%ps) request.\\n\",\n\t\t\t *bug_id, READ_ONCE(per_cpu(cur_csd_func, cpux)),\n\t\t\t READ_ONCE(per_cpu(cur_csd_info, cpux)));\n\t} else {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) %s.\\n\",\n\t\t\t *bug_id, !cpu_cur_csd ? \"unresponsive\" : \"handling this request\");\n\t}\n\tif (cpu >= 0) {\n\t\tif (static_branch_unlikely(&csdlock_debug_extended))\n\t\t\tcsd_lock_print_extended(csd, cpu);\n\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\tdump_cpu_task(cpu);\n\t\tif (!cpu_cur_csd) {\n\t\t\tpr_alert(\"csd: Re-sending CSD lock (#%d) IPI from CPU#%02d to CPU#%02d\\n\", *bug_id, raw_smp_processor_id(), cpu);\n\t\t\tarch_send_call_function_single_ipi(cpu);\n\t\t}\n\t}\n\tdump_stack();\n\t*ts1 = ts2;\n\n\treturn false;\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CSD_LOCK_TIMEOUT (5ULL * NSEC_PER_SEC)"
          ],
          "globals_used": [
            "unsigned int nr_cpu_ids"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CSD_LOCK_TIMEOUT (5ULL * NSEC_PER_SEC)\n\nunsigned int nr_cpu_ids;\n\nstatic bool csd_lock_wait_toolong(struct __call_single_data *csd, u64 ts0, u64 *ts1, int *bug_id)\n{\n\tint cpu = -1;\n\tint cpux;\n\tbool firsttime;\n\tu64 ts2, ts_delta;\n\tcall_single_data_t *cpu_cur_csd;\n\tunsigned int flags = READ_ONCE(csd->node.u_flags);\n\n\tif (!(flags & CSD_FLAG_LOCK)) {\n\t\tif (!unlikely(*bug_id))\n\t\t\treturn true;\n\t\tcpu = csd_lock_wait_getcpu(csd);\n\t\tpr_alert(\"csd: CSD lock (#%d) got unstuck on CPU#%02d, CPU#%02d released the lock.\\n\",\n\t\t\t *bug_id, raw_smp_processor_id(), cpu);\n\t\treturn true;\n\t}\n\n\tts2 = sched_clock();\n\tts_delta = ts2 - *ts1;\n\tif (likely(ts_delta <= CSD_LOCK_TIMEOUT))\n\t\treturn false;\n\n\tfirsttime = !*bug_id;\n\tif (firsttime)\n\t\t*bug_id = atomic_inc_return(&csd_bug_count);\n\tcpu = csd_lock_wait_getcpu(csd);\n\tif (WARN_ONCE(cpu < 0 || cpu >= nr_cpu_ids, \"%s: cpu = %d\\n\", __func__, cpu))\n\t\tcpux = 0;\n\telse\n\t\tcpux = cpu;\n\tcpu_cur_csd = smp_load_acquire(&per_cpu(cur_csd, cpux)); /* Before func and info. */\n\tpr_alert(\"csd: %s non-responsive CSD lock (#%d) on CPU#%d, waiting %llu ns for CPU#%02d %pS(%ps).\\n\",\n\t\t firsttime ? \"Detected\" : \"Continued\", *bug_id, raw_smp_processor_id(), ts2 - ts0,\n\t\t cpu, csd->func, csd->info);\n\tif (cpu_cur_csd && csd != cpu_cur_csd) {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) handling prior %pS(%ps) request.\\n\",\n\t\t\t *bug_id, READ_ONCE(per_cpu(cur_csd_func, cpux)),\n\t\t\t READ_ONCE(per_cpu(cur_csd_info, cpux)));\n\t} else {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) %s.\\n\",\n\t\t\t *bug_id, !cpu_cur_csd ? \"unresponsive\" : \"handling this request\");\n\t}\n\tif (cpu >= 0) {\n\t\tif (static_branch_unlikely(&csdlock_debug_extended))\n\t\t\tcsd_lock_print_extended(csd, cpu);\n\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\tdump_cpu_task(cpu);\n\t\tif (!cpu_cur_csd) {\n\t\t\tpr_alert(\"csd: Re-sending CSD lock (#%d) IPI from CPU#%02d to CPU#%02d\\n\", *bug_id, raw_smp_processor_id(), cpu);\n\t\t\tarch_send_call_function_single_ipi(cpu);\n\t\t}\n\t}\n\tdump_stack();\n\t*ts1 = ts2;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void __csd_lock_wait(struct __call_single_data *csd)\n{\n\tint bug_id = 0;\n\tu64 ts0, ts1;\n\n\tts1 = ts0 = sched_clock();\n\tfor (;;) {\n\t\tif (csd_lock_wait_toolong(csd, ts0, &ts1, &bug_id))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tsmp_acquire__after_ctrl_dep();\n}"
  },
  {
    "function_name": "csd_lock_wait_toolong",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "324-381",
    "snippet": "static bool csd_lock_wait_toolong(struct __call_single_data *csd, u64 ts0, u64 *ts1, int *bug_id)\n{\n\tint cpu = -1;\n\tint cpux;\n\tbool firsttime;\n\tu64 ts2, ts_delta;\n\tcall_single_data_t *cpu_cur_csd;\n\tunsigned int flags = READ_ONCE(csd->node.u_flags);\n\n\tif (!(flags & CSD_FLAG_LOCK)) {\n\t\tif (!unlikely(*bug_id))\n\t\t\treturn true;\n\t\tcpu = csd_lock_wait_getcpu(csd);\n\t\tpr_alert(\"csd: CSD lock (#%d) got unstuck on CPU#%02d, CPU#%02d released the lock.\\n\",\n\t\t\t *bug_id, raw_smp_processor_id(), cpu);\n\t\treturn true;\n\t}\n\n\tts2 = sched_clock();\n\tts_delta = ts2 - *ts1;\n\tif (likely(ts_delta <= CSD_LOCK_TIMEOUT))\n\t\treturn false;\n\n\tfirsttime = !*bug_id;\n\tif (firsttime)\n\t\t*bug_id = atomic_inc_return(&csd_bug_count);\n\tcpu = csd_lock_wait_getcpu(csd);\n\tif (WARN_ONCE(cpu < 0 || cpu >= nr_cpu_ids, \"%s: cpu = %d\\n\", __func__, cpu))\n\t\tcpux = 0;\n\telse\n\t\tcpux = cpu;\n\tcpu_cur_csd = smp_load_acquire(&per_cpu(cur_csd, cpux)); /* Before func and info. */\n\tpr_alert(\"csd: %s non-responsive CSD lock (#%d) on CPU#%d, waiting %llu ns for CPU#%02d %pS(%ps).\\n\",\n\t\t firsttime ? \"Detected\" : \"Continued\", *bug_id, raw_smp_processor_id(), ts2 - ts0,\n\t\t cpu, csd->func, csd->info);\n\tif (cpu_cur_csd && csd != cpu_cur_csd) {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) handling prior %pS(%ps) request.\\n\",\n\t\t\t *bug_id, READ_ONCE(per_cpu(cur_csd_func, cpux)),\n\t\t\t READ_ONCE(per_cpu(cur_csd_info, cpux)));\n\t} else {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) %s.\\n\",\n\t\t\t *bug_id, !cpu_cur_csd ? \"unresponsive\" : \"handling this request\");\n\t}\n\tif (cpu >= 0) {\n\t\tif (static_branch_unlikely(&csdlock_debug_extended))\n\t\t\tcsd_lock_print_extended(csd, cpu);\n\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\tdump_cpu_task(cpu);\n\t\tif (!cpu_cur_csd) {\n\t\t\tpr_alert(\"csd: Re-sending CSD lock (#%d) IPI from CPU#%02d to CPU#%02d\\n\", *bug_id, raw_smp_processor_id(), cpu);\n\t\t\tarch_send_call_function_single_ipi(cpu);\n\t\t}\n\t}\n\tdump_stack();\n\t*ts1 = ts2;\n\n\treturn false;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define CSD_LOCK_TIMEOUT (5ULL * NSEC_PER_SEC)"
    ],
    "globals_used": [
      "unsigned int nr_cpu_ids"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_send_call_function_single_ipi",
          "args": [
            "cpu"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"csd: Re-sending CSD lock (#%d) IPI from CPU#%02d to CPU#%02d\\n\"",
            "*bug_id",
            "raw_smp_processor_id()",
            "cpu"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_cpu_task",
          "args": [
            "cpu"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "dump_cpu_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "10875-10879",
          "snippet": "void dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid dump_cpu_task(int cpu)\n{\n\tpr_info(\"Task dump for CPU %d:\\n\", cpu);\n\tsched_show_task(cpu_curr(cpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_single_cpu_backtrace",
          "args": [
            "cpu"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_print_extended",
          "args": [
            "csd",
            "cpu"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_print_extended",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "285-317",
          "snippet": "static void csd_lock_print_extended(struct __call_single_data *csd, int cpu)\n{\n\tstruct cfd_seq_local *seq = &per_cpu(cfd_seq_local, cpu);\n\tunsigned int srccpu = csd->node.src;\n\tstruct call_function_data *cfd = per_cpu_ptr(&cfd_data, srccpu);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\tunsigned int now;\n\tunion cfd_seq_cnt data[2 * ARRAY_SIZE(seq_type)];\n\tunsigned int n_data = 0, i;\n\n\tdata[0].val = READ_ONCE(cfd_seq);\n\tnow = data[0].u.cnt;\n\n\tcfd_seq_data_add(pcpu->seq_queue,\t\t\tsrccpu, cpu,\t       CFD_SEQ_QUEUE,  data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_ipi,\t\t\t\tsrccpu, cpu,\t       CFD_SEQ_IPI,    data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_noipi,\t\t\tsrccpu, cpu,\t       CFD_SEQ_NOIPI,  data, &n_data, now);\n\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.ping, srccpu),\tsrccpu, CFD_SEQ_NOCPU, CFD_SEQ_PING,   data, &n_data, now);\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.pinged, srccpu), srccpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED, data, &n_data, now);\n\n\tcfd_seq_data_add(seq->idle,    CFD_SEQ_NOCPU, cpu, CFD_SEQ_IDLE,    data, &n_data, now);\n\tcfd_seq_data_add(seq->gotipi,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_GOTIPI,  data, &n_data, now);\n\tcfd_seq_data_add(seq->handle,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HANDLE,  data, &n_data, now);\n\tcfd_seq_data_add(seq->dequeue, CFD_SEQ_NOCPU, cpu, CFD_SEQ_DEQUEUE, data, &n_data, now);\n\tcfd_seq_data_add(seq->hdlend,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HDLEND,  data, &n_data, now);\n\n\tfor (i = 0; i < n_data; i++) {\n\t\tpr_alert(\"\\tcsd: cnt(%07x): %04x->%04x %s\\n\",\n\t\t\t data[i].u.cnt & ~0x80000000U, data[i].u.src,\n\t\t\t data[i].u.dst, csd_lock_get_type(data[i].u.type));\n\t}\n\tpr_alert(\"\\tcsd: cnt now: %07x\\n\", now);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_GOTIPI\t8",
            "#define CFD_SEQ_IDLE\t7",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_PINGED\t4",
            "#define CFD_SEQ_PING\t3",
            "#define CFD_SEQ_NOIPI\t2",
            "#define CFD_SEQ_IPI\t1",
            "#define CFD_SEQ_QUEUE\t0",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_GOTIPI\t8\n#define CFD_SEQ_IDLE\t7\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\n\nstatic void csd_lock_print_extended(struct __call_single_data *csd, int cpu)\n{\n\tstruct cfd_seq_local *seq = &per_cpu(cfd_seq_local, cpu);\n\tunsigned int srccpu = csd->node.src;\n\tstruct call_function_data *cfd = per_cpu_ptr(&cfd_data, srccpu);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\tunsigned int now;\n\tunion cfd_seq_cnt data[2 * ARRAY_SIZE(seq_type)];\n\tunsigned int n_data = 0, i;\n\n\tdata[0].val = READ_ONCE(cfd_seq);\n\tnow = data[0].u.cnt;\n\n\tcfd_seq_data_add(pcpu->seq_queue,\t\t\tsrccpu, cpu,\t       CFD_SEQ_QUEUE,  data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_ipi,\t\t\t\tsrccpu, cpu,\t       CFD_SEQ_IPI,    data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_noipi,\t\t\tsrccpu, cpu,\t       CFD_SEQ_NOIPI,  data, &n_data, now);\n\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.ping, srccpu),\tsrccpu, CFD_SEQ_NOCPU, CFD_SEQ_PING,   data, &n_data, now);\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.pinged, srccpu), srccpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED, data, &n_data, now);\n\n\tcfd_seq_data_add(seq->idle,    CFD_SEQ_NOCPU, cpu, CFD_SEQ_IDLE,    data, &n_data, now);\n\tcfd_seq_data_add(seq->gotipi,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_GOTIPI,  data, &n_data, now);\n\tcfd_seq_data_add(seq->handle,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HANDLE,  data, &n_data, now);\n\tcfd_seq_data_add(seq->dequeue, CFD_SEQ_NOCPU, cpu, CFD_SEQ_DEQUEUE, data, &n_data, now);\n\tcfd_seq_data_add(seq->hdlend,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HDLEND,  data, &n_data, now);\n\n\tfor (i = 0; i < n_data; i++) {\n\t\tpr_alert(\"\\tcsd: cnt(%07x): %04x->%04x %s\\n\",\n\t\t\t data[i].u.cnt & ~0x80000000U, data[i].u.src,\n\t\t\t data[i].u.dst, csd_lock_get_type(data[i].u.type));\n\t}\n\tpr_alert(\"\\tcsd: cnt now: %07x\\n\", now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&csdlock_debug_extended"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\tcsd: CSD lock (#%d) %s.\\n\"",
            "*bug_id",
            "!cpu_cur_csd ? \"unresponsive\" : \"handling this request\""
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\tcsd: CSD lock (#%d) handling prior %pS(%ps) request.\\n\"",
            "*bug_id",
            "READ_ONCE(per_cpu(cur_csd_func, cpux))",
            "READ_ONCE(per_cpu(cur_csd_info, cpux))"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(cur_csd_info, cpux)"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cur_csd_info",
            "cpux"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "per_cpu(cur_csd_func, cpux)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"csd: %s non-responsive CSD lock (#%d) on CPU#%d, waiting %llu ns for CPU#%02d %pS(%ps).\\n\"",
            "firsttime ? \"Detected\" : \"Continued\"",
            "*bug_id",
            "raw_smp_processor_id()",
            "ts2 - ts0",
            "cpu",
            "csd->func",
            "csd->info"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&per_cpu(cur_csd, cpux)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "cpu < 0 || cpu >= nr_cpu_ids",
            "\"%s: cpu = %d\\n\"",
            "__func__",
            "cpu"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_wait_getcpu",
          "args": [
            "csd"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_wait_getcpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "235-243",
          "snippet": "static int csd_lock_wait_getcpu(struct __call_single_data *csd)\n{\n\tunsigned int csd_type;\n\n\tcsd_type = CSD_TYPE(csd);\n\tif (csd_type == CSD_TYPE_ASYNC || csd_type == CSD_TYPE_SYNC)\n\t\treturn csd->node.dst; /* Other CSD_TYPE_ values might not have ->dst. */\n\treturn -1;\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic int csd_lock_wait_getcpu(struct __call_single_data *csd)\n{\n\tunsigned int csd_type;\n\n\tcsd_type = CSD_TYPE(csd);\n\tif (csd_type == CSD_TYPE_ASYNC || csd_type == CSD_TYPE_SYNC)\n\t\treturn csd->node.dst; /* Other CSD_TYPE_ values might not have ->dst. */\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&csd_bug_count"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ts_delta <= CSD_LOCK_TIMEOUT"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "453-459",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"csd: CSD lock (#%d) got unstuck on CPU#%02d, CPU#%02d released the lock.\\n\"",
            "*bug_id",
            "raw_smp_processor_id()",
            "cpu"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*bug_id"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "csd->node.u_flags"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CSD_LOCK_TIMEOUT (5ULL * NSEC_PER_SEC)\n\nunsigned int nr_cpu_ids;\n\nstatic bool csd_lock_wait_toolong(struct __call_single_data *csd, u64 ts0, u64 *ts1, int *bug_id)\n{\n\tint cpu = -1;\n\tint cpux;\n\tbool firsttime;\n\tu64 ts2, ts_delta;\n\tcall_single_data_t *cpu_cur_csd;\n\tunsigned int flags = READ_ONCE(csd->node.u_flags);\n\n\tif (!(flags & CSD_FLAG_LOCK)) {\n\t\tif (!unlikely(*bug_id))\n\t\t\treturn true;\n\t\tcpu = csd_lock_wait_getcpu(csd);\n\t\tpr_alert(\"csd: CSD lock (#%d) got unstuck on CPU#%02d, CPU#%02d released the lock.\\n\",\n\t\t\t *bug_id, raw_smp_processor_id(), cpu);\n\t\treturn true;\n\t}\n\n\tts2 = sched_clock();\n\tts_delta = ts2 - *ts1;\n\tif (likely(ts_delta <= CSD_LOCK_TIMEOUT))\n\t\treturn false;\n\n\tfirsttime = !*bug_id;\n\tif (firsttime)\n\t\t*bug_id = atomic_inc_return(&csd_bug_count);\n\tcpu = csd_lock_wait_getcpu(csd);\n\tif (WARN_ONCE(cpu < 0 || cpu >= nr_cpu_ids, \"%s: cpu = %d\\n\", __func__, cpu))\n\t\tcpux = 0;\n\telse\n\t\tcpux = cpu;\n\tcpu_cur_csd = smp_load_acquire(&per_cpu(cur_csd, cpux)); /* Before func and info. */\n\tpr_alert(\"csd: %s non-responsive CSD lock (#%d) on CPU#%d, waiting %llu ns for CPU#%02d %pS(%ps).\\n\",\n\t\t firsttime ? \"Detected\" : \"Continued\", *bug_id, raw_smp_processor_id(), ts2 - ts0,\n\t\t cpu, csd->func, csd->info);\n\tif (cpu_cur_csd && csd != cpu_cur_csd) {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) handling prior %pS(%ps) request.\\n\",\n\t\t\t *bug_id, READ_ONCE(per_cpu(cur_csd_func, cpux)),\n\t\t\t READ_ONCE(per_cpu(cur_csd_info, cpux)));\n\t} else {\n\t\tpr_alert(\"\\tcsd: CSD lock (#%d) %s.\\n\",\n\t\t\t *bug_id, !cpu_cur_csd ? \"unresponsive\" : \"handling this request\");\n\t}\n\tif (cpu >= 0) {\n\t\tif (static_branch_unlikely(&csdlock_debug_extended))\n\t\t\tcsd_lock_print_extended(csd, cpu);\n\t\tif (!trigger_single_cpu_backtrace(cpu))\n\t\t\tdump_cpu_task(cpu);\n\t\tif (!cpu_cur_csd) {\n\t\t\tpr_alert(\"csd: Re-sending CSD lock (#%d) IPI from CPU#%02d to CPU#%02d\\n\", *bug_id, raw_smp_processor_id(), cpu);\n\t\t\tarch_send_call_function_single_ipi(cpu);\n\t\t}\n\t}\n\tdump_stack();\n\t*ts1 = ts2;\n\n\treturn false;\n}"
  },
  {
    "function_name": "csd_lock_print_extended",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "285-317",
    "snippet": "static void csd_lock_print_extended(struct __call_single_data *csd, int cpu)\n{\n\tstruct cfd_seq_local *seq = &per_cpu(cfd_seq_local, cpu);\n\tunsigned int srccpu = csd->node.src;\n\tstruct call_function_data *cfd = per_cpu_ptr(&cfd_data, srccpu);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\tunsigned int now;\n\tunion cfd_seq_cnt data[2 * ARRAY_SIZE(seq_type)];\n\tunsigned int n_data = 0, i;\n\n\tdata[0].val = READ_ONCE(cfd_seq);\n\tnow = data[0].u.cnt;\n\n\tcfd_seq_data_add(pcpu->seq_queue,\t\t\tsrccpu, cpu,\t       CFD_SEQ_QUEUE,  data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_ipi,\t\t\t\tsrccpu, cpu,\t       CFD_SEQ_IPI,    data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_noipi,\t\t\tsrccpu, cpu,\t       CFD_SEQ_NOIPI,  data, &n_data, now);\n\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.ping, srccpu),\tsrccpu, CFD_SEQ_NOCPU, CFD_SEQ_PING,   data, &n_data, now);\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.pinged, srccpu), srccpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED, data, &n_data, now);\n\n\tcfd_seq_data_add(seq->idle,    CFD_SEQ_NOCPU, cpu, CFD_SEQ_IDLE,    data, &n_data, now);\n\tcfd_seq_data_add(seq->gotipi,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_GOTIPI,  data, &n_data, now);\n\tcfd_seq_data_add(seq->handle,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HANDLE,  data, &n_data, now);\n\tcfd_seq_data_add(seq->dequeue, CFD_SEQ_NOCPU, cpu, CFD_SEQ_DEQUEUE, data, &n_data, now);\n\tcfd_seq_data_add(seq->hdlend,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HDLEND,  data, &n_data, now);\n\n\tfor (i = 0; i < n_data; i++) {\n\t\tpr_alert(\"\\tcsd: cnt(%07x): %04x->%04x %s\\n\",\n\t\t\t data[i].u.cnt & ~0x80000000U, data[i].u.src,\n\t\t\t data[i].u.dst, csd_lock_get_type(data[i].u.type));\n\t}\n\tpr_alert(\"\\tcsd: cnt now: %07x\\n\", now);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [
      "#define CFD_SEQ_HDLEND\t9",
      "#define CFD_SEQ_GOTIPI\t8",
      "#define CFD_SEQ_IDLE\t7",
      "#define CFD_SEQ_DEQUEUE\t6",
      "#define CFD_SEQ_HANDLE\t5",
      "#define CFD_SEQ_PINGED\t4",
      "#define CFD_SEQ_PING\t3",
      "#define CFD_SEQ_NOIPI\t2",
      "#define CFD_SEQ_IPI\t1",
      "#define CFD_SEQ_QUEUE\t0",
      "#define CFD_SEQ_NOCPU\t0xffff"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\tcsd: cnt now: %07x\\n\"",
            "now"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\tcsd: cnt(%07x): %04x->%04x %s\\n\"",
            "data[i].u.cnt & ~0x80000000U",
            "data[i].u.src",
            "data[i].u.dst",
            "csd_lock_get_type(data[i].u.type)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csd_lock_get_type",
          "args": [
            "data[i].u.type"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "csd_lock_get_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "280-283",
          "snippet": "static const char *csd_lock_get_type(unsigned int type)\n{\n\treturn (type >= ARRAY_SIZE(seq_type)) ? \"?\" : seq_type[type];\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic const char *csd_lock_get_type(unsigned int type)\n{\n\treturn (type >= ARRAY_SIZE(seq_type)) ? \"?\" : seq_type[type];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cfd_seq_data_add",
          "args": [
            "seq->hdlend",
            "CFD_SEQ_NOCPU",
            "cpu",
            "CFD_SEQ_HDLEND",
            "data",
            "&n_data",
            "now"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "cfd_seq_data_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "245-278",
          "snippet": "static void cfd_seq_data_add(u64 val, unsigned int src, unsigned int dst,\n\t\t\t     unsigned int type, union cfd_seq_cnt *data,\n\t\t\t     unsigned int *n_data, unsigned int now)\n{\n\tunion cfd_seq_cnt new[2];\n\tunsigned int i, j, k;\n\n\tnew[0].val = val;\n\tnew[1] = CFD_SEQ(src, dst, type, new[0].u.cnt + 1);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (new[i].u.cnt <= now)\n\t\t\tnew[i].u.cnt |= 0x80000000U;\n\t\tfor (j = 0; j < *n_data; j++) {\n\t\t\tif (new[i].u.cnt == data[j].u.cnt) {\n\t\t\t\t/* Direct read value trumps generated one. */\n\t\t\t\tif (i == 0)\n\t\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (new[i].u.cnt < data[j].u.cnt) {\n\t\t\t\tfor (k = *n_data; k > j; k--)\n\t\t\t\t\tdata[k].val = data[k - 1].val;\n\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\t(*n_data)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == *n_data) {\n\t\t\tdata[j].val = new[i].val;\n\t\t\t(*n_data)++;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void cfd_seq_data_add(u64 val, unsigned int src, unsigned int dst,\n\t\t\t     unsigned int type, union cfd_seq_cnt *data,\n\t\t\t     unsigned int *n_data, unsigned int now)\n{\n\tunion cfd_seq_cnt new[2];\n\tunsigned int i, j, k;\n\n\tnew[0].val = val;\n\tnew[1] = CFD_SEQ(src, dst, type, new[0].u.cnt + 1);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (new[i].u.cnt <= now)\n\t\t\tnew[i].u.cnt |= 0x80000000U;\n\t\tfor (j = 0; j < *n_data; j++) {\n\t\t\tif (new[i].u.cnt == data[j].u.cnt) {\n\t\t\t\t/* Direct read value trumps generated one. */\n\t\t\t\tif (i == 0)\n\t\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (new[i].u.cnt < data[j].u.cnt) {\n\t\t\t\tfor (k = *n_data; k > j; k--)\n\t\t\t\t\tdata[k].val = data[k - 1].val;\n\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\t(*n_data)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == *n_data) {\n\t\t\tdata[j].val = new[i].val;\n\t\t\t(*n_data)++;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cfd_seq_local.pinged",
            "srccpu"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cfd_seq"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "seq_type"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "cfd->pcpu",
            "cpu"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&cfd_data",
            "srccpu"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_GOTIPI\t8\n#define CFD_SEQ_IDLE\t7\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_PINGED\t4\n#define CFD_SEQ_PING\t3\n#define CFD_SEQ_NOIPI\t2\n#define CFD_SEQ_IPI\t1\n#define CFD_SEQ_QUEUE\t0\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\n\nstatic void csd_lock_print_extended(struct __call_single_data *csd, int cpu)\n{\n\tstruct cfd_seq_local *seq = &per_cpu(cfd_seq_local, cpu);\n\tunsigned int srccpu = csd->node.src;\n\tstruct call_function_data *cfd = per_cpu_ptr(&cfd_data, srccpu);\n\tstruct cfd_percpu *pcpu = per_cpu_ptr(cfd->pcpu, cpu);\n\tunsigned int now;\n\tunion cfd_seq_cnt data[2 * ARRAY_SIZE(seq_type)];\n\tunsigned int n_data = 0, i;\n\n\tdata[0].val = READ_ONCE(cfd_seq);\n\tnow = data[0].u.cnt;\n\n\tcfd_seq_data_add(pcpu->seq_queue,\t\t\tsrccpu, cpu,\t       CFD_SEQ_QUEUE,  data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_ipi,\t\t\t\tsrccpu, cpu,\t       CFD_SEQ_IPI,    data, &n_data, now);\n\tcfd_seq_data_add(pcpu->seq_noipi,\t\t\tsrccpu, cpu,\t       CFD_SEQ_NOIPI,  data, &n_data, now);\n\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.ping, srccpu),\tsrccpu, CFD_SEQ_NOCPU, CFD_SEQ_PING,   data, &n_data, now);\n\tcfd_seq_data_add(per_cpu(cfd_seq_local.pinged, srccpu), srccpu, CFD_SEQ_NOCPU, CFD_SEQ_PINGED, data, &n_data, now);\n\n\tcfd_seq_data_add(seq->idle,    CFD_SEQ_NOCPU, cpu, CFD_SEQ_IDLE,    data, &n_data, now);\n\tcfd_seq_data_add(seq->gotipi,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_GOTIPI,  data, &n_data, now);\n\tcfd_seq_data_add(seq->handle,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HANDLE,  data, &n_data, now);\n\tcfd_seq_data_add(seq->dequeue, CFD_SEQ_NOCPU, cpu, CFD_SEQ_DEQUEUE, data, &n_data, now);\n\tcfd_seq_data_add(seq->hdlend,  CFD_SEQ_NOCPU, cpu, CFD_SEQ_HDLEND,  data, &n_data, now);\n\n\tfor (i = 0; i < n_data; i++) {\n\t\tpr_alert(\"\\tcsd: cnt(%07x): %04x->%04x %s\\n\",\n\t\t\t data[i].u.cnt & ~0x80000000U, data[i].u.src,\n\t\t\t data[i].u.dst, csd_lock_get_type(data[i].u.type));\n\t}\n\tpr_alert(\"\\tcsd: cnt now: %07x\\n\", now);\n}"
  },
  {
    "function_name": "csd_lock_get_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "280-283",
    "snippet": "static const char *csd_lock_get_type(unsigned int type)\n{\n\treturn (type >= ARRAY_SIZE(seq_type)) ? \"?\" : seq_type[type];\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "seq_type"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic const char *csd_lock_get_type(unsigned int type)\n{\n\treturn (type >= ARRAY_SIZE(seq_type)) ? \"?\" : seq_type[type];\n}"
  },
  {
    "function_name": "cfd_seq_data_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "245-278",
    "snippet": "static void cfd_seq_data_add(u64 val, unsigned int src, unsigned int dst,\n\t\t\t     unsigned int type, union cfd_seq_cnt *data,\n\t\t\t     unsigned int *n_data, unsigned int now)\n{\n\tunion cfd_seq_cnt new[2];\n\tunsigned int i, j, k;\n\n\tnew[0].val = val;\n\tnew[1] = CFD_SEQ(src, dst, type, new[0].u.cnt + 1);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (new[i].u.cnt <= now)\n\t\t\tnew[i].u.cnt |= 0x80000000U;\n\t\tfor (j = 0; j < *n_data; j++) {\n\t\t\tif (new[i].u.cnt == data[j].u.cnt) {\n\t\t\t\t/* Direct read value trumps generated one. */\n\t\t\t\tif (i == 0)\n\t\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (new[i].u.cnt < data[j].u.cnt) {\n\t\t\t\tfor (k = *n_data; k > j; k--)\n\t\t\t\t\tdata[k].val = data[k - 1].val;\n\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\t(*n_data)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == *n_data) {\n\t\t\tdata[j].val = new[i].val;\n\t\t\t(*n_data)++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CFD_SEQ",
          "args": [
            "src",
            "dst",
            "type",
            "new[0].u.cnt + 1"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void cfd_seq_data_add(u64 val, unsigned int src, unsigned int dst,\n\t\t\t     unsigned int type, union cfd_seq_cnt *data,\n\t\t\t     unsigned int *n_data, unsigned int now)\n{\n\tunion cfd_seq_cnt new[2];\n\tunsigned int i, j, k;\n\n\tnew[0].val = val;\n\tnew[1] = CFD_SEQ(src, dst, type, new[0].u.cnt + 1);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (new[i].u.cnt <= now)\n\t\t\tnew[i].u.cnt |= 0x80000000U;\n\t\tfor (j = 0; j < *n_data; j++) {\n\t\t\tif (new[i].u.cnt == data[j].u.cnt) {\n\t\t\t\t/* Direct read value trumps generated one. */\n\t\t\t\tif (i == 0)\n\t\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (new[i].u.cnt < data[j].u.cnt) {\n\t\t\t\tfor (k = *n_data; k > j; k--)\n\t\t\t\t\tdata[k].val = data[k - 1].val;\n\t\t\t\tdata[j].val = new[i].val;\n\t\t\t\t(*n_data)++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == *n_data) {\n\t\t\tdata[j].val = new[i].val;\n\t\t\t(*n_data)++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "csd_lock_wait_getcpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "235-243",
    "snippet": "static int csd_lock_wait_getcpu(struct __call_single_data *csd)\n{\n\tunsigned int csd_type;\n\n\tcsd_type = CSD_TYPE(csd);\n\tif (csd_type == CSD_TYPE_ASYNC || csd_type == CSD_TYPE_SYNC)\n\t\treturn csd->node.dst; /* Other CSD_TYPE_ values might not have ->dst. */\n\treturn -1;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CSD_TYPE",
          "args": [
            "csd"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic int csd_lock_wait_getcpu(struct __call_single_data *csd)\n{\n\tunsigned int csd_type;\n\n\tcsd_type = CSD_TYPE(csd);\n\tif (csd_type == CSD_TYPE_ASYNC || csd_type == CSD_TYPE_SYNC)\n\t\treturn csd->node.dst; /* Other CSD_TYPE_ values might not have ->dst. */\n\treturn -1;\n}"
  },
  {
    "function_name": "csd_lock_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "229-233",
    "snippet": "static __always_inline void csd_lock_record(struct __call_single_data *csd)\n{\n\tif (static_branch_unlikely(&csdlock_debug_enabled))\n\t\t__csd_lock_record(csd);\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__csd_lock_record",
          "args": [
            "csd"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "__csd_lock_record",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "214-227",
          "snippet": "static void __csd_lock_record(struct __call_single_data *csd)\n{\n\tif (!csd) {\n\t\tsmp_mb(); /* NULL cur_csd after unlock. */\n\t\t__this_cpu_write(cur_csd, NULL);\n\t\treturn;\n\t}\n\t__this_cpu_write(cur_csd_func, csd->func);\n\t__this_cpu_write(cur_csd_info, csd->info);\n\tsmp_wmb(); /* func and info before csd. */\n\t__this_cpu_write(cur_csd, csd);\n\tsmp_mb(); /* Update cur_csd before function call. */\n\t\t  /* Or before unlock, as the case may be. */\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void __csd_lock_record(struct __call_single_data *csd)\n{\n\tif (!csd) {\n\t\tsmp_mb(); /* NULL cur_csd after unlock. */\n\t\t__this_cpu_write(cur_csd, NULL);\n\t\treturn;\n\t}\n\t__this_cpu_write(cur_csd_func, csd->func);\n\t__this_cpu_write(cur_csd_info, csd->info);\n\tsmp_wmb(); /* func and info before csd. */\n\t__this_cpu_write(cur_csd, csd);\n\tsmp_mb(); /* Update cur_csd before function call. */\n\t\t  /* Or before unlock, as the case may be. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&csdlock_debug_enabled"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic __always_inline void csd_lock_record(struct __call_single_data *csd)\n{\n\tif (static_branch_unlikely(&csdlock_debug_enabled))\n\t\t__csd_lock_record(csd);\n}"
  },
  {
    "function_name": "__csd_lock_record",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "214-227",
    "snippet": "static void __csd_lock_record(struct __call_single_data *csd)\n{\n\tif (!csd) {\n\t\tsmp_mb(); /* NULL cur_csd after unlock. */\n\t\t__this_cpu_write(cur_csd, NULL);\n\t\treturn;\n\t}\n\t__this_cpu_write(cur_csd_func, csd->func);\n\t__this_cpu_write(cur_csd_info, csd->info);\n\tsmp_wmb(); /* func and info before csd. */\n\t__this_cpu_write(cur_csd, csd);\n\tsmp_mb(); /* Update cur_csd before function call. */\n\t\t  /* Or before unlock, as the case may be. */\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "cur_csd",
            "csd"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "cur_csd_info",
            "csd->info"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "cur_csd_func",
            "csd->func"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "cur_csd",
            "NULL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic void __csd_lock_record(struct __call_single_data *csd)\n{\n\tif (!csd) {\n\t\tsmp_mb(); /* NULL cur_csd after unlock. */\n\t\t__this_cpu_write(cur_csd, NULL);\n\t\treturn;\n\t}\n\t__this_cpu_write(cur_csd_func, csd->func);\n\t__this_cpu_write(cur_csd_info, csd->info);\n\tsmp_wmb(); /* func and info before csd. */\n\t__this_cpu_write(cur_csd, csd);\n\tsmp_mb(); /* Update cur_csd before function call. */\n\t\t  /* Or before unlock, as the case may be. */\n}"
  },
  {
    "function_name": "cfd_seq_inc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "193-205",
    "snippet": "static u64 cfd_seq_inc(unsigned int src, unsigned int dst, unsigned int type)\n{\n\tunion cfd_seq_cnt new, old;\n\n\tnew = CFD_SEQ(src, dst, type, 0);\n\n\tdo {\n\t\told.val = READ_ONCE(cfd_seq);\n\t\tnew.u.cnt = old.u.cnt + 1;\n\t} while (cmpxchg(&cfd_seq, old.val, new.val) != old.val);\n\n\treturn old.val;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&cfd_seq",
            "old.val",
            "new.val"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cfd_seq"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CFD_SEQ",
          "args": [
            "src",
            "dst",
            "type",
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic u64 cfd_seq_inc(unsigned int src, unsigned int dst, unsigned int type)\n{\n\tunion cfd_seq_cnt new, old;\n\n\tnew = CFD_SEQ(src, dst, type, 0);\n\n\tdo {\n\t\told.val = READ_ONCE(cfd_seq);\n\t\tnew.u.cnt = old.u.cnt + 1;\n\t} while (cmpxchg(&cfd_seq, old.val, new.val) != old.val);\n\n\treturn old.val;\n}"
  },
  {
    "function_name": "csdlock_debug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "164-178",
    "snippet": "static int __init csdlock_debug(char *str)\n{\n\tunsigned int val = 0;\n\n\tif (str && !strcmp(str, \"ext\")) {\n\t\tval = 1;\n\t\tstatic_branch_enable(&csdlock_debug_extended);\n\t} else\n\t\tget_option(&str, &val);\n\n\tif (val)\n\t\tstatic_branch_enable(&csdlock_debug_enabled);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&csdlock_debug_enabled"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&val"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&csdlock_debug_extended"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ext\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic int __init csdlock_debug(char *str)\n{\n\tunsigned int val = 0;\n\n\tif (str && !strcmp(str, \"ext\")) {\n\t\tval = 1;\n\t\tstatic_branch_enable(&csdlock_debug_extended);\n\t} else\n\t\tget_option(&str, &val);\n\n\tif (val)\n\t\tstatic_branch_enable(&csdlock_debug_enabled);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "call_function_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "149-157",
    "snippet": "void __init call_function_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\tinit_llist_head(&per_cpu(call_single_queue, i));\n\n\tsmpcfd_prepare_cpu(smp_processor_id());\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smpcfd_prepare_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "smpcfd_prepare_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "101-121",
          "snippet": "int smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->pcpu = alloc_percpu(struct cfd_percpu);\n\tif (!cfd->pcpu) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\n\nint smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->pcpu = alloc_percpu(struct cfd_percpu);\n\tif (!cfd->pcpu) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\n\nvoid __init call_function_init(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i)\n\t\tinit_llist_head(&per_cpu(call_single_queue, i));\n\n\tsmpcfd_prepare_cpu(smp_processor_id());\n}"
  },
  {
    "function_name": "smpcfd_dying_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "133-147",
    "snippet": "int smpcfd_dying_cpu(unsigned int cpu)\n{\n\t/*\n\t * The IPIs for the smp-call-function callbacks queued by other\n\t * CPUs might arrive late, either due to hardware latencies or\n\t * because this CPU disabled interrupts (inside stop-machine)\n\t * before the IPIs were sent. So flush out any pending callbacks\n\t * explicitly (without waiting for the IPIs to arrive), to\n\t * ensure that the outgoing CPU doesn't go offline with work\n\t * still pending.\n\t */\n\tflush_smp_call_function_queue(false);\n\tirq_work_run();\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_run",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_run",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "249-256",
          "snippet": "void irq_work_run(void)\n{\n\tirq_work_run_list(this_cpu_ptr(&raised_list));\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n\telse\n\t\twake_irq_workd();\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nvoid irq_work_run(void)\n{\n\tirq_work_run_list(this_cpu_ptr(&raised_list));\n\tif (!IS_ENABLED(CONFIG_PREEMPT_RT))\n\t\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n\telse\n\t\twake_irq_workd();\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_smp_call_function_queue",
          "args": [
            "false"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "flush_smp_call_function_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "561-682",
          "snippet": "static void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define CFD_SEQ_HDLEND\t9",
            "#define CFD_SEQ_DEQUEUE\t6",
            "#define CFD_SEQ_HANDLE\t5",
            "#define CFD_SEQ_NOCPU\t0xffff"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);",
            "static void flush_smp_call_function_queue(bool warn_cpu_offline);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define CFD_SEQ_HDLEND\t9\n#define CFD_SEQ_DEQUEUE\t6\n#define CFD_SEQ_HANDLE\t5\n#define CFD_SEQ_NOCPU\t0xffff\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct llist_head, call_single_queue);\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline);\n\nstatic void flush_smp_call_function_queue(bool warn_cpu_offline)\n{\n\tcall_single_data_t *csd, *csd_next;\n\tstruct llist_node *entry, *prev;\n\tstruct llist_head *head;\n\tstatic bool warned;\n\n\tlockdep_assert_irqs_disabled();\n\n\thead = this_cpu_ptr(&call_single_queue);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->handle, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HANDLE);\n\tentry = llist_del_all(head);\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->dequeue,\n\t\t      /* Special meaning of source cpu: 0 == queue empty */\n\t\t      entry ? CFD_SEQ_NOCPU : 0,\n\t\t      smp_processor_id(), CFD_SEQ_DEQUEUE);\n\tentry = llist_reverse_order(entry);\n\n\t/* There shouldn't be any pending callbacks on an offline CPU. */\n\tif (unlikely(warn_cpu_offline && !cpu_online(smp_processor_id()) &&\n\t\t     !warned && !llist_empty(head))) {\n\t\twarned = true;\n\t\tWARN(1, \"IPI on offline CPU %d\\n\", smp_processor_id());\n\n\t\t/*\n\t\t * We don't have to use the _safe() variant here\n\t\t * because we are not invoking the IPI handlers yet.\n\t\t */\n\t\tllist_for_each_entry(csd, entry, node.llist) {\n\t\t\tswitch (CSD_TYPE(csd)) {\n\t\t\tcase CSD_TYPE_ASYNC:\n\t\t\tcase CSD_TYPE_SYNC:\n\t\t\tcase CSD_TYPE_IRQ_WORK:\n\t\t\t\tpr_warn(\"IPI callback %pS sent to offline CPU\\n\",\n\t\t\t\t\tcsd->func);\n\t\t\t\tbreak;\n\n\t\t\tcase CSD_TYPE_TTWU:\n\t\t\t\tpr_warn(\"IPI task-wakeup sent to offline CPU\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tpr_warn(\"IPI callback, unknown type %d, sent to offline CPU\\n\",\n\t\t\t\t\tCSD_TYPE(csd));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * First; run all SYNC callbacks, people are waiting for us.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\t/* Do we wait until *after* callback? */\n\t\tif (CSD_TYPE(csd) == CSD_TYPE_SYNC) {\n\t\t\tsmp_call_func_t func = csd->func;\n\t\t\tvoid *info = csd->info;\n\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tcsd_lock_record(csd);\n\t\t\tfunc(info);\n\t\t\tcsd_unlock(csd);\n\t\t\tcsd_lock_record(NULL);\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend,\n\t\t\t      0, smp_processor_id(),\n\t\t\t      CFD_SEQ_HDLEND);\n\t\treturn;\n\t}\n\n\t/*\n\t * Second; run all !SYNC callbacks.\n\t */\n\tprev = NULL;\n\tllist_for_each_entry_safe(csd, csd_next, entry, node.llist) {\n\t\tint type = CSD_TYPE(csd);\n\n\t\tif (type != CSD_TYPE_TTWU) {\n\t\t\tif (prev) {\n\t\t\t\tprev->next = &csd_next->node.llist;\n\t\t\t} else {\n\t\t\t\tentry = &csd_next->node.llist;\n\t\t\t}\n\n\t\t\tif (type == CSD_TYPE_ASYNC) {\n\t\t\t\tsmp_call_func_t func = csd->func;\n\t\t\t\tvoid *info = csd->info;\n\n\t\t\t\tcsd_lock_record(csd);\n\t\t\t\tcsd_unlock(csd);\n\t\t\t\tfunc(info);\n\t\t\t\tcsd_lock_record(NULL);\n\t\t\t} else if (type == CSD_TYPE_IRQ_WORK) {\n\t\t\t\tirq_work_single(csd);\n\t\t\t}\n\n\t\t} else {\n\t\t\tprev = &csd->node.llist;\n\t\t}\n\t}\n\n\t/*\n\t * Third; only CSD_TYPE_TTWU is left, issue those.\n\t */\n\tif (entry)\n\t\tsched_ttwu_pending(entry);\n\n\tcfd_seq_store(this_cpu_ptr(&cfd_seq_local)->hdlend, CFD_SEQ_NOCPU,\n\t\t      smp_processor_id(), CFD_SEQ_HDLEND);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nint smpcfd_dying_cpu(unsigned int cpu)\n{\n\t/*\n\t * The IPIs for the smp-call-function callbacks queued by other\n\t * CPUs might arrive late, either due to hardware latencies or\n\t * because this CPU disabled interrupts (inside stop-machine)\n\t * before the IPIs were sent. So flush out any pending callbacks\n\t * explicitly (without waiting for the IPIs to arrive), to\n\t * ensure that the outgoing CPU doesn't go offline with work\n\t * still pending.\n\t */\n\tflush_smp_call_function_queue(false);\n\tirq_work_run();\n\treturn 0;\n}"
  },
  {
    "function_name": "smpcfd_dead_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "123-131",
    "snippet": "int smpcfd_dead_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tfree_cpumask_var(cfd->cpumask);\n\tfree_cpumask_var(cfd->cpumask_ipi);\n\tfree_percpu(cfd->pcpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "cfd->pcpu"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cfd_data",
            "cpu"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\n\nint smpcfd_dead_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tfree_cpumask_var(cfd->cpumask);\n\tfree_cpumask_var(cfd->cpumask_ipi);\n\tfree_percpu(cfd->pcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "smpcfd_prepare_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
    "lines": "101-121",
    "snippet": "int smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->pcpu = alloc_percpu(struct cfd_percpu);\n\tif (!cfd->pcpu) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched/smp.h\"",
      "#include \"smpboot.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/nmi.h>",
      "#include <linux/sched/clock.h>",
      "#include <linux/hypervisor.h>",
      "#include <linux/sched/idle.h>",
      "#include <linux/sched.h>",
      "#include <linux/cpu.h>",
      "#include <linux/smp.h>",
      "#include <linux/gfp.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>",
      "#include <linux/rculist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/irq_work.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask_ipi"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structcfd_percpu"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cfd->cpumask"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var_node",
          "args": [
            "&cfd->cpumask_ipi",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var_node",
          "args": [
            "&cfd->cpumask",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "cfd_data",
            "cpu"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nstatic DEFINE_PER_CPU_ALIGNED(struct call_function_data, cfd_data);\n\nint smpcfd_prepare_cpu(unsigned int cpu)\n{\n\tstruct call_function_data *cfd = &per_cpu(cfd_data, cpu);\n\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu)))\n\t\treturn -ENOMEM;\n\tif (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,\n\t\t\t\t     cpu_to_node(cpu))) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\treturn -ENOMEM;\n\t}\n\tcfd->pcpu = alloc_percpu(struct cfd_percpu);\n\tif (!cfd->pcpu) {\n\t\tfree_cpumask_var(cfd->cpumask);\n\t\tfree_cpumask_var(cfd->cpumask_ipi);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  }
]