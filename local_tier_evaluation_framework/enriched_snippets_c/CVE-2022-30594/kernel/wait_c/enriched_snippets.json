[
  {
    "function_name": "woken_wake_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "475-482",
    "snippet": "int woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\t/* Pairs with the smp_store_mb() in wait_woken(). */\n\tsmp_mb(); /* C */\n\twq_entry->flags |= WQ_FLAG_WOKEN;\n\n\treturn default_wake_function(wq_entry, mode, sync, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "wq_entry",
            "mode",
            "sync",
            "key"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "default_wake_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6719-6724",
          "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint woken_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\t/* Pairs with the smp_store_mb() in wait_woken(). */\n\tsmp_mb(); /* C */\n\twq_entry->flags |= WQ_FLAG_WOKEN;\n\n\treturn default_wake_function(wq_entry, mode, sync, key);\n}"
  },
  {
    "function_name": "wait_woken",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "450-472",
    "snippet": "long wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)\n{\n\t/*\n\t * The below executes an smp_mb(), which matches with the full barrier\n\t * executed by the try_to_wake_up() in woken_wake_function() such that\n\t * either we see the store to wq_entry->flags in woken_wake_function()\n\t * or woken_wake_function() sees our store to current->state.\n\t */\n\tset_current_state(mode); /* A */\n\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !is_kthread_should_stop())\n\t\ttimeout = schedule_timeout(timeout);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * The below executes an smp_mb(), which matches with the smp_mb() (C)\n\t * in woken_wake_function() such that either we see the wait condition\n\t * being true or the store to wq_entry->flags in woken_wake_function()\n\t * follows ours in the coherence order.\n\t */\n\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN); /* B */\n\n\treturn timeout;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "wq_entry->flags",
            "wq_entry->flags & ~WQ_FLAG_WOKEN"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule_timeout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8396-8406",
          "snippet": "long __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nlong __sched io_schedule_timeout(long timeout)\n{\n\tint token;\n\tlong ret;\n\n\ttoken = io_schedule_prepare();\n\tret = schedule_timeout(timeout);\n\tio_schedule_finish(token);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_kthread_should_stop",
          "args": [],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "is_kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "425-428",
          "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "mode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nlong wait_woken(struct wait_queue_entry *wq_entry, unsigned mode, long timeout)\n{\n\t/*\n\t * The below executes an smp_mb(), which matches with the full barrier\n\t * executed by the try_to_wake_up() in woken_wake_function() such that\n\t * either we see the store to wq_entry->flags in woken_wake_function()\n\t * or woken_wake_function() sees our store to current->state.\n\t */\n\tset_current_state(mode); /* A */\n\tif (!(wq_entry->flags & WQ_FLAG_WOKEN) && !is_kthread_should_stop())\n\t\ttimeout = schedule_timeout(timeout);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * The below executes an smp_mb(), which matches with the smp_mb() (C)\n\t * in woken_wake_function() such that either we see the wait condition\n\t * being true or the store to wq_entry->flags in woken_wake_function()\n\t * follows ours in the coherence order.\n\t */\n\tsmp_store_mb(wq_entry->flags, wq_entry->flags & ~WQ_FLAG_WOKEN); /* B */\n\n\treturn timeout;\n}"
  },
  {
    "function_name": "is_kthread_should_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "425-428",
    "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "is_kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "425-428",
          "snippet": "static inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic inline bool is_kthread_should_stop(void)\n{\n\treturn (current->flags & PF_KTHREAD) && kthread_should_stop();\n}"
  },
  {
    "function_name": "autoremove_wake_function",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "414-422",
    "snippet": "int autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init_careful(&wq_entry->entry);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init_careful",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "wq_entry",
            "mode",
            "sync",
            "key"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "default_wake_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6719-6724",
          "snippet": "int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,\n\t\t\t  void *key)\n{\n\tWARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);\n\treturn try_to_wake_up(curr->private, mode, wake_flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint autoremove_wake_function(struct wait_queue_entry *wq_entry, unsigned mode, int sync, void *key)\n{\n\tint ret = default_wake_function(wq_entry, mode, sync, key);\n\n\tif (ret)\n\t\tlist_del_init_careful(&wq_entry->entry);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "finish_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "388-411",
    "snippet": "void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\t__set_current_state(TASK_RUNNING);\n\t/*\n\t * We can check for list emptiness outside the lock\n\t * IFF:\n\t *  - we use the \"careful\" check that verifies both\n\t *    the next and prev pointers, so that there cannot\n\t *    be any half-pending updates in progress on other\n\t *    CPU's that we haven't seen yet (and that might\n\t *    still change the stack area.\n\t * and\n\t *  - all other users take the lock (ie we can only\n\t *    have _one_ other CPU that looks at or modifies\n\t *    the list).\n\t */\n\tif (!list_empty_careful(&wq_entry->entry)) {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tlist_del_init(&wq_entry->entry);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t}\n}"
  },
  {
    "function_name": "do_wait_intr_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "362-376",
    "snippet": "int do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock_irq(&wq->lock);\n\tschedule();\n\tspin_lock_irq(&wq->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&wq->lock"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8409-8416",
          "snippet": "void __sched io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&wq->lock"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq",
            "wait"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "list_empty(&wait->entry)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wait->entry"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint do_wait_intr_irq(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock_irq(&wq->lock);\n\tschedule();\n\tspin_lock_irq(&wq->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_wait_intr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "345-359",
    "snippet": "int do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock(&wq->lock);\n\tschedule();\n\tspin_lock(&wq->lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wq->lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "io_schedule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8409-8416",
          "snippet": "void __sched io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched io_schedule(void)\n{\n\tint token;\n\n\ttoken = io_schedule_prepare();\n\tschedule();\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wq->lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq",
            "wait"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "list_empty(&wait->entry)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wait->entry"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nint do_wait_intr(wait_queue_head_t *wq, wait_queue_entry_t *wait)\n{\n\tif (likely(list_empty(&wait->entry)))\n\t\t__add_wait_queue_entry_tail(wq, wait);\n\n\tset_current_state(TASK_INTERRUPTIBLE);\n\tif (signal_pending(current))\n\t\treturn -ERESTARTSYS;\n\n\tspin_unlock(&wq->lock);\n\tschedule();\n\tspin_lock(&wq->lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_to_wait_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "302-335",
    "snippet": "long prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending_state",
          "args": [
            "state",
            "current"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nlong prepare_to_wait_event(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tlong ret = 0;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (signal_pending_state(state, current)) {\n\t\t/*\n\t\t * Exclusive waiter must not fail if it was selected by wakeup,\n\t\t * it should \"consume\" the condition we were waiting for.\n\t\t *\n\t\t * The caller will recheck the condition and return success if\n\t\t * we were already woken up, we can not miss the event because\n\t\t * wakeup locks/unlocks the same wq_head->lock.\n\t\t *\n\t\t * But we need to ensure that set-condition + wakeup after that\n\t\t * can't see us, it should wake up another exclusive waiter if\n\t\t * we fail.\n\t\t */\n\t\tlist_del_init(&wq_entry->entry);\n\t\tret = -ERESTARTSYS;\n\t} else {\n\t\tif (list_empty(&wq_entry->entry)) {\n\t\t\tif (wq_entry->flags & WQ_FLAG_EXCLUSIVE)\n\t\t\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t\t\telse\n\t\t\t\t__add_wait_queue(wq_head, wq_entry);\n\t\t}\n\t\tset_current_state(state);\n\t}\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "init_wait_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "293-299",
    "snippet": "void init_wait_entry(struct wait_queue_entry *wq_entry, int flags)\n{\n\twq_entry->flags = flags;\n\twq_entry->private = current;\n\twq_entry->func = autoremove_wake_function;\n\tINIT_LIST_HEAD(&wq_entry->entry);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid init_wait_entry(struct wait_queue_entry *wq_entry, int flags)\n{\n\twq_entry->flags = flags;\n\twq_entry->private = current;\n\twq_entry->func = autoremove_wake_function;\n\tINIT_LIST_HEAD(&wq_entry->entry);\n}"
  },
  {
    "function_name": "prepare_to_wait_exclusive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "275-290",
    "snippet": "bool\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tbool was_empty = false;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry)) {\n\t\twas_empty = list_empty(&wq_head->head);\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t}\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\treturn was_empty;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq_head->head"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nbool\nprepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\tbool was_empty = false;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry)) {\n\t\twas_empty = list_empty(&wq_head->head);\n\t\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\t}\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\treturn was_empty;\n}"
  },
  {
    "function_name": "prepare_to_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "260-271",
    "snippet": "void\nprepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wq_entry->entry"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid\nprepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\tif (list_empty(&wq_entry->entry))\n\t\t__add_wait_queue(wq_head, wq_entry);\n\tset_current_state(state);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "__wake_up_pollfree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "241-246",
    "snippet": "void __wake_up_pollfree(struct wait_queue_head *wq_head)\n{\n\t__wake_up(wq_head, TASK_NORMAL, 0, poll_to_key(EPOLLHUP | POLLFREE));\n\t/* POLLFREE must have cleared the queue. */\n\tWARN_ON_ONCE(waitqueue_active(wq_head));\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "waitqueue_active(wq_head)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "wq_head"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up",
          "args": [
            "wq_head",
            "TASK_NORMAL",
            "0",
            "poll_to_key(EPOLLHUP | POLLFREE)"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_locked_key_bookmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "176-180",
          "snippet": "void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_to_key",
          "args": [
            "EPOLLHUP | POLLFREE"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_pollfree(struct wait_queue_head *wq_head)\n{\n\t__wake_up(wq_head, TASK_NORMAL, 0, poll_to_key(EPOLLHUP | POLLFREE));\n\t/* POLLFREE must have cleared the queue. */\n\tWARN_ON_ONCE(waitqueue_active(wq_head));\n}"
  },
  {
    "function_name": "__wake_up_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "235-238",
    "snippet": "void __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode)\n{\n\t__wake_up_sync_key(wq_head, mode, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_sync_key",
          "args": [
            "wq_head",
            "mode",
            "NULL"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_sync_key",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "199-206",
          "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync(struct wait_queue_head *wq_head, unsigned int mode)\n{\n\t__wake_up_sync_key(wq_head, mode, NULL);\n}"
  },
  {
    "function_name": "__wake_up_locked_sync_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "225-229",
    "snippet": "void __wake_up_locked_sync_key(struct wait_queue_head *wq_head,\n\t\t\t       unsigned int mode, void *key)\n{\n        __wake_up_common(wq_head, mode, 1, WF_SYNC, key, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "1",
            "WF_SYNC",
            "key",
            "NULL"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "81-123",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_sync_key(struct wait_queue_head *wq_head,\n\t\t\t       unsigned int mode, void *key)\n{\n        __wake_up_common(wq_head, mode, 1, WF_SYNC, key, NULL);\n}"
  },
  {
    "function_name": "__wake_up_sync_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "199-206",
    "snippet": "void __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common_lock",
          "args": [
            "wq_head",
            "mode",
            "1",
            "WF_SYNC",
            "key"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "125-142",
          "snippet": "static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!wq_head"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_sync_key(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tvoid *key)\n{\n\tif (unlikely(!wq_head))\n\t\treturn;\n\n\t__wake_up_common_lock(wq_head, mode, 1, WF_SYNC, key);\n}"
  },
  {
    "function_name": "__wake_up_locked_key_bookmark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "176-180",
    "snippet": "void __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "1",
            "0",
            "key",
            "bookmark"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "81-123",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key_bookmark(struct wait_queue_head *wq_head,\n\t\tunsigned int mode, void *key, wait_queue_entry_t *bookmark)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, bookmark);\n}"
  },
  {
    "function_name": "__wake_up_locked_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "170-173",
    "snippet": "void __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "1",
            "0",
            "key",
            "NULL"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "81-123",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked_key(struct wait_queue_head *wq_head, unsigned int mode, void *key)\n{\n\t__wake_up_common(wq_head, mode, 1, 0, key, NULL);\n}"
  },
  {
    "function_name": "__wake_up_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "164-167",
    "snippet": "void __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)\n{\n\t__wake_up_common(wq_head, mode, nr, 0, NULL, NULL);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "nr",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "81-123",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up_locked(struct wait_queue_head *wq_head, unsigned int mode, int nr)\n{\n\t__wake_up_common(wq_head, mode, nr, 0, NULL, NULL);\n}"
  },
  {
    "function_name": "__wake_up",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "154-158",
    "snippet": "void __wake_up(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__wake_up_common_lock",
          "args": [
            "wq_head",
            "mode",
            "nr_exclusive",
            "0",
            "key"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "125-142",
          "snippet": "static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __wake_up(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, void *key)\n{\n\t__wake_up_common_lock(wq_head, mode, nr_exclusive, 0, key);\n}"
  },
  {
    "function_name": "__wake_up_common_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "125-142",
    "snippet": "static void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up_common",
          "args": [
            "wq_head",
            "mode",
            "nr_exclusive",
            "wake_flags",
            "key",
            "&bookmark"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
          "lines": "81-123",
          "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAITQUEUE_WALK_BREAK_CNT 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bookmark.entry"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nstatic void __wake_up_common_lock(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key)\n{\n\tunsigned long flags;\n\twait_queue_entry_t bookmark;\n\n\tbookmark.flags = 0;\n\tbookmark.private = NULL;\n\tbookmark.func = NULL;\n\tINIT_LIST_HEAD(&bookmark.entry);\n\n\tdo {\n\t\tspin_lock_irqsave(&wq_head->lock, flags);\n\t\tnr_exclusive = __wake_up_common(wq_head, mode, nr_exclusive,\n\t\t\t\t\t\twake_flags, key, &bookmark);\n\t\tspin_unlock_irqrestore(&wq_head->lock, flags);\n\t} while (bookmark.flags & WQ_FLAG_BOOKMARK);\n}"
  },
  {
    "function_name": "__wake_up_common",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "81-123",
    "snippet": "static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define WAITQUEUE_WALK_BREAK_CNT 64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&bookmark->entry",
            "&next->entry"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr->func",
          "args": [
            "curr",
            "mode",
            "wake_flags",
            "key"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_from",
          "args": [
            "curr",
            "next",
            "&wq_head->head",
            "entry"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&wq_head->head",
            "wait_queue_entry_t",
            "entry"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&bookmark->entry"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_next_entry",
          "args": [
            "bookmark",
            "entry"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&wq_head->lock"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\n#define WAITQUEUE_WALK_BREAK_CNT 64\n\nstatic int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode,\n\t\t\tint nr_exclusive, int wake_flags, void *key,\n\t\t\twait_queue_entry_t *bookmark)\n{\n\twait_queue_entry_t *curr, *next;\n\tint cnt = 0;\n\n\tlockdep_assert_held(&wq_head->lock);\n\n\tif (bookmark && (bookmark->flags & WQ_FLAG_BOOKMARK)) {\n\t\tcurr = list_next_entry(bookmark, entry);\n\n\t\tlist_del(&bookmark->entry);\n\t\tbookmark->flags = 0;\n\t} else\n\t\tcurr = list_first_entry(&wq_head->head, wait_queue_entry_t, entry);\n\n\tif (&curr->entry == &wq_head->head)\n\t\treturn nr_exclusive;\n\n\tlist_for_each_entry_safe_from(curr, next, &wq_head->head, entry) {\n\t\tunsigned flags = curr->flags;\n\t\tint ret;\n\n\t\tif (flags & WQ_FLAG_BOOKMARK)\n\t\t\tcontinue;\n\n\t\tret = curr->func(curr, mode, wake_flags, key);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret && (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)\n\t\t\tbreak;\n\n\t\tif (bookmark && (++cnt > WAITQUEUE_WALK_BREAK_CNT) &&\n\t\t\t\t(&next->entry != &wq_head->head)) {\n\t\t\tbookmark->flags = WQ_FLAG_BOOKMARK;\n\t\t\tlist_add_tail(&bookmark->entry, &next->entry);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn nr_exclusive;\n}"
  },
  {
    "function_name": "remove_wait_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "51-58",
    "snippet": "void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__remove_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "add_wait_queue_priority",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "40-48",
    "snippet": "void add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_priority(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE | WQ_FLAG_PRIORITY;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "add_wait_queue_exclusive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "29-37",
    "snippet": "void add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_entry_tail",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags |= WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue_entry_tail(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "add_wait_queue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "18-26",
    "snippet": "void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__add_wait_queue",
          "args": [
            "wq_head",
            "wq_entry"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&wq_head->lock",
            "flags"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry)\n{\n\tunsigned long flags;\n\n\twq_entry->flags &= ~WQ_FLAG_EXCLUSIVE;\n\tspin_lock_irqsave(&wq_head->lock, flags);\n\t__add_wait_queue(wq_head, wq_entry);\n\tspin_unlock_irqrestore(&wq_head->lock, flags);\n}"
  },
  {
    "function_name": "__init_waitqueue_head",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait.c",
    "lines": "9-14",
    "snippet": "void __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)\n{\n\tspin_lock_init(&wq_head->lock);\n\tlockdep_set_class_and_name(&wq_head->lock, key, name);\n\tINIT_LIST_HEAD(&wq_head->head);\n}",
    "includes": [
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&wq_head->head"
          ],
          "line": 13
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class_and_name",
          "args": [
            "&wq_head->lock",
            "key",
            "name"
          ],
          "line": 12
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&wq_head->lock"
          ],
          "line": 11
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n\nvoid __init_waitqueue_head(struct wait_queue_head *wq_head, const char *name, struct lock_class_key *key)\n{\n\tspin_lock_init(&wq_head->lock);\n\tlockdep_set_class_and_name(&wq_head->lock, key, name);\n\tINIT_LIST_HEAD(&wq_head->head);\n}"
  }
]